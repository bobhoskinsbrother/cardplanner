<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">第 10 章 与对象共事</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化"/><link rel="up" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化"/><link rel="prev" href="inheritance.html" title="第 9 章 Inheritance mapping"/><link rel="next" href="transactions.html" title="第 11 章 Transactions and Concurrency"/><link rel="copyright" href="ln-Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="inheritance.html"><strong>上一页</strong></a></li><li class="next"><a accesskey="n" href="transactions.html"><strong>下一页</strong></a></li></ul><div class="chapter" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate"/>第 10 章 与对象共事</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="objectstate.html#objectstate-overview">10.1. Hibernate对象状态(object states)</a></span></dt><dt><span class="sect1"><a href="objectstate.html#objectstate-makingpersistent">10.2. 使对象持久化</a></span></dt><dt><span class="sect1"><a href="objectstate.html#objectstate-loading">10.3. 装载对象</a></span></dt><dt><span class="sect1"><a href="objectstate.html#objectstate-querying">10.4. 查询</a></span></dt><dd><dl><dt><span class="sect2"><a href="objectstate.html#objectstate-querying-executing">10.4.1. 执行查询</a></span></dt><dt><span class="sect2"><a href="objectstate.html#objectstate-filtering">10.4.2. 过滤集合</a></span></dt><dt><span class="sect2"><a href="objectstate.html#objecstate-querying-criteria">10.4.3. 条件查询(Criteria queries)</a></span></dt><dt><span class="sect2"><a href="objectstate.html#objectstate-querying-nativesql">10.4.4. 使用原生SQL的查询</a></span></dt></dl></dd><dt><span class="sect1"><a href="objectstate.html#objectstate-modifying">10.5. 修改持久对象</a></span></dt><dt><span class="sect1"><a href="objectstate.html#objectstate-detached">10.6. 修改脱管(Detached)对象</a></span></dt><dt><span class="sect1"><a href="objectstate.html#objectstate-saveorupdate">10.7. 自动状态检测</a></span></dt><dt><span class="sect1"><a href="objectstate.html#objectstate-deleting">10.8. 删除持久对象</a></span></dt><dt><span class="sect1"><a href="objectstate.html#objectstate-replicating">10.9. 在两个不同数据库间复制对象</a></span></dt><dt><span class="sect1"><a href="objectstate.html#objectstate-flushing">10.10. Session刷出(flush)</a></span></dt><dt><span class="sect1"><a href="objectstate.html#objectstate-transitive">10.11. 传播性持久化(transitive persistence)</a></span></dt><dt><span class="sect1"><a href="objectstate.html#objectstate-metadata">10.12. 使用元数据</a></span></dt></dl></div><p>Hibernate is a full object/relational mapping solution that not only shields the developer from the details of the underlying database management system, but also offers <span class="emphasis"><em>state management</em></span> of objects. This is, contrary to the management of SQL <code class="literal">statements</code> in common JDBC/SQL persistence layers, a natural object-oriented view of persistence in Java applications. </p><p>换句话说，使用Hibernate的开发者应该总是关注对象的<span class="emphasis"><em>状态(state)</em></span>，不必考虑SQL语句的执行。 这部分细节已经由Hibernate掌管妥当，只有开发者在进行系统性能调优的时候才需要进行了解。 </p><div class="sect1" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-overview"/>10.1. Hibernate对象状态(object states)</h2></div></div></div><p>Hibernate定义并支持下列对象状态(state): </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Transient</em></span> - an object is transient if it has just been instantiated using the <code class="literal">new</code> operator, and it is not associated with a Hibernate <code class="literal">Session</code>. It has no persistent representation in the database and no identifier value has been assigned. Transient instances will be destroyed by the garbage collector if the application does not hold a reference anymore. Use the Hibernate <code class="literal">Session</code> to make an object persistent (and let Hibernate take care of the SQL statements that need to be executed for this transition). </p></li><li><p><span class="emphasis"><em>Persistent</em></span> - a persistent instance has a representation in the database and an identifier value. It might just have been saved or loaded, however, it is by definition in the scope of a <code class="literal">Session</code>. Hibernate will detect any changes made to an object in persistent state and synchronize the state with the database when the unit of work completes. Developers do not execute manual <code class="literal">UPDATE</code> statements, or <code class="literal">DELETE</code> statements when an object should be made transient. </p></li><li><p><span class="emphasis"><em>Detached</em></span> - a detached instance is an object that has been persistent, but its <code class="literal">Session</code> has been closed. The reference to the object is still valid, of course, and the detached instance might even be modified in this state. A detached instance can be reattached to a new <code class="literal">Session</code> at a later point in time, making it (and all the modifications) persistent again. This feature enables a programming model for long running units of work that require user think-time. We call them <span class="emphasis"><em>application transactions</em></span>, i.e., a unit of work from the point of view of the user. </p></li></ul></div><p>We will now discuss the states and state transitions (and the Hibernate methods that trigger a transition) in more detail. </p></div><div class="sect1" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-makingpersistent"/>10.2. 使对象持久化</h2></div></div></div><p>Hibernate认为持久化类(persistent class)新实例化的对象是<span class="emphasis"><em>瞬时(Transient)</em></span>的。 我们可通过将瞬时(Transient)对象与session关联而把它变为<span class="emphasis"><em>持久(Persistent)</em></span>的。 </p><pre class="programlisting">DomesticCat fritz = new DomesticCat();
fritz.setColor(Color.GINGER);
fritz.setSex('M');
fritz.setName("Fritz");
Long generatedId = (Long) sess.save(fritz);</pre><p>If <code class="literal">Cat</code> has a generated identifier, the identifier is generated and assigned to the <code class="literal">cat</code> when <code class="literal">save()</code> is called. If <code class="literal">Cat</code> has an <code class="literal">assigned</code> identifier, or a composite key, the identifier should be assigned to the <code class="literal">cat</code> instance before calling <code class="literal">save()</code>. You can also use <code class="literal">persist()</code> instead of <code class="literal">save()</code>, with the semantics defined in the EJB3 early draft. </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">persist()</code> makes a transient instance persistent. However, it does not guarantee that the identifier value will be assigned to the persistent instance immediately, the assignment might happen at flush time. <code class="literal">persist()</code> also guarantees that it will not execute an <code class="literal">INSERT</code> statement if it is called outside of transaction boundaries. This is useful in long-running conversations with an extended Session/persistence context. </p></li><li><p><code class="literal">save()</code> does guarantee to return an identifier. If an INSERT has to be executed to get the identifier ( e.g. "identity" generator, not "sequence"), this INSERT happens immediately, no matter if you are inside or outside of a transaction. This is problematic in a long-running conversation with an extended Session/persistence context. </p></li></ul></div><p>Alternatively, you can assign the identifier using an overloaded version of <code class="literal">save()</code>. </p><pre class="programlisting">DomesticCat pk = new DomesticCat();
pk.setColor(Color.TABBY);
pk.setSex('F');
pk.setName("PK");
pk.setKittens( new HashSet() );
pk.addKitten(fritz);
sess.save( pk, new Long(1234) );</pre><p>If the object you make persistent has associated objects (e.g. the <code class="literal">kittens</code> collection in the previous example), these objects can be made persistent in any order you like unless you have a <code class="literal">NOT NULL</code> constraint upon a foreign key column. There is never a risk of violating foreign key constraints. However, you might violate a <code class="literal">NOT NULL</code> constraint if you <code class="literal">save()</code> the objects in the wrong order. </p><p>Usually you do not bother with this detail, as you will normally use Hibernate's <span class="emphasis"><em>transitive persistence</em></span> feature to save the associated objects automatically. Then, even <code class="literal">NOT NULL</code> constraint violations do not occur - Hibernate will take care of everything. Transitive persistence is discussed later in this chapter. </p></div><div class="sect1" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-loading"/>10.3. 装载对象</h2></div></div></div><p>The <code class="literal">load()</code> methods of <code class="literal">Session</code> provide a way of retrieving a persistent instance if you know its identifier. <code class="literal">load()</code> takes a class object and loads the state into a newly instantiated instance of that class in a persistent state. </p><pre class="programlisting">Cat fritz = (Cat) sess.load(Cat.class, generatedId);</pre><pre class="programlisting">// you need to wrap primitive identifiers
long id = 1234;
DomesticCat pk = (DomesticCat) sess.load( DomesticCat.class, new Long(id) );</pre><p>此外, 你可以把数据(state)加载到指定的对象实例上（覆盖掉该实例原来的数据）。 </p><pre class="programlisting">Cat cat = new DomesticCat();
// load pk's state into cat
sess.load( cat, new Long(pkId) );
Set kittens = cat.getKittens();</pre><p>Be aware that <code class="literal">load()</code> will throw an unrecoverable exception if there is no matching database row. If the class is mapped with a proxy, <code class="literal">load()</code> just returns an uninitialized proxy and does not actually hit the database until you invoke a method of the proxy. This is useful if you wish to create an association to an object without actually loading it from the database. It also allows multiple instances to be loaded as a batch if <code class="literal">batch-size</code> is defined for the class mapping. </p><p>If you are not certain that a matching row exists, you should use the <code class="literal">get()</code> method which hits the database immediately and returns null if there is no matching row. </p><pre class="programlisting">Cat cat = (Cat) sess.get(Cat.class, id);
if (cat==null) {
    cat = new Cat();
    sess.save(cat, id);
}
return cat;</pre><p>You can even load an object using an SQL <code class="literal">SELECT ... FOR UPDATE</code>, using a <code class="literal">LockMode</code>. See the API documentation for more information. </p><pre class="programlisting">Cat cat = (Cat) sess.get(Cat.class, id, LockMode.UPGRADE);</pre><p>Any associated instances or contained collections will <span class="emphasis"><em>not</em></span> be selected <code class="literal">FOR UPDATE</code>, unless you decide to specify <code class="literal">lock</code> or <code class="literal">all</code> as a cascade style for the association. </p><p>任何时候都可以使用<code class="literal">refresh()</code>方法强迫装载对象和它的集合。如果你使用数据库触发器功能来处理对象的某些属性，这个方法就很有用了。 </p><pre class="programlisting">sess.save(cat);
sess.flush(); //force the SQL INSERT
sess.refresh(cat); //re-read the state (after the trigger executes)</pre><p>How much does Hibernate load from the database and how many SQL <code class="literal">SELECT</code>s will it use? This depends on the <span class="emphasis"><em>fetching strategy</em></span>. This is explained in <a href="performance.html#performance-fetching" title="19.1. 抓取策略(Fetching strategies)">第 19.1 节 “抓取策略(Fetching strategies)”</a>. </p></div><div class="sect1" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-querying"/>10.4. 查询</h2></div></div></div><p>If you do not know the identifiers of the objects you are looking for, you need a query. Hibernate supports an easy-to-use but powerful object oriented query language (HQL). For programmatic query creation, Hibernate supports a sophisticated Criteria and Example query feature (QBC and QBE). You can also express your query in the native SQL of your database, with optional support from Hibernate for result set conversion into objects. </p><div class="sect2" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="objectstate-querying-executing"/>10.4.1. 执行查询</h3></div></div></div><p>HQL和原生SQL(native SQL)查询要通过为<code class="literal">org.hibernate.Query</code>的实例来表达。 这个接口提供了参数绑定、结果集处理以及运行实际查询的方法。 你总是可以通过当前<code class="literal">Session</code>获取一个<code class="literal">Query</code>对象： </p><pre class="programlisting">List cats = session.createQuery(
    "from Cat as cat where cat.birthdate &lt; ?")
    .setDate(0, date)
    .list();

List mothers = session.createQuery(
    "select mother from Cat as cat join cat.mother as mother where cat.name = ?")
    .setString(0, name)
    .list();

List kittens = session.createQuery(
    "from Cat as cat where cat.mother = ?")
    .setEntity(0, pk)
    .list();

Cat mother = (Cat) session.createQuery(
    "select cat.mother from Cat as cat where cat = ?")
    .setEntity(0, izi)
    .uniqueResult();]]

Query mothersWithKittens = (Cat) session.createQuery(
    "select mother from Cat as mother left join fetch mother.kittens");
Set uniqueMothers = new HashSet(mothersWithKittens.list());</pre><p>A query is usually executed by invoking <code class="literal">list()</code>. The result of the query will be loaded completely into a collection in memory. Entity instances retrieved by a query are in a persistent state. The <code class="literal">uniqueResult()</code> method offers a shortcut if you know your query will only return a single object. Queries that make use of eager fetching of collections usually return duplicates of the root objects, but with their collections initialized. You can filter these duplicates through a <code class="literal">Set</code>. </p><div class="sect3" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-iterate"/>10.4.1.1. 迭代式获取结果(Iterating results)</h4></div></div></div><p>Occasionally, you might be able to achieve better performance by executing the query using the <code class="literal">iterate()</code> method. This will usually be the case if you expect that the actual entity instances returned by the query will already be in the session or second-level cache. If they are not already cached, <code class="literal">iterate()</code> will be slower than <code class="literal">list()</code> and might require many database hits for a simple query, usually <span class="emphasis"><em>1</em></span> for the initial select which only returns identifiers, and <span class="emphasis"><em>n</em></span> additional selects to initialize the actual instances. </p><pre class="programlisting">// fetch ids
Iterator iter = sess.createQuery("from eg.Qux q order by q.likeliness").iterate();
while ( iter.hasNext() ) {
    Qux qux = (Qux) iter.next();  // fetch the object
    // something we couldnt express in the query
    if ( qux.calculateComplicatedAlgorithm() ) {
        // delete the current instance
        iter.remove();
        // dont need to process the rest
        break;
    }
}</pre></div><div class="sect3" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-tuples"/>10.4.1.2. 返回元组(tuples)的查询</h4></div></div></div><p>Hibernate queries sometimes return tuples of objects. Each tuple is returned as an array: </p><pre class="programlisting">Iterator kittensAndMothers = sess.createQuery(
            "select kitten, mother from Cat kitten join kitten.mother mother")
            .list()
            .iterator();

while ( kittensAndMothers.hasNext() ) {
    Object[] tuple = (Object[]) kittensAndMothers.next();
    Cat kitten = (Cat) tuple[0];
    Cat mother = (Cat) tuple[1];
    ....
}</pre></div><div class="sect3" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-scalar"/>10.4.1.3. 标量(Scalar)结果</h4></div></div></div><p>Queries can specify a property of a class in the <code class="literal">select</code> clause. They can even call SQL aggregate functions. Properties or aggregates are considered "scalar" results and not entities in persistent state. </p><pre class="programlisting">Iterator results = sess.createQuery(
        "select cat.color, min(cat.birthdate), count(cat) from Cat cat " +
        "group by cat.color")
        .list()
        .iterator();

while ( results.hasNext() ) {
    Object[] row = (Object[]) results.next();
    Color type = (Color) row[0];
    Date oldest = (Date) row[1];
    Integer count = (Integer) row[2];
    .....
}</pre></div><div class="sect3" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-parameters"/>10.4.1.4. 绑定参数</h4></div></div></div><p>Methods on <code class="literal">Query</code> are provided for binding values to named parameters or JDBC-style <code class="literal">?</code> parameters. <span class="emphasis"><em>Contrary to JDBC, Hibernate numbers parameters from zero.</em></span> Named parameters are identifiers of the form <code class="literal">:name</code> in the query string. The advantages of named parameters are as follows: </p><div class="itemizedlist"><ul compact="compact"><li><p>命名参数(named parameters)与其在查询串中出现的顺序无关 </p></li><li><p>they can occur multiple times in the same query </p></li><li><p>它们本身是自我说明的 </p></li></ul></div><pre class="programlisting">//named parameter (preferred)
Query q = sess.createQuery("from DomesticCat cat where cat.name = :name");
q.setString("name", "Fritz");
Iterator cats = q.iterate();</pre><pre class="programlisting">//positional parameter
Query q = sess.createQuery("from DomesticCat cat where cat.name = ?");
q.setString(0, "Izi");
Iterator cats = q.iterate();</pre><pre class="programlisting">//named parameter list
List names = new ArrayList();
names.add("Izi");
names.add("Fritz");
Query q = sess.createQuery("from DomesticCat cat where cat.name in (:namesList)");
q.setParameterList("namesList", names);
List cats = q.list();</pre></div><div class="sect3" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-pagination"/>10.4.1.5. 分页</h4></div></div></div><p>If you need to specify bounds upon your result set, that is, the maximum number of rows you want to retrieve and/or the first row you want to retrieve, you can use methods of the <code class="literal">Query</code> interface: </p><pre class="programlisting">Query q = sess.createQuery("from DomesticCat cat");
q.setFirstResult(20);
q.setMaxResults(10);
List cats = q.list();</pre><p>Hibernate 知道如何将这个有限定条件的查询转换成你的数据库的原生SQL(native SQL)。 </p></div><div class="sect3" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-scrolling"/>10.4.1.6. 可滚动遍历(Scrollable iteration)</h4></div></div></div><p>If your JDBC driver supports scrollable <code class="literal">ResultSet</code>s, the <code class="literal">Query</code> interface can be used to obtain a <code class="literal">ScrollableResults</code> object that allows flexible navigation of the query results. </p><pre class="programlisting">Query q = sess.createQuery("select cat.name, cat from DomesticCat cat " +
                            "order by cat.name");
ScrollableResults cats = q.scroll();
if ( cats.first() ) {

    // find the first name on each page of an alphabetical list of cats by name
    firstNamesOfPages = new ArrayList();
    do {
        String name = cats.getString(0);
        firstNamesOfPages.add(name);
    }
    while ( cats.scroll(PAGE_SIZE) );

    // Now get the first page of cats
    pageOfCats = new ArrayList();
    cats.beforeFirst();
    int i=0;
    while( ( PAGE_SIZE &gt; i++ ) &amp;&amp; cats.next() ) pageOfCats.add( cats.get(1) );

}
cats.close()</pre><p>Note that an open database connection and cursor is required for this functionality. Use <code class="literal">setMaxResult()</code>/<code class="literal">setFirstResult()</code> if you need offline pagination functionality. </p></div><div class="sect3" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-named"/>10.4.1.7. 外置命名查询(Externalizing named queries)</h4></div></div></div><p>You can also define named queries in the mapping document. Remember to use a <code class="literal">CDATA</code> section if your query contains characters that could be interpreted as markup. </p><pre class="programlisting">&lt;query name="ByNameAndMaximumWeight"&gt;&lt;![CDATA[
    from eg.DomesticCat as cat
        where cat.name = ?
        and cat.weight &gt; ?
] ]&gt;&lt;/query&gt;</pre><p>参数绑定及执行以编程方式(programatically)完成： </p><pre class="programlisting">Query q = sess.getNamedQuery("ByNameAndMaximumWeight");
q.setString(0, name);
q.setInt(1, minWeight);
List cats = q.list();</pre><p>The actual program code is independent of the query language that is used. You can also define native SQL queries in metadata, or migrate existing queries to Hibernate by placing them in mapping files. </p><p>Also note that a query declaration inside a <code class="literal">&lt;hibernate-mapping&gt;</code> element requires a global unique name for the query, while a query declaration inside a <code class="literal">&lt;class&gt;</code> element is made unique automatically by prepending the fully qualified name of the class. For example <code class="literal">eg.Cat.ByNameAndMaximumWeight</code>. </p></div></div><div class="sect2" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="objectstate-filtering"/>10.4.2. 过滤集合</h3></div></div></div><p>A collection <span class="emphasis"><em>filter</em></span> is a special type of query that can be applied to a persistent collection or array. The query string can refer to <code class="literal">this</code>, meaning the current collection element. </p><pre class="programlisting">Collection blackKittens = session.createFilter(
    pk.getKittens(), 
    "where this.color = ?")
    .setParameter( Color.BLACK, Hibernate.custom(ColorUserType.class) )
    .list()
);</pre><p>The returned collection is considered a bag that is a copy of the given collection. The original collection is not modified. This is contrary to the implication of the name "filter", but consistent with expected behavior. </p><p>Observe that filters do not require a <code class="literal">from</code> clause, although they can have one if required. Filters are not limited to returning the collection elements themselves. </p><pre class="programlisting">Collection blackKittenMates = session.createFilter(
    pk.getKittens(), 
    "select this.mate where this.color = eg.Color.BLACK.intValue")
    .list();</pre><p>Even an empty filter query is useful, e.g. to load a subset of elements in a large collection: </p><pre class="programlisting">Collection tenKittens = session.createFilter(
    mother.getKittens(), "")
    .setFirstResult(0).setMaxResults(10)
    .list();</pre></div><div class="sect2" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="objecstate-querying-criteria"/>10.4.3. 条件查询(Criteria queries)</h3></div></div></div><p>HQL is extremely powerful, but some developers prefer to build queries dynamically using an object-oriented API, rather than building query strings. Hibernate provides an intuitive <code class="literal">Criteria</code> query API for these cases: </p><pre class="programlisting">Criteria crit = session.createCriteria(Cat.class);
crit.add( Restrictions.eq( "color", eg.Color.BLACK ) );
crit.setMaxResults(10);
List cats = crit.list();</pre><p><code class="literal">Criteria</code>以及相关的<code class="literal">样例(Example)</code>API将会再<a href="querycriteria.html" title="第 15 章 条件查询(Criteria Queries)">第 15 章 <i xmlns:xlink="http://www.w3.org/1999/xlink">条件查询(Criteria Queries)</i></a>中详细讨论。 </p></div><div class="sect2" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="objectstate-querying-nativesql"/>10.4.4. 使用原生SQL的查询</h3></div></div></div><p>You can express a query in SQL, using <code class="literal">createSQLQuery()</code> and let Hibernate manage the mapping from result sets to objects. You can at any time call <code class="literal">session.connection()</code> and use the JDBC <code class="literal">Connection</code> directly. If you choose to use the Hibernate API, you must enclose SQL aliases in braces: </p><pre class="programlisting">List cats = session.createSQLQuery("SELECT {cat.*} FROM CAT {cat} WHERE ROWNUM&lt;10")
    .addEntity("cat", Cat.class)
.list();</pre><pre class="programlisting">List cats = session.createSQLQuery(
    "SELECT {cat}.ID AS {cat.id}, {cat}.SEX AS {cat.sex}, " +
           "{cat}.MATE AS {cat.mate}, {cat}.SUBCLASS AS {cat.class}, ... " +
    "FROM CAT {cat} WHERE ROWNUM&lt;10")
    .addEntity("cat", Cat.class)
.list()</pre><p>SQL queries can contain named and positional parameters, just like Hibernate queries. More information about native SQL queries in Hibernate can be found in <a href="querysql.html" title="第 16 章 Native SQL查询">第 16 章 <i xmlns:xlink="http://www.w3.org/1999/xlink">Native SQL查询</i></a>. </p></div></div><div class="sect1" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-modifying"/>10.5. 修改持久对象</h2></div></div></div><p><span class="emphasis"><em>Transactional persistent instances</em></span> (i.e. objects loaded, saved, created or queried by the <code class="literal">Session</code>) can be manipulated by the application, and any changes to persistent state will be persisted when the <code class="literal">Session</code> is <span class="emphasis"><em>flushed</em></span>. This is discussed later in this chapter. There is no need to call a particular method (like <code class="literal">update()</code>, which has a different purpose) to make your modifications persistent. The most straightforward way to update the state of an object is to <code class="literal">load()</code> it and then manipulate it directly while the <code class="literal">Session</code> is open: </p><pre class="programlisting">DomesticCat cat = (DomesticCat) sess.load( Cat.class, new Long(69) );
cat.setName("PK");
sess.flush();  // changes to cat are automatically detected and persisted</pre><p>Sometimes this programming model is inefficient, as it requires in the same session both an SQL <code class="literal">SELECT</code> to load an object and an SQL <code class="literal">UPDATE</code> to persist its updated state. Hibernate offers an alternate approach by using detached instances. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>重要</h2><p>Hibernate does not offer its own API for direct execution of <code class="literal">UPDATE</code> or <code class="literal">DELETE</code> statements. Hibernate is a <span class="emphasis"><em>state management</em></span> service, you do not have to think in <span class="emphasis"><em>statements</em></span> to use it. JDBC is a perfect API for executing SQL statements, you can get a JDBC <code class="literal">Connection</code> at any time by calling <code class="literal">session.connection()</code>. Furthermore, the notion of mass operations conflicts with object/relational mapping for online transaction processing-oriented applications. Future versions of Hibernate can, however, provide special mass operation functions. See <a href="batch.html" title="第 13 章 æ¹éå¤çï¼Batch processingï¼">第 13 章 <i xmlns:xlink="http://www.w3.org/1999/xlink">æ¹éå¤çï¼Batch processingï¼</i></a> for some possible batch operation tricks. </p></div></div><div class="sect1" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-detached"/>10.6. 修改脱管(Detached)对象</h2></div></div></div><p>很多程序需要在某个事务中获取对象，然后将对象发送到界面层去操作，最后在一个新的事务保存所做的修改。 在高并发访问的环境中使用这种方式，通常使用附带版本信息的数据来保证这些“长“工作单元之间的隔离。 </p><p>Hibernate通过提供<code class="literal">Session.update()</code>或<code class="literal">Session.merge()</code> 重新关联脱管实例的办法来支持这种模型。 </p><pre class="programlisting">// in the first session
Cat cat = (Cat) firstSession.load(Cat.class, catId);
Cat potentialMate = new Cat();
firstSession.save(potentialMate);

// in a higher layer of the application
cat.setMate(potentialMate);

// later, in a new session
secondSession.update(cat);  // update cat
secondSession.update(mate); // update mate</pre><p>如果具有<code class="literal">catId</code>持久化标识的<code class="literal">Cat</code>之前已经被<code class="literal">另一Session(secondSession)</code>装载了， 应用程序进行重关联操作(reattach)的时候会抛出一个异常。 </p><p>Use <code class="literal">update()</code> if you are certain that the session does not contain an already persistent instance with the same identifier. Use <code class="literal">merge()</code> if you want to merge your modifications at any time without consideration of the state of the session. In other words, <code class="literal">update()</code> is usually the first method you would call in a fresh session, ensuring that the reattachment of your detached instances is the first operation that is executed. </p><p>The application should individually <code class="literal">update()</code> detached instances that are reachable from the given detached instance <span class="emphasis"><em>only</em></span> if it wants their state to be updated. This can be automated using <span class="emphasis"><em>transitive persistence</em></span>. See <a href="objectstate.html#objectstate-transitive" title="10.11. 传播性持久化(transitive persistence)">第 10.11 节 “传播性持久化(transitive persistence)”</a> for more information. </p><p>The <code class="literal">lock()</code> method also allows an application to reassociate an object with a new session. However, the detached instance has to be unmodified. </p><pre class="programlisting">//just reassociate:
sess.lock(fritz, LockMode.NONE);
//do a version check, then reassociate:
sess.lock(izi, LockMode.READ);
//do a version check, using SELECT ... FOR UPDATE, then reassociate:
sess.lock(pk, LockMode.UPGRADE);</pre><p>Note that <code class="literal">lock()</code> can be used with various <code class="literal">LockMode</code>s. See the API documentation and the chapter on transaction handling for more information. Reattachment is not the only usecase for <code class="literal">lock()</code>. </p><p>其他用于长时间工作单元的模型会在<a href="transactions.html#transactions-optimistic" title="11.3. 乐观并发控制(Optimistic concurrency control)">第 11.3 节 “乐观并发控制(Optimistic concurrency control)”</a>中讨论。 </p></div><div class="sect1" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-saveorupdate"/>10.7. 自动状态检测</h2></div></div></div><p>Hibernate的用户曾要求一个既可自动分配新持久化标识(identifier)保存瞬时(transient)对象，又可更新/重新关联脱管(detached)实例的通用方法。 <code class="literal">saveOrUpdate()</code>方法实现了这个功能。 </p><pre class="programlisting">// in the first session
Cat cat = (Cat) firstSession.load(Cat.class, catID);

// in a higher tier of the application
Cat mate = new Cat();
cat.setMate(mate);

// later, in a new session
secondSession.saveOrUpdate(cat);   // update existing state (cat has a non-null id)
secondSession.saveOrUpdate(mate);  // save the new instance (mate has a null id)</pre><p><code class="literal">saveOrUpdate()</code>用途和语义可能会使新用户感到迷惑。 首先，只要你没有尝试在某个session中使用来自另一session的实例，你就应该不需要使用<code class="literal">update()</code>， <code class="literal">saveOrUpdate()</code>，或<code class="literal">merge()</code>。有些程序从来不用这些方法。 </p><p>通常下面的场景会使用<code class="literal">update()</code>或<code class="literal">saveOrUpdate()</code>： </p><div class="itemizedlist"><ul compact="compact"><li><p>程序在第一个session中加载对象 </p></li><li><p>该对象被传递到表现层 </p></li><li><p>对象发生了一些改动 </p></li><li><p>该对象被返回到业务逻辑层 </p></li><li><p>程序调用第二个session的<code class="literal">update()</code>方法持久这些改动 </p></li></ul></div><p><code class="literal">saveOrUpdate()</code>做下面的事: </p><div class="itemizedlist"><ul compact="compact"><li><p>如果对象已经在本session中持久化了，不做任何事 </p></li><li><p>如果另一个与本session关联的对象拥有相同的持久化标识(identifier)，抛出一个异常 </p></li><li><p>如果对象没有持久化标识(identifier)属性，对其调用<code class="literal">save()</code> </p></li><li><p>如果对象的持久标识(identifier)表明其是一个新实例化的对象，对其调用<code class="literal">save()</code> </p></li><li><p>if the object is versioned by a <code class="literal">&lt;version&gt;</code> or <code class="literal">&lt;timestamp&gt;</code>, and the version property value is the same value assigned to a newly instantiated object, <code class="literal">save()</code> it </p></li><li><p>否则<code class="literal">update()</code> 这个对象 </p></li></ul></div><p><code class="literal">merge()</code>可非常不同: </p><div class="itemizedlist"><ul compact="compact"><li><p>如果session中存在相同持久化标识(identifier)的实例，用用户给出的对象的状态覆盖旧有的持久实例 </p></li><li><p>如果session没有相应的持久实例，则尝试从数据库中加载，或创建新的持久化实例 </p></li><li><p>最后返回该持久实例 </p></li><li><p>用户给出的这个对象没有被关联到session上，它依旧是脱管的 </p></li></ul></div></div><div class="sect1" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-deleting"/>10.8. 删除持久对象</h2></div></div></div><p><code class="literal">Session.delete()</code> will remove an object's state from the database. Your application, however, can still hold a reference to a deleted object. It is best to think of <code class="literal">delete()</code> as making a persistent instance, transient. </p><pre class="programlisting">sess.delete(cat);</pre><p>You can delete objects in any order, without risk of foreign key constraint violations. It is still possible to violate a <code class="literal">NOT NULL</code> constraint on a foreign key column by deleting objects in the wrong order, e.g. if you delete the parent, but forget to delete the children. </p></div><div class="sect1" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-replicating"/>10.9. 在两个不同数据库间复制对象</h2></div></div></div><p>It is sometimes useful to be able to take a graph of persistent instances and make them persistent in a different datastore, without regenerating identifier values. </p><pre class="programlisting">//retrieve a cat from one database
Session session1 = factory1.openSession();
Transaction tx1 = session1.beginTransaction();
Cat cat = session1.get(Cat.class, catId);
tx1.commit();
session1.close();

//reconcile with a second database
Session session2 = factory2.openSession();
Transaction tx2 = session2.beginTransaction();
session2.replicate(cat, ReplicationMode.LATEST_VERSION);
tx2.commit();
session2.close();</pre><p>The <code class="literal">ReplicationMode</code> determines how <code class="literal">replicate()</code> will deal with conflicts with existing rows in the database: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">ReplicationMode.IGNORE</code>: ignores the object when there is an existing database row with the same identifier </p></li><li><p><code class="literal">ReplicationMode.OVERWRITE</code>: overwrites any existing database row with the same identifier </p></li><li><p><code class="literal">ReplicationMode.EXCEPTION</code>: throws an exception if there is an existing database row with the same identifier </p></li><li><p><code class="literal">ReplicationMode.LATEST_VERSION</code>: overwrites the row if its version number is earlier than the version number of the object, or ignore the object otherwise </p></li></ul></div><p>这个功能的用途包括使录入的数据在不同数据库中一致，产品升级时升级系统配置信息，回滚non-ACID事务中的修改等等。 （译注，non-ACID，非ACID;ACID，Atomic，Consistent，Isolated and Durable的缩写） </p></div><div class="sect1" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-flushing"/>10.10. Session刷出(flush)</h2></div></div></div><p>Sometimes the <code class="literal">Session</code> will execute the SQL statements needed to synchronize the JDBC connection's state with the state of objects held in memory. This process, called <span class="emphasis"><em>flush</em></span>, occurs by default at the following points: </p><div class="itemizedlist"><ul compact="compact"><li><p>在某些查询执行之前 </p></li><li><p>在调用<code class="literal">org.hibernate.Transaction.commit()</code>的时候 </p></li><li><p>在调用<code class="literal">Session.flush()</code>的时候 </p></li></ul></div><p>The SQL statements are issued in the following order: </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>all entity insertions in the same order the corresponding objects were saved using <code class="literal">Session.save()</code> </p></li><li><p>所有对实体进行更新的语句 </p></li><li><p>所有进行集合删除的语句 </p></li><li><p>所有对集合元素进行删除，更新或者插入的语句 </p></li><li><p>所有进行集合插入的语句 </p></li><li><p>all entity deletions in the same order the corresponding objects were deleted using <code class="literal">Session.delete()</code> </p></li></ol></div><p>An exception is that objects using <code class="literal">native</code> ID generation are inserted when they are saved. </p><p>Except when you explicitly <code class="literal">flush()</code>, there are absolutely no guarantees about <span class="emphasis"><em>when</em></span> the <code class="literal">Session</code> executes the JDBC calls, only the <span class="emphasis"><em>order</em></span> in which they are executed. However, Hibernate does guarantee that the <code class="literal">Query.list(..)</code> will never return stale or incorrect data. </p><p>It is possible to change the default behavior so that flush occurs less frequently. The <code class="literal">FlushMode</code> class defines three different modes: only flush at commit time when the Hibernate <code class="literal">Transaction</code> API is used, flush automatically using the explained routine, or never flush unless <code class="literal">flush()</code> is called explicitly. The last mode is useful for long running units of work, where a <code class="literal">Session</code> is kept open and disconnected for a long time (see <a href="transactions.html#transactions-optimistic-longsession" title="11.3.2. 扩展周期的session和自动版本化">第 11.3.2 节 “扩展周期的session和自动版本化”</a>). </p><pre class="programlisting">sess = sf.openSession();
Transaction tx = sess.beginTransaction();
sess.setFlushMode(FlushMode.COMMIT); // allow queries to return stale state

Cat izi = (Cat) sess.load(Cat.class, id);
izi.setName(iznizi);

// might return stale data
sess.find("from Cat as cat left outer join cat.kittens kitten");

// change to izi is not flushed!
...
tx.commit(); // flush occurs
sess.close();</pre><p>刷出(flush)期间，可能会抛出异常。（例如一个DML操作违反了约束） 异常处理涉及到对Hibernate事务性行为的理解，因此我们将在<a href="transactions.html" title="第 11 章 Transactions and Concurrency">第 11 章 <i xmlns:xlink="http://www.w3.org/1999/xlink">Transactions and Concurrency</i></a>中讨论。 </p></div><div class="sect1" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-transitive"/>10.11. 传播性持久化(transitive persistence)</h2></div></div></div><p>对每一个对象都要执行保存，删除或重关联操作让人感觉有点麻烦，尤其是在处理许多彼此关联的对象的时候。 一个常见的例子是父子关系。考虑下面的例子: </p><p>If the children in a parent/child relationship would be value typed (e.g. a collection of addresses or strings), their life cycle would depend on the parent and no further action would be required for convenient "cascading" of state changes. When the parent is saved, the value-typed child objects are saved and when the parent is deleted, the children will be deleted, etc. This works for operations such as the removal of a child from the collection. Since value-typed objects cannot have shared references, Hibernate will detect this and delete the child from the database. </p><p>Now consider the same scenario with parent and child objects being entities, not value-types (e.g. categories and items, or parent and child cats). Entities have their own life cycle and support shared references. Removing an entity from the collection does not mean it can be deleted), and there is by default no cascading of state from one entity to any other associated entities. Hibernate does not implement <span class="emphasis"><em>persistence by reachability</em></span> by default. </p><p>每个Hibernate session的基本操作 - 包括 <code class="literal">persist(), merge(), saveOrUpdate(), delete(), lock(), refresh(), evict(), replicate()</code> - 都有对应的级联风格(cascade style)。 这些级联风格(cascade style)风格分别命名为 <code class="literal">create, merge, save-update, delete, lock, refresh, evict, replicate</code>。 如果你希望一个操作被顺着关联关系级联传播，你必须在映射文件中指出这一点。例如： </p><pre class="programlisting">&lt;one-to-one name="person" cascade="persist"/&gt;</pre><p>级联风格(cascade style)是可组合的: </p><pre class="programlisting">&lt;one-to-one name="person" cascade="persist,delete,lock"/&gt;</pre><p>You can even use <code class="literal">cascade="all"</code> to specify that <span class="emphasis"><em>all</em></span> operations should be cascaded along the association. The default <code class="literal">cascade="none"</code> specifies that no operations are to be cascaded. </p><p>注意有一个特殊的级联风格(cascade style) <code class="literal">delete-orphan</code>，只应用于one-to-many关联，表明<code class="literal">delete()</code>操作 应该被应用于所有从关联中删除的对象。 </p><p>建议: </p><div class="itemizedlist"><ul compact="compact"><li><p>It does not usually make sense to enable cascade on a <code class="literal">&lt;many-to-one&gt;</code> or <code class="literal">&lt;many-to-many&gt;</code> association. Cascade is often useful for <code class="literal">&lt;one-to-one&gt;</code> and <code class="literal">&lt;one-to-many&gt;</code> associations. </p></li><li><p>如果子对象的寿命限定在父亲对象的寿命之内，可通过指定<code class="literal">cascade="all,delete-orphan"</code>将其变为<span class="emphasis"><em>自动生命周期管理的对象(life cycle object)</em></span>。 </p></li><li><p>其他情况，你可根本不需要级联(cascade)。但是如果你认为你会经常在某个事务中同时用到父对象与子对象，并且你希望少打点儿字，可以考虑使用<code class="literal">cascade="persist,merge,save-update"</code>。 </p></li></ul></div><p>可以使用<code class="literal">cascade="all"</code>将一个关联关系（无论是对值对象的关联，或者对一个集合的关联）标记为<span class="emphasis"><em>父/子</em></span>关系的关联。 这样对父对象进行save/update/delete操作就会导致子对象也进行save/update/delete操作。 </p><p>Furthermore, a mere reference to a child from a persistent parent will result in save/update of the child. This metaphor is incomplete, however. A child which becomes unreferenced by its parent is <span class="emphasis"><em>not</em></span> automatically deleted, except in the case of a <code class="literal">&lt;one-to-many&gt;</code> association mapped with <code class="literal">cascade="delete-orphan"</code>. The precise semantics of cascading operations for a parent/child relationship are as follows: </p><div class="itemizedlist"><ul compact="compact"><li><p>如果父对象被<code class="literal">persist()</code>，那么所有子对象也会被<code class="literal">persist()</code> </p></li><li><p>如果父对象被<code class="literal">merge()</code>，那么所有子对象也会被<code class="literal">merge()</code> </p></li><li><p>如果父对象被<code class="literal">save()</code>，<code class="literal">update()</code>或 <code class="literal">saveOrUpdate()</code>，那么所有子对象则会被<code class="literal">saveOrUpdate()</code> </p></li><li><p>如果某个持久的父对象引用了瞬时(transient)或者脱管(detached)的子对象，那么子对象将会被<code class="literal">saveOrUpdate()</code> </p></li><li><p>如果父对象被删除，那么所有子对象也会被<code class="literal">delete()</code> </p></li><li><p>除非被标记为<code class="literal">cascade="delete-orphan"</code>（删除“孤儿”模式，此时不被任何一个父对象引用的子对象会被删除）， 否则子对象失掉父对象对其的引用时，<span class="emphasis"><em>什么事也不会发生</em></span>。 如果有特殊需要，应用程序可通过显式调用delete()删除子对象。 </p></li></ul></div><p>Finally, note that cascading of operations can be applied to an object graph at <span class="emphasis"><em>call time</em></span> or at <span class="emphasis"><em>flush time</em></span>. All operations, if enabled, are cascaded to associated entities reachable when the operation is executed. However, <code class="literal">save-update</code> and <code class="literal">delete-orphan</code> are transitive for all associated entities reachable during flush of the <code class="literal">Session</code>. </p></div><div class="sect1" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-metadata"/>10.12. 使用元数据</h2></div></div></div><p>Hibernate requires a rich meta-level model of all entity and value types. This model can be useful to the application itself. For example, the application might use Hibernate's metadata to implement a "smart" deep-copy algorithm that understands which objects should be copied (eg. mutable value types) and which objects that should not (e.g. immutable value types and, possibly, associated entities). </p><p>Hibernate exposes metadata via the <code class="literal">ClassMetadata</code> and <code class="literal">CollectionMetadata</code> interfaces and the <code class="literal">Type</code> hierarchy. Instances of the metadata interfaces can be obtained from the <code class="literal">SessionFactory</code>. </p><pre class="programlisting">Cat fritz = ......;
ClassMetadata catMeta = sessionfactory.getClassMetadata(Cat.class);

Object[] propertyValues = catMeta.getPropertyValues(fritz);
String[] propertyNames = catMeta.getPropertyNames();
Type[] propertyTypes = catMeta.getPropertyTypes();

// get a Map of all properties which are not collections or associations
Map namedValues = new HashMap();
for ( int i=0; i&lt;propertyNames.length; i++ ) {
    if ( !propertyTypes[i].isEntityType() &amp;&amp; !propertyTypes[i].isCollectionType() ) {
        namedValues.put( propertyNames[i], propertyValues[i] );
    }
}</pre></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">版权 © 2004 Red Hat Middleware, LLC.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="inheritance.html"><strong>上一页</strong>第 9 章 Inheritance mapping</a></li><li class="up"><a accesskey="u" href="#"><strong>上一级</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>起始页</strong></a></li><li class="next"><a accesskey="n" href="transactions.html"><strong>下一页</strong>第 11 章 Transactions and Concurrency</a></li></ul></body></html>