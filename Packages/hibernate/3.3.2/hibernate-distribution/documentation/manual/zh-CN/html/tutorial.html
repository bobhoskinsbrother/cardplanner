<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">第 1 章 Tutorial</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化"/><link rel="up" href="index.html" title="HIBERNATE - 符合Java习惯的关系数据库持久化"/><link rel="prev" href="preface.html" title="前言"/><link rel="next" href="architecture.html" title="第 2 章 体系结构(Architecture)"/><link rel="copyright" href="ln-Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="preface.html"><strong>上一页</strong></a></li><li class="next"><a accesskey="n" href="architecture.html"><strong>下一页</strong></a></li></ul><div class="chapter" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial"/>第 1 章 Tutorial</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="tutorial.html#tutorial-firstapp">1.1. 第一部分 － 第一个Hibernate应用程序</a></span></dt><dd><dl><dt><span class="sect2"><a href="tutorial.html#tutorial-firstapp-setup">1.1.1. Setup</a></span></dt><dt><span class="sect2"><a href="tutorial.html#tutorial-firstapp-firstclass">1.1.2. 第一个class</a></span></dt><dt><span class="sect2"><a href="tutorial.html#tutorial-firstapp-mapping">1.1.3. 映射文件</a></span></dt><dt><span class="sect2"><a href="tutorial.html#tutorial-firstapp-configuration">1.1.4. Hibernate配置</a></span></dt><dt><span class="sect2"><a href="tutorial.html#tutorial-firstapp-mvn">1.1.5. Building with Maven</a></span></dt><dt><span class="sect2"><a href="tutorial.html#tutorial-firstapp-helpers">1.1.6. 启动和辅助类</a></span></dt><dt><span class="sect2"><a href="tutorial.html#tutorial-firstapp-workingpersistence">1.1.7. 加载并存储对象</a></span></dt></dl></dd><dt><span class="sect1"><a href="tutorial.html#tutorial-associations">1.2. 第二部分 － 关联映射</a></span></dt><dd><dl><dt><span class="sect2"><a href="tutorial.html#tutorial-associations-mappinguser">1.2.1. 映射Person类</a></span></dt><dt><span class="sect2"><a href="tutorial.html#tutorial-associations-unidirset">1.2.2. 单向Set-based的关联</a></span></dt><dt><span class="sect2"><a href="tutorial.html#tutorial-associations-working">1.2.3. 使关联工作</a></span></dt><dt><span class="sect2"><a href="tutorial.html#tutorial-associations-valuecollections">1.2.4. 值类型的集合</a></span></dt><dt><span class="sect2"><a href="tutorial.html#tutorial-associations-bidirectional">1.2.5. 双向关联</a></span></dt><dt><span class="sect2"><a href="tutorial.html#tutorial-associations-usingbidir">1.2.6. 使双向连起来</a></span></dt></dl></dd><dt><span class="sect1"><a href="tutorial.html#tutorial-webapp">1.3. 第三部分 - EventManager web应用程序</a></span></dt><dd><dl><dt><span class="sect2"><a href="tutorial.html#tutorial-webapp-servlet">1.3.1. 编写基本的servlet</a></span></dt><dt><span class="sect2"><a href="tutorial.html#tutorial-webapp-processing">1.3.2. 最后，当处理与渲染都结束的时候，这个工作单元就结束了。假若在处理或渲染的时候有任何错误发生，会抛出一个异常，回滚数据库事务。这样，<code class="literal">session-per-request</code>模式就完成了。为了避免在每个servlet中都编写事务边界界定的代码，可以考虑写一个servlet 过滤器（filter）来更好地解决。关于这一模式的更多信息，请参阅Hibernate网站和Wiki，这一模式叫做<span class="emphasis"><em>Open Session in View</em></span>-只要你考虑用JSP来渲染你的视图（view），而不是在servlet中，你就会很快用到它。</a></span></dt><dt><span class="sect2"><a href="tutorial.html#tutorial-webapp-deploy">1.3.3. 部署与测试</a></span></dt></dl></dd><dt><span class="sect1"><a href="tutorial.html#tutorial-summary">1.4. 总结</a></span></dt></dl></div><p>Intended for new users, this chapter provides an step-by-step introduction to Hibernate, starting with a simple application using an in-memory database. The tutorial is based on an earlier tutorial developed by Michael Gloegl. All code is contained in the <code class="filename">tutorials/web</code> directory of the project source. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>重要</h2><p>This tutorial expects the user have knowledge of both Java and SQL. If you have a limited knowledge of JAVA or SQL, it is advised that you start with a good introduction to that technology prior to attempting to learn Hibernate. </p></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>The distribution contains another example application under the <code class="filename">tutorial/eg</code> project source directory. </p></div><div class="sect1" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial-firstapp"/>1.1. 第一部分 － 第一个Hibernate应用程序</h2></div></div></div><p>For this example, we will set up a small database application that can store events we want to attend and information about the host(s) of these events. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>Although you can use whatever database you feel comfortable using, we will use <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://hsqldb.org/">HSQLDB</a> (an in-memory, Java database) to avoid describing installation/setup of any particular database servers. </p></div><div class="sect2" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-setup"/>1.1.1. Setup</h3></div></div></div><p>The first thing we need to do is to set up the development environment. We will be using the "standard layout" advocated by alot of build tools such as <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://maven.org">Maven</a>. Maven, in particular, has a good resource describing this <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html">layout</a>. As this tutorial is to be a web application, we will be creating and making use of <code class="filename">src/main/java</code>, <code class="filename">src/main/resources</code> and <code class="filename">src/main/webapp</code> directories. </p><p>We will be using Maven in this tutorial, taking advantage of its transitive dependency management capabilities as well as the ability of many IDEs to automatically set up a project for us based on the maven descriptor. </p><pre class="programlisting">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;

    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.hibernate.tutorials&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-tutorial&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;First Hibernate Tutorial&lt;/name&gt;

    &lt;build&gt;
         &lt;!-- we dont want the version to be part of the generated war file name --&gt;
         &lt;finalName&gt;${artifactId}&lt;/finalName&gt;
    &lt;/build&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- Because this is a web app, we also have a dependency on the servlet api. --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- Hibernate uses slf4j for logging, for our purposes here use the simple backend --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- Hibernate gives you a choice of bytecode providers between cglib and javassist --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javassist&lt;/groupId&gt;
            &lt;artifactId&gt;javassist&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>提示</h2><p>It is not a requirement to use Maven. If you wish to use something else to build this tutoial (such as Ant), the layout will remain the same. The only change is that you will need to manually account for all the needed dependencies. If you use something like <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://ant.apache.org/ivy/">Ivy</a> providing transitive dependency management you would still use the dependencies mentioned below. Otherwise, you'd need to grab <span class="emphasis"><em>all</em></span> dependencies, both explicit and transitive, and add them to the project's classpath. If working from the Hibernate distribution bundle, this would mean <code class="filename">hibernate3.jar</code>, all artifacts in the <code class="filename">lib/required</code> directory and all files from either the <code class="filename">lib/bytecode/cglib</code> or <code class="filename">lib/bytecode/javassist</code> directory; additionally you will need both the servlet-api jar and one of the slf4j logging backends. </p></div><p>Save this file as <code class="filename">pom.xml</code> in the project root directory. </p></div><div class="sect2" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-firstclass"/>1.1.2. 第一个class</h3></div></div></div><p>Next, we create a class that represents the event we want to store in the database; it is a simple JavaBean class with some properties: </p><pre class="programlisting">package org.hibernate.tutorial.domain;

import java.util.Date;

public class Event {
    private Long id;

    private String title;
    private Date date;

    public Event() {}

    public Long getId() {
        return id;
    }

    private void setId(Long id) {
        this.id = id;
    }

    public Date getDate() {
        return date;
    }

    public void setDate(Date date) {
        this.date = date;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }
}</pre><p>This class uses standard JavaBean naming conventions for property getter and setter methods, as well as private visibility for the fields. Although this is the recommended design, it is not required. Hibernate can also access fields directly, the benefit of accessor methods is robustness for refactoring. </p><p>The <code class="literal">id</code> property holds a unique identifier value for a particular event. All persistent entity classes (there are less important dependent classes as well) will need such an identifier property if we want to use the full feature set of Hibernate. In fact, most applications, especially web applications, need to distinguish objects by identifier, so you should consider this a feature rather than a limitation. However, we usually do not manipulate the identity of an object, hence the setter method should be private. Only Hibernate will assign identifiers when an object is saved. Hibernate can access public, private, and protected accessor methods, as well as public, private and protected fields directly. The choice is up to you and you can match it to fit your application design. </p><p>The no-argument constructor is a requirement for all persistent classes; Hibernate has to create objects for you, using Java Reflection. The constructor can be private, however package or public visibility is required for runtime proxy generation and efficient data retrieval without bytecode instrumentation. </p><p>Save this file to the <code class="filename">src/main/java/org/hibernate/tutorial/domain</code> directory. </p></div><div class="sect2" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-mapping"/>1.1.3. 映射文件</h3></div></div></div><p>Hibernate需要知道怎样去加载（load）和存储（store）持久化类的对象。这正是Hibernate映射文件发挥作用的地方。映射文件告诉Hibernate它，应该访问数据库(database)里面的哪个表（table）及应该使用表里面的哪些字段（column）。 </p><p>一个映射文件的基本结构看起来像这样： </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;
[...]
&lt;/hibernate-mapping&gt;</pre><p>Hibernate DTD is sophisticated. You can use it for auto-completion of XML mapping elements and attributes in your editor or IDE. Opening up the DTD file in your text editor is the easiest way to get an overview of all elements and attributes, and to view the defaults, as well as some comments. Hibernate will not load the DTD file from the web, but first look it up from the classpath of the application. The DTD file is included in <code class="filename">hibernate-core.jar</code> (it is also included in the <code class="filename">hibernate3.jar</code>, if using the distribution bundle). </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>重要</h2><p>We will omit the DTD declaration in future examples to shorten the code. It is, of course, not optional. </p></div><p>Between the two <code class="literal">hibernate-mapping</code> tags, include a <code class="literal">class</code> element. All persistent entity classes (again, there might be dependent classes later on, which are not first-class entities) need a mapping to a table in the SQL database: </p><pre class="programlisting">&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;

    &lt;class name="Event" table="EVENTS"&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>So far we have told Hibernate how to persist and load object of class <code class="literal">Event</code> to the table <code class="literal">EVENTS</code>. Each instance is now represented by a row in that table. Now we can continue by mapping the unique identifier property to the tables primary key. As we do not want to care about handling this identifier, we configure Hibernate's identifier generation strategy for a surrogate primary key column: </p><pre class="programlisting">&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;

    &lt;class name="Event" table="EVENTS"&gt;
        &lt;id name="id" column="EVENT_ID"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>The <code class="literal">id</code> element is the declaration of the identifier property. The <code class="literal">name="id"</code> mapping attribute declares the name of the JavaBean property and tells Hibernate to use the <code class="literal">getId()</code> and <code class="literal">setId()</code> methods to access the property. The column attribute tells Hibernate which column of the <code class="literal">EVENTS</code> table holds the primary key value. </p><p>The nested <code class="literal">generator</code> element specifies the identifier generation strategy (aka how are identifier values generated?). In this case we choose <code class="literal">native</code>, which offers a level of portability depending on the configured database dialect. Hibernate supports database generated, globally unique, as well as application assigned, identifiers. Identifier value generation is also one of Hibernate's many extension points and you can plugin in your own strategy. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>提示</h2><p><code class="literal">native</code> is no longer consider the best strategy in terms of portability. for further discussion, see <a href="portability.html#portability-idgen" title="25.4. Identifier generation">第 25.4 节 “Identifier generation”</a> </p></div><p>Lastly, we need to tell Hibernate about the remaining entity class properties. By default, no properties of the class are considered persistent: </p><pre class="programlisting">
&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;

    &lt;class name="Event" table="EVENTS"&gt;
        &lt;id name="id" column="EVENT_ID"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="date" type="timestamp" column="EVENT_DATE"/&gt;
        &lt;property name="title"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>Similar to the <code class="literal">id</code> element, the <code class="literal">name</code> attribute of the <code class="literal">property</code> element tells Hibernate which getter and setter methods to use. In this case, Hibernate will search for <code class="literal">getDate()</code>, <code class="literal">setDate()</code>, <code class="literal">getTitle()</code> and <code class="literal">setTitle()</code> methods. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>Why does the <code class="literal">date</code> property mapping include the <code class="literal">column</code> attribute, but the <code class="literal">title</code> does not? Without the <code class="literal">column</code> attribute, Hibernate by default uses the property name as the column name. This works for <code class="literal">title</code>, however, <code class="literal">date</code> is a reserved keyword in most databases so you will need to map it to a different name. </p></div><p>The <code class="literal">title</code> mapping also lacks a <code class="literal">type</code> attribute. The types declared and used in the mapping files are not Java data types; they are not SQL database types either. These types are called <span class="emphasis"><em>Hibernate mapping types</em></span>, converters which can translate from Java to SQL data types and vice versa. Again, Hibernate will try to determine the correct conversion and mapping type itself if the <code class="literal">type</code> attribute is not present in the mapping. In some cases this automatic detection using Reflection on the Java class might not have the default you expect or need. This is the case with the <code class="literal">date</code> property. Hibernate cannot know if the property, which is of <code class="literal">java.util.Date</code>, should map to a SQL <code class="literal">date</code>, <code class="literal">timestamp</code>, or <code class="literal">time</code> column. Full date and time information is preserved by mapping the property with a <code class="literal">timestamp</code> converter. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>提示</h2><p>Hibernate makes this mapping type determination using reflection when the mapping files are processed. This can take time and resources, so if startup performance is important you should consider explicitly defining the type to use. </p></div><p>Save this mapping file as <code class="filename">src/main/resources/org/hibernate/tutorial/domain/Event.hbm.xml</code>. </p></div><div class="sect2" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-configuration"/>1.1.4. Hibernate配置</h3></div></div></div><p>At this point, you should have the persistent class and its mapping file in place. It is now time to configure Hibernate. First let's set up HSQLDB to run in "server mode" </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>We do this do that the data remains between runs. </p></div><p>We will utilize the Maven exec plugin to launch the HSQLDB server by running: <code class="command"> mvn exec:java -Dexec.mainClass="org.hsqldb.Server" -Dexec.args="-database.0 file:target/data/tutorial"</code> You will see it start up and bind to a TCP/IP socket; this is where our application will connect later. If you want to start with a fresh database during this tutorial, shutdown HSQLDB, delete all files in the <code class="filename">target/data</code> directory, and start HSQLDB again. </p><p>Hibernate will be connecting to the database on behalf of your application, so it needs to know how to obtain connections. For this tutorial we will be using a standalone connection pool (as opposed to a <code class="interfacename">javax.sql.DataSource</code>). Hibernate comes with support for two third-party open source JDBC connection pools: <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://sourceforge.net/projects/c3p0">c3p0</a> and <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://proxool.sourceforge.net/">proxool</a>. However, we will be using the Hibernate built-in connection pool for this tutorial. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="caution"><h2>小心</h2><p>The built-in Hibernate connection pool is in no way intended for production use. It lacks several features found on any decent connection pool. </p></div><p>For Hibernate's configuration, we can use a simple <code class="literal">hibernate.properties</code> file, a more sophisticated <code class="literal">hibernate.cfg.xml</code> file, or even complete programmatic setup. Most users prefer the XML configuration file: </p><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;

&lt;hibernate-configuration&gt;

    &lt;session-factory&gt;

        &lt;!-- Database connection settings --&gt;
        &lt;property name="connection.driver_class"&gt;org.hsqldb.jdbcDriver&lt;/property&gt;
        &lt;property name="connection.url"&gt;jdbc:hsqldb:hsql://localhost&lt;/property&gt;
        &lt;property name="connection.username"&gt;sa&lt;/property&gt;
        &lt;property name="connection.password"&gt;&lt;/property&gt;

        &lt;!-- JDBC connection pool (use the built-in) --&gt;
        &lt;property name="connection.pool_size"&gt;1&lt;/property&gt;

        &lt;!-- SQL dialect --&gt;
        &lt;property name="dialect"&gt;org.hibernate.dialect.HSQLDialect&lt;/property&gt;

        &lt;!-- Enable Hibernate's automatic session context management --&gt;
        &lt;property name="current_session_context_class"&gt;thread&lt;/property&gt;

        &lt;!-- Disable the second-level cache  --&gt;
        &lt;property name="cache.provider_class"&gt;org.hibernate.cache.NoCacheProvider&lt;/property&gt;

        &lt;!-- Echo all executed SQL to stdout --&gt;
        &lt;property name="show_sql"&gt;true&lt;/property&gt;

        &lt;!-- Drop and re-create the database schema on startup --&gt;
        &lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt;

        &lt;mapping resource="org/hibernate/tutorial/domain/Event.hbm.xml"/&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>Notice that this configuration file specifies a different DTD</p></div><p>You configure Hibernate's <code class="literal">SessionFactory</code>. SessionFactory is a global factory responsible for a particular database. If you have several databases, for easier startup you should use several <code class="literal">&lt;session-factory&gt;</code> configurations in several configuration files. </p><p>The first four <code class="literal">property</code> elements contain the necessary configuration for the JDBC connection. The dialect <code class="literal">property</code> element specifies the particular SQL variant Hibernate generates. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>提示</h2><p>In most cases, Hibernate is able to properly determine which dialect to use. See <a href="portability.html#portability-dialectresolver" title="25.3. Dialect resolution">第 25.3 节 “Dialect resolution”</a> for more information. </p></div><p>Hibernate's automatic session management for persistence contexts is particularly useful in this context. The <code class="literal">hbm2ddl.auto</code> option turns on automatic generation of database schemas directly into the database. This can also be turned off by removing the configuration option, or redirected to a file with the help of the <code class="literal">SchemaExport</code> Ant task. Finally, add the mapping file(s) for persistent classes to the configuration. </p><p>Save this file as <code class="filename">hibernate.cfg.xml</code> into the <code class="filename">src/main/resources</code> directory. </p></div><div class="sect2" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-mvn"/>1.1.5. Building with Maven</h3></div></div></div><p>We will now build the tutorial with Maven. You will need to have Maven installed; it is available from the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://maven.apache.org/download.html">Maven download page</a>. Maven will read the <code class="filename">/pom.xml</code> file we created earlier and know how to perform some basic project tasks. First, lets run the <code class="literal">compile</code> goal to make sure we can compile everything so far: </p><pre class="programlisting">[hibernateTutorial]$ mvn compile
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Building First Hibernate Tutorial
[INFO]    task-segment: [compile]
[INFO] ------------------------------------------------------------------------
[INFO] [resources:resources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:compile]
[INFO] Compiling 1 source file to /home/steve/projects/sandbox/hibernateTutorial/target/classes
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 2 seconds
[INFO] Finished at: Tue Jun 09 12:25:25 CDT 2009
[INFO] Final Memory: 5M/547M
[INFO] ------------------------------------------------------------------------</pre></div><div class="sect2" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-helpers"/>1.1.6. 启动和辅助类</h3></div></div></div><p>It is time to load and store some <code class="literal">Event</code> objects, but first you have to complete the setup with some infrastructure code. You have to startup Hibernate by building a global <code class="interfacename">org.hibernate.SessionFactory</code> object and storing it somewhere for easy access in application code. A <code class="interfacename">org.hibernate.SessionFactory</code> is used to obtain <code class="interfacename">org.hibernate.Session</code> instances. A <code class="interfacename">org.hibernate.Session</code> represents a single-threaded unit of work. The <code class="interfacename">org.hibernate.SessionFactory</code> is a thread-safe global object that is instantiated once. </p><p>We will create a <code class="literal">HibernateUtil</code> helper class that takes care of startup and makes accessing the <code class="interfacename">org.hibernate.SessionFactory</code> more convenient. </p><pre class="programlisting">package org.hibernate.tutorial.util;

import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;

public class HibernateUtil {

    private static final SessionFactory sessionFactory = buildSessionFactory();

    private static SessionFactory buildSessionFactory() {
        try {
            // Create the SessionFactory from hibernate.cfg.xml
            return new Configuration().configure().buildSessionFactory();
        }
        catch (Throwable ex) {
            // Make sure you log the exception, as it might be swallowed
            System.err.println("Initial SessionFactory creation failed." + ex);
            throw new ExceptionInInitializerError(ex);
        }
    }

    public static SessionFactory getSessionFactory() {
        return sessionFactory;
    }

}</pre><p>Save this code as <code class="filename">src/main/java/org/hibernate/tutorial/util/HibernateUtil.java</code> </p><p>This class not only produces the global <code class="interfacename">org.hibernate.SessionFactory</code> reference in its static initializer; it also hides the fact that it uses a static singleton. We might just as well have looked up the <code class="interfacename">org.hibernate.SessionFactory</code> reference from JNDI in an application server or any other location for that matter. </p><p>If you give the <code class="interfacename">org.hibernate.SessionFactory</code> a name in your configuration, Hibernate will try to bind it to JNDI under that name after it has been built. Another, better option is to use a JMX deployment and let the JMX-capable container instantiate and bind a <code class="literal">HibernateService</code> to JNDI. Such advanced options are discussed later. </p><p>You now need to configure a logging system. Hibernate uses commons logging and provides two choices: Log4j and JDK 1.4 logging. Most developers prefer Log4j: copy <code class="literal">log4j.properties</code> from the Hibernate distribution in the <code class="literal">etc/</code> directory to your <code class="literal">src</code> directory, next to <code class="literal">hibernate.cfg.xml</code>. If you prefer to have more verbose output than that provided in the example configuration, you can change the settings. By default, only the Hibernate startup message is shown on stdout. </p><p>The tutorial infrastructure is complete and you are now ready to do some real work with Hibernate. </p></div><div class="sect2" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-workingpersistence"/>1.1.7. 加载并存储对象</h3></div></div></div><p>We are now ready to start doing some real worjk with Hibernate. Let's start by writing an <code class="literal">EventManager</code> class with a <code class="literal">main()</code> method: </p><pre class="programlisting">package org.hibernate.tutorial;

import org.hibernate.Session;

import java.util.*;

import org.hibernate.tutorial.domain.Event;
import org.hibernate.tutorial.util.HibernateUtil;

public class EventManager {

    public static void main(String[] args) {
        EventManager mgr = new EventManager();

        if (args[0].equals("store")) {
            mgr.createAndStoreEvent("My Event", new Date());
        }

        HibernateUtil.getSessionFactory().close();
    }

    private void createAndStoreEvent(String title, Date theDate) {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();

        Event theEvent = new Event();
        theEvent.setTitle(title);
        theEvent.setDate(theDate);
        session.save(theEvent);

        session.getTransaction().commit();
    }

}</pre><p>In <code class="literal">createAndStoreEvent()</code> we created a new <code class="literal">Event</code> object and handed it over to Hibernate. At that point, Hibernate takes care of the SQL and executes an <code class="literal">INSERT</code> on the database. </p><p>A <span class="interface">org.hibernate.Session</span> is designed to represent a single unit of work (a single atmoic piece of work to be performed). For now we will keep things simple and assume a one-to-one granularity between a Hibernate <span class="interface">org.hibernate.Session</span> and a database transaction. To shield our code from the actual underlying transaction system we use the Hibernate <code class="interfacename">org.hibernate.Transaction</code> API. In this particular case we are using JDBC-based transactional semantics, but it could also run with JTA. </p><p>What does <code class="literal">sessionFactory.getCurrentSession()</code> do? First, you can call it as many times and anywhere you like once you get hold of your <code class="interfacename">org.hibernate.SessionFactory</code>. The <code class="literal">getCurrentSession()</code> method always returns the "current" unit of work. Remember that we switched the configuration option for this mechanism to "thread" in our <code class="filename">src/main/resources/hibernate.cfg.xml</code>? Due to that setting, the context of a current unit of work is bound to the current Java thread that executes the application. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>重要</h2><p>Hibernate offers three methods of current session tracking. The "thread" based method is not intended for production use; it is merely useful for prototyping and tutorials such as this one. Current session tracking is discussed in more detail later on. </p></div><p>A <span class="interface">org.hibernate.Session</span> begins when the first call to <code class="literal">getCurrentSession()</code> is made for the current thread. It is then bound by Hibernate to the current thread. When the transaction ends, either through commit or rollback, Hibernate automatically unbinds the <span class="interface">org.hibernate.Session</span> from the thread and closes it for you. If you call <code class="literal">getCurrentSession()</code> again, you get a new <span class="interface">org.hibernate.Session</span> and can start a new unit of work. </p><p>Related to the unit of work scope, should the Hibernate <span class="interface">org.hibernate.Session</span> be used to execute one or several database operations? The above example uses one <span class="interface">org.hibernate.Session</span> for one operation. However this is pure coincidence; the example is just not complex enough to show any other approach. The scope of a Hibernate <span class="interface">org.hibernate.Session</span> is flexible but you should never design your application to use a new Hibernate <span class="interface">org.hibernate.Session</span> for <span class="emphasis"><em>every</em></span> database operation. Even though it is used in the following examples, consider <span class="emphasis"><em>session-per-operation</em></span> an anti-pattern. A real web application is shown later in the tutorial which will help illustrate this. </p><p>See <a href="transactions.html" title="第 11 章 Transactions and Concurrency">第 11 章 <i xmlns:xlink="http://www.w3.org/1999/xlink">Transactions and Concurrency</i></a> for more information about transaction handling and demarcation. The previous example also skipped any error handling and rollback. </p><p>To run this, we will make use of the Maven exec plugin to call our class with the necessary classpath setup: <code class="command">mvn exec:java -Dexec.mainClass="org.hibernate.tutorial.EventManager" -Dexec.args="store"</code> </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>You may need to perform <code class="command">mvn compile</code> first. </p></div><p>You should see Hibernate starting up and, depending on your configuration, lots of log output. Towards the end, the following line will be displayed: </p><pre class="programlisting">[java] Hibernate: insert into EVENTS (EVENT_DATE, title, EVENT_ID) values (?, ?, ?)</pre><p>This is the <code class="literal">INSERT</code> executed by Hibernate. </p><p>To list stored events an option is added to the main method: </p><pre class="programlisting">        if (args[0].equals("store")) {
            mgr.createAndStoreEvent("My Event", new Date());
        }
        else if (args[0].equals("list")) {
            List events = mgr.listEvents();
            for (int i = 0; i &lt; events.size(); i++) {
                Event theEvent = (Event) events.get(i);
                System.out.println(
                        "Event: " + theEvent.getTitle() + " Time: " + theEvent.getDate()
                );
            }
        }</pre><p>A new <code class="literal">listEvents() method is also added</code>: </p><pre class="programlisting">    private List listEvents() {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();
        List result = session.createQuery("from Event").list();
        session.getTransaction().commit();
        return result;
    }</pre><p>Here, we are using a Hibernate Query Language (HQL) query to load all existing <code class="literal">Event</code> objects from the database. Hibernate will generate the appropriate SQL, send it to the database and populate <code class="literal">Event</code> objects with the data. You can create more complex queries with HQL. See <a href="queryhql.html" title="第 14 章 HQL: Hibernate查询语言">第 14 章 <i xmlns:xlink="http://www.w3.org/1999/xlink">HQL: Hibernate查询语言</i></a> for more information. </p><p>Now we can call our new functionality, again using the Maven exec plugin: <code class="command">mvn exec:java -Dexec.mainClass="org.hibernate.tutorial.EventManager" -Dexec.args="list"</code> </p></div></div><div class="sect1" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial-associations"/>1.2. 第二部分 － 关联映射</h2></div></div></div><p>So far we have mapped a single persistent entity class to a table in isolation. Let's expand on that a bit and add some class associations. We will add people to the application and store a list of events in which they participate. </p><div class="sect2" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-mappinguser"/>1.2.1. 映射Person类</h3></div></div></div><p>The first cut of the <code class="literal">Person</code> class looks like this: </p><pre class="programlisting">package org.hibernate.tutorial.domain;

public class Person {

    private Long id;
    private int age;
    private String firstname;
    private String lastname;

    public Person() {}

    // Accessor methods for all properties, private setter for 'id'

}</pre><p>Save this to a file named <code class="filename">src/main/java/org/hibernate/tutorial/domain/Person.java</code> </p><p>Next, create the new mapping file as <code class="filename">src/main/resources/org/hibernate/tutorial/domain/Person.hbm.xml</code> </p><pre class="programlisting">&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;

    &lt;class name="Person" table="PERSON"&gt;
        &lt;id name="id" column="PERSON_ID"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="age"/&gt;
        &lt;property name="firstname"/&gt;
        &lt;property name="lastname"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>最后，把新的映射加入到Hibernate的配置中： </p><pre class="programlisting">&lt;mapping resource="events/Event.hbm.xml"/&gt;
&lt;mapping resource="events/Person.hbm.xml"/&gt;</pre><p>Create an association between these two entities. Persons can participate in events, and events have participants. The design questions you have to deal with are: directionality, multiplicity, and collection behavior. </p></div><div class="sect2" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-unidirset"/>1.2.2. 单向Set-based的关联</h3></div></div></div><p>By adding a collection of events to the <code class="literal">Person</code> class, you can easily navigate to the events for a particular person, without executing an explicit query - by calling <code class="literal">Person#getEvents</code>. Multi-valued associations are represented in Hibernate by one of the Java Collection Framework contracts; here we choose a <code class="interfacename">java.util.Set</code> because the collection will not contain duplicate elements and the ordering is not relevant to our examples: </p><pre class="programlisting">public class Person {

    private Set events = new HashSet();

    public Set getEvents() {
        return events;
    }

    public void setEvents(Set events) {
        this.events = events;
    }
}</pre><p>Before mapping this association, let's consider the other side. We could just keep this unidirectional or create another collection on the <code class="literal">Event</code>, if we wanted to be able to navigate it from both directions. This is not necessary, from a functional perspective. You can always execute an explicit query to retrieve the participants for a particular event. This is a design choice left to you, but what is clear from this discussion is the multiplicity of the association: "many" valued on both sides is called a <span class="emphasis"><em>many-to-many</em></span> association. Hence, we use Hibernate's many-to-many mapping: </p><pre class="programlisting">&lt;class name="Person" table="PERSON"&gt;
    &lt;id name="id" column="PERSON_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="age"/&gt;
    &lt;property name="firstname"/&gt;
    &lt;property name="lastname"/&gt;

    &lt;set name="events" table="PERSON_EVENT"&gt;
        &lt;key column="PERSON_ID"/&gt;
        &lt;many-to-many column="EVENT_ID" class="Event"/&gt;
    &lt;/set&gt;

&lt;/class&gt;</pre><p>Hibernate supports a broad range of collection mappings, a <code class="literal">set</code> being most common. For a many-to-many association, or <span class="emphasis"><em>n:m</em></span> entity relationship, an association table is required. Each row in this table represents a link between a person and an event. The table name is decalred using the <code class="literal">table</code> attribute of the <code class="literal">set</code> element. The identifier column name in the association, for the person side, is defined with the <code class="literal">key</code> element, the column name for the event's side with the <code class="literal">column</code> attribute of the <code class="literal">many-to-many</code>. You also have to tell Hibernate the class of the objects in your collection (the class on the other side of the collection of references). </p><p>因而这个映射的数据库schema是： </p><pre class="programlisting">
    _____________        __________________
   |             |      |                  |       _____________
   |   EVENTS    |      |   PERSON_EVENT   |      |             |
   |_____________|      |__________________|      |    PERSON   |
   |             |      |                  |      |_____________|
   | *EVENT_ID   | &lt;--&gt; | *EVENT_ID        |      |             |
   |  EVENT_DATE |      | *PERSON_ID       | &lt;--&gt; | *PERSON_ID  |
   |  TITLE      |      |__________________|      |  AGE        |
   |_____________|                                |  FIRSTNAME  |
                                                  |  LASTNAME   |
                                                  |_____________|
 </pre></div><div class="sect2" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-working"/>1.2.3. 使关联工作</h3></div></div></div><p>Now we will bring some people and events together in a new method in <code class="literal">EventManager</code>: </p><pre class="programlisting">    private void addPersonToEvent(Long personId, Long eventId) {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();

        Person aPerson = (Person) session.load(Person.class, personId);
        Event anEvent = (Event) session.load(Event.class, eventId);
        aPerson.getEvents().add(anEvent);

        session.getTransaction().commit();
    }</pre><p>After loading a <code class="literal">Person</code> and an <code class="literal">Event</code>, simply modify the collection using the normal collection methods. There is no explicit call to <code class="literal">update()</code> or <code class="literal">save()</code>; Hibernate automatically detects that the collection has been modified and needs to be updated. This is called <span class="emphasis"><em>automatic dirty checking</em></span>. You can also try it by modifying the name or the date property of any of your objects. As long as they are in <span class="emphasis"><em>persistent</em></span> state, that is, bound to a particular Hibernate <code class="interfacename">org.hibernate.Session</code>, Hibernate monitors any changes and executes SQL in a write-behind fashion. The process of synchronizing the memory state with the database, usually only at the end of a unit of work, is called <span class="emphasis"><em>flushing</em></span>. In our code, the unit of work ends with a commit, or rollback, of the database transaction. </p><p>You can load person and event in different units of work. Or you can modify an object outside of a <code class="interfacename">org.hibernate.Session</code>, when it is not in persistent state (if it was persistent before, this state is called <span class="emphasis"><em>detached</em></span>). You can even modify a collection when it is detached: </p><pre class="programlisting">    private void addPersonToEvent(Long personId, Long eventId) {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();

        Person aPerson = (Person) session
                .createQuery("select p from Person p left join fetch p.events where p.id = :pid")
                .setParameter("pid", personId)
                .uniqueResult(); // Eager fetch the collection so we can use it detached
        Event anEvent = (Event) session.load(Event.class, eventId);

        session.getTransaction().commit();

        // End of first unit of work

        aPerson.getEvents().add(anEvent); // aPerson (and its collection) is detached

        // Begin second unit of work

        Session session2 = HibernateUtil.getSessionFactory().getCurrentSession();
        session2.beginTransaction();
        session2.update(aPerson); // Reattachment of aPerson

        session2.getTransaction().commit();
    }</pre><p>The call to <code class="literal">update</code> makes a detached object persistent again by binding it to a new unit of work, so any modifications you made to it while detached can be saved to the database. This includes any modifications (additions/deletions) you made to a collection of that entity object. </p><p>This is not much use in our example, but it is an important concept you can incorporate into your own application. Complete this exercise by adding a new action to the main method of the <code class="literal">EventManager</code> and call it from the command line. If you need the identifiers of a person and an event - the <code class="literal">save()</code> method returns it (you might have to modify some of the previous methods to return that identifier): </p><pre class="programlisting">        else if (args[0].equals("addpersontoevent")) {
            Long eventId = mgr.createAndStoreEvent("My Event", new Date());
            Long personId = mgr.createAndStorePerson("Foo", "Bar");
            mgr.addPersonToEvent(personId, eventId);
            System.out.println("Added person " + personId + " to event " + eventId);
        }</pre><p>This is an example of an association between two equally important classes : two entities. As mentioned earlier, there are other classes and types in a typical model, usually "less important". Some you have already seen, like an <code class="literal">int</code> or a <code class="classname">java.lang.String</code>. We call these classes <span class="emphasis"><em>value types</em></span>, and their instances <span class="emphasis"><em>depend</em></span> on a particular entity. Instances of these types do not have their own identity, nor are they shared between entities. Two persons do not reference the same <code class="literal">firstname</code> object, even if they have the same first name. Value types cannot only be found in the JDK , but you can also write dependent classes yourself such as an <code class="literal">Address</code> or <code class="literal">MonetaryAmount</code> class. In fact, in a Hibernate application all JDK classes are considered value types. </p><p>You can also design a collection of value types. This is conceptually different from a collection of references to other entities, but looks almost the same in Java. </p></div><div class="sect2" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-valuecollections"/>1.2.4. 值类型的集合</h3></div></div></div><p>Let's add a collection of email addresses to the <code class="literal">Person</code> entity. This will be represented as a <code class="interfacename">java.util.Set</code> of <code class="classname">java.lang.String</code> instances: </p><pre class="programlisting">    private Set emailAddresses = new HashSet();

    public Set getEmailAddresses() {
        return emailAddresses;
    }

    public void setEmailAddresses(Set emailAddresses) {
        this.emailAddresses = emailAddresses;
    }</pre><p>The mapping of this <code class="literal">Set</code> is as follows: </p><pre class="programlisting">        &lt;set name="emailAddresses" table="PERSON_EMAIL_ADDR"&gt;
            &lt;key column="PERSON_ID"/&gt;
            &lt;element type="string" column="EMAIL_ADDR"/&gt;
        &lt;/set&gt;</pre><p>The difference compared with the earlier mapping is the use of the <code class="literal">element</code> part which tells Hibernate that the collection does not contain references to another entity, but is rather a collection whose elements are values types, here specifically of type <code class="literal">string</code>. The lowercase name tells you it is a Hibernate mapping type/converter. Again the <code class="literal">table</code> attribute of the <code class="literal">set</code> element determines the table name for the collection. The <code class="literal">key</code> element defines the foreign-key column name in the collection table. The <code class="literal">column</code> attribute in the <code class="literal">element</code> element defines the column name where the email address values will actually be stored. </p><p>Here is the updated schema: </p><pre class="programlisting">
  _____________        __________________
 |             |      |                  |       _____________
 |   EVENTS    |      |   PERSON_EVENT   |      |             |       ___________________
 |_____________|      |__________________|      |    PERSON   |      |                   |
 |             |      |                  |      |_____________|      | PERSON_EMAIL_ADDR |
 | *EVENT_ID   | &lt;--&gt; | *EVENT_ID        |      |             |      |___________________|
 |  EVENT_DATE |      | *PERSON_ID       | &lt;--&gt; | *PERSON_ID  | &lt;--&gt; |  *PERSON_ID       |
 |  TITLE      |      |__________________|      |  AGE        |      |  *EMAIL_ADDR      |
 |_____________|                                |  FIRSTNAME  |      |___________________|
                                                |  LASTNAME   |
                                                |_____________|
 </pre><p>You can see that the primary key of the collection table is in fact a composite key that uses both columns. This also implies that there cannot be duplicate email addresses per person, which is exactly the semantics we need for a set in Java. </p><p>You can now try to add elements to this collection, just like we did before by linking persons and events. It is the same code in Java: </p><pre class="programlisting">    private void addEmailToPerson(Long personId, String emailAddress) {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();

        Person aPerson = (Person) session.load(Person.class, personId);
        // adding to the emailAddress collection might trigger a lazy load of the collection
        aPerson.getEmailAddresses().add(emailAddress);

        session.getTransaction().commit();
    }</pre><p>This time we did not use a <span class="emphasis"><em>fetch</em></span> query to initialize the collection. Monitor the SQL log and try to optimize this with an eager fetch. </p></div><div class="sect2" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-bidirectional"/>1.2.5. 双向关联</h3></div></div></div><p>Next you will map a bi-directional association. You will make the association between person and event work from both sides in Java. The database schema does not change, so you will still have many-to-many multiplicity. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>A relational database is more flexible than a network programming language, in that it does not need a navigation direction; data can be viewed and retrieved in any possible way. </p></div><p>First, add a collection of participants to the <code class="literal">Event</code> class: </p><pre class="programlisting">    private Set participants = new HashSet();

    public Set getParticipants() {
        return participants;
    }

    public void setParticipants(Set participants) {
        this.participants = participants;
    }</pre><p>Now map this side of the association in <code class="literal">Event.hbm.xml</code>. </p><pre class="programlisting">        &lt;set name="participants" table="PERSON_EVENT" inverse="true"&gt;
            &lt;key column="EVENT_ID"/&gt;
            &lt;many-to-many column="PERSON_ID" class="events.Person"/&gt;
        &lt;/set&gt;</pre><p>These are normal <code class="literal">set</code> mappings in both mapping documents. Notice that the column names in <code class="literal">key</code> and <code class="literal">many-to-many</code> swap in both mapping documents. The most important addition here is the <code class="literal">inverse="true"</code> attribute in the <code class="literal">set</code> element of the <code class="literal">Event</code>'s collection mapping. </p><p>What this means is that Hibernate should take the other side, the <code class="literal">Person</code> class, when it needs to find out information about the link between the two. This will be a lot easier to understand once you see how the bi-directional link between our two entities is created. </p></div><div class="sect2" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-usingbidir"/>1.2.6. 使双向连起来</h3></div></div></div><p>First, keep in mind that Hibernate does not affect normal Java semantics. How did we create a link between a <code class="literal">Person</code> and an <code class="literal">Event</code> in the unidirectional example? You add an instance of <code class="literal">Event</code> to the collection of event references, of an instance of <code class="literal">Person</code>. If you want to make this link bi-directional, you have to do the same on the other side by adding a <code class="literal">Person</code> reference to the collection in an <code class="literal">Event</code>. This process of "setting the link on both sides" is absolutely necessary with bi-directional links. </p><p>Many developers program defensively and create link management methods to correctly set both sides (for example, in <code class="literal">Person</code>): </p><pre class="programlisting">    protected Set getEvents() {
        return events;
    }

    protected void setEvents(Set events) {
        this.events = events;
    }

    public void addToEvent(Event event) {
        this.getEvents().add(event);
        event.getParticipants().add(this);
    }

    public void removeFromEvent(Event event) {
        this.getEvents().remove(event);
        event.getParticipants().remove(this);
    }</pre><p>The get and set methods for the collection are now protected. This allows classes in the same package and subclasses to still access the methods, but prevents everybody else from altering the collections directly. Repeat the steps for the collection on the other side. </p><p>What about the <code class="literal">inverse</code> mapping attribute? For you, and for Java, a bi-directional link is simply a matter of setting the references on both sides correctly. Hibernate, however, does not have enough information to correctly arrange SQL <code class="literal">INSERT</code> and <code class="literal">UPDATE</code> statements (to avoid constraint violations). Making one side of the association <code class="literal">inverse</code> tells Hibernate to consider it a <span class="emphasis"><em>mirror</em></span> of the other side. That is all that is necessary for Hibernate to resolve any issues that arise when transforming a directional navigation model to a SQL database schema. The rules are straightforward: all bi-directional associations need one side as <code class="literal">inverse</code>. In a one-to-many association it has to be the many-side, and in many-to-many association you can select either side. </p></div></div><div class="sect1" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial-webapp"/>1.3. 第三部分 - EventManager web应用程序</h2></div></div></div><p>A Hibernate web application uses <code class="literal">Session</code> and <code class="literal">Transaction</code> almost like a standalone application. However, some common patterns are useful. You can now write an <code class="literal">EventManagerServlet</code>. This servlet can list all events stored in the database, and it provides an HTML form to enter new events. </p><div class="sect2" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-webapp-servlet"/>1.3.1. 编写基本的servlet</h3></div></div></div><p>First we need create our basic processing servlet. Since our servlet only handles HTTP <code class="literal">GET</code> requests, we will only implement the <code class="literal">doGet()</code> method: </p><pre class="programlisting">package org.hibernate.tutorial.web;

// Imports

public class EventManagerServlet extends HttpServlet {

    protected void doGet(
            HttpServletRequest request,
            HttpServletResponse response) throws ServletException, IOException {

        SimpleDateFormat dateFormatter = new SimpleDateFormat( "dd.MM.yyyy" );

        try {
            // Begin unit of work
            HibernateUtil.getSessionFactory().getCurrentSession().beginTransaction();

            // Process request and render page...

            // End unit of work
            HibernateUtil.getSessionFactory().getCurrentSession().getTransaction().commit();
        }
        catch (Exception ex) {
            HibernateUtil.getSessionFactory().getCurrentSession().getTransaction().rollback();
            if ( ServletException.class.isInstance( ex ) ) {
                throw ( ServletException ) ex;
            }
            else {
                throw new ServletException( ex );
            }
        }
    }

}</pre><p>Save this servlet as <code class="filename">src/main/java/org/hibernate/tutorial/web/EventManagerServlet.java</code> </p><p>The pattern applied here is called <span class="emphasis"><em>session-per-request</em></span>. When a request hits the servlet, a new Hibernate <code class="literal">Session</code> is opened through the first call to <code class="literal">getCurrentSession()</code> on the <code class="literal">SessionFactory</code>. A database transaction is then started. All data access occurs inside a transaction irrespective of whether the data is read or written. Do not use the auto-commit mode in applications. </p><p>我们称这里应用的模式为每次请求一个session<span class="emphasis"><em>(session-per-request)</em></span>。当有请求到达这个servlet的时候，通过对<code class="literal">SessionFactory</code>的第一次调用，打开一个新的Hibernate <code class="literal">Session</code>。然后启动一个数据库事务-所有的数据访问都是在事务中进行，不管是读还是写（我们在应用程序中不使用auto-commit模式）。 </p><p>Next, the possible actions of the request are processed and the response HTML is rendered. We will get to that part soon. </p><p>Finally, the unit of work ends when processing and rendering are complete. If any problems occurred during processing or rendering, an exception will be thrown and the database transaction rolled back. This completes the <code class="literal">session-per-request</code> pattern. Instead of the transaction demarcation code in every servlet, you could also write a servlet filter. See the Hibernate website and Wiki for more information about this pattern called <span class="emphasis"><em>Open Session in View</em></span>. You will need it as soon as you consider rendering your view in JSP, not in a servlet. </p></div><div class="sect2" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-webapp-processing"/>1.3.2. 最后，当处理与渲染都结束的时候，这个工作单元就结束了。假若在处理或渲染的时候有任何错误发生，会抛出一个异常，回滚数据库事务。这样，<code class="literal">session-per-request</code>模式就完成了。为了避免在每个servlet中都编写事务边界界定的代码，可以考虑写一个servlet 过滤器（filter）来更好地解决。关于这一模式的更多信息，请参阅Hibernate网站和Wiki，这一模式叫做<span class="emphasis"><em>Open Session in View</em></span>-只要你考虑用JSP来渲染你的视图（view），而不是在servlet中，你就会很快用到它。</h3></div></div></div><p>Now you can implement the processing of the request and the rendering of the page. </p><pre class="programlisting">        // Write HTML header
        PrintWriter out = response.getWriter();
        out.println("&lt;html&gt;&lt;head&gt;&lt;title&gt;Event Manager&lt;/title&gt;&lt;/head&gt;&lt;body&gt;");

        // Handle actions
        if ( "store".equals(request.getParameter("action")) ) {

            String eventTitle = request.getParameter("eventTitle");
            String eventDate = request.getParameter("eventDate");

            if ( "".equals(eventTitle) || "".equals(eventDate) ) {
                out.println("&lt;b&gt;&lt;i&gt;Please enter event title and date.&lt;/i&gt;&lt;/b&gt;");
            }
            else {
                createAndStoreEvent(eventTitle, dateFormatter.parse(eventDate));
                out.println("&lt;b&gt;&lt;i&gt;Added event.&lt;/i&gt;&lt;/b&gt;");
            }
        }

        // Print page
       printEventForm(out);
       listEvents(out, dateFormatter);

       // Write HTML footer
       out.println("&lt;/body&gt;&lt;/html&gt;");
       out.flush();
       out.close();</pre><p>This coding style, with a mix of Java and HTML, would not scale in a more complex application-keep in mind that we are only illustrating basic Hibernate concepts in this tutorial. The code prints an HTML header and a footer. Inside this page, an HTML form for event entry and a list of all events in the database are printed. The first method is trivial and only outputs HTML: </p><pre class="programlisting">    private void printEventForm(PrintWriter out) {
        out.println("&lt;h2&gt;Add new event:&lt;/h2&gt;");
        out.println("&lt;form&gt;");
        out.println("Title: &lt;input name='eventTitle' length='50'/&gt;&lt;br/&gt;");
        out.println("Date (e.g. 24.12.2009): &lt;input name='eventDate' length='10'/&gt;&lt;br/&gt;");
        out.println("&lt;input type='submit' name='action' value='store'/&gt;");
        out.println("&lt;/form&gt;");
    }</pre><p><code class="literal">listEvents()</code>方法使用绑定到当前线程的Hibernate <code class="literal">Session</code>来执行查询： </p><pre class="programlisting">    private void listEvents(PrintWriter out, SimpleDateFormat dateFormatter) {

        List result = HibernateUtil.getSessionFactory()
                .getCurrentSession().createCriteria(Event.class).list();
        if (result.size() &gt; 0) {
            out.println("&lt;h2&gt;Events in database:&lt;/h2&gt;");
            out.println("&lt;table border='1'&gt;");
            out.println("&lt;tr&gt;");
            out.println("&lt;th&gt;Event title&lt;/th&gt;");
            out.println("&lt;th&gt;Event date&lt;/th&gt;");
            out.println("&lt;/tr&gt;");
            Iterator it = result.iterator();
            while (it.hasNext()) {
                Event event = (Event) it.next();
                out.println("&lt;tr&gt;");
                out.println("&lt;td&gt;" + event.getTitle() + "&lt;/td&gt;");
                out.println("&lt;td&gt;" + dateFormatter.format(event.getDate()) + "&lt;/td&gt;");
                out.println("&lt;/tr&gt;");
            }
            out.println("&lt;/table&gt;");
        }
    }</pre><p>最后，<code class="literal">store</code>动作会被导向到<code class="literal">createAndStoreEvent()</code>方法，它也使用当前线程的<code class="literal">Session</code>: </p><pre class="programlisting">    protected void createAndStoreEvent(String title, Date theDate) {
        Event theEvent = new Event();
        theEvent.setTitle(title);
        theEvent.setDate(theDate);

        HibernateUtil.getSessionFactory()
                .getCurrentSession().save(theEvent);
    }</pre><p>The servlet is now complete. A request to the servlet will be processed in a single <code class="literal">Session</code> and <code class="literal">Transaction</code>. As earlier in the standalone application, Hibernate can automatically bind these objects to the current thread of execution. This gives you the freedom to layer your code and access the <code class="literal">SessionFactory</code> in any way you like. Usually you would use a more sophisticated design and move the data access code into data access objects (the DAO pattern). See the Hibernate Wiki for more examples. </p></div><div class="sect2" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-webapp-deploy"/>1.3.3. 部署与测试</h3></div></div></div><p>To deploy this application for testing we must create a Web ARchive (WAR). First we must define the WAR descriptor as <code class="filename">src/main/webapp/WEB-INF/web.xml</code> </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="2.4"
    xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;Event Manager&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.hibernate.tutorial.web.EventManagerServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Event Manager&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/eventmanager&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre><p>To build and deploy call <code class="literal">mvn package</code> in your project directory and copy the <code class="filename">hibernate-tutorial.war</code> file into your Tomcat <code class="filename">webapps</code> directory. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>If you do not have Tomcat installed, download it from <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://tomcat.apache.org/">http://tomcat.apache.org/</a> and follow the installation instructions. Our application requires no changes to the standard Tomcat configuration. </p></div><p>在部署完，启动Tomcat之后，通过<code class="literal">http://localhost:8080/hibernate-tutorial/eventmanager</code>进行访问你的应用，在第一次servlet 请求发生时，请在Tomcat log中确认你看到Hibernate被初始化了（<code class="literal">HibernateUtil</code>的静态初始化器被调用），假若有任何异常抛出，也可以看到详细的输出。 </p></div></div><div class="sect1" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial-summary"/>1.4. 总结</h2></div></div></div><p>This tutorial covered the basics of writing a simple standalone Hibernate application and a small web application. More tutorials are available from the Hibernate <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://hibernate.org">website</a>. </p></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">版权 © 2004 Red Hat Middleware, LLC.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="preface.html"><strong>上一页</strong>前言</a></li><li class="up"><a accesskey="u" href="#"><strong>上一级</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>起始页</strong></a></li><li class="next"><a accesskey="n" href="architecture.html"><strong>下一页</strong>第 2 章 体系结构(Architecture)</a></li></ul></body></html>