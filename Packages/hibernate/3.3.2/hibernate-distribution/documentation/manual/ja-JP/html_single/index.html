<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">HIBERNATE - Relational Persistence for Idiomatic Java</title><link rel="stylesheet" href="css/hibernate-single.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.72.0"/></head><body><div class="book" lang="ja-JP"><div class="titlepage"><div><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><div><h1 class="title"><a id="d0e2"/>HIBERNATE - Relational Persistence for Idiomatic Java</h1></div><div><h2 class="subtitle">Hibernate Reference Documentation</h2></div><div><div xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="authorgroup"><div class="authors">： <span xmlns="http://www.w3.org/1999/xhtml" class="surname">King</span> <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Gavin</span> [FAMILY Given], <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Bauer</span> <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Christian</span> [FAMILY Given], <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Andersen</span> <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Max</span> [FAMILY Given], <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Bernard</span> <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Emmanuel</span> [FAMILY Given], 、 <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Ebersole</span> <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Steve</span> [FAMILY Given]</div><div class="editors"/><div class="others">and thanks to <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Cobb</span> <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">James</span> [FAMILY Given] (Graphic Design) 、 <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Weaver</span> <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Cheyenne</span> [FAMILY Given] (Graphic Design)</div></div></div><div><p class="releaseinfo">3.3.2.GA</p></div><div><p class="copyright">製作著作 © 2004 Red Hat Middleware, LLC.</p></div><div><a href="legalnotice.html">Legal Notice</a></div><div><p class="pubdate">June 24, 2009</p></div></div><hr/></div><div class="toc"><dl><dt><span class="preface"><a href="#preface">前書き</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e197">1. Feedback</a></span></dt></dl></dd><dt><span class="chapter"><a href="#tutorial">1. Tutorial</a></span></dt><dd><dl><dt><span class="sect1"><a href="#tutorial-firstapp">1.1. パート1 - 初めてのHibernateアプリケーション</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-firstapp-setup">1.1.1. Setup</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-firstclass">1.1.2. 最初のクラス</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-mapping">1.1.3. マッピングファイル</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-configuration">1.1.4. Hibernateの設定</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-mvn">1.1.5. Building with Maven</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-helpers">1.1.6. スタートアップとヘルパ</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-workingpersistence">1.1.7. オブジェクトのロードと格納</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-associations">1.2. パート2 - 関連のマッピング</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-associations-mappinguser">1.2.1. Personクラスのマッピング</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-unidirset">1.2.2. 単方向Setベース関連</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-working">1.2.3. 関連を働かせる</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-valuecollections">1.2.4. 値のコレクション</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-bidirectional">1.2.5. 双方向関連</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-usingbidir">1.2.6. 双方向リンクの動作</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-webapp">1.3. パート3 - EventManager Webアプリケーション</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-webapp-servlet">1.3.1. 基本的なServletの記述</a></span></dt><dt><span class="sect2"><a href="#tutorial-webapp-processing">1.3.2. 処理と描画</a></span></dt><dt><span class="sect2"><a href="#tutorial-webapp-deploy">1.3.3. デプロイとテスト</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-summary">1.4. 要約</a></span></dt></dl></dd><dt><span class="chapter"><a href="#architecture">2. アーキテクチャ</a></span></dt><dd><dl><dt><span class="sect1"><a href="#architecture-overview">2.1. 概観</a></span></dt><dt><span class="sect1"><a href="#architecture-states">2.2. インスタンスの状態</a></span></dt><dt><span class="sect1"><a href="#architecture-jmx">2.3. JMXとの統合</a></span></dt><dt><span class="sect1"><a href="#architecture-jca">2.4. JCA サポート</a></span></dt><dt><span class="sect1"><a href="#architecture-current-session">2.5. Contextual sessions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#session-configuration">3. 設定</a></span></dt><dd><dl><dt><span class="sect1"><a href="#configuration-programmatic">3.1. プログラム上の設定</a></span></dt><dt><span class="sect1"><a href="#configuration-sessionfactory">3.2. SessionFactoryを取得する</a></span></dt><dt><span class="sect1"><a href="#configuration-hibernatejdbc">3.3. JDBCコネクション</a></span></dt><dt><span class="sect1"><a href="#configuration-optional">3.4. オプション設定プロパティ</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuration-optional-dialects">3.4.1. SQL 方言（Dialect）</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-outerjoin">3.4.2. 外部結合フェッチ</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-binarystreams">3.4.3. バイナリストリーム</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-cacheprovider">3.4.4. 2次キャッシュとクエリーキャッシュ</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-querysubstitution">3.4.5. クエリー言語の置き換え</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-statistics">3.4.6. Hibernate 統計</a></span></dt></dl></dd><dt><span class="sect1"><a href="#configuration-logging">3.5. ロギング</a></span></dt><dt><span class="sect1"><a href="#configuration-namingstrategy">3.6. <code class="literal">NamingStrategy</code> の実装</a></span></dt><dt><span class="sect1"><a href="#configuration-xmlconfig">3.7. XML設定ファイル</a></span></dt><dt><span class="sect1"><a href="#configuration-j2ee">3.8. J2EEアプリケーションサーバとの統合</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuration-optional-transactionstrategy">3.8.1. トランザクション戦略設定</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-jndi">3.8.2. <code class="literal">SessionFactory</code> のJNDIへの登録</a></span></dt><dt><span class="sect2"><a href="#configuration-j2ee-currentsession">3.8.3. JTAによる現在のセッションコンテキストマネージメント</a></span></dt><dt><span class="sect2"><a href="#configuration-j2ee-jmx">3.8.4. JMXデプロイメント</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#persistent-classes">4. 永続クラス</a></span></dt><dd><dl><dt><span class="sect1"><a href="#persistent-classes-pojo">4.1. 単純なPOJOの例</a></span></dt><dd><dl><dt><span class="sect2"><a href="#persistent-classes-pojo-constructor">4.1.1. 引数のないコンストラクタを実装する</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-identifier">4.1.2. 識別子プロパティを用意する（オプション）</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-final">4.1.3. finalクラスにしない（オプション）</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-accessors">4.1.4. 永続フィールドに対するアクセサとミューテータを定義する（オプション）</a></span></dt></dl></dd><dt><span class="sect1"><a href="#persistent-classes-inheritance">4.2. 継承の実装</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-equalshashcode">4.3. <code class="literal">equals()</code> と <code class="literal">hashCode()</code> の実装</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-dynamicmodels">4.4. 動的モデル</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-tuplizers">4.5. Tuplizer</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-entity-name-resolver">4.6. EntityNameResolvers</a></span></dt></dl></dd><dt><span class="chapter"><a href="#mapping">5. 基本的なO/Rマッピング</a></span></dt><dd><dl><dt><span class="sect1"><a href="#mapping-declaration">5.1. マッピング定義</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-declaration-doctype">5.1.1. Doctype</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-mapping">5.1.2. Hibernate-mapping</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-class">5.1.3. Class</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id">5.1.4. id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id-enhanced">5.1.5. Enhanced identifier generators</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id-enhanced-optimizers">5.1.6. Identifier generator optimization</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-compositeid">5.1.7. composite-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-discriminator">5.1.8. Discriminator</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-version">5.1.9. Version (optional)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-timestamp">5.1.10. Timestamp (optional)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-property">5.1.11. Property</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-manytoone">5.1.12. Many-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-onetoone">5.1.13. One-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-naturalid">5.1.14. Natural-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-component">5.1.15. Component and dynamic-component</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-properties">5.1.16. Properties</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-subclass">5.1.17. Subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-joinedsubclass">5.1.18. Joined-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-unionsubclass">5.1.19. Union-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-join">5.1.20. Join</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-key">5.1.21. Key</a></span></dt><dt><span class="sect2"><a href="#mapping-column">5.1.22. Column and formula elements</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-import">5.1.23. Import</a></span></dt><dt><span class="sect2"><a href="#mapping-types-anymapping">5.1.24. Any</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-types">5.2. Hibernate types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-types-entitiesvalues">5.2.1. エンティティと値</a></span></dt><dt><span class="sect2"><a href="#mapping-types-basictypes">5.2.2. 基本的な型</a></span></dt><dt><span class="sect2"><a href="#mapping-types-custom">5.2.3. カスタム型</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-entityname">5.3. １つのクラスに１つ以上のマッピング</a></span></dt><dt><span class="sect1"><a href="#mapping-quotedidentifiers">5.4. バッククォートで囲んだ SQL 識別子</a></span></dt><dt><span class="sect1"><a href="#mapping-alternatives">5.5. メタデータの代替手段</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-xdoclet">5.5.1. XDoclet マークアップの使用</a></span></dt><dt><span class="sect2"><a href="#mapping-annotations">5.5.2. JDK 5.0 アノテーションの使用</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-generated">5.6. Generated properties</a></span></dt><dt><span class="sect1"><a href="#mapping-database-object">5.7. Auxiliary database objects</a></span></dt></dl></dd><dt><span class="chapter"><a href="#collections">6. Collection mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#collections-persistent">6.1. コレクションの永続化</a></span></dt><dt><span class="sect1"><a href="#collections-mapping">6.2. コレクションのマッピング</a></span></dt><dd><dl><dt><span class="sect2"><a href="#collections-foreignkeys">6.2.1. コレクションの外部キー</a></span></dt><dt><span class="sect2"><a href="#collections-elements">6.2.2. コレクションの要素</a></span></dt><dt><span class="sect2"><a href="#collections-indexed">6.2.3. インデックス付きのコレクション</a></span></dt><dt><span class="sect2"><a href="#collections-ofvalues">6.2.4. 値のコレクションと多対多関連</a></span></dt><dt><span class="sect2"><a href="#collections-onetomany">6.2.5. 一対多関連</a></span></dt></dl></dd><dt><span class="sect1"><a href="#collections-advancedmappings">6.3. 高度なコレクション･マッピング</a></span></dt><dd><dl><dt><span class="sect2"><a href="#collections-sorted">6.3.1. ソートされたコレクション</a></span></dt><dt><span class="sect2"><a href="#collections-bidirectional">6.3.2. 双方向関連</a></span></dt><dt><span class="sect2"><a href="#collections-indexedbidirectional">6.3.3. インデックス付きコレクションと双方向関連</a></span></dt><dt><span class="sect2"><a href="#collections-ternary">6.3.4. 3項関連</a></span></dt><dt><span class="sect2"><a href="#collections-idbag">6.3.5. <code class="literal"><code class="literal">&lt;idbag&gt;</code>の使用</code></a></span></dt></dl></dd><dt><span class="sect1"><a href="#collections-example">6.4. コレクションの例</a></span></dt></dl></dd><dt><span class="chapter"><a href="#associations">7. 関連マッピング</a></span></dt><dd><dl><dt><span class="sect1"><a href="#assoc-intro">7.1. イントロダクション</a></span></dt><dt><span class="sect1"><a href="#assoc-unidirectional">7.2. 単方向関連</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-unidirectional-m21">7.2.1. Many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-121">7.2.2. One-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-12m">7.2.3. One-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-unidirectional-join">7.3. 結合テーブルを使った単方向関連</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-unidirectional-join-12m">7.3.1. One-to-many</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-m21">7.3.2. Many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-121">7.3.3. One-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-m2m">7.3.4. Many-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-bidirectional">7.4. 双方向関連</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-bidirectional-m21">7.4.1. one-to-many / many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-121">7.4.2. One-to-one</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-bidirectional-join">7.5. 結合テーブルを使った双方向関連</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-bidirectional-join-12m">7.5.1. one-to-many / many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-join-121">7.5.2. 一対一</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-join-m2m">7.5.3. Many-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-complex">7.6. より複雑な関連マッピング</a></span></dt></dl></dd><dt><span class="chapter"><a href="#components">8. コンポーネントのマッピング</a></span></dt><dd><dl><dt><span class="sect1"><a href="#components-dependentobjects">8.1. 依存オブジェクト</a></span></dt><dt><span class="sect1"><a href="#components-incollections">8.2. 従属するオブジェクトのコレクション</a></span></dt><dt><span class="sect1"><a href="#components-asmapindex">8.3. Mapのインデックスとしてのコンポーネント</a></span></dt><dt><span class="sect1"><a href="#components-compositeid">8.4. 複合識別子としてのコンポーネント</a></span></dt><dt><span class="sect1"><a href="#components-dynamic">8.5. 動的コンポーネント</a></span></dt></dl></dd><dt><span class="chapter"><a href="#inheritance">9. Inheritance mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#inheritance-strategies">9.1. The three strategies</a></span></dt><dd><dl><dt><span class="sect2"><a href="#inheritance-tableperclass">9.1.1. クラス階層ごとのテーブル（table-per-class-hierarchy）</a></span></dt><dt><span class="sect2"><a href="#inheritance-tablepersubclass">9.1.2. サブクラスごとのテーブル（table-per-subclass）</a></span></dt><dt><span class="sect2"><a href="#inheritance-tablepersubclass-discriminator">9.1.3. Table per subclass: using a discriminator</a></span></dt><dt><span class="sect2"><a href="#inheritance-mixing-tableperclass-tablepersubclass">9.1.4. table-per-subclass と table-per-class-hierarchy の混合</a></span></dt><dt><span class="sect2"><a href="#inheritance-tableperconcrete">9.1.5. 具象クラスごとのテーブル（table-per-concrete-class）</a></span></dt><dt><span class="sect2"><a href="#inheritance-tableperconcreate-polymorphism">9.1.6. Table per concrete class using implicit polymorphism</a></span></dt><dt><span class="sect2"><a href="#inheritance-mixingpolymorphism">9.1.7. 他の継承マッピングと暗黙的ポリモーフィズムの組み合わせ</a></span></dt></dl></dd><dt><span class="sect1"><a href="#inheritance-limitations">9.2. 制限</a></span></dt></dl></dd><dt><span class="chapter"><a href="#objectstate">10. オブジェクトを扱う</a></span></dt><dd><dl><dt><span class="sect1"><a href="#objectstate-overview">10.1. Hibernateにおけるオブジェクトの状態</a></span></dt><dt><span class="sect1"><a href="#objectstate-makingpersistent">10.2. オブジェクトを永続状態にする</a></span></dt><dt><span class="sect1"><a href="#objectstate-loading">10.3. オブジェクトのロード</a></span></dt><dt><span class="sect1"><a href="#objectstate-querying">10.4. クエリ</a></span></dt><dd><dl><dt><span class="sect2"><a href="#objectstate-querying-executing">10.4.1. クエリの実行</a></span></dt><dt><span class="sect2"><a href="#objectstate-filtering">10.4.2. コレクションのフィルタリング</a></span></dt><dt><span class="sect2"><a href="#objecstate-querying-criteria">10.4.3. クライテリアのクエリ</a></span></dt><dt><span class="sect2"><a href="#objectstate-querying-nativesql">10.4.4. ネイティブSQLのクエリ</a></span></dt></dl></dd><dt><span class="sect1"><a href="#objectstate-modifying">10.5. 永続オブジェクトの修正</a></span></dt><dt><span class="sect1"><a href="#objectstate-detached">10.6. 分離オブジェクトの修正</a></span></dt><dt><span class="sect1"><a href="#objectstate-saveorupdate">10.7. 自動的な状態検出</a></span></dt><dt><span class="sect1"><a href="#objectstate-deleting">10.8. 永続オブジェクトの削除</a></span></dt><dt><span class="sect1"><a href="#objectstate-replicating">10.9. 異なる二つのデータストア間でのオブジェクトのレプリケーション</a></span></dt><dt><span class="sect1"><a href="#objectstate-flushing">10.10. セッションのフラッシュ</a></span></dt><dt><span class="sect1"><a href="#objectstate-transitive">10.11. 連鎖的な永続化</a></span></dt><dt><span class="sect1"><a href="#objectstate-metadata">10.12. メタデータの使用</a></span></dt></dl></dd><dt><span class="chapter"><a href="#transactions">11. Transactions and Concurrency</a></span></dt><dd><dl><dt><span class="sect1"><a href="#transactions-basics">11.1. sessionスコープとtransactionスコープ</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-basics-uow">11.1.1. 作業単位（Unit of work）</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-apptx">11.1.2. 長い対話</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-identity">11.1.3. オブジェクト識別子を考える</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-issues">11.1.4. 一般的な問題</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-demarcation">11.2. データベーストランザクション境界</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-demarcation-nonmanaged">11.2.1. 管理されていない環境</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-jta">11.2.2. JTAを使用する</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-exceptions">11.2.3. 例外ハンドリング</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-timeout">11.2.4. トランザクションのタイムアウト</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-optimistic">11.3. 楽観的同時実行制御</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-optimistic-manual">11.3.1. アプリケーションによるバージョンチェック</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-longsession">11.3.2. 拡張セッションと自動バージョニング</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-detached">11.3.3. デタッチされたオブジェクトと自動バージョニング</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-customizing">11.3.4. 自動バージョニングのカスタマイズ</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-locking">11.4. Pessimistic locking</a></span></dt><dt><span class="sect1"><a href="#transactions-connection-release">11.5. Connection release modes</a></span></dt></dl></dd><dt><span class="chapter"><a href="#events">12. インターセプタとイベント</a></span></dt><dd><dl><dt><span class="sect1"><a href="#objectstate-interceptors">12.1. インターセプタ</a></span></dt><dt><span class="sect1"><a href="#objectstate-events">12.2. イベントシステム</a></span></dt><dt><span class="sect1"><a href="#objectstate-decl-security">12.3. Hibernateの宣言的なセキュリティ</a></span></dt></dl></dd><dt><span class="chapter"><a href="#batch">13. ãããå¦ç</a></span></dt><dd><dl><dt><span class="sect1"><a href="#batch-inserts">13.1. ãããæ¿å¥</a></span></dt><dt><span class="sect1"><a href="#batch-update">13.2. ãããæ´æ°</a></span></dt><dt><span class="sect1"><a href="#batch-statelesssession">13.3. StatelessSessionã¤ã³ã¿ã¼ãã§ã¤ã¹</a></span></dt><dt><span class="sect1"><a href="#batch-direct">13.4. DMLã¹ã¿ã¤ã«ã®æä½</a></span></dt></dl></dd><dt><span class="chapter"><a href="#queryhql">14. HQL: The Hibernate Query Language</a></span></dt><dd><dl><dt><span class="sect1"><a href="#queryhql-casesensitivity">14.1. 大文字と小文字の区別</a></span></dt><dt><span class="sect1"><a href="#queryhql-from">14.2. from節</a></span></dt><dt><span class="sect1"><a href="#queryhql-joins">14.3. 関連と結合</a></span></dt><dt><span class="sect1"><a href="#queryhql-joins-forms">14.4. 結合構文の形式</a></span></dt><dt><span class="sect1"><a href="#queryhql-identifier-property">14.5. Referring to identifier property</a></span></dt><dt><span class="sect1"><a href="#queryhql-select">14.6. Select節</a></span></dt><dt><span class="sect1"><a href="#queryhql-aggregation">14.7. 集約関数</a></span></dt><dt><span class="sect1"><a href="#queryhql-polymorphism">14.8. ポリモーフィックなクエリ</a></span></dt><dt><span class="sect1"><a href="#queryhql-where">14.9. where節</a></span></dt><dt><span class="sect1"><a href="#queryhql-expressions">14.10. Expressions 式</a></span></dt><dt><span class="sect1"><a href="#queryhql-ordering">14.11. order by節</a></span></dt><dt><span class="sect1"><a href="#queryhql-grouping">14.12. group by節</a></span></dt><dt><span class="sect1"><a href="#queryhql-subqueries">14.13. 副問い合わせ</a></span></dt><dt><span class="sect1"><a href="#queryhql-examples">14.14. HQLの例</a></span></dt><dt><span class="sect1"><a href="#queryhql-bulk">14.15. 大量のUPDATEとDELETE</a></span></dt><dt><span class="sect1"><a href="#queryhql-tipstricks">14.16. Tips &amp; Tricks</a></span></dt><dt><span class="sect1"><a href="#queryhql-components">14.17. translator-credits</a></span></dt><dt><span class="sect1"><a href="#queryhql-tuple">14.18. Row value constructor syntax</a></span></dt></dl></dd><dt><span class="chapter"><a href="#querycriteria">15. Criteriaクエリ</a></span></dt><dd><dl><dt><span class="sect1"><a href="#querycriteria-creating">15.1. <code class="literal">Criteria</code> インスタンスの作成</a></span></dt><dt><span class="sect1"><a href="#querycriteria-narrowing">15.2. リザルトセットの絞込み</a></span></dt><dt><span class="sect1"><a href="#querycriteria-ordering">15.3. 結果の整列</a></span></dt><dt><span class="sect1"><a href="#querycriteria-associations">15.4. 関連</a></span></dt><dt><span class="sect1"><a href="#querycriteria-dynamicfetching">15.5. 関連の動的フェッチ</a></span></dt><dt><span class="sect1"><a href="#querycriteria-examples">15.6. クエリの例</a></span></dt><dt><span class="sect1"><a href="#querycriteria-projection">15.7. 射影、集約、グループ化</a></span></dt><dt><span class="sect1"><a href="#querycriteria-detachedqueries">15.8. クエリおよびサブクエリの分離</a></span></dt><dt><span class="sect1"><a href="#query-criteria-naturalid">15.9. 自然識別子によるクエリ</a></span></dt></dl></dd><dt><span class="chapter"><a href="#querysql">16. ネイティブSQL</a></span></dt><dd><dl><dt><span class="sect1"><a href="#querysql-creating">16.1. <code class="literal">SQLQuery</code> の使用</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e13308">16.1.1. スカラーのクエリ</a></span></dt><dt><span class="sect2"><a href="#d0e13358">16.1.2. エンティティのクエリ</a></span></dt><dt><span class="sect2"><a href="#d0e13394">16.1.3. 関連とコレクションの操作</a></span></dt><dt><span class="sect2"><a href="#d0e13425">16.1.4. 複数エンティティの取得</a></span></dt><dt><span class="sect2"><a href="#d0e13566">16.1.5. 管理されていないエンティティの取得</a></span></dt><dt><span class="sect2"><a href="#d0e13587">16.1.6. 継承の制御</a></span></dt><dt><span class="sect2"><a href="#d0e13592">16.1.7. パラメータ</a></span></dt></dl></dd><dt><span class="sect1"><a href="#querysql-namedqueries">16.2. 名前付きSQLクエリ</a></span></dt><dd><dl><dt><span class="sect2"><a href="#propertyresults">16.2.1. 列と列の別名を明示的に指定するために return-property を使う</a></span></dt><dt><span class="sect2"><a href="#sp_query">16.2.2. 問い合わせするためにストアドプロシージャを使う</a></span></dt></dl></dd><dt><span class="sect1"><a href="#querysql-cud">16.3. 作成、更新、削除のためのカスタムSQL</a></span></dt><dt><span class="sect1"><a href="#querysql-load">16.4. ロードのためのカスタムSQL</a></span></dt></dl></dd><dt><span class="chapter"><a href="#filters">17. データのフィルタリング</a></span></dt><dd><dl><dt><span class="sect1"><a href="#objectstate-filters">17.1. Hibernateのフィルタ</a></span></dt></dl></dd><dt><span class="chapter"><a href="#xml">18. XMLマッピング</a></span></dt><dd><dl><dt><span class="sect1"><a href="#xml-intro">18.1. XMLデータでの作業</a></span></dt><dd><dl><dt><span class="sect2"><a href="#xml-intro-mapping">18.1.1. XMLとクラスのマッピングを同時に指定する</a></span></dt><dt><span class="sect2"><a href="#xml-onlyxml">18.1.2. XMLマッピングだけを指定する</a></span></dt></dl></dd><dt><span class="sect1"><a href="#xml-mapping">18.2. XMLマッピングのメタデータ</a></span></dt><dt><span class="sect1"><a href="#xml-manipulation">18.3. XMLデータを扱う</a></span></dt></dl></dd><dt><span class="chapter"><a href="#performance">19. パフォーマンスの改善</a></span></dt><dd><dl><dt><span class="sect1"><a href="#performance-fetching">19.1. フェッチ戦略</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-fetching-lazy">19.1.1. 遅延関連の働き</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-custom">19.1.2. フェッチ戦略のチューニング</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-proxies">19.1.3. 単一端関連プロキシ</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-initialization">19.1.4. コレクションとプロキシの初期化</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-batch">19.1.5. バッチフェッチの使用</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-subselect">19.1.6. サブセレクトフェッチの使用</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-lazyproperties">19.1.7. 遅延プロパティフェッチの使用</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-cache">19.2. 第2レベルキャッシュ</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-cache-mapping">19.2.1. キャッシュのマッピング</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readonly">19.2.2. read only戦略</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readwrite">19.2.3. read/write戦略</a></span></dt><dt><span class="sect2"><a href="#performance-cache-nonstrict">19.2.4. 厳密ではないread/write戦略</a></span></dt><dt><span class="sect2"><a href="#performance-cache-transactional">19.2.5. transactional戦略</a></span></dt><dt><span class="sect2"><a href="#performance-cache-compat-matrix">19.2.6. Cache-provider/concurrency-strategy compatibility</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-sessioncache">19.3. キャッシュの管理</a></span></dt><dt><span class="sect1"><a href="#performance-querycache">19.4. クエリキャッシュ</a></span></dt><dt><span class="sect1"><a href="#performance-collections">19.5. コレクションのパフォーマンスの理解</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-collections-taxonomy">19.5.1. 分類</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficientupdate">19.5.2. 更新にもっとも効率的なコレクション list、map、idbag、set</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficentinverse">19.5.3. inverseコレクションにもっとも最適なbagとlist</a></span></dt><dt><span class="sect2"><a href="#performance-collections-oneshotdelete">19.5.4. 一括削除</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-monitoring">19.6. パフォーマンスのモニタリング</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-monitoring-sf">19.6.1. SessionFactoryのモニタリング</a></span></dt><dt><span class="sect2"><a href="#performance-monitoring-metrics">19.6.2. メトリクス</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#toolsetguide">20. Toolset Guide ツールセットガイド</a></span></dt><dd><dl><dt><span class="sect1"><a href="#toolsetguide-s1">20.1. スキーマの自動生成</a></span></dt><dd><dl><dt><span class="sect2"><a href="#toolsetguide-s1-2">20.1.1. スキーマのカスタマイズ</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-3">20.1.2. ツールの実行</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-4">20.1.3. プロパティ</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-5">20.1.4. Antを使用する</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-6">20.1.5. インクリメンタルなスキーマ更新</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-7">20.1.6. インクリメンタルなスキーマ更新に対するAntの使用</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-8">20.1.7. Schema validation</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-9">20.1.8. スキーマのバリデーションにAntを使用します</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#example-parentchild">21. 例：親/子供</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-parentchild-collections">21.1. コレクションに関する注意</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-bidir">21.2. 双方向一対多</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-cascades">21.3. ライフサイクルのカスケード</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-update">21.4. カスケードと <code class="literal">unsaved-value</code></a></span></dt><dt><span class="sect1"><a href="#example-parentchild-conclusion">21.5. 結論</a></span></dt></dl></dd><dt><span class="chapter"><a href="#example-weblog">22. 例: Weblogアプリケーション</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-weblog-classes">22.1. 永続クラス</a></span></dt><dt><span class="sect1"><a href="#example-weblog-mappings">22.2. Hibernateのマッピング</a></span></dt><dt><span class="sect1"><a href="#example-weblog-code">22.3. Hibernateのコード</a></span></dt></dl></dd><dt><span class="chapter"><a href="#example-mappings">23. 例：いろいろなマッピング</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-mappings-emp">23.1. 雇用者/従業員</a></span></dt><dt><span class="sect1"><a href="#example-mappings-authorwork">23.2. 作者/作品</a></span></dt><dt><span class="sect1"><a href="#example-mappings-customerorderproduct">23.3. 顧客/注文/製品</a></span></dt><dt><span class="sect1"><a href="#misc">23.4. 種々雑多なマッピング例</a></span></dt><dd><dl><dt><span class="sect2"><a href="#example-mappings-typed-onetone">23.4.1. 「型付けされた」一対一関連</a></span></dt><dt><span class="sect2"><a href="#example-mappings-composite-key">23.4.2. 複合キーの例</a></span></dt><dt><span class="sect2"><a href="#example-mappings-composite-key-manytomany">23.4.3. 複合キー属性を共有する多対多</a></span></dt><dt><span class="sect2"><a href="#example-mappings-content-discrimination">23.4.4. discriminationに基づく内容</a></span></dt><dt><span class="sect2"><a href="#example-mappings-association-alternatekeys">23.4.5. 代替キーの関連</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#best-practices">24. ベストプラクティス</a></span></dt><dt><span class="chapter"><a href="#portability">25. Database Portability Considerations</a></span></dt><dd><dl><dt><span class="sect1"><a href="#portability-basics">25.1. Portability Basics</a></span></dt><dt><span class="sect1"><a href="#portability-dialect">25.2. Dialect</a></span></dt><dt><span class="sect1"><a href="#portability-dialectresolver">25.3. Dialect resolution</a></span></dt><dt><span class="sect1"><a href="#portability-idgen">25.4. Identifier generation</a></span></dt><dt><span class="sect1"><a href="#portability-functions">25.5. Database functions</a></span></dt><dt><span class="sect1"><a href="#portability-types">25.6. Type mappings</a></span></dt></dl></dd><dt><span class="bibliography"><a href="#d0e16864">References</a></span></dt></dl></div><div class="preface" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="preface"/>前書き</h2></div></div></div><p>Working with object-oriented software and a relational database can be cumbersome and time consuming in today's enterprise environments. Hibernate is an Object/Relational Mapping tool for Java environments. The term Object/Relational Mapping (ORM) refers to the technique of mapping a data representation from an object model to a relational data model with a SQL-based schema. </p><p>Hibernate not only takes care of the mapping from Java classes to database tables (and from Java data types to SQL data types), but also provides data query and retrieval facilities. It can also significantly reduce development time otherwise spent with manual data handling in SQL and JDBC. </p><p>Hibernate's goal is to relieve the developer from 95 percent of common data persistence related programming tasks. Hibernate may not be the best solution for data-centric applications that only use stored-procedures to implement the business logic in the database, it is most useful with object-oriented domain models and business logic in the Java-based middle-tier. However, Hibernate can certainly help you to remove or encapsulate vendor-specific SQL code and will help with the common task of result set translation from a tabular representation to a graph of objects. </p><p>Hibernateやオブジェクト/リレーショナルマッピング、 さらにはJavaが初めての方は、以下のステップに従ってください： </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p><a href="#tutorial" title="第1章 Tutorial">章 1. <i xmlns:xlink="http://www.w3.org/1999/xlink">Tutorial</i></a> を読んでください。 段階的に解説していきます。 チュートリアルのソースコードはディストリビューションの <code class="literal">doc/reference/tutorial</code> ディレクトリに含まれています。 </p></li><li><p><a href="#architecture" title="第2章 アーキテクチャ">章 2. <i xmlns:xlink="http://www.w3.org/1999/xlink">アーキテクチャ</i></a> を読んで、Hibernateが利用可能な環境を理解してください。 </p></li><li><p>View the <code class="literal">eg/</code> directory in the Hibernate distribution. It contains a simple standalone application. Copy your JDBC driver to the <code class="literal">lib/</code> directory and edit <code class="literal">etc/hibernate.properties</code>, specifying correct values for your database. From a command prompt in the distribution directory, type <code class="literal">ant eg</code> (using Ant), or under Windows, type <code class="literal">build eg</code>. </p></li><li><p>Use this reference documentation as your primary source of information. Consider reading [<a xmlns:xlink="http://www.w3.org/1999/xlink" href="#biblio-JPwH" title="[JPwH]"><abbr class="abbrev">JPwH</abbr></a>] if you need more help with application design, or if you prefer a step-by-step tutorial. Also visit <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://caveatemptor.hibernate.org">http://caveatemptor.hibernate.org</a> and download the example application from [<a xmlns:xlink="http://www.w3.org/1999/xlink" href="#biblio-JPwH" title="[JPwH]"><abbr class="abbrev">JPwH</abbr></a>]. </p></li><li><p>FAQはHibernateウェブサイトにあります。 </p></li><li><p>Links to third party demos, examples, and tutorials are maintained on the Hibernate website. </p></li><li><p>Hibernateウェブサイトのコミュニティエリアは、デザインパターンやさまざまな統合ソリューション （Tomcat, JBoss AS, Struts, EJB, 等）についてのよい情報源です。 </p></li></ol></div><p>If you have questions, use the user forum linked on the Hibernate website. We also provide a JIRA issue tracking system for bug reports and feature requests. If you are interested in the development of Hibernate, join the developer mailing list. If you are interested in translating this documentation into your language, contact us on the developer mailing list. </p><p>商用開発のサポート、製品のサポート、HibernateのトレーニングはJBoss Inc.が提供しています （http://www.hibernate.org/SupportTraining/を見てください）。 HibernateはProfessional Open Sourceプロジェクト、 そしてJBoss Enterprise Middleware System（JEMS）プロダクトスイートのクリティカルコンポーネントです。 </p><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="d0e197"/>1. Feedback</h2></div></div></div><p>Use <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://opensource.atlassian.com/projects/hibernate">Hibernate JIRA</a> to report errors or request enhacements to this documentation. </p></div></div><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial"/>第1章 Tutorial</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#tutorial-firstapp">1.1. パート1 - 初めてのHibernateアプリケーション</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-firstapp-setup">1.1.1. Setup</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-firstclass">1.1.2. 最初のクラス</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-mapping">1.1.3. マッピングファイル</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-configuration">1.1.4. Hibernateの設定</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-mvn">1.1.5. Building with Maven</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-helpers">1.1.6. スタートアップとヘルパ</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-workingpersistence">1.1.7. オブジェクトのロードと格納</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-associations">1.2. パート2 - 関連のマッピング</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-associations-mappinguser">1.2.1. Personクラスのマッピング</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-unidirset">1.2.2. 単方向Setベース関連</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-working">1.2.3. 関連を働かせる</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-valuecollections">1.2.4. 値のコレクション</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-bidirectional">1.2.5. 双方向関連</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-usingbidir">1.2.6. 双方向リンクの動作</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-webapp">1.3. パート3 - EventManager Webアプリケーション</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-webapp-servlet">1.3.1. 基本的なServletの記述</a></span></dt><dt><span class="sect2"><a href="#tutorial-webapp-processing">1.3.2. 処理と描画</a></span></dt><dt><span class="sect2"><a href="#tutorial-webapp-deploy">1.3.3. デプロイとテスト</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-summary">1.4. 要約</a></span></dt></dl></div><p>Intended for new users, this chapter provides an step-by-step introduction to Hibernate, starting with a simple application using an in-memory database. The tutorial is based on an earlier tutorial developed by Michael Gloegl. All code is contained in the <code class="filename">tutorials/web</code> directory of the project source. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>重要項目</h2><p>This tutorial expects the user have knowledge of both Java and SQL. If you have a limited knowledge of JAVA or SQL, it is advised that you start with a good introduction to that technology prior to attempting to learn Hibernate. </p></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>The distribution contains another example application under the <code class="filename">tutorial/eg</code> project source directory. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial-firstapp"/>1.1. パート1 - 初めてのHibernateアプリケーション</h2></div></div></div><p>For this example, we will set up a small database application that can store events we want to attend and information about the host(s) of these events. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>Although you can use whatever database you feel comfortable using, we will use <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://hsqldb.org/">HSQLDB</a> (an in-memory, Java database) to avoid describing installation/setup of any particular database servers. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-setup"/>1.1.1. Setup</h3></div></div></div><p>The first thing we need to do is to set up the development environment. We will be using the "standard layout" advocated by alot of build tools such as <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://maven.org">Maven</a>. Maven, in particular, has a good resource describing this <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html">layout</a>. As this tutorial is to be a web application, we will be creating and making use of <code class="filename">src/main/java</code>, <code class="filename">src/main/resources</code> and <code class="filename">src/main/webapp</code> directories. </p><p>We will be using Maven in this tutorial, taking advantage of its transitive dependency management capabilities as well as the ability of many IDEs to automatically set up a project for us based on the maven descriptor. </p><pre class="programlisting">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;

    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.hibernate.tutorials&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-tutorial&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;First Hibernate Tutorial&lt;/name&gt;

    &lt;build&gt;
         &lt;!-- we dont want the version to be part of the generated war file name --&gt;
         &lt;finalName&gt;${artifactId}&lt;/finalName&gt;
    &lt;/build&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- Because this is a web app, we also have a dependency on the servlet api. --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- Hibernate uses slf4j for logging, for our purposes here use the simple backend --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- Hibernate gives you a choice of bytecode providers between cglib and javassist --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javassist&lt;/groupId&gt;
            &lt;artifactId&gt;javassist&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>ティップ</h2><p>It is not a requirement to use Maven. If you wish to use something else to build this tutoial (such as Ant), the layout will remain the same. The only change is that you will need to manually account for all the needed dependencies. If you use something like <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://ant.apache.org/ivy/">Ivy</a> providing transitive dependency management you would still use the dependencies mentioned below. Otherwise, you'd need to grab <span class="emphasis"><em>all</em></span> dependencies, both explicit and transitive, and add them to the project's classpath. If working from the Hibernate distribution bundle, this would mean <code class="filename">hibernate3.jar</code>, all artifacts in the <code class="filename">lib/required</code> directory and all files from either the <code class="filename">lib/bytecode/cglib</code> or <code class="filename">lib/bytecode/javassist</code> directory; additionally you will need both the servlet-api jar and one of the slf4j logging backends. </p></div><p>Save this file as <code class="filename">pom.xml</code> in the project root directory. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-firstclass"/>1.1.2. 最初のクラス</h3></div></div></div><p>Next, we create a class that represents the event we want to store in the database; it is a simple JavaBean class with some properties: </p><pre class="programlisting">package org.hibernate.tutorial.domain;

import java.util.Date;

public class Event {
    private Long id;

    private String title;
    private Date date;

    public Event() {}

    public Long getId() {
        return id;
    }

    private void setId(Long id) {
        this.id = id;
    }

    public Date getDate() {
        return date;
    }

    public void setDate(Date date) {
        this.date = date;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }
}</pre><p>This class uses standard JavaBean naming conventions for property getter and setter methods, as well as private visibility for the fields. Although this is the recommended design, it is not required. Hibernate can also access fields directly, the benefit of accessor methods is robustness for refactoring. </p><p>The <code class="literal">id</code> property holds a unique identifier value for a particular event. All persistent entity classes (there are less important dependent classes as well) will need such an identifier property if we want to use the full feature set of Hibernate. In fact, most applications, especially web applications, need to distinguish objects by identifier, so you should consider this a feature rather than a limitation. However, we usually do not manipulate the identity of an object, hence the setter method should be private. Only Hibernate will assign identifiers when an object is saved. Hibernate can access public, private, and protected accessor methods, as well as public, private and protected fields directly. The choice is up to you and you can match it to fit your application design. </p><p>The no-argument constructor is a requirement for all persistent classes; Hibernate has to create objects for you, using Java Reflection. The constructor can be private, however package or public visibility is required for runtime proxy generation and efficient data retrieval without bytecode instrumentation. </p><p>Save this file to the <code class="filename">src/main/java/org/hibernate/tutorial/domain</code> directory. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-mapping"/>1.1.3. マッピングファイル</h3></div></div></div><p>Hibernateは、どのように永続クラスのオブジェクトをロードし格納すればよいかを知る必要があります。 ここでHibernateマッピングファイルが登場します。 マッピングファイルは、データベース内のどのテーブルにアクセスしなければならないか、 そのテーブルのどのカラムを使うべきかを、Hibernateに教えます。 </p><p>マッピングファイルの基本的な構造はこのようになります： </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;
[...]
&lt;/hibernate-mapping&gt;</pre><p>Hibernate DTD is sophisticated. You can use it for auto-completion of XML mapping elements and attributes in your editor or IDE. Opening up the DTD file in your text editor is the easiest way to get an overview of all elements and attributes, and to view the defaults, as well as some comments. Hibernate will not load the DTD file from the web, but first look it up from the classpath of the application. The DTD file is included in <code class="filename">hibernate-core.jar</code> (it is also included in the <code class="filename">hibernate3.jar</code>, if using the distribution bundle). </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>重要項目</h2><p>We will omit the DTD declaration in future examples to shorten the code. It is, of course, not optional. </p></div><p>Between the two <code class="literal">hibernate-mapping</code> tags, include a <code class="literal">class</code> element. All persistent entity classes (again, there might be dependent classes later on, which are not first-class entities) need a mapping to a table in the SQL database: </p><pre class="programlisting">&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;

    &lt;class name="Event" table="EVENTS"&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>So far we have told Hibernate how to persist and load object of class <code class="literal">Event</code> to the table <code class="literal">EVENTS</code>. Each instance is now represented by a row in that table. Now we can continue by mapping the unique identifier property to the tables primary key. As we do not want to care about handling this identifier, we configure Hibernate's identifier generation strategy for a surrogate primary key column: </p><pre class="programlisting">&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;

    &lt;class name="Event" table="EVENTS"&gt;
        &lt;id name="id" column="EVENT_ID"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>The <code class="literal">id</code> element is the declaration of the identifier property. The <code class="literal">name="id"</code> mapping attribute declares the name of the JavaBean property and tells Hibernate to use the <code class="literal">getId()</code> and <code class="literal">setId()</code> methods to access the property. The column attribute tells Hibernate which column of the <code class="literal">EVENTS</code> table holds the primary key value. </p><p>The nested <code class="literal">generator</code> element specifies the identifier generation strategy (aka how are identifier values generated?). In this case we choose <code class="literal">native</code>, which offers a level of portability depending on the configured database dialect. Hibernate supports database generated, globally unique, as well as application assigned, identifiers. Identifier value generation is also one of Hibernate's many extension points and you can plugin in your own strategy. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>ティップ</h2><p><code class="literal">native</code> is no longer consider the best strategy in terms of portability. for further discussion, see <a href="#portability-idgen" title="25.4. Identifier generation">項25.4. 「Identifier generation」</a> </p></div><p>Lastly, we need to tell Hibernate about the remaining entity class properties. By default, no properties of the class are considered persistent: </p><pre class="programlisting">
&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;

    &lt;class name="Event" table="EVENTS"&gt;
        &lt;id name="id" column="EVENT_ID"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="date" type="timestamp" column="EVENT_DATE"/&gt;
        &lt;property name="title"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>Similar to the <code class="literal">id</code> element, the <code class="literal">name</code> attribute of the <code class="literal">property</code> element tells Hibernate which getter and setter methods to use. In this case, Hibernate will search for <code class="literal">getDate()</code>, <code class="literal">setDate()</code>, <code class="literal">getTitle()</code> and <code class="literal">setTitle()</code> methods. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>Why does the <code class="literal">date</code> property mapping include the <code class="literal">column</code> attribute, but the <code class="literal">title</code> does not? Without the <code class="literal">column</code> attribute, Hibernate by default uses the property name as the column name. This works for <code class="literal">title</code>, however, <code class="literal">date</code> is a reserved keyword in most databases so you will need to map it to a different name. </p></div><p>The <code class="literal">title</code> mapping also lacks a <code class="literal">type</code> attribute. The types declared and used in the mapping files are not Java data types; they are not SQL database types either. These types are called <span class="emphasis"><em>Hibernate mapping types</em></span>, converters which can translate from Java to SQL data types and vice versa. Again, Hibernate will try to determine the correct conversion and mapping type itself if the <code class="literal">type</code> attribute is not present in the mapping. In some cases this automatic detection using Reflection on the Java class might not have the default you expect or need. This is the case with the <code class="literal">date</code> property. Hibernate cannot know if the property, which is of <code class="literal">java.util.Date</code>, should map to a SQL <code class="literal">date</code>, <code class="literal">timestamp</code>, or <code class="literal">time</code> column. Full date and time information is preserved by mapping the property with a <code class="literal">timestamp</code> converter. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>ティップ</h2><p>Hibernate makes this mapping type determination using reflection when the mapping files are processed. This can take time and resources, so if startup performance is important you should consider explicitly defining the type to use. </p></div><p>Save this mapping file as <code class="filename">src/main/resources/org/hibernate/tutorial/domain/Event.hbm.xml</code>. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-configuration"/>1.1.4. Hibernateの設定</h3></div></div></div><p>At this point, you should have the persistent class and its mapping file in place. It is now time to configure Hibernate. First let's set up HSQLDB to run in "server mode" </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>We do this do that the data remains between runs. </p></div><p>We will utilize the Maven exec plugin to launch the HSQLDB server by running: <code class="command"> mvn exec:java -Dexec.mainClass="org.hsqldb.Server" -Dexec.args="-database.0 file:target/data/tutorial"</code> You will see it start up and bind to a TCP/IP socket; this is where our application will connect later. If you want to start with a fresh database during this tutorial, shutdown HSQLDB, delete all files in the <code class="filename">target/data</code> directory, and start HSQLDB again. </p><p>Hibernate will be connecting to the database on behalf of your application, so it needs to know how to obtain connections. For this tutorial we will be using a standalone connection pool (as opposed to a <code class="interfacename">javax.sql.DataSource</code>). Hibernate comes with support for two third-party open source JDBC connection pools: <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://sourceforge.net/projects/c3p0">c3p0</a> and <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://proxool.sourceforge.net/">proxool</a>. However, we will be using the Hibernate built-in connection pool for this tutorial. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="caution"><h2>注意</h2><p>The built-in Hibernate connection pool is in no way intended for production use. It lacks several features found on any decent connection pool. </p></div><p>For Hibernate's configuration, we can use a simple <code class="literal">hibernate.properties</code> file, a more sophisticated <code class="literal">hibernate.cfg.xml</code> file, or even complete programmatic setup. Most users prefer the XML configuration file: </p><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;

&lt;hibernate-configuration&gt;

    &lt;session-factory&gt;

        &lt;!-- Database connection settings --&gt;
        &lt;property name="connection.driver_class"&gt;org.hsqldb.jdbcDriver&lt;/property&gt;
        &lt;property name="connection.url"&gt;jdbc:hsqldb:hsql://localhost&lt;/property&gt;
        &lt;property name="connection.username"&gt;sa&lt;/property&gt;
        &lt;property name="connection.password"&gt;&lt;/property&gt;

        &lt;!-- JDBC connection pool (use the built-in) --&gt;
        &lt;property name="connection.pool_size"&gt;1&lt;/property&gt;

        &lt;!-- SQL dialect --&gt;
        &lt;property name="dialect"&gt;org.hibernate.dialect.HSQLDialect&lt;/property&gt;

        &lt;!-- Enable Hibernate's automatic session context management --&gt;
        &lt;property name="current_session_context_class"&gt;thread&lt;/property&gt;

        &lt;!-- Disable the second-level cache  --&gt;
        &lt;property name="cache.provider_class"&gt;org.hibernate.cache.NoCacheProvider&lt;/property&gt;

        &lt;!-- Echo all executed SQL to stdout --&gt;
        &lt;property name="show_sql"&gt;true&lt;/property&gt;

        &lt;!-- Drop and re-create the database schema on startup --&gt;
        &lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt;

        &lt;mapping resource="org/hibernate/tutorial/domain/Event.hbm.xml"/&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>Notice that this configuration file specifies a different DTD</p></div><p>You configure Hibernate's <code class="literal">SessionFactory</code>. SessionFactory is a global factory responsible for a particular database. If you have several databases, for easier startup you should use several <code class="literal">&lt;session-factory&gt;</code> configurations in several configuration files. </p><p>The first four <code class="literal">property</code> elements contain the necessary configuration for the JDBC connection. The dialect <code class="literal">property</code> element specifies the particular SQL variant Hibernate generates. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>ティップ</h2><p>In most cases, Hibernate is able to properly determine which dialect to use. See <a href="#portability-dialectresolver" title="25.3. Dialect resolution">項25.3. 「Dialect resolution」</a> for more information. </p></div><p>Hibernate's automatic session management for persistence contexts is particularly useful in this context. The <code class="literal">hbm2ddl.auto</code> option turns on automatic generation of database schemas directly into the database. This can also be turned off by removing the configuration option, or redirected to a file with the help of the <code class="literal">SchemaExport</code> Ant task. Finally, add the mapping file(s) for persistent classes to the configuration. </p><p>Save this file as <code class="filename">hibernate.cfg.xml</code> into the <code class="filename">src/main/resources</code> directory. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-mvn"/>1.1.5. Building with Maven</h3></div></div></div><p>We will now build the tutorial with Maven. You will need to have Maven installed; it is available from the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://maven.apache.org/download.html">Maven download page</a>. Maven will read the <code class="filename">/pom.xml</code> file we created earlier and know how to perform some basic project tasks. First, lets run the <code class="literal">compile</code> goal to make sure we can compile everything so far: </p><pre class="programlisting">[hibernateTutorial]$ mvn compile
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Building First Hibernate Tutorial
[INFO]    task-segment: [compile]
[INFO] ------------------------------------------------------------------------
[INFO] [resources:resources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:compile]
[INFO] Compiling 1 source file to /home/steve/projects/sandbox/hibernateTutorial/target/classes
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 2 seconds
[INFO] Finished at: Tue Jun 09 12:25:25 CDT 2009
[INFO] Final Memory: 5M/547M
[INFO] ------------------------------------------------------------------------</pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-helpers"/>1.1.6. スタートアップとヘルパ</h3></div></div></div><p>It is time to load and store some <code class="literal">Event</code> objects, but first you have to complete the setup with some infrastructure code. You have to startup Hibernate by building a global <code class="interfacename">org.hibernate.SessionFactory</code> object and storing it somewhere for easy access in application code. A <code class="interfacename">org.hibernate.SessionFactory</code> is used to obtain <code class="interfacename">org.hibernate.Session</code> instances. A <code class="interfacename">org.hibernate.Session</code> represents a single-threaded unit of work. The <code class="interfacename">org.hibernate.SessionFactory</code> is a thread-safe global object that is instantiated once. </p><p>We will create a <code class="literal">HibernateUtil</code> helper class that takes care of startup and makes accessing the <code class="interfacename">org.hibernate.SessionFactory</code> more convenient. </p><pre class="programlisting">package org.hibernate.tutorial.util;

import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;

public class HibernateUtil {

    private static final SessionFactory sessionFactory = buildSessionFactory();

    private static SessionFactory buildSessionFactory() {
        try {
            // Create the SessionFactory from hibernate.cfg.xml
            return new Configuration().configure().buildSessionFactory();
        }
        catch (Throwable ex) {
            // Make sure you log the exception, as it might be swallowed
            System.err.println("Initial SessionFactory creation failed." + ex);
            throw new ExceptionInInitializerError(ex);
        }
    }

    public static SessionFactory getSessionFactory() {
        return sessionFactory;
    }

}</pre><p>Save this code as <code class="filename">src/main/java/org/hibernate/tutorial/util/HibernateUtil.java</code> </p><p>This class not only produces the global <code class="interfacename">org.hibernate.SessionFactory</code> reference in its static initializer; it also hides the fact that it uses a static singleton. We might just as well have looked up the <code class="interfacename">org.hibernate.SessionFactory</code> reference from JNDI in an application server or any other location for that matter. </p><p>If you give the <code class="interfacename">org.hibernate.SessionFactory</code> a name in your configuration, Hibernate will try to bind it to JNDI under that name after it has been built. Another, better option is to use a JMX deployment and let the JMX-capable container instantiate and bind a <code class="literal">HibernateService</code> to JNDI. Such advanced options are discussed later. </p><p>You now need to configure a logging system. Hibernate uses commons logging and provides two choices: Log4j and JDK 1.4 logging. Most developers prefer Log4j: copy <code class="literal">log4j.properties</code> from the Hibernate distribution in the <code class="literal">etc/</code> directory to your <code class="literal">src</code> directory, next to <code class="literal">hibernate.cfg.xml</code>. If you prefer to have more verbose output than that provided in the example configuration, you can change the settings. By default, only the Hibernate startup message is shown on stdout. </p><p>The tutorial infrastructure is complete and you are now ready to do some real work with Hibernate. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-workingpersistence"/>1.1.7. オブジェクトのロードと格納</h3></div></div></div><p>We are now ready to start doing some real worjk with Hibernate. Let's start by writing an <code class="literal">EventManager</code> class with a <code class="literal">main()</code> method: </p><pre class="programlisting">package org.hibernate.tutorial;

import org.hibernate.Session;

import java.util.*;

import org.hibernate.tutorial.domain.Event;
import org.hibernate.tutorial.util.HibernateUtil;

public class EventManager {

    public static void main(String[] args) {
        EventManager mgr = new EventManager();

        if (args[0].equals("store")) {
            mgr.createAndStoreEvent("My Event", new Date());
        }

        HibernateUtil.getSessionFactory().close();
    }

    private void createAndStoreEvent(String title, Date theDate) {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();

        Event theEvent = new Event();
        theEvent.setTitle(title);
        theEvent.setDate(theDate);
        session.save(theEvent);

        session.getTransaction().commit();
    }

}</pre><p>In <code class="literal">createAndStoreEvent()</code> we created a new <code class="literal">Event</code> object and handed it over to Hibernate. At that point, Hibernate takes care of the SQL and executes an <code class="literal">INSERT</code> on the database. </p><p>A <span class="interface">org.hibernate.Session</span> is designed to represent a single unit of work (a single atmoic piece of work to be performed). For now we will keep things simple and assume a one-to-one granularity between a Hibernate <span class="interface">org.hibernate.Session</span> and a database transaction. To shield our code from the actual underlying transaction system we use the Hibernate <code class="interfacename">org.hibernate.Transaction</code> API. In this particular case we are using JDBC-based transactional semantics, but it could also run with JTA. </p><p>What does <code class="literal">sessionFactory.getCurrentSession()</code> do? First, you can call it as many times and anywhere you like once you get hold of your <code class="interfacename">org.hibernate.SessionFactory</code>. The <code class="literal">getCurrentSession()</code> method always returns the "current" unit of work. Remember that we switched the configuration option for this mechanism to "thread" in our <code class="filename">src/main/resources/hibernate.cfg.xml</code>? Due to that setting, the context of a current unit of work is bound to the current Java thread that executes the application. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>重要項目</h2><p>Hibernate offers three methods of current session tracking. The "thread" based method is not intended for production use; it is merely useful for prototyping and tutorials such as this one. Current session tracking is discussed in more detail later on. </p></div><p>A <span class="interface">org.hibernate.Session</span> begins when the first call to <code class="literal">getCurrentSession()</code> is made for the current thread. It is then bound by Hibernate to the current thread. When the transaction ends, either through commit or rollback, Hibernate automatically unbinds the <span class="interface">org.hibernate.Session</span> from the thread and closes it for you. If you call <code class="literal">getCurrentSession()</code> again, you get a new <span class="interface">org.hibernate.Session</span> and can start a new unit of work. </p><p>Related to the unit of work scope, should the Hibernate <span class="interface">org.hibernate.Session</span> be used to execute one or several database operations? The above example uses one <span class="interface">org.hibernate.Session</span> for one operation. However this is pure coincidence; the example is just not complex enough to show any other approach. The scope of a Hibernate <span class="interface">org.hibernate.Session</span> is flexible but you should never design your application to use a new Hibernate <span class="interface">org.hibernate.Session</span> for <span class="emphasis"><em>every</em></span> database operation. Even though it is used in the following examples, consider <span class="emphasis"><em>session-per-operation</em></span> an anti-pattern. A real web application is shown later in the tutorial which will help illustrate this. </p><p>See <a href="#transactions" title="第11章 Transactions and Concurrency">章 11. <i xmlns:xlink="http://www.w3.org/1999/xlink">Transactions and Concurrency</i></a> for more information about transaction handling and demarcation. The previous example also skipped any error handling and rollback. </p><p>To run this, we will make use of the Maven exec plugin to call our class with the necessary classpath setup: <code class="command">mvn exec:java -Dexec.mainClass="org.hibernate.tutorial.EventManager" -Dexec.args="store"</code> </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>You may need to perform <code class="command">mvn compile</code> first. </p></div><p>You should see Hibernate starting up and, depending on your configuration, lots of log output. Towards the end, the following line will be displayed: </p><pre class="programlisting">[java] Hibernate: insert into EVENTS (EVENT_DATE, title, EVENT_ID) values (?, ?, ?)</pre><p>This is the <code class="literal">INSERT</code> executed by Hibernate. </p><p>To list stored events an option is added to the main method: </p><pre class="programlisting">        if (args[0].equals("store")) {
            mgr.createAndStoreEvent("My Event", new Date());
        }
        else if (args[0].equals("list")) {
            List events = mgr.listEvents();
            for (int i = 0; i &lt; events.size(); i++) {
                Event theEvent = (Event) events.get(i);
                System.out.println(
                        "Event: " + theEvent.getTitle() + " Time: " + theEvent.getDate()
                );
            }
        }</pre><p>A new <code class="literal">listEvents() method is also added</code>: </p><pre class="programlisting">    private List listEvents() {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();
        List result = session.createQuery("from Event").list();
        session.getTransaction().commit();
        return result;
    }</pre><p>Here, we are using a Hibernate Query Language (HQL) query to load all existing <code class="literal">Event</code> objects from the database. Hibernate will generate the appropriate SQL, send it to the database and populate <code class="literal">Event</code> objects with the data. You can create more complex queries with HQL. See <a href="#queryhql" title="第14章 HQL: The Hibernate Query Language">章 14. <i xmlns:xlink="http://www.w3.org/1999/xlink">HQL: The Hibernate Query Language</i></a> for more information. </p><p>Now we can call our new functionality, again using the Maven exec plugin: <code class="command">mvn exec:java -Dexec.mainClass="org.hibernate.tutorial.EventManager" -Dexec.args="list"</code> </p></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial-associations"/>1.2. パート2 - 関連のマッピング</h2></div></div></div><p>So far we have mapped a single persistent entity class to a table in isolation. Let's expand on that a bit and add some class associations. We will add people to the application and store a list of events in which they participate. </p><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-mappinguser"/>1.2.1. Personクラスのマッピング</h3></div></div></div><p>The first cut of the <code class="literal">Person</code> class looks like this: </p><pre class="programlisting">package org.hibernate.tutorial.domain;

public class Person {

    private Long id;
    private int age;
    private String firstname;
    private String lastname;

    public Person() {}

    // Accessor methods for all properties, private setter for 'id'

}</pre><p>Save this to a file named <code class="filename">src/main/java/org/hibernate/tutorial/domain/Person.java</code> </p><p>Next, create the new mapping file as <code class="filename">src/main/resources/org/hibernate/tutorial/domain/Person.hbm.xml</code> </p><pre class="programlisting">&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;

    &lt;class name="Person" table="PERSON"&gt;
        &lt;id name="id" column="PERSON_ID"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="age"/&gt;
        &lt;property name="firstname"/&gt;
        &lt;property name="lastname"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>最後にHibernateの設定に新しいマッピングを追加してください： </p><pre class="programlisting">&lt;mapping resource="events/Event.hbm.xml"/&gt;
&lt;mapping resource="events/Person.hbm.xml"/&gt;</pre><p>Create an association between these two entities. Persons can participate in events, and events have participants. The design questions you have to deal with are: directionality, multiplicity, and collection behavior. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-unidirset"/>1.2.2. 単方向Setベース関連</h3></div></div></div><p>By adding a collection of events to the <code class="literal">Person</code> class, you can easily navigate to the events for a particular person, without executing an explicit query - by calling <code class="literal">Person#getEvents</code>. Multi-valued associations are represented in Hibernate by one of the Java Collection Framework contracts; here we choose a <code class="interfacename">java.util.Set</code> because the collection will not contain duplicate elements and the ordering is not relevant to our examples: </p><pre class="programlisting">public class Person {

    private Set events = new HashSet();

    public Set getEvents() {
        return events;
    }

    public void setEvents(Set events) {
        this.events = events;
    }
}</pre><p>Before mapping this association, let's consider the other side. We could just keep this unidirectional or create another collection on the <code class="literal">Event</code>, if we wanted to be able to navigate it from both directions. This is not necessary, from a functional perspective. You can always execute an explicit query to retrieve the participants for a particular event. This is a design choice left to you, but what is clear from this discussion is the multiplicity of the association: "many" valued on both sides is called a <span class="emphasis"><em>many-to-many</em></span> association. Hence, we use Hibernate's many-to-many mapping: </p><pre class="programlisting">&lt;class name="Person" table="PERSON"&gt;
    &lt;id name="id" column="PERSON_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="age"/&gt;
    &lt;property name="firstname"/&gt;
    &lt;property name="lastname"/&gt;

    &lt;set name="events" table="PERSON_EVENT"&gt;
        &lt;key column="PERSON_ID"/&gt;
        &lt;many-to-many column="EVENT_ID" class="Event"/&gt;
    &lt;/set&gt;

&lt;/class&gt;</pre><p>Hibernate supports a broad range of collection mappings, a <code class="literal">set</code> being most common. For a many-to-many association, or <span class="emphasis"><em>n:m</em></span> entity relationship, an association table is required. Each row in this table represents a link between a person and an event. The table name is decalred using the <code class="literal">table</code> attribute of the <code class="literal">set</code> element. The identifier column name in the association, for the person side, is defined with the <code class="literal">key</code> element, the column name for the event's side with the <code class="literal">column</code> attribute of the <code class="literal">many-to-many</code>. You also have to tell Hibernate the class of the objects in your collection (the class on the other side of the collection of references). </p><p>そのためこのマッピングのデータベーススキーマは以下のようになります。： </p><pre class="programlisting">
    _____________        __________________
   |             |      |                  |       _____________
   |   EVENTS    |      |   PERSON_EVENT   |      |             |
   |_____________|      |__________________|      |    PERSON   |
   |             |      |                  |      |_____________|
   | *EVENT_ID   | &lt;--&gt; | *EVENT_ID        |      |             |
   |  EVENT_DATE |      | *PERSON_ID       | &lt;--&gt; | *PERSON_ID  |
   |  TITLE      |      |__________________|      |  AGE        |
   |_____________|                                |  FIRSTNAME  |
                                                  |  LASTNAME   |
                                                  |_____________|
 </pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-working"/>1.2.3. 関連を働かせる</h3></div></div></div><p>Now we will bring some people and events together in a new method in <code class="literal">EventManager</code>: </p><pre class="programlisting">    private void addPersonToEvent(Long personId, Long eventId) {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();

        Person aPerson = (Person) session.load(Person.class, personId);
        Event anEvent = (Event) session.load(Event.class, eventId);
        aPerson.getEvents().add(anEvent);

        session.getTransaction().commit();
    }</pre><p>After loading a <code class="literal">Person</code> and an <code class="literal">Event</code>, simply modify the collection using the normal collection methods. There is no explicit call to <code class="literal">update()</code> or <code class="literal">save()</code>; Hibernate automatically detects that the collection has been modified and needs to be updated. This is called <span class="emphasis"><em>automatic dirty checking</em></span>. You can also try it by modifying the name or the date property of any of your objects. As long as they are in <span class="emphasis"><em>persistent</em></span> state, that is, bound to a particular Hibernate <code class="interfacename">org.hibernate.Session</code>, Hibernate monitors any changes and executes SQL in a write-behind fashion. The process of synchronizing the memory state with the database, usually only at the end of a unit of work, is called <span class="emphasis"><em>flushing</em></span>. In our code, the unit of work ends with a commit, or rollback, of the database transaction. </p><p>You can load person and event in different units of work. Or you can modify an object outside of a <code class="interfacename">org.hibernate.Session</code>, when it is not in persistent state (if it was persistent before, this state is called <span class="emphasis"><em>detached</em></span>). You can even modify a collection when it is detached: </p><pre class="programlisting">    private void addPersonToEvent(Long personId, Long eventId) {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();

        Person aPerson = (Person) session
                .createQuery("select p from Person p left join fetch p.events where p.id = :pid")
                .setParameter("pid", personId)
                .uniqueResult(); // Eager fetch the collection so we can use it detached
        Event anEvent = (Event) session.load(Event.class, eventId);

        session.getTransaction().commit();

        // End of first unit of work

        aPerson.getEvents().add(anEvent); // aPerson (and its collection) is detached

        // Begin second unit of work

        Session session2 = HibernateUtil.getSessionFactory().getCurrentSession();
        session2.beginTransaction();
        session2.update(aPerson); // Reattachment of aPerson

        session2.getTransaction().commit();
    }</pre><p>The call to <code class="literal">update</code> makes a detached object persistent again by binding it to a new unit of work, so any modifications you made to it while detached can be saved to the database. This includes any modifications (additions/deletions) you made to a collection of that entity object. </p><p>This is not much use in our example, but it is an important concept you can incorporate into your own application. Complete this exercise by adding a new action to the main method of the <code class="literal">EventManager</code> and call it from the command line. If you need the identifiers of a person and an event - the <code class="literal">save()</code> method returns it (you might have to modify some of the previous methods to return that identifier): </p><pre class="programlisting">        else if (args[0].equals("addpersontoevent")) {
            Long eventId = mgr.createAndStoreEvent("My Event", new Date());
            Long personId = mgr.createAndStorePerson("Foo", "Bar");
            mgr.addPersonToEvent(personId, eventId);
            System.out.println("Added person " + personId + " to event " + eventId);
        }</pre><p>This is an example of an association between two equally important classes : two entities. As mentioned earlier, there are other classes and types in a typical model, usually "less important". Some you have already seen, like an <code class="literal">int</code> or a <code class="classname">java.lang.String</code>. We call these classes <span class="emphasis"><em>value types</em></span>, and their instances <span class="emphasis"><em>depend</em></span> on a particular entity. Instances of these types do not have their own identity, nor are they shared between entities. Two persons do not reference the same <code class="literal">firstname</code> object, even if they have the same first name. Value types cannot only be found in the JDK , but you can also write dependent classes yourself such as an <code class="literal">Address</code> or <code class="literal">MonetaryAmount</code> class. In fact, in a Hibernate application all JDK classes are considered value types. </p><p>You can also design a collection of value types. This is conceptually different from a collection of references to other entities, but looks almost the same in Java. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-valuecollections"/>1.2.4. 値のコレクション</h3></div></div></div><p>Let's add a collection of email addresses to the <code class="literal">Person</code> entity. This will be represented as a <code class="interfacename">java.util.Set</code> of <code class="classname">java.lang.String</code> instances: </p><pre class="programlisting">    private Set emailAddresses = new HashSet();

    public Set getEmailAddresses() {
        return emailAddresses;
    }

    public void setEmailAddresses(Set emailAddresses) {
        this.emailAddresses = emailAddresses;
    }</pre><p>The mapping of this <code class="literal">Set</code> is as follows: </p><pre class="programlisting">        &lt;set name="emailAddresses" table="PERSON_EMAIL_ADDR"&gt;
            &lt;key column="PERSON_ID"/&gt;
            &lt;element type="string" column="EMAIL_ADDR"/&gt;
        &lt;/set&gt;</pre><p>The difference compared with the earlier mapping is the use of the <code class="literal">element</code> part which tells Hibernate that the collection does not contain references to another entity, but is rather a collection whose elements are values types, here specifically of type <code class="literal">string</code>. The lowercase name tells you it is a Hibernate mapping type/converter. Again the <code class="literal">table</code> attribute of the <code class="literal">set</code> element determines the table name for the collection. The <code class="literal">key</code> element defines the foreign-key column name in the collection table. The <code class="literal">column</code> attribute in the <code class="literal">element</code> element defines the column name where the email address values will actually be stored. </p><p>Here is the updated schema: </p><pre class="programlisting">
  _____________        __________________
 |             |      |                  |       _____________
 |   EVENTS    |      |   PERSON_EVENT   |      |             |       ___________________
 |_____________|      |__________________|      |    PERSON   |      |                   |
 |             |      |                  |      |_____________|      | PERSON_EMAIL_ADDR |
 | *EVENT_ID   | &lt;--&gt; | *EVENT_ID        |      |             |      |___________________|
 |  EVENT_DATE |      | *PERSON_ID       | &lt;--&gt; | *PERSON_ID  | &lt;--&gt; |  *PERSON_ID       |
 |  TITLE      |      |__________________|      |  AGE        |      |  *EMAIL_ADDR      |
 |_____________|                                |  FIRSTNAME  |      |___________________|
                                                |  LASTNAME   |
                                                |_____________|
 </pre><p>You can see that the primary key of the collection table is in fact a composite key that uses both columns. This also implies that there cannot be duplicate email addresses per person, which is exactly the semantics we need for a set in Java. </p><p>You can now try to add elements to this collection, just like we did before by linking persons and events. It is the same code in Java: </p><pre class="programlisting">    private void addEmailToPerson(Long personId, String emailAddress) {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();

        Person aPerson = (Person) session.load(Person.class, personId);
        // adding to the emailAddress collection might trigger a lazy load of the collection
        aPerson.getEmailAddresses().add(emailAddress);

        session.getTransaction().commit();
    }</pre><p>This time we did not use a <span class="emphasis"><em>fetch</em></span> query to initialize the collection. Monitor the SQL log and try to optimize this with an eager fetch. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-bidirectional"/>1.2.5. 双方向関連</h3></div></div></div><p>Next you will map a bi-directional association. You will make the association between person and event work from both sides in Java. The database schema does not change, so you will still have many-to-many multiplicity. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>A relational database is more flexible than a network programming language, in that it does not need a navigation direction; data can be viewed and retrieved in any possible way. </p></div><p>First, add a collection of participants to the <code class="literal">Event</code> class: </p><pre class="programlisting">    private Set participants = new HashSet();

    public Set getParticipants() {
        return participants;
    }

    public void setParticipants(Set participants) {
        this.participants = participants;
    }</pre><p>Now map this side of the association in <code class="literal">Event.hbm.xml</code>. </p><pre class="programlisting">        &lt;set name="participants" table="PERSON_EVENT" inverse="true"&gt;
            &lt;key column="EVENT_ID"/&gt;
            &lt;many-to-many column="PERSON_ID" class="events.Person"/&gt;
        &lt;/set&gt;</pre><p>These are normal <code class="literal">set</code> mappings in both mapping documents. Notice that the column names in <code class="literal">key</code> and <code class="literal">many-to-many</code> swap in both mapping documents. The most important addition here is the <code class="literal">inverse="true"</code> attribute in the <code class="literal">set</code> element of the <code class="literal">Event</code>'s collection mapping. </p><p>What this means is that Hibernate should take the other side, the <code class="literal">Person</code> class, when it needs to find out information about the link between the two. This will be a lot easier to understand once you see how the bi-directional link between our two entities is created. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-usingbidir"/>1.2.6. 双方向リンクの動作</h3></div></div></div><p>First, keep in mind that Hibernate does not affect normal Java semantics. How did we create a link between a <code class="literal">Person</code> and an <code class="literal">Event</code> in the unidirectional example? You add an instance of <code class="literal">Event</code> to the collection of event references, of an instance of <code class="literal">Person</code>. If you want to make this link bi-directional, you have to do the same on the other side by adding a <code class="literal">Person</code> reference to the collection in an <code class="literal">Event</code>. This process of "setting the link on both sides" is absolutely necessary with bi-directional links. </p><p>Many developers program defensively and create link management methods to correctly set both sides (for example, in <code class="literal">Person</code>): </p><pre class="programlisting">    protected Set getEvents() {
        return events;
    }

    protected void setEvents(Set events) {
        this.events = events;
    }

    public void addToEvent(Event event) {
        this.getEvents().add(event);
        event.getParticipants().add(this);
    }

    public void removeFromEvent(Event event) {
        this.getEvents().remove(event);
        event.getParticipants().remove(this);
    }</pre><p>The get and set methods for the collection are now protected. This allows classes in the same package and subclasses to still access the methods, but prevents everybody else from altering the collections directly. Repeat the steps for the collection on the other side. </p><p>What about the <code class="literal">inverse</code> mapping attribute? For you, and for Java, a bi-directional link is simply a matter of setting the references on both sides correctly. Hibernate, however, does not have enough information to correctly arrange SQL <code class="literal">INSERT</code> and <code class="literal">UPDATE</code> statements (to avoid constraint violations). Making one side of the association <code class="literal">inverse</code> tells Hibernate to consider it a <span class="emphasis"><em>mirror</em></span> of the other side. That is all that is necessary for Hibernate to resolve any issues that arise when transforming a directional navigation model to a SQL database schema. The rules are straightforward: all bi-directional associations need one side as <code class="literal">inverse</code>. In a one-to-many association it has to be the many-side, and in many-to-many association you can select either side. </p></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial-webapp"/>1.3. パート3 - EventManager Webアプリケーション</h2></div></div></div><p>A Hibernate web application uses <code class="literal">Session</code> and <code class="literal">Transaction</code> almost like a standalone application. However, some common patterns are useful. You can now write an <code class="literal">EventManagerServlet</code>. This servlet can list all events stored in the database, and it provides an HTML form to enter new events. </p><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-webapp-servlet"/>1.3.1. 基本的なServletの記述</h3></div></div></div><p>First we need create our basic processing servlet. Since our servlet only handles HTTP <code class="literal">GET</code> requests, we will only implement the <code class="literal">doGet()</code> method: </p><pre class="programlisting">package org.hibernate.tutorial.web;

// Imports

public class EventManagerServlet extends HttpServlet {

    protected void doGet(
            HttpServletRequest request,
            HttpServletResponse response) throws ServletException, IOException {

        SimpleDateFormat dateFormatter = new SimpleDateFormat( "dd.MM.yyyy" );

        try {
            // Begin unit of work
            HibernateUtil.getSessionFactory().getCurrentSession().beginTransaction();

            // Process request and render page...

            // End unit of work
            HibernateUtil.getSessionFactory().getCurrentSession().getTransaction().commit();
        }
        catch (Exception ex) {
            HibernateUtil.getSessionFactory().getCurrentSession().getTransaction().rollback();
            if ( ServletException.class.isInstance( ex ) ) {
                throw ( ServletException ) ex;
            }
            else {
                throw new ServletException( ex );
            }
        }
    }

}</pre><p>Save this servlet as <code class="filename">src/main/java/org/hibernate/tutorial/web/EventManagerServlet.java</code> </p><p>The pattern applied here is called <span class="emphasis"><em>session-per-request</em></span>. When a request hits the servlet, a new Hibernate <code class="literal">Session</code> is opened through the first call to <code class="literal">getCurrentSession()</code> on the <code class="literal">SessionFactory</code>. A database transaction is then started. All data access occurs inside a transaction irrespective of whether the data is read or written. Do not use the auto-commit mode in applications. </p><p>Do <span class="emphasis"><em>not</em></span> use a new Hibernate <code class="literal">Session</code> for every database operation. Use one Hibernate <code class="literal">Session</code> that is scoped to the whole request. Use <code class="literal">getCurrentSession()</code>, so that it is automatically bound to the current Java thread. </p><p>Next, the possible actions of the request are processed and the response HTML is rendered. We will get to that part soon. </p><p>Finally, the unit of work ends when processing and rendering are complete. If any problems occurred during processing or rendering, an exception will be thrown and the database transaction rolled back. This completes the <code class="literal">session-per-request</code> pattern. Instead of the transaction demarcation code in every servlet, you could also write a servlet filter. See the Hibernate website and Wiki for more information about this pattern called <span class="emphasis"><em>Open Session in View</em></span>. You will need it as soon as you consider rendering your view in JSP, not in a servlet. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-webapp-processing"/>1.3.2. 処理と描画</h3></div></div></div><p>Now you can implement the processing of the request and the rendering of the page. </p><pre class="programlisting">        // Write HTML header
        PrintWriter out = response.getWriter();
        out.println("&lt;html&gt;&lt;head&gt;&lt;title&gt;Event Manager&lt;/title&gt;&lt;/head&gt;&lt;body&gt;");

        // Handle actions
        if ( "store".equals(request.getParameter("action")) ) {

            String eventTitle = request.getParameter("eventTitle");
            String eventDate = request.getParameter("eventDate");

            if ( "".equals(eventTitle) || "".equals(eventDate) ) {
                out.println("&lt;b&gt;&lt;i&gt;Please enter event title and date.&lt;/i&gt;&lt;/b&gt;");
            }
            else {
                createAndStoreEvent(eventTitle, dateFormatter.parse(eventDate));
                out.println("&lt;b&gt;&lt;i&gt;Added event.&lt;/i&gt;&lt;/b&gt;");
            }
        }

        // Print page
       printEventForm(out);
       listEvents(out, dateFormatter);

       // Write HTML footer
       out.println("&lt;/body&gt;&lt;/html&gt;");
       out.flush();
       out.close();</pre><p>This coding style, with a mix of Java and HTML, would not scale in a more complex application-keep in mind that we are only illustrating basic Hibernate concepts in this tutorial. The code prints an HTML header and a footer. Inside this page, an HTML form for event entry and a list of all events in the database are printed. The first method is trivial and only outputs HTML: </p><pre class="programlisting">    private void printEventForm(PrintWriter out) {
        out.println("&lt;h2&gt;Add new event:&lt;/h2&gt;");
        out.println("&lt;form&gt;");
        out.println("Title: &lt;input name='eventTitle' length='50'/&gt;&lt;br/&gt;");
        out.println("Date (e.g. 24.12.2009): &lt;input name='eventDate' length='10'/&gt;&lt;br/&gt;");
        out.println("&lt;input type='submit' name='action' value='store'/&gt;");
        out.println("&lt;/form&gt;");
    }</pre><p><code class="literal">listEvents()</code> メソッドは、現在のスレッドに結びつく Hibernateの <code class="literal">Session</code> を使用して、クエリを実行します。 </p><pre class="programlisting">    private void listEvents(PrintWriter out, SimpleDateFormat dateFormatter) {

        List result = HibernateUtil.getSessionFactory()
                .getCurrentSession().createCriteria(Event.class).list();
        if (result.size() &gt; 0) {
            out.println("&lt;h2&gt;Events in database:&lt;/h2&gt;");
            out.println("&lt;table border='1'&gt;");
            out.println("&lt;tr&gt;");
            out.println("&lt;th&gt;Event title&lt;/th&gt;");
            out.println("&lt;th&gt;Event date&lt;/th&gt;");
            out.println("&lt;/tr&gt;");
            Iterator it = result.iterator();
            while (it.hasNext()) {
                Event event = (Event) it.next();
                out.println("&lt;tr&gt;");
                out.println("&lt;td&gt;" + event.getTitle() + "&lt;/td&gt;");
                out.println("&lt;td&gt;" + dateFormatter.format(event.getDate()) + "&lt;/td&gt;");
                out.println("&lt;/tr&gt;");
            }
            out.println("&lt;/table&gt;");
        }
    }</pre><p>最後に、 <code class="literal">store</code> アクションが <code class="literal">createAndStoreEvent()</code> メソッドを 呼び出します。このメソッドでも現在のスレッドの <code class="literal">Session</code> を利用します。 </p><pre class="programlisting">    protected void createAndStoreEvent(String title, Date theDate) {
        Event theEvent = new Event();
        theEvent.setTitle(title);
        theEvent.setDate(theDate);

        HibernateUtil.getSessionFactory()
                .getCurrentSession().save(theEvent);
    }</pre><p>The servlet is now complete. A request to the servlet will be processed in a single <code class="literal">Session</code> and <code class="literal">Transaction</code>. As earlier in the standalone application, Hibernate can automatically bind these objects to the current thread of execution. This gives you the freedom to layer your code and access the <code class="literal">SessionFactory</code> in any way you like. Usually you would use a more sophisticated design and move the data access code into data access objects (the DAO pattern). See the Hibernate Wiki for more examples. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-webapp-deploy"/>1.3.3. デプロイとテスト</h3></div></div></div><p>To deploy this application for testing we must create a Web ARchive (WAR). First we must define the WAR descriptor as <code class="filename">src/main/webapp/WEB-INF/web.xml</code> </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="2.4"
    xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;Event Manager&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.hibernate.tutorial.web.EventManagerServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Event Manager&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/eventmanager&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre><p>To build and deploy call <code class="literal">mvn package</code> in your project directory and copy the <code class="filename">hibernate-tutorial.war</code> file into your Tomcat <code class="filename">webapps</code> directory. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>If you do not have Tomcat installed, download it from <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://tomcat.apache.org/">http://tomcat.apache.org/</a> and follow the installation instructions. Our application requires no changes to the standard Tomcat configuration. </p></div><p>一度デプロイしてTomcatを起動すれば、 <code class="literal">http://localhost:8080/hibernate-tutorial/eventmanager</code> で アプリケーションへのアクセスが可能です。 最初のリクエストが作成したサーブレットに渡ったときに、Tomcatのログで Hibernateの初期化処理を確認してください （ <code class="literal">HibernateUtil</code> 内の静的初期化ブロックが呼ばれています）。 また、exceptionが発生したなら詳細を確認してください。 </p></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial-summary"/>1.4. 要約</h2></div></div></div><p>This tutorial covered the basics of writing a simple standalone Hibernate application and a small web application. More tutorials are available from the Hibernate <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://hibernate.org">website</a>. </p></div></div><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="architecture"/>第2章 アーキテクチャ</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#architecture-overview">2.1. 概観</a></span></dt><dt><span class="sect1"><a href="#architecture-states">2.2. インスタンスの状態</a></span></dt><dt><span class="sect1"><a href="#architecture-jmx">2.3. JMXとの統合</a></span></dt><dt><span class="sect1"><a href="#architecture-jca">2.4. JCA サポート</a></span></dt><dt><span class="sect1"><a href="#architecture-current-session">2.5. Contextual sessions</a></span></dt></dl></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-overview"/>2.1. 概観</h2></div></div></div><p>The diagram below provides a high-level view of the Hibernate architecture: </p><div class="mediaobject" align="center"><img src="../images/overview.png" align="middle"/></div><p>We do not have the scope in this document to provide a more detailed view of all the runtime architectures available; Hibernate is flexible and supports several different approaches. We will, however, show the two extremes: "minimal" architecture and "comprehensive" architecture. </p><p>This next diagram illustrates how Hibernate utilizes database and configuration data to provide persistence services, and persistent objects, to the application. </p><p>The "minimal" architecture has the application provide its own JDBC connections and manage its own transactions. This approach uses a minimal subset of Hibernate's APIs: </p><div class="mediaobject" align="center"><img src="../images/lite.png" align="middle"/></div><p>The "comprehensive" architecture abstracts the application away from the underlying JDBC/JTA APIs and allows Hibernate to manage the details. </p><div class="mediaobject" align="center"><img src="../images/full_cream.png" align="middle"/></div><p>Here are some definitions of the objects depicted in the diagrams: </p><div class="variablelist"><dl><dt><span class="term">SessionFactory (<code class="literal">org.hibernate.SessionFactory</code>)</span></dt><dd><p>A threadsafe, immutable cache of compiled mappings for a single database. A factory for <code class="literal">Session</code> and a client of <code class="literal">ConnectionProvider</code>, <code class="literal">SessionFactory</code> can hold an optional (second-level) cache of data that is reusable between transactions at a process, or cluster, level. </p></dd><dt><span class="term">Session (<code class="literal">org.hibernate.Session</code>)</span></dt><dd><p>A single-threaded, short-lived object representing a conversation between the application and the persistent store. It wraps a JDBC connection and is a factory for <code class="literal">Transaction</code>. <code class="literal">Session</code> holds a mandatory first-level cache of persistent objects that are used when navigating the object graph or looking up objects by identifier. </p></dd><dt><span class="term">Persistent objects と Collections</span></dt><dd><p>Short-lived, single threaded objects containing persistent state and business function. These can be ordinary JavaBeans/POJOs. They are associated with exactly one <code class="literal">Session</code>. Once the <code class="literal">Session</code> is closed, they will be detached and free to use in any application layer (for example, directly as data transfer objects to and from presentation). </p></dd><dt><span class="term">Transient と detached な objects と Collections</span></dt><dd><p>Instances of persistent classes that are not currently associated with a <code class="literal">Session</code>. They may have been instantiated by the application and not yet persisted, or they may have been instantiated by a closed <code class="literal">Session</code>. </p></dd><dt><span class="term">Transaction (<code class="literal">org.hibernate.Transaction</code>)</span></dt><dd><p>(Optional) A single-threaded, short-lived object used by the application to specify atomic units of work. It abstracts the application from the underlying JDBC, JTA or CORBA transaction. A <code class="literal">Session</code> might span several <code class="literal">Transaction</code>s in some cases. However, transaction demarcation, either using the underlying API or <code class="literal">Transaction</code>, is never optional. </p></dd><dt><span class="term">ConnectionProvider (<code class="literal">org.hibernate.connection.ConnectionProvider</code>)</span></dt><dd><p>(Optional) A factory for, and pool of, JDBC connections. It abstracts the application from underlying <code class="literal">Datasource</code> or <code class="literal">DriverManager</code>. It is not exposed to application, but it can be extended and/or implemented by the developer. </p></dd><dt><span class="term">TransactionFactory (<code class="literal">org.hibernate.TransactionFactory</code>)</span></dt><dd><p>(Optional) A factory for <code class="literal">Transaction</code> instances. It is not exposed to the application, but it can be extended and/or implemented by the developer. </p></dd><dt><span class="term"><span class="emphasis"><em>Extension Interfaces</em></span></span></dt><dd><p>Hibernate offers a range of optional extension interfaces you can implement to customize the behavior of your persistence layer. See the API documentation for details. </p></dd></dl></div><p>
        </p><p>Given a "minimal" architecture, the application bypasses the <code class="literal">Transaction</code>/<code class="literal">TransactionFactory</code> and/or <code class="literal">ConnectionProvider</code> APIs to communicate with JTA or JDBC directly. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-states"/>2.2. インスタンスの状態</h2></div></div></div><p>An instance of a persistent class can be in one of three different states. These states are defined in relation to a <span class="emphasis"><em>persistence context</em></span>. The Hibernate <code class="literal">Session</code> object is the persistence context. The three different states are as follows: </p><div class="variablelist"><dl><dt><span class="term">transient</span></dt><dd><p>The instance is not associated with any persistence context. It has no persistent identity or primary key value. </p></dd><dt><span class="term">persistent</span></dt><dd><p>The instance is currently associated with a persistence context. It has a persistent identity (primary key value) and can have a corresponding row in the database. For a particular persistence context, Hibernate <span class="emphasis"><em>guarantees</em></span> that persistent identity is equivalent to Java identity in relation to the in-memory location of the object. </p></dd><dt><span class="term">detached</span></dt><dd><p>The instance was once associated with a persistence context, but that context was closed, or the instance was serialized to another process. It has a persistent identity and can have a corresponding row in the database. For detached instances, Hibernate does not guarantee the relationship between persistent identity and Java identity. </p></dd></dl></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-jmx"/>2.3. JMXとの統合</h2></div></div></div><p>JMX is the J2EE standard for the management of Java components. Hibernate can be managed via a JMX standard service. AN MBean implementation is provided in the distribution: <code class="literal">org.hibernate.jmx.HibernateService</code>. </p><p>For an example of how to deploy Hibernate as a JMX service on the JBoss Application Server, please see the JBoss User Guide. JBoss AS also provides these benefits if you deploy using JMX: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Session Management</em></span>: the Hibernate <code class="literal">Session</code>'s life cycle can be automatically bound to the scope of a JTA transaction. This means that you no longer have to manually open and close the <code class="literal">Session</code>; this becomes the job of a JBoss EJB interceptor. You also do not have to worry about transaction demarcation in your code (if you would like to write a portable persistence layer use the optional Hibernate <code class="literal">Transaction</code> API for this). You call the <code class="literal">HibernateContext</code> to access a <code class="literal">Session</code>. </p></li><li><p><span class="emphasis"><em>HAR deployment</em></span>: the Hibernate JMX service is deployed using a JBoss service deployment descriptor in an EAR and/or SAR file, as it supports all the usual configuration options of a Hibernate <code class="literal">SessionFactory</code>. However, you still need to name all your mapping files in the deployment descriptor. If you use the optional HAR deployment, JBoss will automatically detect all mapping files in your HAR file. </p></li></ul></div><p>これらのオプションについての詳細な情報は、JBossアプリケーションサーバユーザガイドを 参考にしてください。 </p><p>Another feature available as a JMX service is runtime Hibernate statistics. See <a href="#configuration-optional-statistics" title="3.4.6. Hibernate 統計">項3.4.6. 「Hibernate 統計」</a> for more information. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-jca"/>2.4. JCA サポート</h2></div></div></div><p>Hibernate can also be configured as a JCA connector. Please see the website for more information. Please note, however, that at this stage Hibernate JCA support is under development. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-current-session"/>2.5. Contextual sessions</h2></div></div></div><p>Most applications using Hibernate need some form of "contextual" session, where a given session is in effect throughout the scope of a given context. However, across applications the definition of what constitutes a context is typically different; different contexts define different scopes to the notion of current. Applications using Hibernate prior to version 3.0 tended to utilize either home-grown <code class="literal">ThreadLocal</code>-based contextual sessions, helper classes such as <code class="literal">HibernateUtil</code>, or utilized third-party frameworks, such as Spring or Pico, which provided proxy/interception-based contextual sessions. </p><p>Starting with version 3.0.1, Hibernate added the <code class="literal">SessionFactory.getCurrentSession()</code> method. Initially, this assumed usage of <code class="literal">JTA</code> transactions, where the <code class="literal">JTA</code> transaction defined both the scope and context of a current session. Given the maturity of the numerous stand-alone <code class="literal">JTA TransactionManager</code> implementations, most, if not all, applications should be using <code class="literal">JTA</code> transaction management, whether or not they are deployed into a <code class="literal">J2EE</code> container. Based on that, the <code class="literal">JTA</code>-based contextual sessions are all you need to use. </p><p>However, as of version 3.1, the processing behind <code class="literal">SessionFactory.getCurrentSession()</code> is now pluggable. To that end, a new extension interface, <code class="literal">org.hibernate.context.CurrentSessionContext</code>, and a new configuration parameter, <code class="literal">hibernate.current_session_context_class</code>, have been added to allow pluggability of the scope and context of defining current sessions. </p><p>See the Javadocs for the <code class="literal">org.hibernate.context.CurrentSessionContext</code> interface for a detailed discussion of its contract. It defines a single method, <code class="literal">currentSession()</code>, by which the implementation is responsible for tracking the current contextual session. Out-of-the-box, Hibernate comes with three implementations of this interface: </p><div class="itemizedlist"><ul><li><p><code class="literal">org.hibernate.context.JTASessionContext</code>: current sessions are tracked and scoped by a <code class="literal">JTA</code> transaction. The processing here is exactly the same as in the older JTA-only approach. See the Javadocs for details. </p></li><li><p><code class="literal">org.hibernate.context.ThreadLocalSessionContext</code>:current sessions are tracked by thread of execution. See the Javadocs for details. </p></li><li><p><code class="literal">org.hibernate.context.ManagedSessionContext</code>: current sessions are tracked by thread of execution. However, you are responsible to bind and unbind a <code class="literal">Session</code> instance with static methods on this class: it does not open, flush, or close a <code class="literal">Session</code>. </p></li></ul></div><p>The first two implementations provide a "one session - one database transaction" programming model. This is also also known and used as <span class="emphasis"><em>session-per-request</em></span>. The beginning and end of a Hibernate session is defined by the duration of a database transaction. If you use programmatic transaction demarcation in plain JSE without JTA, you are advised to use the Hibernate <code class="literal">Transaction</code> API to hide the underlying transaction system from your code. If you use JTA, you can utilize the JTA interfaces to demarcate transactions. If you execute in an EJB container that supports CMT, transaction boundaries are defined declaratively and you do not need any transaction or session demarcation operations in your code. Refer to <a href="#transactions" title="第11章 Transactions and Concurrency">章 11. <i xmlns:xlink="http://www.w3.org/1999/xlink">Transactions and Concurrency</i></a> for more information and code examples. </p><p>The <code class="literal">hibernate.current_session_context_class</code> configuration parameter defines which <code class="literal">org.hibernate.context.CurrentSessionContext</code> implementation should be used. For backwards compatibility, if this configuration parameter is not set but a <code class="literal">org.hibernate.transaction.TransactionManagerLookup</code> is configured, Hibernate will use the <code class="literal">org.hibernate.context.JTASessionContext</code>. Typically, the value of this parameter would just name the implementation class to use. For the three out-of-the-box implementations, however, there are three corresponding short names: "jta", "thread", and "managed". </p></div></div><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="session-configuration"/>第3章 設定</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#configuration-programmatic">3.1. プログラム上の設定</a></span></dt><dt><span class="sect1"><a href="#configuration-sessionfactory">3.2. SessionFactoryを取得する</a></span></dt><dt><span class="sect1"><a href="#configuration-hibernatejdbc">3.3. JDBCコネクション</a></span></dt><dt><span class="sect1"><a href="#configuration-optional">3.4. オプション設定プロパティ</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuration-optional-dialects">3.4.1. SQL 方言（Dialect）</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-outerjoin">3.4.2. 外部結合フェッチ</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-binarystreams">3.4.3. バイナリストリーム</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-cacheprovider">3.4.4. 2次キャッシュとクエリーキャッシュ</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-querysubstitution">3.4.5. クエリー言語の置き換え</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-statistics">3.4.6. Hibernate 統計</a></span></dt></dl></dd><dt><span class="sect1"><a href="#configuration-logging">3.5. ロギング</a></span></dt><dt><span class="sect1"><a href="#configuration-namingstrategy">3.6. <code class="literal">NamingStrategy</code> の実装</a></span></dt><dt><span class="sect1"><a href="#configuration-xmlconfig">3.7. XML設定ファイル</a></span></dt><dt><span class="sect1"><a href="#configuration-j2ee">3.8. J2EEアプリケーションサーバとの統合</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuration-optional-transactionstrategy">3.8.1. トランザクション戦略設定</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-jndi">3.8.2. <code class="literal">SessionFactory</code> のJNDIへの登録</a></span></dt><dt><span class="sect2"><a href="#configuration-j2ee-currentsession">3.8.3. JTAによる現在のセッションコンテキストマネージメント</a></span></dt><dt><span class="sect2"><a href="#configuration-j2ee-jmx">3.8.4. JMXデプロイメント</a></span></dt></dl></dd></dl></div><p>Hibernate is designed to operate in many different environments and, as such, there is a broad range of configuration parameters. Fortunately, most have sensible default values and Hibernate is distributed with an example <code class="literal">hibernate.properties</code> file in <code class="literal">etc/</code> that displays the various options. Simply put the example file in your classpath and customize it to suit your needs. </p><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-programmatic"/>3.1. プログラム上の設定</h2></div></div></div><p>An instance of <code class="classname">org.hibernate.cfg.Configuration</code> represents an entire set of mappings of an application's Java types to an SQL database. The <code class="classname">org.hibernate.cfg.Configuration</code> is used to build an immutable <code class="interfacename">org.hibernate.SessionFactory</code>. The mappings are compiled from various XML mapping files. </p><p>You can obtain a <code class="classname">org.hibernate.cfg.Configuration</code> instance by instantiating it directly and specifying XML mapping documents. If the mapping files are in the classpath, use <code class="literal">addResource()</code>. For example: </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addResource("Item.hbm.xml")
    .addResource("Bid.hbm.xml");</pre><p>An alternative way is to specify the mapped class and allow Hibernate to find the mapping document for you: </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class);</pre><p>Hibernate will then search for mapping files named <code class="filename">/org/hibernate/auction/Item.hbm.xml</code> and <code class="filename">/org/hibernate/auction/Bid.hbm.xml</code> in the classpath. This approach eliminates any hardcoded filenames. </p><p>A <code class="classname">org.hibernate.cfg.Configuration</code> also allows you to specify configuration properties. For example: </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class)
    .setProperty("hibernate.dialect", "org.hibernate.dialect.MySQLInnoDBDialect")
    .setProperty("hibernate.connection.datasource", "java:comp/env/jdbc/test")
    .setProperty("hibernate.order_updates", "true");</pre><p>This is not the only way to pass configuration properties to Hibernate. Some alternative options include: </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>Pass an instance of <code class="classname">java.util.Properties</code> to <code class="literal">Configuration.setProperties()</code>. </p></li><li><p>Place a file named <code class="filename">hibernate.properties</code> in a root directory of the classpath. </p></li><li><p><code class="literal">System</code> プロパティが <code class="literal">java -Dproperty=value</code> を使うように設定します。 </p></li><li><p>Include <code class="literal">&lt;property&gt;</code> elements in <code class="literal">hibernate.cfg.xml</code> (this is discussed later). </p></li></ol></div><p>If you want to get started quickly<code class="filename">hibernate.properties</code> is the easiest approach. </p><p>The <code class="classname">org.hibernate.cfg.Configuration</code> is intended as a startup-time object that will be discarded once a <code class="literal">SessionFactory</code> is created. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-sessionfactory"/>3.2. SessionFactoryを取得する</h2></div></div></div><p>When all mappings have been parsed by the <code class="classname">org.hibernate.cfg.Configuration</code>, the application must obtain a factory for <code class="interfacename">org.hibernate.Session</code> instances. This factory is intended to be shared by all application threads: </p><pre class="programlisting">SessionFactory sessions = cfg.buildSessionFactory();</pre><p>Hibernate does allow your application to instantiate more than one <code class="interfacename">org.hibernate.SessionFactory</code>. This is useful if you are using more than one database. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-hibernatejdbc"/>3.3. JDBCコネクション</h2></div></div></div><p>It is advisable to have the <code class="interfacename">org.hibernate.SessionFactory</code> create and pool JDBC connections for you. If you take this approach, opening a <code class="interfacename">org.hibernate.Session</code> is as simple as: </p><pre class="programlisting">Session session = sessions.openSession(); // open a new Session</pre><p>Once you start a task that requires access to the database, a JDBC connection will be obtained from the pool. </p><p>Before you can do this, you first need to pass some JDBC connection properties to Hibernate. All Hibernate property names and semantics are defined on the class <code class="classname">org.hibernate.cfg.Environment</code>. The most important settings for JDBC connection configuration are outlined below. </p><p>Hibernate will obtain and pool connections using <code class="classname">java.sql.DriverManager</code> if you set the following properties: </p><div class="table"><a id="d0e1745"/><p class="title"><b>表 3.1. Hibernate JDBCプロパティ</b></p><div class="table-contents"><table summary="Hibernate JDBCプロパティ" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>プロパティ名</th><th>意味</th></tr></thead><tbody><tr><td>
                    <span class="property">hibernate.connection.driver_class</span>
                </td><td>
                    <span class="emphasis"><em>JDBCドライバクラス</em></span>
                </td></tr><tr><td>
                    <span class="property">hibernate.connection.url</span>
                </td><td>
                    <span class="emphasis"><em>jdbc URL</em></span>
                </td></tr><tr><td>
                    <span class="property">hibernate.connection.username</span>
                </td><td>
                    <span class="emphasis"><em>database user</em></span>
                </td></tr><tr><td>
                    <span class="property">hibernate.connection.password</span>
                </td><td>
                    <span class="emphasis"><em>database user password</em></span>
                </td></tr><tr><td>
                    <span class="property">hibernate.connection.pool_size</span>
                </td><td>
                    <span class="emphasis"><em>プールするコネクションの最大数</em></span>
                </td></tr></tbody></table></div></div><br class="table-break"/><p>Hibernate's own connection pooling algorithm is, however, quite rudimentary. It is intended to help you get started and is <span class="emphasis"><em>not intended for use in a production system</em></span>, or even for performance testing. You should use a third party pool for best performance and stability. Just replace the <span class="property">hibernate.connection.pool_size</span> property with connection pool specific settings. This will turn off Hibernate's internal pool. For example, you might like to use c3p0. </p><p>C3P0 is an open source JDBC connection pool distributed along with Hibernate in the <code class="filename">lib</code> directory. Hibernate will use its <code class="classname">org.hibernate.connection.C3P0ConnectionProvider</code> for connection pooling if you set <span class="property">hibernate.c3p0.*</span> properties. If you would like to use Proxool, refer to the packaged <code class="filename">hibernate.properties</code> and the Hibernate web site for more information. </p><p>The following is an example <code class="filename">hibernate.properties</code> file for c3p0: </p><a id="c3p0-configuration"/><pre class="programlisting">hibernate.connection.driver_class = org.postgresql.Driver
hibernate.connection.url = jdbc:postgresql://localhost/mydatabase
hibernate.connection.username = myuser
hibernate.connection.password = secret
hibernate.c3p0.min_size=5
hibernate.c3p0.max_size=20
hibernate.c3p0.timeout=1800
hibernate.c3p0.max_statements=50
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect</pre><p>For use inside an application server, you should almost always configure Hibernate to obtain connections from an application server <code class="interfacename">javax.sql.Datasource</code> registered in JNDI. You will need to set at least one of the following properties: </p><div class="table"><a id="d0e1847"/><p class="title"><b>表 3.2. Hibernate データソースプロパティ</b></p><div class="table-contents"><table summary="Hibernate データソースプロパティ" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>プロパティ名</th><th>意味</th></tr></thead><tbody><tr><td>
                    <span class="property">hibernate.connection.datasource</span>
                </td><td>
                    <span class="emphasis"><em>データソースのJNDI名</em></span>
                </td></tr><tr><td>
                    <span class="property">hibernate.jndi.url</span>
                </td><td><span class="emphasis"><em>URL of the JNDI provider</em></span> (optional) </td></tr><tr><td>
                    <span class="property">hibernate.jndi.class</span>
                </td><td><span class="emphasis"><em>class of the JNDI <code class="literal">InitialContextFactory</code></em></span> (optional) </td></tr><tr><td>
                    <span class="property">hibernate.connection.username</span>
                </td><td><span class="emphasis"><em>database user</em></span> (optional) </td></tr><tr><td>
                    <span class="property">hibernate.connection.password</span>
                </td><td><span class="emphasis"><em>database user password</em></span> (optional) </td></tr></tbody></table></div></div><br class="table-break"/><p>Here is an example <code class="filename">hibernate.properties</code> file for an application server provided JNDI datasource: </p><pre class="programlisting">hibernate.connection.datasource = java:/comp/env/jdbc/test
hibernate.transaction.factory_class = \
    org.hibernate.transaction.JTATransactionFactory
hibernate.transaction.manager_lookup_class = \
    org.hibernate.transaction.JBossTransactionManagerLookup
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect</pre><p>JNDIデータソースから取得したJDBCコネクションは、アプリケーションサーバの コンテナ管理トランザクションに自動的に参加します。 </p><p>Arbitrary connection properties can be given by prepending "<code class="literal">hibernate.connection</code>" to the connection property name. For example, you can specify a <span class="property">charSet</span> connection property using <span class="property">hibernate.connection.charSet</span>. </p><p>You can define your own plugin strategy for obtaining JDBC connections by implementing the interface <code class="interfacename">org.hibernate.connection.ConnectionProvider</code>, and specifying your custom implementation via the <span class="property">hibernate.connection.provider_class</span> property. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-optional"/>3.4. オプション設定プロパティ</h2></div></div></div><p>There are a number of other properties that control the behavior of Hibernate at runtime. All are optional and have reasonable default values. </p><p>
        	</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>警告</h2><span class="emphasis"><em>Some of these properties are "system-level" only.</em></span> System-level properties can be set only via <code class="literal">java -Dproperty=value</code> or <code class="filename">hibernate.properties</code>. They <span class="emphasis"><em>cannot</em></span> be set by the other techniques described above.</div><p>
        </p><div class="table"><a id="configuration-optional-properties"/><p class="title"><b>表 3.3. Hibernate設定プロパティ</b></p><div class="table-contents"><table summary="Hibernate設定プロパティ" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>プロパティ名</th><th>意味</th></tr></thead><tbody><tr><td>
                            <span class="property">hibernate.dialect</span>
                        </td><td>The classname of a Hibernate <code class="classname">org.hibernate.dialect.Dialect</code> which allows Hibernate to generate SQL optimized for a particular relational database. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">full.classname.of.Dialect</code> </p>
                            <p>In most cases Hibernate will actually be able to choose the correct <code class="classname">org.hibernate.dialect.Dialect</code> implementation based on the <code class="literal">JDBC metadata</code> returned by the JDBC driver. </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.show_sql</span>
                        </td><td>Write all SQL statements to console. This is an alternative to setting the log category <code class="literal">org.hibernate.SQL</code> to <code class="literal">debug</code>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.format_sql</span>
                        </td><td>Pretty print the SQL in the log and console. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.default_schema</span>
                        </td><td>Qualify unqualified table names with the given schema/tablespace in generated SQL. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">SCHEMA_NAME</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.default_catalog</span>
                        </td><td>Qualifies unqualified table names with the given catalog in generated SQL. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">CATALOG_NAME</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.session_factory_name</span>
                        </td><td>The <code class="interfacename">org.hibernate.SessionFactory</code> will be automatically bound to this name in JNDI after it has been created. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">jndi/composite/name</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.max_fetch_depth</span>
                        </td><td>Sets a maximum "depth" for the outer join fetch tree for single-ended associations (one-to-one, many-to-one). A <code class="literal">0</code> disables default outer join fetching. <p><span class="strong"><strong>e.g.</strong></span> recommended values between <code class="literal">0</code> and <code class="literal">3</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.default_batch_fetch_size</span>
                        </td><td>Sets a default size for Hibernate batch fetching of associations. <p><span class="strong"><strong>e.g.</strong></span> recommended values <code class="literal">4</code>, <code class="literal">8</code>, <code class="literal">16</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.default_entity_mode</span>
                        </td><td>Sets a default mode for entity representation for all sessions opened from this <code class="literal">SessionFactory</code> <p><code class="literal">dynamic-map</code>, <code class="literal">dom4j</code>, <code class="literal">pojo</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.order_updates</span>
                        </td><td>Forces Hibernate to order SQL updates by the primary key value of the items being updated. This will result in fewer transaction deadlocks in highly concurrent systems. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.generate_statistics</span>
                        </td><td>If enabled, Hibernate will collect statistics useful for performance tuning. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.use_identifer_rollback</span>
                        </td><td>If enabled, generated identifier properties will be reset to default values when objects are deleted. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.use_sql_comments</span>
                        </td><td>If turned on, Hibernate will generate comments inside the SQL, for easier debugging, defaults to <code class="literal">false</code>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="configuration-jdbc-properties"/><p class="title"><b>表 3.4. Hibernate JDBC とコネクションプロパティ</b></p><div class="table-contents"><table summary="Hibernate JDBC とコネクションプロパティ" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>プロパティ名</th><th>意味</th></tr></thead><tbody><tr><td>
                            <span class="property">hibernate.jdbc.fetch_size</span>
                        </td><td>A non-zero value determines the JDBC fetch size (calls <code class="literal">Statement.setFetchSize()</code>). </td></tr><tr><td>
                            <span class="property">hibernate.jdbc.batch_size</span>
                        </td><td>A non-zero value enables use of JDBC2 batch updates by Hibernate. <p><span class="strong"><strong>e.g.</strong></span> recommended values between <code class="literal">5</code> and <code class="literal">30</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.jdbc.batch_versioned_data</span>
                        </td><td>Set this property to <code class="literal">true</code> if your JDBC driver returns correct row counts from <code class="literal">executeBatch()</code>. Iit is usually safe to turn this option on. Hibernate will then use batched DML for automatically versioned data. Defaults to <code class="literal">false</code>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.jdbc.factory_class</span>
                        </td><td>Select a custom <code class="interfacename">org.hibernate.jdbc.Batcher</code>. Most applications will not need this configuration property. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">classname.of.BatcherFactory</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.jdbc.use_scrollable_resultset</span>
                        </td><td>Enables use of JDBC2 scrollable resultsets by Hibernate. This property is only necessary when using user-supplied JDBC connections. Hibernate uses connection metadata otherwise. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.jdbc.use_streams_for_binary</span>
                        </td><td>Use streams when writing/reading <code class="literal">binary</code> or <code class="literal">serializable</code> types to/from JDBC. <span class="emphasis"><em>*system-level property*</em></span> <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.jdbc.use_get_generated_keys</span>
                        </td><td>Enables use of JDBC3 <code class="literal">PreparedStatement.getGeneratedKeys()</code> to retrieve natively generated keys after insert. Requires JDBC3+ driver and JRE1.4+, set to false if your driver has problems with the Hibernate identifier generators. By default, it tries to determine the driver capabilities using connection metadata. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true|false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.connection.provider_class</span>
                        </td><td>The classname of a custom <code class="interfacename">org.hibernate.connection.ConnectionProvider</code> which provides JDBC connections to Hibernate. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">classname.of.ConnectionProvider</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.connection.isolation</span>
                        </td><td>Sets the JDBC transaction isolation level. Check <code class="interfacename">java.sql.Connection</code> for meaningful values, but note that most databases do not support all isolation levels and some define additional, non-standard isolations. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">1, 2, 4, 8</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.connection.autocommit</span>
                        </td><td>Enables autocommit for JDBC pooled connections (it is not recommended). <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.connection.release_mode</span>
                        </td><td>Specifies when Hibernate should release JDBC connections. By default, a JDBC connection is held until the session is explicitly closed or disconnected. For an application server JTA datasource, use <code class="literal">after_statement</code> to aggressively release connections after every JDBC call. For a non-JTA connection, it often makes sense to release the connection at the end of each transaction, by using <code class="literal">after_transaction</code>. <code class="literal">auto</code> will choose <code class="literal">after_statement</code> for the JTA and CMT transaction strategies and <code class="literal">after_transaction</code> for the JDBC transaction strategy. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">auto</code> (default) | <code class="literal">on_close</code> | <code class="literal">after_transaction</code> | <code class="literal">after_statement</code> </p>
                            <p>This setting only affects <code class="literal">Session</code>s returned from <code class="literal">SessionFactory.openSession</code>. For <code class="literal">Session</code>s obtained through <code class="literal">SessionFactory.getCurrentSession</code>, the <code class="literal">CurrentSessionContext</code> implementation configured for use controls the connection release mode for those <code class="literal">Session</code>s. See <a href="#architecture-current-session" title="2.5. Contextual sessions">項2.5. 「Contextual sessions」</a> </p>
                        </td></tr><tr><td><span class="property">hibernate.connection.</span><span class="emphasis"><em>&lt;propertyName&gt;</em></span> </td><td>Pass the JDBC property <span class="emphasis"><em>&lt;propertyName&gt;</em></span> to <code class="literal">DriverManager.getConnection()</code>. </td></tr><tr><td><span class="property">hibernate.jndi.</span><span class="emphasis"><em>&lt;propertyName&gt;</em></span> </td><td>Pass the property <span class="emphasis"><em>&lt;propertyName&gt;</em></span> to the JNDI <code class="literal">InitialContextFactory</code>. </td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="configuration-cache-properties"/><p class="title"><b>表 3.5. Hibernate キャッシュプロパティ</b></p><div class="table-contents"><table summary="Hibernate キャッシュプロパティ" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>プロパティ名</th><th>意味</th></tr></thead><tbody><tr><td>
                            <code class="literal">hibernate.cache.provider_class</code>
                        </td><td>The classname of a custom <code class="literal">CacheProvider</code>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">classname.of.CacheProvider</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cache.use_minimal_puts</code>
                        </td><td>Optimizes second-level cache operation to minimize writes, at the cost of more frequent reads. This setting is most useful for clustered caches and, in Hibernate3, is enabled by default for clustered cache implementations. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true|false</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cache.use_query_cache</code>
                        </td><td>Enables the query cache. Individual queries still have to be set cachable. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true|false</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cache.use_second_level_cache</code>
                        </td><td>Can be used to completely disable the second level cache, which is enabled by default for classes which specify a <code class="literal">&lt;cache&gt;</code> mapping. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true|false</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cache.query_cache_factory</code>
                        </td><td>The classname of a custom <code class="literal">QueryCache</code> interface, defaults to the built-in <code class="literal">StandardQueryCache</code>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">classname.of.QueryCache</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cache.region_prefix</code>
                        </td><td>A prefix to use for second-level cache region names. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">prefix</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cache.use_structured_entries</code>
                        </td><td>Forces Hibernate to store data in the second-level cache in a more human-friendly format. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true|false</code> </p>
                        </td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="configuration-transaction-properties"/><p class="title"><b>表 3.6. Hibernate トランザクションプロパティ</b></p><div class="table-contents"><table summary="Hibernate トランザクションプロパティ" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>プロパティ名</th><th>意味</th></tr></thead><tbody><tr><td>
                            <code class="literal">hibernate.transaction.factory_class</code>
                        </td><td>The classname of a <code class="literal">TransactionFactory</code> to use with Hibernate <code class="literal">Transaction</code> API (defaults to <code class="literal">JDBCTransactionFactory</code>). <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">classname.of.TransactionFactory</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">jta.UserTransaction</code>
                        </td><td>A JNDI name used by <code class="literal">JTATransactionFactory</code> to obtain the JTA <code class="literal">UserTransaction</code> from the application server. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">jndi/composite/name</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.transaction.manager_lookup_class</code>
                        </td><td>The classname of a <code class="literal">TransactionManagerLookup</code>. It is required when JVM-level caching is enabled or when using hilo generator in a JTA environment. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">classname.of.TransactionManagerLookup</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.transaction.flush_before_completion</code>
                        </td><td>If enabled, the session will be automatically flushed during the before completion phase of the transaction. Built-in and automatic session context management is preferred, see <a href="#architecture-current-session" title="2.5. Contextual sessions">項2.5. 「Contextual sessions」</a>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.transaction.auto_close_session</code>
                        </td><td>If enabled, the session will be automatically closed during the after completion phase of the transaction. Built-in and automatic session context management is preferred, see <a href="#architecture-current-session" title="2.5. Contextual sessions">項2.5. 「Contextual sessions」</a>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="configuration-misc-properties"/><p class="title"><b>表 3.7. その他のプロパティ</b></p><div class="table-contents"><table summary="その他のプロパティ" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>プロパティ名</th><th>意味</th></tr></thead><tbody><tr><td>
                            <code class="literal">hibernate.current_session_context_class</code>
                        </td><td>Supply a custom strategy for the scoping of the "current" <code class="literal">Session</code>. See <a href="#architecture-current-session" title="2.5. Contextual sessions">項2.5. 「Contextual sessions」</a> for more information about the built-in strategies. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">jta</code> | <code class="literal">thread</code> | <code class="literal">managed</code> | <code class="literal">custom.Class</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.query.factory_class</code>
                        </td><td>Chooses the HQL parser implementation. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">org.hibernate.hql.ast.ASTQueryTranslatorFactory</code> or <code class="literal">org.hibernate.hql.classic.ClassicQueryTranslatorFactory</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.query.substitutions</code>
                        </td><td>Is used to map from tokens in Hibernate queries to SQL tokens (tokens might be function or literal names, for example). <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.hbm2ddl.auto</code>
                        </td><td>Automatically validates or exports schema DDL to the database when the <code class="literal">SessionFactory</code> is created. With <code class="literal">create-drop</code>, the database schema will be dropped when the <code class="literal">SessionFactory</code> is closed explicitly. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">validate</code> | <code class="literal">update</code> | <code class="literal">create</code> | <code class="literal">create-drop</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cglib.use_reflection_optimizer</code>
                        </td><td>Enables the use of CGLIB instead of runtime reflection (System-level property). Reflection can sometimes be useful when troubleshooting. Hibernate always requires CGLIB even if you turn off the optimizer. You cannot set this property in <code class="literal">hibernate.cfg.xml</code>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr></tbody></table></div></div><br class="table-break"/><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-dialects"/>3.4.1. SQL 方言（Dialect）</h3></div></div></div><p>Always set the <code class="literal">hibernate.dialect</code> property to the correct <code class="literal">org.hibernate.dialect.Dialect</code> subclass for your database. If you specify a dialect, Hibernate will use sensible defaults for some of the other properties listed above. This means that you will not have to specify them manually. </p><div class="table"><a id="sql-dialects"/><p class="title"><b>表 3.8. Hibernate SQL Dialects (<code class="literal">hibernate.dialect</code>)</b></p><div class="table-contents"><table summary="Hibernate SQL Dialects (hibernate.dialect)" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>RDBMS</th><th>Dialect</th></tr></thead><tbody><tr><td>DB2</td><td><code class="literal">org.hibernate.dialect.DB2Dialect</code></td></tr><tr><td>DB2 AS/400</td><td><code class="literal">org.hibernate.dialect.DB2400Dialect</code></td></tr><tr><td>DB2 OS390</td><td><code class="literal">org.hibernate.dialect.DB2390Dialect</code></td></tr><tr><td>PostgreSQL</td><td><code class="literal">org.hibernate.dialect.PostgreSQLDialect</code></td></tr><tr><td>MySQL</td><td><code class="literal">org.hibernate.dialect.MySQLDialect</code></td></tr><tr><td>MySQL with InnoDB</td><td><code class="literal">org.hibernate.dialect.MySQLInnoDBDialect</code></td></tr><tr><td>MySQL with MyISAM</td><td><code class="literal">org.hibernate.dialect.MySQLMyISAMDialect</code></td></tr><tr><td>Oracle (any version)</td><td><code class="literal">org.hibernate.dialect.OracleDialect</code></td></tr><tr><td>Oracle 9i</td><td><code class="literal">org.hibernate.dialect.Oracle9iDialect</code></td></tr><tr><td>Oracle 10g</td><td><code class="literal">org.hibernate.dialect.Oracle10gDialect</code></td></tr><tr><td>Sybase</td><td><code class="literal">org.hibernate.dialect.SybaseDialect</code></td></tr><tr><td>Sybase Anywhere</td><td><code class="literal">org.hibernate.dialect.SybaseAnywhereDialect</code></td></tr><tr><td>Microsoft SQL Server</td><td><code class="literal">org.hibernate.dialect.SQLServerDialect</code></td></tr><tr><td>SAP DB</td><td><code class="literal">org.hibernate.dialect.SAPDBDialect</code></td></tr><tr><td>Informix</td><td><code class="literal">org.hibernate.dialect.InformixDialect</code></td></tr><tr><td>HypersonicSQL</td><td><code class="literal">org.hibernate.dialect.HSQLDialect</code></td></tr><tr><td>Ingres</td><td><code class="literal">org.hibernate.dialect.IngresDialect</code></td></tr><tr><td>Progress</td><td><code class="literal">org.hibernate.dialect.ProgressDialect</code></td></tr><tr><td>Mckoi SQL</td><td><code class="literal">org.hibernate.dialect.MckoiDialect</code></td></tr><tr><td>Interbase</td><td><code class="literal">org.hibernate.dialect.InterbaseDialect</code></td></tr><tr><td>Pointbase</td><td><code class="literal">org.hibernate.dialect.PointbaseDialect</code></td></tr><tr><td>FrontBase</td><td><code class="literal">org.hibernate.dialect.FrontbaseDialect</code></td></tr><tr><td>Firebird</td><td><code class="literal">org.hibernate.dialect.FirebirdDialect</code></td></tr></tbody></table></div></div><br class="table-break"/></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-outerjoin"/>3.4.2. 外部結合フェッチ</h3></div></div></div><p>If your database supports ANSI, Oracle or Sybase style outer joins, <span class="emphasis"><em>outer join fetching</em></span> will often increase performance by limiting the number of round trips to and from the database. This is, however, at the cost of possibly more work performed by the database itself. Outer join fetching allows a whole graph of objects connected by many-to-one, one-to-many, many-to-many and one-to-one associations to be retrieved in a single SQL <code class="literal">SELECT</code>. </p><p>Outer join fetching can be disabled <span class="emphasis"><em>globally</em></span> by setting the property <code class="literal">hibernate.max_fetch_depth</code> to <code class="literal">0</code>. A setting of <code class="literal">1</code> or higher enables outer join fetching for one-to-one and many-to-one associations that have been mapped with <code class="literal">fetch="join"</code>. </p><p>See <a href="#performance-fetching" title="19.1. フェッチ戦略">項19.1. 「フェッチ戦略」</a> for more information. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-binarystreams"/>3.4.3. バイナリストリーム</h3></div></div></div><p>Oracle limits the size of <code class="literal">byte</code> arrays that can be passed to and/or from its JDBC driver. If you wish to use large instances of <code class="literal">binary</code> or <code class="literal">serializable</code> type, you should enable <code class="literal">hibernate.jdbc.use_streams_for_binary</code>. <span class="emphasis"><em>This is a system-level setting only.</em></span> </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-cacheprovider"/>3.4.4. 2次キャッシュとクエリーキャッシュ</h3></div></div></div><p>The properties prefixed by <code class="literal">hibernate.cache</code> allow you to use a process or cluster scoped second-level cache system with Hibernate. See the <a href="#performance-cache" title="19.2. 第2レベルキャッシュ">項19.2. 「第2レベルキャッシュ」</a> for more information. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-querysubstitution"/>3.4.5. クエリー言語の置き換え</h3></div></div></div><p>You can define new Hibernate query tokens using <code class="literal">hibernate.query.substitutions</code>. For example: </p><pre class="programlisting">hibernate.query.substitutions true=1, false=0</pre><p>This would cause the tokens <code class="literal">true</code> and <code class="literal">false</code> to be translated to integer literals in the generated SQL. </p><pre class="programlisting">hibernate.query.substitutions toLowercase=LOWER</pre><p>This would allow you to rename the SQL <code class="literal">LOWER</code> function. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-statistics"/>3.4.6. Hibernate 統計</h3></div></div></div><p>If you enable <code class="literal">hibernate.generate_statistics</code>, Hibernate exposes a number of metrics that are useful when tuning a running system via <code class="literal">SessionFactory.getStatistics()</code>. Hibernate can even be configured to expose these statistics via JMX. Read the Javadoc of the interfaces in <code class="literal">org.hibernate.stats</code> for more information. </p></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-logging"/>3.5. ロギング</h2></div></div></div><p>Hibernate utilizes <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.slf4j.org/">Simple Logging Facade for Java</a> (SLF4J) in order to log various system events. SLF4J can direct your logging output to several logging frameworks (NOP, Simple, log4j version 1.2, JDK 1.4 logging, JCL or logback) depending on your chosen binding. In order to setup logging you will need <code class="filename">slf4j-api.jar</code> in your classpath together with the jar file for your preferred binding - <code class="filename">slf4j-log4j12.jar</code> in the case of Log4J. See the SLF4J <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.slf4j.org/manual.html">documentation</a> for more detail. To use Log4j you will also need to place a <code class="filename">log4j.properties</code> file in your classpath. An example properties file is distributed with Hibernate in the <code class="literal">src/</code> directory. </p><p>It is recommended that you familiarize yourself with Hibernate's log messages. A lot of work has been put into making the Hibernate log as detailed as possible, without making it unreadable. It is an essential troubleshooting device. The most interesting log categories are the following: </p><div class="table"><a id="log-categories"/><p class="title"><b>表 3.9. Hibernate ログカテゴリ</b></p><div class="table-contents"><table summary="Hibernate ログカテゴリ" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>カテゴリ</th><th>機能</th></tr></thead><tbody><tr><td><code class="literal">org.hibernate.SQL</code></td><td>実行したすべてのSQL（DDL）ステートメントをロギングします。</td></tr><tr><td><code class="literal">org.hibernate.type</code></td><td>すべてのJDBCパラメータをロギングします。</td></tr><tr><td><code class="literal">org.hibernate.tool.hbm2ddl</code></td><td>実行したすべてのSQL（DDL）ステートメントをロギングします。</td></tr><tr><td><code class="literal">org.hibernate.pretty</code></td><td>sessionに関連するすべてのエンティティ（最大２０）のフラッシュ時間をロギングします。 </td></tr><tr><td><code class="literal">org.hibernate.cache</code></td><td>すべての２次キャッシュの動作をロギングします。</td></tr><tr><td><code class="literal">org.hibernate.transaction</code></td><td>トランザクションに関連する動作をロギングします。</td></tr><tr><td><code class="literal">org.hibernate.jdbc</code></td><td>JDBCリソース取得をロギングします。</td></tr><tr><td><code class="literal">org.hibernate.hql.ast.AST</code></td><td>HQLとSQLのASTのクエリーパースをロギングします。 </td></tr><tr><td><code class="literal">org.hibernate.secure</code></td><td>すべてのJAAS分析をロギングします。</td></tr><tr><td><code class="literal">org.hibernate</code></td><td>Log everything. This is a lot of information but it is useful for troubleshooting </td></tr></tbody></table></div></div><br class="table-break"/><p>Hibernateでアプリケーションを作成するときは、<code class="literal">org.hibernate.SQL</code> カテゴリの <code class="literal">debug</code> を常に有効にしておいたほうが良いでしょう。 代替方法として、<code class="literal">hibernate.show_sql</code> を有効にする方法があります。 </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-namingstrategy"/>3.6. <code class="literal">NamingStrategy</code> の実装</h2></div></div></div><p>インターフェイス <code class="literal">net.sf.hibernate.cfg.NamingStrategy</code> を使うと データベースオブジェクトとスキーマ要素のための「命名標準」を指定できます。 </p><p>You can provide rules for automatically generating database identifiers from Java identifiers or for processing "logical" column and table names given in the mapping file into "physical" table and column names. This feature helps reduce the verbosity of the mapping document, eliminating repetitive noise (<code class="literal">TBL_</code> prefixes, for example). The default strategy used by Hibernate is quite minimal. </p><p>You can specify a different strategy by calling <code class="literal">Configuration.setNamingStrategy()</code> before adding mappings: </p><pre class="programlisting">SessionFactory sf = new Configuration()
    .setNamingStrategy(ImprovedNamingStrategy.INSTANCE)
    .addFile("Item.hbm.xml")
    .addFile("Bid.hbm.xml")
    .buildSessionFactory();</pre><p><code class="literal">org.hibernate.cfg.ImprovedNamingStrategy</code> は組み込みの戦略です。 これはいくつかのアプリケーションにとって有用な開始点となるかもしれません。 </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-xmlconfig"/>3.7. XML設定ファイル</h2></div></div></div><p>もう1つの方法は <code class="literal">hibernate.cfg.xml</code> という名前のファイルで 十分な設定を指定する方法です。 このファイルは <code class="literal">hibernate.properties</code> ファイルの代わりとなります。 もし両方のファイルがあれば、プロパティが置き換えられます。 </p><p>The XML configuration file is by default expected to be in the root of your <code class="literal">CLASSPATH</code>. Here is an example: </p><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
    "-//Hibernate/Hibernate Configuration DTD//EN"
    "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;

&lt;hibernate-configuration&gt;

    &lt;!-- a SessionFactory instance listed as /jndi/name --&gt;
    &lt;session-factory
        name="java:hibernate/SessionFactory"&gt;

        &lt;!-- properties --&gt;
        &lt;property name="connection.datasource"&gt;java:/comp/env/jdbc/MyDB&lt;/property&gt;
        &lt;property name="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;
        &lt;property name="show_sql"&gt;false&lt;/property&gt;
        &lt;property name="transaction.factory_class"&gt;
            org.hibernate.transaction.JTATransactionFactory
        &lt;/property&gt;
        &lt;property name="jta.UserTransaction"&gt;java:comp/UserTransaction&lt;/property&gt;

        &lt;!-- mapping files --&gt;
        &lt;mapping resource="org/hibernate/auction/Item.hbm.xml"/&gt;
        &lt;mapping resource="org/hibernate/auction/Bid.hbm.xml"/&gt;

        &lt;!-- cache settings --&gt;
        &lt;class-cache class="org.hibernate.auction.Item" usage="read-write"/&gt;
        &lt;class-cache class="org.hibernate.auction.Bid" usage="read-only"/&gt;
        &lt;collection-cache collection="org.hibernate.auction.Item.bids" usage="read-write"/&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre><p>The advantage of this approach is the externalization of the mapping file names to configuration. The <code class="literal">hibernate.cfg.xml</code> is also more convenient once you have to tune the Hibernate cache. It is your choice to use either <code class="literal">hibernate.properties</code> or <code class="literal">hibernate.cfg.xml</code>. Both are equivalent, except for the above mentioned benefits of using the XML syntax. </p><p>With the XML configuration, starting Hibernate is then as simple as: </p><pre class="programlisting">SessionFactory sf = new Configuration().configure().buildSessionFactory();</pre><p>You can select a different XML configuration file using: </p><pre class="programlisting">SessionFactory sf = new Configuration()
    .configure("catdb.cfg.xml")
    .buildSessionFactory();</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-j2ee"/>3.8. J2EEアプリケーションサーバとの統合</h2></div></div></div><p>HibernateはJ2EE構造と統合するポイントをサポートしています。 </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Container-managed datasources</em></span>: Hibernate can use JDBC connections managed by the container and provided through JNDI. Usually, a JTA compatible <code class="literal">TransactionManager</code> and a <code class="literal">ResourceManager</code> take care of transaction management (CMT), especially distributed transaction handling across several datasources. You can also demarcate transaction boundaries programmatically (BMT), or you might want to use the optional Hibernate <code class="literal">Transaction</code> API for this to keep your code portable. </p></li></ul></div><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>自動JNDIバインディング</em></span>：HibernateはJNDIが立ち上がった後に <code class="literal">SessionFactory</code> を生成します。 </p></li></ul></div><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>JTA Session binding:</em></span> the Hibernate <code class="literal">Session</code> can be automatically bound to the scope of JTA transactions. Simply lookup the <code class="literal">SessionFactory</code> from JNDI and get the current <code class="literal">Session</code>. Let Hibernate manage flushing and closing the <code class="literal">Session</code> when your JTA transaction completes. Transaction demarcation is either declarative (CMT) or programmatic (BMT/UserTransaction). </p></li></ul></div><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>JMX deployment:</em></span> if you have a JMX capable application server (e.g. JBoss AS), you can choose to deploy Hibernate as a managed MBean. This saves you the one line startup code to build your <code class="literal">SessionFactory</code> from a <code class="literal">Configuration</code>. The container will startup your <code class="literal">HibernateService</code> and also take care of service dependencies (datasource has to be available before Hibernate starts, etc). </p></li></ul></div><p>環境に依存しますが、もし、アプリケーションサーバが"connection containment"の例外をスローするなら 設定のオプション <code class="literal">hibernate.connection.aggressive_release</code> をtrueにしてください。 </p><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-transactionstrategy"/>3.8.1. トランザクション戦略設定</h3></div></div></div><p>The Hibernate <code class="literal">Session</code> API is independent of any transaction demarcation system in your architecture. If you let Hibernate use JDBC directly through a connection pool, you can begin and end your transactions by calling the JDBC API. If you run in a J2EE application server, you might want to use bean-managed transactions and call the JTA API and <code class="literal">UserTransaction</code> when needed. </p><p>2つ（それ以上）の環境で互換性のあるコードを維持するために、オプションとして根本的なシステムを ラッピングするHibernate <code class="literal">Transaction</code> APIを推奨します。 Hibernate設定プロパティの <code class="literal">hibernate.transaction.factory_class</code> を設定することで ある特定の <code class="literal">Transaction</code> クラスのインスタンスを持つことができます。 </p><p>There are three standard, or built-in, choices: </p><div class="variablelist"><dl><dt><span class="term"><code class="literal">org.hibernate.transaction.JDBCTransactionFactory</code></span></dt><dd><p>データベース(JDBC)トランザクションに委譲します（デフォルト）</p></dd><dt><span class="term"><code class="literal">org.hibernate.transaction.JTATransactionFactory</code></span></dt><dd><p>delegates to container-managed transactions if an existing transaction is underway in this context (for example, EJB session bean method). Otherwise, a new transaction is started and bean-managed transactions are used. </p></dd><dt><span class="term"><code class="literal">org.hibernate.transaction.CMTTransactionFactory</code></span></dt><dd><p>コンテナ管理JTAトランザクションに委譲します</p></dd></dl></div><p>You can also define your own transaction strategies (for a CORBA transaction service, for example). </p><p>Some features in Hibernate (i.e., the second level cache, Contextual Sessions with JTA, etc.) require access to the JTA <code class="literal">TransactionManager</code> in a managed environment. In an application server, since J2EE does not standardize a single mechanism, you have to specify how Hibernate should obtain a reference to the <code class="literal">TransactionManager</code>: </p><div class="table"><a id="jtamanagerlookup"/><p class="title"><b>表 3.10. JTA トランザクションマネージャ</b></p><div class="table-contents"><table summary="JTA トランザクションマネージャ" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Transaction Factory</th><th align="center">Application Server</th></tr></thead><tbody><tr><td><code class="literal">org.hibernate.transaction.JBossTransactionManagerLookup</code></td><td align="center">JBoss</td></tr><tr><td><code class="literal">org.hibernate.transaction.WeblogicTransactionManagerLookup</code></td><td align="center">Weblogic</td></tr><tr><td><code class="literal">org.hibernate.transaction.WebSphereTransactionManagerLookup</code></td><td align="center">WebSphere</td></tr><tr><td><code class="literal">org.hibernate.transaction.WebSphereExtendedJTATransactionLookup</code></td><td align="center">WebSphere 6</td></tr><tr><td><code class="literal">org.hibernate.transaction.OrionTransactionManagerLookup</code></td><td align="center">Orion</td></tr><tr><td><code class="literal">org.hibernate.transaction.ResinTransactionManagerLookup</code></td><td align="center">Resin</td></tr><tr><td><code class="literal">org.hibernate.transaction.JOTMTransactionManagerLookup</code></td><td align="center">JOTM</td></tr><tr><td><code class="literal">org.hibernate.transaction.JOnASTransactionManagerLookup</code></td><td align="center">JOnAS</td></tr><tr><td><code class="literal">org.hibernate.transaction.JRun4TransactionManagerLookup</code></td><td align="center">JRun4</td></tr><tr><td><code class="literal">org.hibernate.transaction.BESTransactionManagerLookup</code></td><td align="center">Borland ES</td></tr></tbody></table></div></div><br class="table-break"/></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-jndi"/>3.8.2. <code class="literal">SessionFactory</code> のJNDIへの登録</h3></div></div></div><p>A JNDI-bound Hibernate <code class="literal">SessionFactory</code> can simplify the lookup function of the factory and create new <code class="literal">Session</code>s. This is not, however, related to a JNDI bound <code class="literal">Datasource</code>; both simply use the same registry. </p><p>If you wish to have the <code class="literal">SessionFactory</code> bound to a JNDI namespace, specify a name (e.g. <code class="literal">java:hibernate/SessionFactory</code>) using the property <code class="literal">hibernate.session_factory_name</code>. If this property is omitted, the <code class="literal">SessionFactory</code> will not be bound to JNDI. This is especially useful in environments with a read-only JNDI default implementation (in Tomcat, for example). </p><p><code class="literal">SessionFactory</code> をJNDIに登録するとき、Hibernateは <code class="literal">hibernate.jndi.url</code> の値を使用し、<code class="literal">hibernate.jndi.class</code> をイニシャルコンテキストとして具体化します。 もし何も設定しない場合は、デフォルトの <code class="literal">InitialContext</code> を使用します。 </p><p>Hibernate will automatically place the <code class="literal">SessionFactory</code> in JNDI after you call <code class="literal">cfg.buildSessionFactory()</code>. This means you will have this call in some startup code, or utility class in your application, unless you use JMX deployment with the <code class="literal">HibernateService</code> (this is discussed later in greater detail). </p><p>If you use a JNDI <code class="literal">SessionFactory</code>, an EJB or any other class, you can obtain the <code class="literal">SessionFactory</code> using a JNDI lookup. </p><p>It is recommended that you bind the <code class="literal">SessionFactory</code> to JNDI in a managed environment and use a <code class="literal">static</code> singleton otherwise. To shield your application code from these details, we also recommend to hide the actual lookup code for a <code class="literal">SessionFactory</code> in a helper class, such as <code class="literal">HibernateUtil.getSessionFactory()</code>. Note that such a class is also a convenient way to startup Hibernatesee chapter 1. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-j2ee-currentsession"/>3.8.3. JTAによる現在のセッションコンテキストマネージメント</h3></div></div></div><p>The easiest way to handle <code class="literal">Sessions</code> and transactions is Hibernate's automatic "current" <code class="literal">Session</code> management. For a discussion of contextual sessions see <a href="#architecture-current-session" title="2.5. Contextual sessions">項2.5. 「Contextual sessions」</a>. Using the <code class="literal">"jta"</code> session context, if there is no Hibernate <code class="literal">Session</code> associated with the current JTA transaction, one will be started and associated with that JTA transaction the first time you call <code class="literal">sessionFactory.getCurrentSession()</code>. The <code class="literal">Session</code>s retrieved via <code class="literal">getCurrentSession()</code> in the<code class="literal">"jta"</code> context are set to automatically flush before the transaction completes, close after the transaction completes, and aggressively release JDBC connections after each statement. This allows the <code class="literal">Session</code>s to be managed by the life cycle of the JTA transaction to which it is associated, keeping user code clean of such management concerns. Your code can either use JTA programmatically through <code class="literal">UserTransaction</code>, or (recommended for portable code) use the Hibernate <code class="literal">Transaction</code> API to set transaction boundaries. If you run in an EJB container, declarative transaction demarcation with CMT is preferred. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-j2ee-jmx"/>3.8.4. JMXデプロイメント</h3></div></div></div><p>The line <code class="literal">cfg.buildSessionFactory()</code> still has to be executed somewhere to get a <code class="literal">SessionFactory</code> into JNDI. You can do this either in a <code class="literal">static</code> initializer block, like the one in <code class="literal">HibernateUtil</code>, or you can deploy Hibernate as a <span class="emphasis"><em>managed service</em></span>. </p><p>Hibernate is distributed with <code class="literal">org.hibernate.jmx.HibernateService</code> for deployment on an application server with JMX capabilities, such as JBoss AS. The actual deployment and configuration is vendor-specific. Here is an example <code class="literal">jboss-service.xml</code> for JBoss 4.0.x: </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;server&gt;

&lt;mbean code="org.hibernate.jmx.HibernateService"
    name="jboss.jca:service=HibernateFactory,name=HibernateFactory"&gt;

    &lt;!-- Required services --&gt;
    &lt;depends&gt;jboss.jca:service=RARDeployer&lt;/depends&gt;
    &lt;depends&gt;jboss.jca:service=LocalTxCM,name=HsqlDS&lt;/depends&gt;

    &lt;!-- Bind the Hibernate service to JNDI --&gt;
    &lt;attribute name="JndiName"&gt;java:/hibernate/SessionFactory&lt;/attribute&gt;

    &lt;!-- Datasource settings --&gt;
    &lt;attribute name="Datasource"&gt;java:HsqlDS&lt;/attribute&gt;
    &lt;attribute name="Dialect"&gt;org.hibernate.dialect.HSQLDialect&lt;/attribute&gt;

    &lt;!-- Transaction integration --&gt;
    &lt;attribute name="TransactionStrategy"&gt;
        org.hibernate.transaction.JTATransactionFactory&lt;/attribute&gt;
    &lt;attribute name="TransactionManagerLookupStrategy"&gt;
        org.hibernate.transaction.JBossTransactionManagerLookup&lt;/attribute&gt;
    &lt;attribute name="FlushBeforeCompletionEnabled"&gt;true&lt;/attribute&gt;
    &lt;attribute name="AutoCloseSessionEnabled"&gt;true&lt;/attribute&gt;

    &lt;!-- Fetching options --&gt;
    &lt;attribute name="MaximumFetchDepth"&gt;5&lt;/attribute&gt;

    &lt;!-- Second-level caching --&gt;
    &lt;attribute name="SecondLevelCacheEnabled"&gt;true&lt;/attribute&gt;
    &lt;attribute name="CacheProviderClass"&gt;org.hibernate.cache.EhCacheProvider&lt;/attribute&gt;
    &lt;attribute name="QueryCacheEnabled"&gt;true&lt;/attribute&gt;

    &lt;!-- Logging --&gt;
    &lt;attribute name="ShowSqlEnabled"&gt;true&lt;/attribute&gt;

    &lt;!-- Mapping files --&gt;
    &lt;attribute name="MapResources"&gt;auction/Item.hbm.xml,auction/Category.hbm.xml&lt;/attribute&gt;

&lt;/mbean&gt;

&lt;/server&gt;</pre><p>This file is deployed in a directory called <code class="literal">META-INF</code> and packaged in a JAR file with the extension <code class="literal">.sar</code> (service archive). You also need to package Hibernate, its required third-party libraries, your compiled persistent classes, as well as your mapping files in the same archive. Your enterprise beans (usually session beans) can be kept in their own JAR file, but you can include this EJB JAR file in the main service archive to get a single (hot-)deployable unit. Consult the JBoss AS documentation for more information about JMX service and EJB deployment. </p></div></div></div><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes"/>第4章 永続クラス</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#persistent-classes-pojo">4.1. 単純なPOJOの例</a></span></dt><dd><dl><dt><span class="sect2"><a href="#persistent-classes-pojo-constructor">4.1.1. 引数のないコンストラクタを実装する</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-identifier">4.1.2. 識別子プロパティを用意する（オプション）</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-final">4.1.3. finalクラスにしない（オプション）</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-accessors">4.1.4. 永続フィールドに対するアクセサとミューテータを定義する（オプション）</a></span></dt></dl></dd><dt><span class="sect1"><a href="#persistent-classes-inheritance">4.2. 継承の実装</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-equalshashcode">4.3. <code class="literal">equals()</code> と <code class="literal">hashCode()</code> の実装</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-dynamicmodels">4.4. 動的モデル</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-tuplizers">4.5. Tuplizer</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-entity-name-resolver">4.6. EntityNameResolvers</a></span></dt></dl></div><p>Persistent classes are classes in an application that implement the entities of the business problem (e.g. Customer and Order in an E-commerce application). Not all instances of a persistent class are considered to be in the persistent state. For example, an instance can instead be transient or detached. </p><p>Hibernate works best if these classes follow some simple rules, also known as the Plain Old Java Object (POJO) programming model. However, none of these rules are hard requirements. Indeed, Hibernate3 assumes very little about the nature of your persistent objects. You can express a domain model in other ways (using trees of <code class="literal">Map</code> instances, for example). </p><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes-pojo"/>4.1. 単純なPOJOの例</h2></div></div></div><p>Most Java applications require a persistent class representing felines. For example: </p><pre class="programlisting">package eg;
import java.util.Set;
import java.util.Date;

public class Cat {
    private Long id; // identifier

    private Date birthdate;
    private Color color;
    private char sex;
    private float weight;
    private int litterId;

    private Cat mother;
    private Set kittens = new HashSet();

    private void setId(Long id) {
        this.id=id;
    }
    public Long getId() {
        return id;
    }

    void setBirthdate(Date date) {
        birthdate = date;
    }
    public Date getBirthdate() {
        return birthdate;
    }

    void setWeight(float weight) {
        this.weight = weight;
    }
    public float getWeight() {
        return weight;
    }

    public Color getColor() {
        return color;
    }
    void setColor(Color color) {
        this.color = color;
    }

    void setSex(char sex) {
        this.sex=sex;
    }
    public char getSex() {
        return sex;
    }

    void setLitterId(int id) {
        this.litterId = id;
    }
    public int getLitterId() {
        return litterId;
    }

    void setMother(Cat mother) {
        this.mother = mother;
    }
    public Cat getMother() {
        return mother;
    }
    void setKittens(Set kittens) {
        this.kittens = kittens;
    }
    public Set getKittens() {
        return kittens;
    }
    
    // addKitten not needed by Hibernate
    public void addKitten(Cat kitten) {
            kitten.setMother(this);
        kitten.setLitterId( kittens.size() ); 
        kittens.add(kitten);
    }
}</pre><p>The four main rules of persistent classes are explored in more detail in the following sections. </p><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="persistent-classes-pojo-constructor"/>4.1.1. 引数のないコンストラクタを実装する</h3></div></div></div><p><code class="literal">Cat</code> has a no-argument constructor. All persistent classes must have a default constructor (which can be non-public) so that Hibernate can instantiate them using <code class="literal">Constructor.newInstance()</code>. It is recommended that you have a default constructor with at least <span class="emphasis"><em>package</em></span> visibility for runtime proxy generation in Hibernate. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="persistent-classes-pojo-identifier"/>4.1.2. 識別子プロパティを用意する（オプション）</h3></div></div></div><p><code class="literal">Cat</code> has a property called <code class="literal">id</code>. This property maps to the primary key column of a database table. The property might have been called anything, and its type might have been any primitive type, any primitive "wrapper" type, <code class="literal">java.lang.String</code> or <code class="literal">java.util.Date</code>. If your legacy database table has composite keys, you can use a user-defined class with properties of these types (see the section on composite identifiers later in the chapter.) </p><p>識別子プロパティは厳密にはオプションです。 これを省略して、Hibernateに内部的にオブジェクトの識別子を追跡させることは可能です。 しかしおすすめはしません。 </p><p>In fact, some functionality is available only to classes that declare an identifier property: </p><div class="itemizedlist"><ul compact="compact"><li><p>Transitive reattachment for detached objects (cascade update or cascade merge) - see <a href="#objectstate-transitive" title="10.11. 連鎖的な永続化">項10.11. 「連鎖的な永続化」</a> </p></li><li><p>
                        <code class="literal">Session.saveOrUpdate()</code>
                    </p></li><li><p>
                        <code class="literal">Session.merge()</code>
                    </p></li></ul></div><p>We recommend that you declare consistently-named identifier properties on persistent classes and that you use a nullable (i.e., non-primitive) type. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="persistent-classes-pojo-final"/>4.1.3. finalクラスにしない（オプション）</h3></div></div></div><p>Hibernateの中心的な特徴である <span class="emphasis"><em>プロキシ</em></span> は、 永続クラスがfinalでないこと、またはメソッドを全部publicで宣言している インターフェイスが実装されているかに依存しています。 </p><p>You can persist <code class="literal">final</code> classes that do not implement an interface with Hibernate. You will not, however, be able to use proxies for lazy association fetching which will ultimately limit your options for performance tuning. </p><p>finalではないクラスで <code class="literal">public final</code> メソッドを定義することも避けるべきです。 <code class="literal">public final</code> メソッドを持つクラスを使いたければ、 <code class="literal">lazy="false"</code> と設定して明示的にプロキシを無効にしなければなりません。 </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="persistent-classes-pojo-accessors"/>4.1.4. 永続フィールドに対するアクセサとミューテータを定義する（オプション）</h3></div></div></div><p><code class="literal">Cat</code> declares accessor methods for all its persistent fields. Many other ORM tools directly persist instance variables. It is better to provide an indirection between the relational schema and internal data structures of the class. By default, Hibernate persists JavaBeans style properties and recognizes method names of the form <code class="literal">getFoo</code>, <code class="literal">isFoo</code> and <code class="literal">setFoo</code>. If required, you can switch to direct field access for particular properties. </p><p>プロパティはpublicで宣言する必要は <span class="emphasis"><em>ありません</em></span> 。 Hibernateはデフォルト、<code class="literal">protected</code> もしくは <code class="literal">private</code> のget / setのペアを持つプロパティを永続化することができます。 </p></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes-inheritance"/>4.2. 継承の実装</h2></div></div></div><p>A subclass must also observe the first and second rules. It inherits its identifier property from the superclass, <code class="literal">Cat</code>. For example: </p><pre class="programlisting">package eg;

public class DomesticCat extends Cat {
        private String name;

        public String getName() {
                return name;
        }
        protected void setName(String name) {
                this.name=name;
        }
}</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes-equalshashcode"/>4.3. <code class="literal">equals()</code> と <code class="literal">hashCode()</code> の実装</h2></div></div></div><p>You have to override the <code class="literal">equals()</code> and <code class="literal">hashCode()</code> methods if you: </p><div class="itemizedlist"><ul compact="compact"><li><p>intend to put instances of persistent classes in a <code class="literal">Set</code> (the recommended way to represent many-valued associations); <span class="emphasis"><em>and</em></span> </p></li><li><p>分離インスタンスをセッションへ再追加する場合。 </p></li></ul></div><p>Hibernate guarantees equivalence of persistent identity (database row) and Java identity only inside a particular session scope. When you mix instances retrieved in different sessions, you must implement <code class="literal">equals()</code> and <code class="literal">hashCode()</code> if you wish to have meaningful semantics for <code class="literal">Set</code>s. </p><p>The most obvious way is to implement <code class="literal">equals()</code>/<code class="literal">hashCode()</code> by comparing the identifier value of both objects. If the value is the same, both must be the same database row, because they are equal. If both are added to a <code class="literal">Set</code>, you will only have one element in the <code class="literal">Set</code>). Unfortunately, you cannot use that approach with generated identifiers. Hibernate will only assign identifier values to objects that are persistent; a newly created instance will not have any identifier value. Furthermore, if an instance is unsaved and currently in a <code class="literal">Set</code>, saving it will assign an identifier value to the object. If <code class="literal">equals()</code> and <code class="literal">hashCode()</code> are based on the identifier value, the hash code would change, breaking the contract of the <code class="literal">Set</code>. See the Hibernate website for a full discussion of this problem. This is not a Hibernate issue, but normal Java semantics of object identity and equality. </p><p>It is recommended that you implement <code class="literal">equals()</code> and <code class="literal">hashCode()</code> using <span class="emphasis"><em>Business key equality</em></span>. Business key equality means that the <code class="literal">equals()</code> method compares only the properties that form the business key. It is a key that would identify our instance in the real world (a <span class="emphasis"><em>natural</em></span> candidate key): </p><pre class="programlisting">public class Cat {

    ...
    public boolean equals(Object other) {
        if (this == other) return true;
        if ( !(other instanceof Cat) ) return false;

        final Cat cat = (Cat) other;

        if ( !cat.getLitterId().equals( getLitterId() ) ) return false;
        if ( !cat.getMother().equals( getMother() ) ) return false;

        return true;
    }

    public int hashCode() {
        int result;
        result = getMother().hashCode();
        result = 29 * result + getLitterId();
        return result;
    }

}</pre><p>A business key does not have to be as solid as a database primary key candidate (see <a href="#transactions-basics-identity" title="11.1.3. オブジェクト識別子を考える">項11.1.3. 「オブジェクト識別子を考える」</a>). Immutable or unique properties are usually good candidates for a business key. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes-dynamicmodels"/>4.4. 動的モデル</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
	 <span class="emphasis"><em>The following features are currently considered experimental and may change in the near future.</em></span>
	      
	</p></div><p>Persistent entities do not necessarily have to be represented as POJO classes or as JavaBean objects at runtime. Hibernate also supports dynamic models (using <code class="literal">Map</code>s of <code class="literal">Map</code>s at runtime) and the representation of entities as DOM4J trees. With this approach, you do not write persistent classes, only mapping files. </p><p>By default, Hibernate works in normal POJO mode. You can set a default entity representation mode for a particular <code class="literal">SessionFactory</code> using the <code class="literal">default_entity_mode</code> configuration option (see <a href="#configuration-optional-properties" title="表 3.3. Hibernate設定プロパティ">表 3.3. 「Hibernate設定プロパティ」</a>). </p><p>The following examples demonstrate the representation using <code class="literal">Map</code>s. First, in the mapping file an <code class="literal">entity-name</code> has to be declared instead of, or in addition to, a class name: </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class entity-name="Customer"&gt;

        &lt;id name="id"
            type="long"
            column="ID"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;

        &lt;property name="name"
            column="NAME"
            type="string"/&gt;

        &lt;property name="address"
            column="ADDRESS"
            type="string"/&gt;

        &lt;many-to-one name="organization"
            column="ORGANIZATION_ID"
            class="Organization"/&gt;

        &lt;bag name="orders"
            inverse="true"
            lazy="false"
            cascade="all"&gt;
            &lt;key column="CUSTOMER_ID"/&gt;
            &lt;one-to-many class="Order"/&gt;
        &lt;/bag&gt;

    &lt;/class&gt;
    
&lt;/hibernate-mapping&gt;</pre><p>Even though associations are declared using target class names, the target type of associations can also be a dynamic entity instead of a POJO. </p><p>After setting the default entity mode to <code class="literal">dynamic-map</code> for the <code class="literal">SessionFactory</code>, you can, at runtime, work with <code class="literal">Map</code>s of <code class="literal">Map</code>s: </p><pre class="programlisting">Session s = openSession();
Transaction tx = s.beginTransaction();
Session s = openSession();

// Create a customer
Map david = new HashMap();
david.put("name", "David");

// Create an organization
Map foobar = new HashMap();
foobar.put("name", "Foobar Inc.");

// Link both
david.put("organization", foobar);

// Save both
s.save("Customer", david);
s.save("Organization", foobar);

tx.commit();
s.close();</pre><p>One of the main advantages of dynamic mapping is quick turnaround time for prototyping, without the need for entity class implementation. However, you lose compile-time type checking and will likely deal with many exceptions at runtime. As a result of the Hibernate mapping, the database schema can easily be normalized and sound, allowing to add a proper domain model implementation on top later on. </p><p>エンティティ表現モードは <code class="literal">Session</code> ごとに設定することも可能です。 </p><pre class="programlisting">Session dynamicSession = pojoSession.getSession(EntityMode.MAP);

// Create a customer
Map david = new HashMap();
david.put("name", "David");
dynamicSession.save("Customer", david);
...
dynamicSession.flush();
dynamicSession.close()
...
// Continue on pojoSession
</pre><p>Please note that the call to <code class="literal">getSession()</code> using an <code class="literal">EntityMode</code> is on the <code class="literal">Session</code> API, not the <code class="literal">SessionFactory</code>. That way, the new <code class="literal">Session</code> shares the underlying JDBC connection, transaction, and other context information. This means you do not have to call <code class="literal">flush()</code> and <code class="literal">close()</code> on the secondary <code class="literal">Session</code>, and also leave the transaction and connection handling to the primary unit of work. </p><p>XML表現の能力についてのさらなる情報は <a href="#xml" title="第18章 XMLマッピング">章 18. <i xmlns:xlink="http://www.w3.org/1999/xlink">XMLマッピング</i></a> で見つかります。 </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes-tuplizers"/>4.5. Tuplizer</h2></div></div></div><p><code class="literal">org.hibernate.tuple.Tuplizer</code>, and its sub-interfaces, are responsible for managing a particular representation of a piece of data given that representation's <code class="literal">org.hibernate.EntityMode</code>. If a given piece of data is thought of as a data structure, then a tuplizer is the thing that knows how to create such a data structure and how to extract values from and inject values into such a data structure. For example, for the POJO entity mode, the corresponding tuplizer knows how create the POJO through its constructor. It also knows how to access the POJO properties using the defined property accessors. </p><p>There are two high-level types of Tuplizers, represented by the <code class="literal">org.hibernate.tuple.entity.EntityTuplizer</code> and <code class="literal">org.hibernate.tuple.component.ComponentTuplizer</code> interfaces. <code class="literal">EntityTuplizer</code>s are responsible for managing the above mentioned contracts in regards to entities, while <code class="literal">ComponentTuplizer</code>s do the same for components. </p><p>Users can also plug in their own tuplizers. Perhaps you require that a <code class="literal">java.util.Map</code> implementation other than <code class="literal">java.util.HashMap</code> be used while in the dynamic-map entity-mode. Or perhaps you need to define a different proxy generation strategy than the one used by default. Both would be achieved by defining a custom tuplizer implementation. Tuplizer definitions are attached to the entity or component mapping they are meant to manage. Going back to the example of our customer entity: </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    &lt;class entity-name="Customer"&gt;
        &lt;!--
            Override the dynamic-map entity-mode
            tuplizer for the customer entity
        --&gt;
        &lt;tuplizer entity-mode="dynamic-map"
                class="CustomMapTuplizerImpl"/&gt;

        &lt;id name="id" type="long" column="ID"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;

        &lt;!-- other properties --&gt;
        ...
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;


public class CustomMapTuplizerImpl
        extends org.hibernate.tuple.entity.DynamicMapEntityTuplizer {
    // override the buildInstantiator() method to plug in our custom map...
    protected final Instantiator buildInstantiator(
            org.hibernate.mapping.PersistentClass mappingInfo) {
        return new CustomMapInstantiator( mappingInfo );
    }

    private static final class CustomMapInstantiator
            extends org.hibernate.tuple.DynamicMapInstantitor {
        // override the generateMap() method to return our custom map...
            protected final Map generateMap() {
                    return new CustomMap();
            }
    }
}</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes-entity-name-resolver"/>4.6. EntityNameResolvers</h2></div></div></div><p>The <code class="interfacename">org.hibernate.EntityNameResolver</code> interface is a contract for resolving the entity name of a given entity instance. The interface defines a single method <code class="methodname">resolveEntityName</code> which is passed the entity instance and is expected to return the appropriate entity name (null is allowed and would indicate that the resolver does not know how to resolve the entity name of the given entity instance). Generally speaking, an <code class="interfacename">org.hibernate.EntityNameResolver</code> is going to be most useful in the case of dynamic models. One example might be using proxied interfaces as your domain model. The hibernate test suite has an example of this exact style of usage under the <span class="package">org.hibernate.test.dynamicentity.tuplizer2</span>. Here is some of the code from that package for illustration. </p><pre class="programlisting">/**
 * A very trivial JDK Proxy InvocationHandler implementation where we proxy an interface as
 * the domain model and simply store persistent state in an internal Map.  This is an extremely
 * trivial example meant only for illustration.
 */
public final class DataProxyHandler implements InvocationHandler {
        private String entityName;
        private HashMap data = new HashMap();

        public DataProxyHandler(String entityName, Serializable id) {
                this.entityName = entityName;
                data.put( "Id", id );
        }

        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                String methodName = method.getName();
                if ( methodName.startsWith( "set" ) ) {
                        String propertyName = methodName.substring( 3 );
                        data.put( propertyName, args[0] );
                }
                else if ( methodName.startsWith( "get" ) ) {
                        String propertyName = methodName.substring( 3 );
                        return data.get( propertyName );
                }
                else if ( "toString".equals( methodName ) ) {
                        return entityName + "#" + data.get( "Id" );
                }
                else if ( "hashCode".equals( methodName ) ) {
                        return new Integer( this.hashCode() );
                }
                return null;
        }

        public String getEntityName() {
                return entityName;
        }

        public HashMap getData() {
                return data;
        }
}

/**
 *
 */
public class ProxyHelper {
    public static String extractEntityName(Object object) {
        // Our custom java.lang.reflect.Proxy instances actually bundle
        // their appropriate entity name, so we simply extract it from there
        // if this represents one of our proxies; otherwise, we return null
        if ( Proxy.isProxyClass( object.getClass() ) ) {
            InvocationHandler handler = Proxy.getInvocationHandler( object );
            if ( DataProxyHandler.class.isAssignableFrom( handler.getClass() ) ) {
                DataProxyHandler myHandler = ( DataProxyHandler ) handler;
                return myHandler.getEntityName();
            }
        }
        return null;
    }

    // various other utility methods ....

}

/**
 * The EntityNameResolver implementation.
 * IMPL NOTE : An EntityNameResolver really defines a strategy for how entity names should be
 * resolved.  Since this particular impl can handle resolution for all of our entities we want to
 * take advantage of the fact that SessionFactoryImpl keeps these in a Set so that we only ever
 * have one instance registered.  Why?  Well, when it comes time to resolve an entity name,
 * Hibernate must iterate over all the registered resolvers.  So keeping that number down
 * helps that process be as speedy as possible.  Hence the equals and hashCode impls
 */
public class MyEntityNameResolver implements EntityNameResolver {
    public static final MyEntityNameResolver INSTANCE = new MyEntityNameResolver();

    public String resolveEntityName(Object entity) {
        return ProxyHelper.extractEntityName( entity );
    }

    public boolean equals(Object obj) {
        return getClass().equals( obj.getClass() );
    }

    public int hashCode() {
        return getClass().hashCode();
    }
}

public class MyEntityTuplizer extends PojoEntityTuplizer {
        public MyEntityTuplizer(EntityMetamodel entityMetamodel, PersistentClass mappedEntity) {
                super( entityMetamodel, mappedEntity );
        }

        public EntityNameResolver[] getEntityNameResolvers() {
                return new EntityNameResolver[] { MyEntityNameResolver.INSTANCE };
        }

    public String determineConcreteSubclassEntityName(Object entityInstance, SessionFactoryImplementor factory) {
        String entityName = ProxyHelper.extractEntityName( entityInstance );
        if ( entityName == null ) {
            entityName = super.determineConcreteSubclassEntityName( entityInstance, factory );
        }
        return entityName;
    }

    ...
}
        </pre><p>In order to register an <code class="interfacename">org.hibernate.EntityNameResolver</code> users must either: </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>Implement a custom <a href="#persistent-classes-tuplizers" title="4.5. Tuplizer">Tuplizer</a>, implementing the <code class="methodname">getEntityNameResolvers</code> method. </p></li><li><p>Register it with the <code class="classname">org.hibernate.impl.SessionFactoryImpl</code> (which is the implementation class for <code class="interfacename">org.hibernate.SessionFactory</code>) using the <code class="methodname">registerEntityNameResolver</code> method. </p></li></ol></div><p>
        </p></div></div><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="mapping"/>第5章 基本的なO/Rマッピング</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#mapping-declaration">5.1. マッピング定義</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-declaration-doctype">5.1.1. Doctype</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-mapping">5.1.2. Hibernate-mapping</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-class">5.1.3. Class</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id">5.1.4. id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id-enhanced">5.1.5. Enhanced identifier generators</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id-enhanced-optimizers">5.1.6. Identifier generator optimization</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-compositeid">5.1.7. composite-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-discriminator">5.1.8. Discriminator</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-version">5.1.9. Version (optional)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-timestamp">5.1.10. Timestamp (optional)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-property">5.1.11. Property</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-manytoone">5.1.12. Many-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-onetoone">5.1.13. One-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-naturalid">5.1.14. Natural-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-component">5.1.15. Component and dynamic-component</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-properties">5.1.16. Properties</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-subclass">5.1.17. Subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-joinedsubclass">5.1.18. Joined-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-unionsubclass">5.1.19. Union-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-join">5.1.20. Join</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-key">5.1.21. Key</a></span></dt><dt><span class="sect2"><a href="#mapping-column">5.1.22. Column and formula elements</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-import">5.1.23. Import</a></span></dt><dt><span class="sect2"><a href="#mapping-types-anymapping">5.1.24. Any</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-types">5.2. Hibernate types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-types-entitiesvalues">5.2.1. エンティティと値</a></span></dt><dt><span class="sect2"><a href="#mapping-types-basictypes">5.2.2. 基本的な型</a></span></dt><dt><span class="sect2"><a href="#mapping-types-custom">5.2.3. カスタム型</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-entityname">5.3. １つのクラスに１つ以上のマッピング</a></span></dt><dt><span class="sect1"><a href="#mapping-quotedidentifiers">5.4. バッククォートで囲んだ SQL 識別子</a></span></dt><dt><span class="sect1"><a href="#mapping-alternatives">5.5. メタデータの代替手段</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-xdoclet">5.5.1. XDoclet マークアップの使用</a></span></dt><dt><span class="sect2"><a href="#mapping-annotations">5.5.2. JDK 5.0 アノテーションの使用</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-generated">5.6. Generated properties</a></span></dt><dt><span class="sect1"><a href="#mapping-database-object">5.7. Auxiliary database objects</a></span></dt></dl></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-declaration"/>5.1. マッピング定義</h2></div></div></div><p>Object/relational mappings are usually defined in an XML document. The mapping document is designed to be readable and hand-editable. The mapping language is Java-centric, meaning that mappings are constructed around persistent class declarations and not table declarations. </p><p>Please note that even though many Hibernate users choose to write the XML by hand, a number of tools exist to generate the mapping document. These include XDoclet, Middlegen and AndroMDA. </p><p>Here is an example mapping: </p><a id="mapping-declaration-ex1"/><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
      "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
          "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

        &lt;class name="Cat"
            table="cats"
            discriminator-value="C"&gt;

                &lt;id name="id"&gt;
                        &lt;generator class="native"/&gt;
                &lt;/id&gt;

                &lt;discriminator column="subclass"
                     type="character"/&gt;

                &lt;property name="weight"/&gt;

                &lt;property name="birthdate"
                    type="date"
                    not-null="true"
                    update="false"/&gt;

                &lt;property name="color"
                    type="eg.types.ColorUserType"
                    not-null="true"
                    update="false"/&gt;

                &lt;property name="sex"
                    not-null="true"
                    update="false"/&gt;

                &lt;property name="litterId"
                    column="litterId"
                    update="false"/&gt;

                &lt;many-to-one name="mother"
                    column="mother_id"
                    update="false"/&gt;

                &lt;set name="kittens"
                    inverse="true"
                    order-by="litter_id"&gt;
                        &lt;key column="mother_id"/&gt;
                        &lt;one-to-many class="Cat"/&gt;
                &lt;/set&gt;

                &lt;subclass name="DomesticCat"
                    discriminator-value="D"&gt;

                        &lt;property name="name"
                            type="string"/&gt;

                &lt;/subclass&gt;

        &lt;/class&gt;

        &lt;class name="Dog"&gt;
                &lt;!-- mapping for Dog could go here --&gt;
        &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>We will now discuss the content of the mapping document. We will only describe, however, the document elements and attributes that are used by Hibernate at runtime. The mapping document also contains some extra optional attributes and elements that affect the database schemas exported by the schema export tool (for example, the <code class="literal"> not-null</code> attribute). </p><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-doctype"/>5.1.1. Doctype</h3></div></div></div><p>All XML mappings should declare the doctype shown. The actual DTD can be found at the URL above, in the directory <code class="literal">hibernate-x.x.x/src/org/hibernate </code>, or in <code class="literal">hibernate3.jar</code>. Hibernate will always look for the DTD in its classpath first. If you experience lookups of the DTD using an Internet connection, check the DTD declaration against the contents of your classpath. </p><div class="sect3" lang="ja-JP"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-entity-resolution"/>5.1.1.1. エンティティ・リゾルバ</h4></div></div></div><p>Hibernate will first attempt to resolve DTDs in its classpath. It does this is by registering a custom <code class="literal">org.xml.sax.EntityResolver</code> implementation with the SAXReader it uses to read in the xml files. This custom <code class="literal">EntityResolver</code> recognizes two different systemId namespaces: </p><div class="itemizedlist"><ul><li><p>a <code class="literal">hibernate namespace</code> is recognized whenever the resolver encounters a systemId starting with <code class="literal">http://hibernate.sourceforge.net/</code>. The resolver attempts to resolve these entities via the classloader which loaded the Hibernate classes. </p></li><li><p>a <code class="literal">user namespace</code> is recognized whenever the resolver encounters a systemId using a <code class="literal">classpath://</code> URL protocol. The resolver will attempt to resolve these entities via (1) the current thread context classloader and (2) the classloader which loaded the Hibernate classes. </p></li></ul></div><p>The following is an example of utilizing user namespacing: </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd" [
    &lt;!ENTITY types SYSTEM "classpath://your/domain/types.xml"&gt;
]&gt;

&lt;hibernate-mapping package="your.domain"&gt;
    &lt;class name="MyEntity"&gt;
        &lt;id name="id" type="my-custom-id-type"&gt;
            ...
        &lt;/id&gt;
    &lt;class&gt;
    &amp;types;
&lt;/hibernate-mapping&gt;</pre><p>ここで <code class="literal">types.xml</code> は <code class="literal">your.domain</code> パッケージ内のリソースであり、 カスタム <a href="#mapping-types-custom" title="5.2.3. カスタム型">項5.2.3. 「カスタム型」</a> を含むます。 </p></div></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-mapping"/>5.1.2. Hibernate-mapping</h3></div></div></div><p>This element has several optional attributes. The <code class="literal">schema</code> and <code class="literal">catalog</code> attributes specify that tables referred to in this mapping belong to the named schema and/or catalog. If they are specified, tablenames will be qualified by the given schema and catalog names. If they are missing, tablenames will be unqualified. The <code class="literal">default-cascade</code> attribute specifies what cascade style should be assumed for properties and collections that do not specify a <code class="literal">cascade</code> attribute. By default, the <code class="literal">auto-import</code> attribute allows you to use unqualified class names in the query language. </p><div class="programlistingco"><pre class="programlisting">&lt;hibernate-mapping
         schema="schemaName"                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
         catalog="catalogName"                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
         default-cascade="cascade_style"              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
         default-access="field|property|ClassName"    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
         default-lazy="true|false"                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
         auto-import="true|false"                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
         package="package.name"                       <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
 /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">schema</code> (optional): the name of a database schema. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">catalog</code> (optional): the name of a database catalog. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">default-cascade</code> (optional - defaults to <code class="literal">none</code>): a default cascade style. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">default-access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate should use for accessing all properties. It can be a custom implementation of <code class="literal">PropertyAccessor</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">default-lazy</code> (optional - defaults to <code class="literal">true</code>): the default value for unspecified <code class="literal">lazy</code> attributes of class and collection mappings. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">auto-import</code> (optional - defaults to <code class="literal">true</code>): specifies whether we can use unqualified class names of classes in this mapping in the query language. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">package</code> (optional): specifies a package prefix to use for unqualified class names in the mapping document. </p></td></tr></table></div></div><p>If you have two persistent classes with the same unqualified name, you should set <code class="literal">auto-import="false"</code>. An exception will result if you attempt to assign two classes to the same "imported" name. </p><p>The <code class="literal">hibernate-mapping</code> element allows you to nest several persistent <code class="literal">&lt;class&gt;</code> mappings, as shown above. It is, however, good practice (and expected by some tools) to map only a single persistent class, or a single class hierarchy, in one mapping file and name it after the persistent superclass. For example, <code class="literal">Cat.hbm.xml</code>, <code class="literal">Dog.hbm.xml</code>, or if using inheritance, <code class="literal">Animal.hbm.xml</code>. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-class"/>5.1.3. Class</h3></div></div></div><p>You can declare a persistent class using the <code class="literal">class</code> element. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;class
        name="ClassName"                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        table="tableName"                             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        discriminator-value="discriminator_value"     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        mutable="true|false"                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        schema="owner"                                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        catalog="catalog"                             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        proxy="ProxyInterface"                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        dynamic-update="true|false"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
        dynamic-insert="true|false"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/9.png" alt="(9)"/></span>
        select-before-update="true|false"             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/10.png" alt="(10)"/></span>
        polymorphism="implicit|explicit"              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/11.png" alt="(11)"/></span>
        where="arbitrary sql where condition"         <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/12.png" alt="(12)"/></span>
        persister="PersisterClass"                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/13.png" alt="(13)"/></span>
        batch-size="N"                                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/14.png" alt="(14)"/></span>
        optimistic-lock="none|version|dirty|all"      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/15.png" alt="(15)"/></span>
        lazy="true|false"                             <span xmlns="" class="co">(16)</span>
        entity-name="EntityName"                      <span xmlns="" class="co">(17)</span>
        check="arbitrary sql check condition"         <span xmlns="" class="co">(18)</span>
        rowid="rowid"                                 <span xmlns="" class="co">(19)</span>
        subselect="SQL expression"                    <span xmlns="" class="co">(20)</span>
        abstract="true|false"                         <span xmlns="" class="co">(21)</span>
        node="element-name"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code> (optional): the fully qualified Java class name of the persistent class or interface. If this attribute is missing, it is assumed that the mapping is for a non-POJO entity. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">table</code> (optional - defaults to the unqualified class name): the name of its database table. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">discriminator-value</code> (optional - defaults to the class name): a value that distinguishes individual subclasses that is used for polymorphic behavior. Acceptable values include <code class="literal">null</code> and <code class="literal">not null</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">mutable</code> (optional - defaults to <code class="literal">true</code>): specifies that instances of the class are (not) mutable. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">schema</code> (optional): overrides the schema name specified by the root <code class="literal">&lt;hibernate-mapping&gt;</code> element. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">catalog</code> (optional): overrides the catalog name specified by the root <code class="literal">&lt;hibernate-mapping&gt;</code> element. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">proxy</code> (optional): specifies an interface to use for lazy initializing proxies. You can specify the name of the class itself. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">dynamic-update</code> (optional - defaults to <code class="literal">false</code>): specifies that <code class="literal">UPDATE</code> SQL should be generated at runtime and can contain only those columns whose values have changed. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/9.png" alt="9" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">dynamic-insert</code> (optional - defaults to <code class="literal">false</code>): specifies that <code class="literal">INSERT</code> SQL should be generated at runtime and contain only the columns whose values are not null. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/10.png" alt="10" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">select-before-update</code> (optional - defaults to <code class="literal">false</code>): specifies that Hibernate should <span class="emphasis"><em>never</em></span> perform an SQL <code class="literal">UPDATE</code> unless it is certain that an object is actually modified. Only when a transient object has been associated with a new session using <code class="literal">update()</code>, will Hibernate perform an extra SQL <code class="literal">SELECT</code> to determine if an <code class="literal">UPDATE</code> is actually required. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/11.png" alt="11" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">polymorphism</code> (optional - defaults to <code class="literal">implicit</code>): determines whether implicit or explicit query polymorphism is used. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/12.png" alt="12" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">where</code> (optional): specifies an arbitrary SQL <code class="literal">WHERE</code> condition to be used when retrieving objects of this class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/13.png" alt="13" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">persister</code> (optional): specifies a custom <code class="literal">ClassPersister</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/14.png" alt="14" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">batch-size</code> (optional - defaults to <code class="literal">1</code>): specifies a "batch size" for fetching instances of this class by identifier. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/15.png" alt="15" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">version</code>): determines the optimistic locking strategy. </p></td></tr><tr><td width="5%" valign="top" align="left">(16)</td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional): lazy fetching can be disabled by setting <code class="literal">lazy="false"</code>. </p></td></tr><tr><td width="5%" valign="top" align="left">(17)</td><td valign="top" align="left"><p><code class="literal">entity-name</code> (optional - defaults to the class name): Hibernate3 allows a class to be mapped multiple times, potentially to different tables. It also allows entity mappings that are represented by Maps or XML at the Java level. In these cases, you should provide an explicit arbitrary name for the entity. See <a href="#persistent-classes-dynamicmodels" title="4.4. 動的モデル">項4.4. 「動的モデル」</a> and <a href="#xml" title="第18章 XMLマッピング">章 18. <i xmlns:xlink="http://www.w3.org/1999/xlink">XMLマッピング</i></a> for more information. </p></td></tr><tr><td width="5%" valign="top" align="left">(18)</td><td valign="top" align="left"><p><code class="literal">check</code> (optional): an SQL expression used to generate a multi-row <span class="emphasis"><em>check</em></span> constraint for automatic schema generation. </p></td></tr><tr><td width="5%" valign="top" align="left">(19)</td><td valign="top" align="left"><p><code class="literal">rowid</code> (optional): Hibernate can use ROWIDs on databases. On Oracle, for example, Hibernate can use the <code class="literal">rowid</code> extra column for fast updates once this option has been set to <code class="literal">rowid</code>. A ROWID is an implementation detail and represents the physical location of a stored tuple. </p></td></tr><tr><td width="5%" valign="top" align="left">(20)</td><td valign="top" align="left"><p><code class="literal">subselect</code> (optional): maps an immutable and read-only entity to a database subselect. This is useful if you want to have a view instead of a base table. See below for more information. </p></td></tr><tr><td width="5%" valign="top" align="left">(21)</td><td valign="top" align="left"><p><code class="literal">abstract</code> (optional): is used to mark abstract superclasses in <code class="literal">&lt;union-subclass&gt;</code> hierarchies. </p></td></tr></table></div></div><p>It is acceptable for the named persistent class to be an interface. You can declare implementing classes of that interface using the <code class="literal">&lt;subclass&gt;</code> element. You can persist any <span class="emphasis"><em>static</em></span> inner class. Specify the class name using the standard form i.e. <code class="literal">e.g.Foo$Bar</code>. </p><p>Immutable classes, <code class="literal">mutable="false"</code>, cannot be updated or deleted by the application. This allows Hibernate to make some minor performance optimizations. </p><p>The optional <code class="literal">proxy</code> attribute enables lazy initialization of persistent instances of the class. Hibernate will initially return CGLIB proxies that implement the named interface. The persistent object will load when a method of the proxy is invoked. See "Initializing collections and proxies" below. </p><p><span class="emphasis"><em>Implicit</em></span> polymorphism means that instances of the class will be returned by a query that names any superclass or implemented interface or class, and that instances of any subclass of the class will be returned by a query that names the class itself. <span class="emphasis"><em>Explicit</em></span> polymorphism means that class instances will be returned only by queries that explicitly name that class. Queries that name the class will return only instances of subclasses mapped inside this <code class="literal">&lt;class&gt;</code> declaration as a <code class="literal">&lt;subclass&gt;</code> or <code class="literal">&lt;joined-subclass&gt;</code>. For most purposes, the default <code class="literal">polymorphism="implicit"</code> is appropriate. Explicit polymorphism is useful when two different classes are mapped to the same table This allows a "lightweight" class that contains a subset of the table columns. </p><p>The <code class="literal">persister</code> attribute lets you customize the persistence strategy used for the class. You can, for example, specify your own subclass of <code class="literal">org.hibernate.persister.EntityPersister</code>, or you can even provide a completely new implementation of the interface <code class="literal">org.hibernate.persister.ClassPersister</code> that implements, for example, persistence via stored procedure calls, serialization to flat files or LDAP. See <code class="literal">org.hibernate.test.CustomPersister</code> for a simple example of "persistence" to a <code class="literal">Hashtable</code>. </p><p>The <code class="literal">dynamic-update</code> and <code class="literal">dynamic-insert</code> settings are not inherited by subclasses, so they can also be specified on the <code class="literal">&lt;subclass&gt;</code> or <code class="literal">&lt;joined-subclass&gt;</code> elements. Although these settings can increase performance in some cases, they can actually decrease performance in others. </p><p>Use of <code class="literal">select-before-update</code> will usually decrease performance. It is useful to prevent a database update trigger being called unnecessarily if you reattach a graph of detached instances to a <code class="literal">Session</code>. </p><p><code class="literal">dynamic-update</code> を有効にすれば、楽観ロック戦略を選ぶことになります。 </p><div class="itemizedlist"><ul><li><p><code class="literal">version</code>: check the version/timestamp columns </p></li><li><p><code class="literal">all</code>: check all columns </p></li><li><p><code class="literal">dirty</code>: check the changed columns, allowing some concurrent updates </p></li><li><p><code class="literal">none</code>: do not use optimistic locking </p></li></ul></div><p>It is <span class="emphasis"><em>strongly</em></span> recommended that you use version/timestamp columns for optimistic locking with Hibernate. This strategy optimizes performance and correctly handles modifications made to detached instances (i.e. when <code class="literal">Session.merge()</code> is used). </p><p>There is no difference between a view and a base table for a Hibernate mapping. This is transparent at the database level, although some DBMS do not support views properly, especially with updates. Sometimes you want to use a view, but you cannot create one in the database (i.e. with a legacy schema). In this case, you can map an immutable and read-only entity to a given SQL subselect expression: </p><pre class="programlisting">&lt;class name="Summary"&gt;
    &lt;subselect&gt;
        select item.name, max(bid.amount), count(*)
        from item
        join bid on bid.item_id = item.id
        group by item.name
    &lt;/subselect&gt;
    &lt;synchronize table="item"/&gt;
    &lt;synchronize table="bid"/&gt;
    &lt;id name="name"/&gt;
    ...
&lt;/class&gt;</pre><p>Declare the tables to synchronize this entity with, ensuring that auto-flush happens correctly and that queries against the derived entity do not return stale data. The <code class="literal">&lt;subselect&gt;</code> is available both as an attribute and a nested mapping element. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-id"/>5.1.4. id</h3></div></div></div><p>マップされたクラスはデータベーステーブルの主キーカラムを定義 <span class="emphasis"><em>しなければなりません</em></span> 。 ほとんどのクラスにはインスタンスのユニークな識別子を保持するJavaBeansスタイルのプロパティもあります。 <code class="literal">&lt;id&gt;</code> 要素は、そのプロパティから主キーカラムへのマッピングを定義します。 </p><div class="programlistingco"><pre class="programlisting">&lt;id
        name="propertyName"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        type="typename"                                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        column="column_name"                                         <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        unsaved-value="null|any|none|undefined|id_value"             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        access="field|property|ClassName"&gt;                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        node="element-name|@attribute-name|element/@attribute|."

        &lt;generator class="generatorClass"/&gt;
&lt;/id&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code> (optional): the name of the identifier property. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">type</code>（オプション）：Hibernateの型を示す名前。 </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional - defaults to the property name): the name of the primary key column. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unsaved-value</code> (optional - defaults to a "sensible" value): an identifier property value that indicates an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate should use for accessing the property value. </p></td></tr></table></div></div><p><code class="literal">name</code> 属性がなければ、クラスには識別子プロパティがないものとみなされます。 </p><p><code class="literal">unsaved-value</code> 属性はHibernate3ではほとんどの場合、必要ではありません。 </p><p>There is an alternative <code class="literal">&lt;composite-id&gt;</code> declaration that allows access to legacy data with composite keys. Its use is strongly discouraged for anything else. </p><div class="sect3" lang="ja-JP"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-generator"/>5.1.4.1. ジェネレータ</h4></div></div></div><p>オプションの <code class="literal">&lt;generator&gt;</code> 子要素は、 永続クラスのインスタンスのユニークな識別子を生成するために使う、Javaクラスを指定します。 ジェネレータインスタンスの設定、もしくは初期化にパラメータが必要であれば、<code class="literal">&lt;param&gt;</code> 要素を使って渡すことができます。 </p><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="org.hibernate.id.TableHiLoGenerator"&gt;
                &lt;param name="table"&gt;uid_table&lt;/param&gt;
                &lt;param name="column"&gt;next_hi_value_column&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>All generators implement the interface <code class="literal">org.hibernate.id.IdentifierGenerator</code>. This is a very simple interface. Some applications can choose to provide their own specialized implementations, however, Hibernate provides a range of built-in implementations. The shortcut names for the built-in generators are as follows: </p><div class="variablelist"><dl><dt><span class="term"><code class="literal">increment</code></span></dt><dd><p><code class="literal">long</code> , <code class="literal">short</code> , <code class="literal">int</code> 型の識別子を生成します。 これらは他のプロセスが同じテーブルにデータを挿入しないときだけユニークです。 <span class="emphasis"><em>クラスタ内では使わないでください</em></span> 。 </p></dd><dt><span class="term"><code class="literal">identity</code></span></dt><dd><p>DB2, MySQL, MS SQL Server, Sybase, HypersonicSQLの識別子カラムを サポートします。 返される識別子の型は <code class="literal">long</code> , <code class="literal">short</code> , <code class="literal">int</code> のいずれかです。 </p></dd><dt><span class="term"><code class="literal">sequence</code></span></dt><dd><p>DB2, PostgreSQL, Oracle, SAP DB, McKoiのシーケンスや、Interbaseのジェネレータを使用します。 返される識別子の型は <code class="literal">long</code> , <code class="literal">short</code> , <code class="literal">int</code> のいずれかです。 </p></dd><dt><span class="term"><code class="literal">hilo</code></span></dt><dd><p><a id="mapping-declaration-id-hilodescription"/><code class="literal">long</code> , <code class="literal">short</code> , <code class="literal">int</code> 型の識別子を効率的に生成するhi/loアルゴリズムを使います。 hi値のソースとして、テーブルとカラムを与えます(デフォルトではそれぞれ <code class="literal">hibernate_unique_key</code> と <code class="literal">next_hi</code> )。 hi/loアルゴリズムは特定のデータベースに対してのみユニークな識別子を生成します。 </p></dd><dt><span class="term"><code class="literal">seqhilo</code></span></dt><dd><p><code class="literal">long</code> , <code class="literal">short</code> , <code class="literal">int</code> 型の識別子を効率的に生成するhi/loアルゴリズムを使います。 指定されたデータベースシーケンスを与えます。 </p></dd><dt><span class="term"><code class="literal">uuid</code></span></dt><dd><p>uses a 128-bit UUID algorithm to generate identifiers of type string that are unique within a network (the IP address is used). The UUID is encoded as a string of 32 hexadecimal digits in length. </p></dd><dt><span class="term"><code class="literal">guid</code></span></dt><dd><p>MS SQLサーバとMySQLでデータベースが生成するGUID文字列を使用します。 </p></dd><dt><span class="term"><code class="literal">native</code></span></dt><dd><p>selects <code class="literal">identity</code>, <code class="literal">sequence</code> or <code class="literal">hilo</code> depending upon the capabilities of the underlying database. </p></dd><dt><span class="term"><code class="literal">assigned</code></span></dt><dd><p>lets the application assign an identifier to the object before <code class="literal">save()</code> is called. This is the default strategy if no <code class="literal">&lt;generator&gt;</code> element is specified. </p></dd><dt><span class="term"><code class="literal">select</code></span></dt><dd><p>retrieves a primary key, assigned by a database trigger, by selecting the row by some unique key and retrieving the primary key value. </p></dd><dt><span class="term"><code class="literal">foreign</code></span></dt><dd><p>uses the identifier of another associated object. It is usually used in conjunction with a <code class="literal">&lt;one-to-one&gt;</code> primary key association. </p></dd><dt><span class="term"><code class="literal">sequence-identity</code></span></dt><dd><p>a specialized sequence generation strategy that utilizes a database sequence for the actual value generation, but combines this with JDBC3 getGeneratedKeys to return the generated identifier value as part of the insert statement execution. This strategy is only supported on Oracle 10g drivers targeted for JDK 1.4. Comments on these insert statements are disabled due to a bug in the Oracle drivers. </p></dd></dl></div><p>

                </p></div><div class="sect3" lang="ja-JP"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-hilo"/>5.1.4.2. Hi/lo アルゴリズム</h4></div></div></div><p>The <code class="literal">hilo</code> and <code class="literal">seqhilo</code> generators provide two alternate implementations of the hi/lo algorithm. The first implementation requires a "special" database table to hold the next available "hi" value. Where supported, the second uses an Oracle-style sequence. </p><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="hilo"&gt;
                &lt;param name="table"&gt;hi_value&lt;/param&gt;
                &lt;param name="column"&gt;next_value&lt;/param&gt;
                &lt;param name="max_lo"&gt;100&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="seqhilo"&gt;
                &lt;param name="sequence"&gt;hi_value&lt;/param&gt;
                &lt;param name="max_lo"&gt;100&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>Unfortunately, you cannot use <code class="literal">hilo</code> when supplying your own <code class="literal">Connection</code> to Hibernate. When Hibernate uses an application server datasource to obtain connections enlisted with JTA, you must configure the <code class="literal">hibernate.transaction.manager_lookup_class</code>. </p></div><div class="sect3" lang="ja-JP"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-uuid"/>5.1.4.3. UUID アルゴリズム</h4></div></div></div><p>The UUID contains: IP address, startup time of the JVM that is accurate to a quarter second, system time and a counter value that is unique within the JVM. It is not possible to obtain a MAC address or memory address from Java code, so this is the best option without using JNI. </p></div><div class="sect3" lang="ja-JP"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-sequences"/>5.1.4.4. 識別子カラムとシーケンス</h4></div></div></div><p>For databases that support identity columns (DB2, MySQL, Sybase, MS SQL), you can use <code class="literal">identity</code> key generation. For databases that support sequences (DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB) you can use <code class="literal">sequence</code> style key generation. Both of these strategies require two SQL queries to insert a new object. For example: </p><pre class="programlisting">&lt;id name="id" type="long" column="person_id"&gt;
        &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;person_id_sequence&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><pre class="programlisting">&lt;id name="id" type="long" column="person_id" unsaved-value="0"&gt;
        &lt;generator class="identity"/&gt;
&lt;/id&gt;</pre><p>For cross-platform development, the <code class="literal">native</code> strategy will, depending on the capabilities of the underlying database, choose from the <code class="literal">identity</code>, <code class="literal">sequence</code> and <code class="literal">hilo</code> strategies. </p></div><div class="sect3" lang="ja-JP"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-assigned"/>5.1.4.5. 識別子の割り当て</h4></div></div></div><p>If you want the application to assign identifiers, as opposed to having Hibernate generate them, you can use the <code class="literal">assigned</code> generator. This special generator uses the identifier value already assigned to the object's identifier property. The generator is used when the primary key is a natural key instead of a surrogate key. This is the default behavior if you do not specify a <code class="literal">&lt;generator&gt;</code> element. </p><p>The <code class="literal">assigned</code> generator makes Hibernate use <code class="literal">unsaved-value="undefined"</code>. This forces Hibernate to go to the database to determine if an instance is transient or detached, unless there is a version or timestamp property, or you define <code class="literal">Interceptor.isUnsaved()</code>. </p></div><div class="sect3" lang="ja-JP"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-select"/>5.1.4.6. トリガにより割り当てられた主キー</h4></div></div></div><p>Hibernate does not generate DDL with triggers. It is for legacy schemas only. </p><pre class="programlisting">&lt;id name="id" type="long" column="person_id"&gt;
        &lt;generator class="select"&gt;
                &lt;param name="key"&gt;socialSecurityNumber&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>In the above example, there is a unique valued property named <code class="literal">socialSecurityNumber</code>. It is defined by the class, as a natural key and a surrogate key named <code class="literal">person_id</code>, whose value is generated by a trigger. </p></div></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-id-enhanced"/>5.1.5. Enhanced identifier generators</h3></div></div></div><p>Starting with release 3.2.3, there are 2 new generators which represent a re-thinking of 2 different aspects of identifier generation. The first aspect is database portability; the second is optimization Optimization means that you do not have to query the database for every request for a new identifier value. These two new generators are intended to take the place of some of the named generators described above, starting in 3.3.x. However, they are included in the current releases and can be referenced by FQN. </p><p>The first of these new generators is <code class="literal">org.hibernate.id.enhanced.SequenceStyleGenerator</code> which is intended, firstly, as a replacement for the <code class="literal">sequence</code> generator and, secondly, as a better portability generator than <code class="literal">native</code>. This is because <code class="literal">native</code> generally chooses between <code class="literal">identity</code> and <code class="literal">sequence</code> which have largely different semantics that can cause subtle issues in applications eyeing portability. <code class="literal">org.hibernate.id.enhanced.SequenceStyleGenerator</code>, however, achieves portability in a different manner. It chooses between a table or a sequence in the database to store its incrementing values, depending on the capabilities of the dialect being used. The difference between this and <code class="literal">native</code> is that table-based and sequence-based storage have the same exact semantic. In fact, sequences are exactly what Hibernate tries to emulate with its table-based generators. This generator has a number of configuration parameters: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">sequence_name</code> (optional, defaults to <code class="literal">hibernate_sequence</code>): the name of the sequence or table to be used. </p></li><li><p><code class="literal">initial_value</code> (optional, defaults to <code class="literal">1</code>): the initial value to be retrieved from the sequence/table. In sequence creation terms, this is analogous to the clause typically named "STARTS WITH". </p></li><li><p><code class="literal">increment_size</code> (optional - defaults to <code class="literal">1</code>): the value by which subsequent calls to the sequence/table should differ. In sequence creation terms, this is analogous to the clause typically named "INCREMENT BY". </p></li><li><p><code class="literal">force_table_use</code> (optional - defaults to <code class="literal">false</code>): should we force the use of a table as the backing structure even though the dialect might support sequence? </p></li><li><p><code class="literal">value_column</code> (optional - defaults to <code class="literal">next_val</code>): only relevant for table structures, it is the name of the column on the table which is used to hold the value. </p></li><li><p><code class="literal">optimizer</code> (optional - defaults to <code class="literal">none</code>): See <a href="#mapping-declaration-id-enhanced-optimizers" title="5.1.6. Identifier generator optimization">項5.1.6. 「Identifier generator optimization」</a> </p></li></ul></div><p>
            </p><p>The second of these new generators is <code class="literal">org.hibernate.id.enhanced.TableGenerator</code>, which is intended, firstly, as a replacement for the <code class="literal">table</code> generator, even though it actually functions much more like <code class="literal">org.hibernate.id.MultipleHiLoPerTableGenerator</code>, and secondly, as a re-implementation of <code class="literal">org.hibernate.id.MultipleHiLoPerTableGenerator</code> that utilizes the notion of pluggable optimizers. Essentially this generator defines a table capable of holding a number of different increment values simultaneously by using multiple distinctly keyed rows. This generator has a number of configuration parameters: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">table_name</code> (optional - defaults to <code class="literal">hibernate_sequences</code>): the name of the table to be used. </p></li><li><p><code class="literal">value_column_name</code> (optional - defaults to <code class="literal">next_val</code>): the name of the column on the table that is used to hold the value. </p></li><li><p><code class="literal">segment_column_name</code> (optional - defaults to <code class="literal">sequence_name</code>): the name of the column on the table that is used to hold the "segment key". This is the value which identifies which increment value to use. </p></li><li><p><code class="literal">segment_value</code> (optional - defaults to <code class="literal">default</code>): The "segment key" value for the segment from which we want to pull increment values for this generator. </p></li><li><p><code class="literal">segment_value_length</code> (optional - defaults to <code class="literal">255</code>): Used for schema generation; the column size to create this segment key column. </p></li><li><p><code class="literal">initial_value</code> (optional - defaults to <code class="literal">1</code>): The initial value to be retrieved from the table. </p></li><li><p><code class="literal">increment_size</code> (optional - defaults to <code class="literal">1</code>): The value by which subsequent calls to the table should differ. </p></li><li><p><code class="literal">optimizer</code> (optional - defaults to <code class="literal"/>): See <a href="#mapping-declaration-id-enhanced-optimizers" title="5.1.6. Identifier generator optimization">項5.1.6. 「Identifier generator optimization」</a> </p></li></ul></div><p>
            </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-id-enhanced-optimizers"/>5.1.6. Identifier generator optimization</h3></div></div></div><p>For identifier generators that store values in the database, it is inefficient for them to hit the database on each and every call to generate a new identifier value. Instead, you can group a bunch of them in memory and only hit the database when you have exhausted your in-memory value group. This is the role of the pluggable optimizers. Currently only the two enhanced generators (<a href="#mapping-declaration-id-enhanced" title="5.1.5. Enhanced identifier generators">項5.1.5. 「Enhanced identifier generators」</a> support this operation. </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">none</code> (generally this is the default if no optimizer was specified): this will not perform any optimizations and hit the database for each and every request. </p></li><li><p><code class="literal">hilo</code>: applies a hi/lo algorithm around the database retrieved values. The values from the database for this optimizer are expected to be sequential. The values retrieved from the database structure for this optimizer indicates the "group number". The <code class="literal">increment_size</code> is multiplied by that value in memory to define a group "hi value". </p></li><li><p><code class="literal">pooled</code>: as with the case of <code class="literal">hilo</code>, this optimizer attempts to minimize the number of hits to the database. Here, however, we simply store the starting value for the "next group" into the database structure rather than a sequential value in combination with an in-memory grouping algorithm. Here, <code class="literal">increment_size</code> refers to the values coming from the database. </p></li></ul></div><p>
            </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-compositeid"/>5.1.7. composite-id</h3></div></div></div><pre class="programlisting">&lt;composite-id
        name="propertyName"
        class="ClassName"
        mapped="true|false"
        access="field|property|ClassName"&gt;
        node="element-name|."

        &lt;key-property name="propertyName" type="typename" column="column_name"/&gt;
        &lt;key-many-to-one name="propertyName class="ClassName" column="column_name"/&gt;
        ......
&lt;/composite-id&gt;</pre><p>A table with a composite key can be mapped with multiple properties of the class as identifier properties. The <code class="literal">&lt;composite-id&gt;</code> element accepts <code class="literal">&lt;key-property&gt;</code> property mappings and <code class="literal">&lt;key-many-to-one&gt;</code> mappings as child elements. </p><pre class="programlisting">&lt;composite-id&gt;
        &lt;key-property name="medicareNumber"/&gt;
        &lt;key-property name="dependent"/&gt;
&lt;/composite-id&gt;</pre><p>The persistent class <span class="emphasis"><em>must</em></span> override <code class="literal">equals()</code> and <code class="literal">hashCode()</code> to implement composite identifier equality. It must also implement <code class="literal">Serializable</code>. </p><p>Unfortunately, this approach means that a persistent object is its own identifier. There is no convenient "handle" other than the object itself. You must instantiate an instance of the persistent class itself and populate its identifier properties before you can <code class="literal">load()</code> the persistent state associated with a composite key. We call this approach an <span class="emphasis"><em>embedded</em></span> composite identifier, and discourage it for serious applications. </p><p>2つ目の方法は <span class="emphasis"><em> マップされた</em></span> 複合識別子と呼ばれるもので、 <code class="literal">&lt;composite-id&gt;</code>エレメント内で指定した識別プロパティが 永続クラスと分離した識別子クラスの両方に重複して存在します。 </p><pre class="programlisting">&lt;composite-id class="MedicareId" mapped="true"&gt;
        &lt;key-property name="medicareNumber"/&gt;
        &lt;key-property name="dependent"/&gt;
&lt;/composite-id&gt;</pre><p>In this example, both the composite identifier class, <code class="literal">MedicareId</code>, and the entity class itself have properties named <code class="literal">medicareNumber</code> and <code class="literal">dependent</code>. The identifier class must override <code class="literal">equals()</code> and <code class="literal">hashCode()</code> and implement <code class="literal">Serializable</code>. The main disadvantage of this approach is code duplication. </p><p>次の属性はマッピングした複合識別子を指定するために使用します。 </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">mapped</code> (optional - defaults to <code class="literal">false</code>): indicates that a mapped composite identifier is used, and that the contained property mappings refer to both the entity class and the composite identifier class. </p></li><li><p><code class="literal">class</code> (optional - but required for a mapped composite identifier): the class used as a composite identifier. </p></li></ul></div><p>We will describe a third, even more convenient approach, where the composite identifier is implemented as a component class in <a href="#components-compositeid" title="8.4. 複合識別子としてのコンポーネント">項8.4. 「複合識別子としてのコンポーネント」</a>. The attributes described below apply only to this alternative approach: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">name</code> (optional - required for this approach): a property of component type that holds the composite identifier. Please see chapter 9 for more information. </p></li><li><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></li><li><p><code class="literal">class</code> (optional - defaults to the property type determined by reflection): the component class used as a composite identifier. Please see the next section for more information. </p></li></ul></div><p>The third approach, an <span class="emphasis"><em>identifier component</em></span>, is recommended for almost all applications. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-discriminator"/>5.1.8. Discriminator</h3></div></div></div><p>The <code class="literal">&lt;discriminator&gt;</code> element is required for polymorphic persistence using the table-per-class-hierarchy mapping strategy. It declares a discriminator column of the table. The discriminator column contains marker values that tell the persistence layer what subclass to instantiate for a particular row. A restricted set of types can be used: <code class="literal">string</code>, <code class="literal">character</code>, <code class="literal">integer</code>, <code class="literal">byte</code>, <code class="literal">short</code>, <code class="literal">boolean</code>, <code class="literal">yes_no</code>, <code class="literal">true_false</code>. </p><div class="programlistingco"><pre class="programlisting">&lt;discriminator
        column="discriminator_column"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        type="discriminator_type"                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        force="true|false"                                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        insert="true|false"                                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        formula="arbitrary sql expression"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional - defaults to <code class="literal">class</code>): the name of the discriminator column. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">type</code> (optional - defaults to <code class="literal">string</code>): a name that indicates the Hibernate type </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">force</code> (optional - defaults to <code class="literal">false</code>): "forces" Hibernate to specify the allowed discriminator values, even when retrieving all instances of the root class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">insert</code> (optional - defaults to <code class="literal">true</code>): set this to <code class="literal">false</code> if your discriminator column is also part of a mapped composite identifier. It tells Hibernate not to include the column in SQL <code class="literal">INSERTs</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">formula</code> (optional): an arbitrary SQL expression that is executed when a type has to be evaluated. It allows content-based discrimination. </p></td></tr></table></div></div><p>識別カラムの実際の値は、 <code class="literal">&lt;class&gt;</code> と <code class="literal">&lt;subclass&gt;</code> 要素の <code class="literal">discriminator-value</code> 属性で指定されます。 </p><p>The <code class="literal">force</code> attribute is only useful if the table contains rows with "extra" discriminator values that are not mapped to a persistent class. This will not usually be the case. </p><p>The <code class="literal">formula</code> attribute allows you to declare an arbitrary SQL expression that will be used to evaluate the type of a row. For example: </p><pre class="programlisting">&lt;discriminator
    formula="case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end"
    type="integer"/&gt;</pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-version"/>5.1.9. Version (optional)</h3></div></div></div><p>The <code class="literal">&lt;version&gt;</code> element is optional and indicates that the table contains versioned data. This is particularly useful if you plan to use <span class="emphasis"><em>long transactions</em></span>. See below for more information: </p><div class="programlistingco"><pre class="programlisting">&lt;version
        column="version_column"                                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        name="propertyName"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        type="typename"                                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        access="field|property|ClassName"                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        unsaved-value="null|negative|undefined"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        generated="never|always"                                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        insert="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        node="element-name|@attribute-name|element/@attribute|."
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional - defaults to the property name): the name of the column holding the version number. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the name of a property of the persistent class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">type</code> (optional - defaults to <code class="literal">integer</code>): the type of the version number. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses to access the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unsaved-value</code> (optional - defaults to <code class="literal">undefined</code>): a version property value that indicates that an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session. <code class="literal">Undefined</code> specifies that the identifier property value should be used. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">generated</code> (optional - defaults to <code class="literal">never</code>): specifies that this version property value is generated by the database. See the discussion of <a href="#mapping-generated" title="5.6. Generated properties">generated properties</a> for more information. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">insert</code> (optional - defaults to <code class="literal">true</code>): specifies whether the version column should be included in SQL insert statements. It can be set to <code class="literal">false</code> if the database column is defined with a default value of <code class="literal">0</code>. </p></td></tr></table></div></div><p>Version numbers can be of Hibernate type <code class="literal">long</code>, <code class="literal">integer</code>, <code class="literal">short</code>, <code class="literal">timestamp</code> or <code class="literal">calendar</code>. </p><p>A version or timestamp property should never be null for a detached instance. Hibernate will detect any instance with a null version or timestamp as transient, irrespective of what other <code class="literal">unsaved-value</code> strategies are specified. <span class="emphasis"><em>Declaring a nullable version or timestamp property is an easy way to avoid problems with transitive reattachment in Hibernate. It is especially useful for people using assigned identifiers or composite keys</em></span>. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-timestamp"/>5.1.10. Timestamp (optional)</h3></div></div></div><p>The optional <code class="literal">&lt;timestamp&gt;</code> element indicates that the table contains timestamped data. This provides an alternative to versioning. Timestamps are a less safe implementation of optimistic locking. However, sometimes the application might use the timestamps in other ways. </p><div class="programlistingco"><pre class="programlisting">&lt;timestamp
        column="timestamp_column"                                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        name="propertyName"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        access="field|property|ClassName"                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        unsaved-value="null|undefined"                               <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        source="vm|db"                                               <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        generated="never|always"                                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        node="element-name|@attribute-name|element/@attribute|."
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional - defaults to the property name): the name of a column holding the timestamp. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the name of a JavaBeans style property of Java type <code class="literal">Date</code> or <code class="literal">Timestamp</code> of the persistent class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unsaved-value</code> (optional - defaults to <code class="literal">null</code>): a version property value that indicates that an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session. <code class="literal">Undefined</code> specifies that the identifier property value should be used. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">source</code> (optional - defaults to <code class="literal">vm</code>): Where should Hibernate retrieve the timestamp value from? From the database, or from the current JVM? Database-based timestamps incur an overhead because Hibernate must hit the database in order to determine the "next value". It is safer to use in clustered environments. Not all <code class="literal">Dialects</code> are known to support the retrieval of the database's current timestamp. Others may also be unsafe for usage in locking due to lack of precision (Oracle 8, for example). </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">generated</code> (optional - defaults to <code class="literal">never</code>): specifies that this timestamp property value is actually generated by the database. See the discussion of <a href="#mapping-generated" title="5.6. Generated properties">generated properties</a> for more information. </p></td></tr></table></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p><code class="literal">&lt;Timestamp&gt;</code> is equivalent to <code class="literal">&lt;version type="timestamp"&gt;</code>. And <code class="literal">&lt;timestamp source="db"&gt;</code> is equivalent to <code class="literal">&lt;version type="dbtimestamp"&gt;</code> </p></div></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-property"/>5.1.11. Property</h3></div></div></div><p>The <code class="literal">&lt;property&gt;</code> element declares a persistent JavaBean style property of the class. </p><div class="programlistingco"><pre class="programlisting">&lt;property
        name="propertyName"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        column="column_name"                                         <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        type="typename"                                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        update="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        insert="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        formula="arbitrary SQL expression"                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        access="field|property|ClassName"                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        lazy="true|false"                                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        unique="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
        not-null="true|false"                                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/9.png" alt="(9)"/></span>
        optimistic-lock="true|false"                                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/10.png" alt="(10)"/></span>
        generated="never|insert|always"                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/11.png" alt="(11)"/></span>
        node="element-name|@attribute-name|element/@attribute|."
        index="index_name"
        unique_key="unique_key_id"
        length="L"
        precision="P"
        scale="S"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>：小文字で始まるプロパティ名。 </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional - defaults to the property name): the name of the mapped database table column. This can also be specified by nested <code class="literal">&lt;column&gt;</code> element(s). </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">type</code>（オプション）：Hibernateの型を示す名前。 </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">update, insert</code> (optional - defaults to <code class="literal">true</code>): specifies that the mapped columns should be included in SQL <code class="literal">UPDATE</code> and/or <code class="literal">INSERT</code> statements. Setting both to <code class="literal">false</code> allows a pure "derived" property whose value is initialized from some other property that maps to the same column(s), or by a trigger or other application. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">formula</code>（オプション）： <span class="emphasis"><em>計算</em></span> プロパティのための値を定義するSQL式。 計算されたプロパティは自身のカラムへのマッピングがありません。 </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional - defaults to <code class="literal">false</code>): specifies that this property should be fetched lazily when the instance variable is first accessed. It requires build-time bytecode instrumentation. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unique</code> (optional): enables the DDL generation of a unique constraint for the columns. Also, allow this to be the target of a <code class="literal">property-ref</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/9.png" alt="9" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">not-null</code> (optional): enables the DDL generation of a nullability constraint for the columns. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/10.png" alt="10" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">true</code>): specifies that updates to this property do or do not require acquisition of the optimistic lock. In other words, it determines if a version increment should occur when this property is dirty. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/11.png" alt="11" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">generated</code> (optional - defaults to <code class="literal">never</code>): specifies that this property value is actually generated by the database. See the discussion of <a href="#mapping-generated" title="5.6. Generated properties">generated properties</a> for more information. </p></td></tr></table></div></div><p><span class="emphasis"><em>typename</em></span> には以下の値が可能です： </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>The name of a Hibernate basic type: <code class="literal">integer, string, character, date, timestamp, float, binary, serializable, object, blob</code> etc. </p></li><li><p>The name of a Java class with a default basic type: <code class="literal">int, float, char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</code> etc. </p></li><li><p>シリアライズ可能なJavaクラスの名前。 </p></li><li><p>The class name of a custom type: <code class="literal">com.illflow.type.MyCustomType</code> etc. </p></li></ol></div><p>If you do not specify a type, Hibernate will use reflection upon the named property and guess the correct Hibernate type. Hibernate will attempt to interpret the name of the return class of the property getter using, in order, rules 2, 3, and 4. In certain cases you will need the <code class="literal">type</code> attribute. For example, to distinguish between <code class="literal">Hibernate.DATE</code> and <code class="literal">Hibernate.TIMESTAMP</code>, or to specify a custom type. </p><p>The <code class="literal">access</code> attribute allows you to control how Hibernate accesses the property at runtime. By default, Hibernate will call the property get/set pair. If you specify <code class="literal">access="field"</code>, Hibernate will bypass the get/set pair and access the field directly using reflection. You can specify your own strategy for property access by naming a class that implements the interface <code class="literal">org.hibernate.property.PropertyAccessor</code>. </p><p>A powerful feature is derived properties. These properties are by definition read-only. The property value is computed at load time. You declare the computation as an SQL expression. This then translates to a <code class="literal">SELECT</code> clause subquery in the SQL query that loads an instance: </p><pre class="programlisting">
&lt;property name="totalPrice"
    formula="( SELECT SUM (li.quantity*p.price) FROM LineItem li, Product p
                WHERE li.productId = p.productId
                AND li.customerId = customerId
                AND li.orderNumber = orderNumber )"/&gt;</pre><p>You can reference the entity table by not declaring an alias on a particular column. This would be <code class="literal">customerId</code> in the given example. You can also use the nested <code class="literal">&lt;formula&gt;</code> mapping element if you do not want to use the attribute. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-manytoone"/>5.1.12. Many-to-one</h3></div></div></div><p>An ordinary association to another persistent class is declared using a <code class="literal">many-to-one</code> element. The relational model is a many-to-one association; a foreign key in one table is referencing the primary key column(s) of the target table. </p><div class="programlistingco"><pre class="programlisting">&lt;many-to-one
        name="propertyName"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        column="column_name"                                         <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        class="ClassName"                                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        cascade="cascade_style"                                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        fetch="join|select"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        update="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        insert="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        property-ref="propertyNameFromAssociatedClass"               <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        access="field|property|ClassName"                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
        unique="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/9.png" alt="(9)"/></span>
        not-null="true|false"                                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/10.png" alt="(10)"/></span>
        optimistic-lock="true|false"                                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/11.png" alt="(11)"/></span>
        lazy="proxy|no-proxy|false"                                  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/12.png" alt="(12)"/></span>
        not-found="ignore|exception"                                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/13.png" alt="(13)"/></span>
        entity-name="EntityName"                                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/14.png" alt="(14)"/></span>
        formula="arbitrary SQL expression"                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/15.png" alt="(15)"/></span>
        node="element-name|@attribute-name|element/@attribute|."
        embed-xml="true|false"
        index="index_name"
        unique_key="unique_key_id"
        foreign-key="foreign_key_name"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the name of the property. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional): the name of the foreign key column. This can also be specified by nested <code class="literal">&lt;column&gt;</code> element(s). </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">class</code> (optional - defaults to the property type determined by reflection): the name of the associated class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">cascade</code> (optional): specifies which operations should be cascaded from the parent object to the associated object. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">fetch</code> (optional - defaults to <code class="literal">select</code>): chooses between outer-join fetching or sequential select fetching. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">update, insert</code> (optional - defaults to <code class="literal">true</code>): specifies that the mapped columns should be included in SQL <code class="literal">UPDATE</code> and/or <code class="literal">INSERT</code> statements. Setting both to <code class="literal">false</code> allows a pure "derived" association whose value is initialized from another property that maps to the same column(s), or by a trigger or other application. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">property-ref</code> (optional): the name of a property of the associated class that is joined to this foreign key. If not specified, the primary key of the associated class is used. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/9.png" alt="9" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unique</code> (optional): enables the DDL generation of a unique constraint for the foreign-key column. By allowing this to be the target of a <code class="literal">property-ref</code>, you can make the association multiplicity one-to-one. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/10.png" alt="10" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">not-null</code> (optional): enables the DDL generation of a nullability constraint for the foreign key columns. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/11.png" alt="11" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">true</code>): specifies that updates to this property do or do not require acquisition of the optimistic lock. In other words, it determines if a version increment should occur when this property is dirty. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/12.png" alt="12" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional - defaults to <code class="literal">proxy</code>): by default, single point associations are proxied. <code class="literal">lazy="no-proxy"</code> specifies that the property should be fetched lazily when the instance variable is first accessed. This requires build-time bytecode instrumentation. <code class="literal">lazy="false"</code> specifies that the association will always be eagerly fetched. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/13.png" alt="13" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">not-found</code> (optional - defaults to <code class="literal">exception</code>): specifies how foreign keys that reference missing rows will be handled. <code class="literal">ignore</code> will treat a missing row as a null association. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/14.png" alt="14" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">entity-name</code> (optional): the entity name of the associated class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/15.png" alt="15" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">formula</code> (オプション): <span class="emphasis"><em> 計算された</em></span> 外部キーに対して値を定義するSQL式 </p></td></tr></table></div></div><p>Setting a value of the <code class="literal">cascade</code> attribute to any meaningful value other than <code class="literal">none</code> will propagate certain operations to the associated object. The meaningful values are divided into three categories. First, basic operations, which include: <code class="literal">persist, merge, delete, save-update, evict, replicate, lock and refresh</code>; second, special values: <code class="literal">delete-orphan</code>; and third,<code class="literal">all</code> comma-separated combinations of operation names: <code class="literal">cascade="persist,merge,evict"</code> or <code class="literal">cascade="all,delete-orphan"</code>. See <a href="#objectstate-transitive" title="10.11. 連鎖的な永続化">項10.11. 「連鎖的な永続化」</a> for a full explanation. Note that single valued, many-to-one and one-to-one, associations do not support orphan delete. </p><p>Here is an example of a typical <code class="literal">many-to-one</code> declaration: </p><pre class="programlisting">&lt;many-to-one name="product" class="Product" column="PRODUCT_ID"/&gt;</pre><p>The <code class="literal">property-ref</code> attribute should only be used for mapping legacy data where a foreign key refers to a unique key of the associated table other than the primary key. This is a complicated and confusing relational model. For example, if the <code class="literal">Product</code> class had a unique serial number that is not the primary key. The <code class="literal">unique</code> attribute controls Hibernate's DDL generation with the SchemaExport tool. </p><pre class="programlisting">&lt;property name="serialNumber" unique="true" type="string" column="SERIAL_NUMBER"/&gt;</pre><p>以下のように <code class="literal">OrderItem</code> に対してマッピングを使えます： </p><pre class="programlisting">&lt;many-to-one name="product" property-ref="serialNumber" column="PRODUCT_SERIAL_NUMBER"/&gt;</pre><p>This is not encouraged, however. </p><p>参照したユニークキーが、関連するエンティティの多数のプロパティから構成される場合、 指定した <code class="literal">&lt;properties&gt;</code> 要素内で、参照するプロパティをマッピングするべきです。 </p><p>If the referenced unique key is the property of a component, you can specify a property path: </p><pre class="programlisting">&lt;many-to-one name="owner" property-ref="identity.ssn" column="OWNER_SSN"/&gt;</pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-onetoone"/>5.1.13. One-to-one</h3></div></div></div><p>他の永続クラスへの一対一関連は、<code class="literal">one-to-one</code> 要素で定義します。 </p><div class="programlistingco"><pre class="programlisting">&lt;one-to-one
        name="propertyName"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        class="ClassName"                                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        cascade="cascade_style"                                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        constrained="true|false"                                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        fetch="join|select"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        property-ref="propertyNameFromAssociatedClass"               <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        access="field|property|ClassName"                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        formula="any SQL expression"                                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
        lazy="proxy|no-proxy|false"                                  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/9.png" alt="(9)"/></span>
        entity-name="EntityName"                                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/10.png" alt="(10)"/></span>
        node="element-name|@attribute-name|element/@attribute|."
        embed-xml="true|false"
        foreign-key="foreign_key_name"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the name of the property. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">class</code> (optional - defaults to the property type determined by reflection): the name of the associated class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">cascade</code> (optional): specifies which operations should be cascaded from the parent object to the associated object. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">constrained</code> (optional): specifies that a foreign key constraint on the primary key of the mapped table and references the table of the associated class. This option affects the order in which <code class="literal">save()</code> and <code class="literal">delete()</code> are cascaded, and determines whether the association can be proxied. It is also used by the schema export tool. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">fetch</code> (optional - defaults to <code class="literal">select</code>): chooses between outer-join fetching or sequential select fetching. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">property-ref</code> (optional): the name of a property of the associated class that is joined to the primary key of this class. If not specified, the primary key of the associated class is used. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">formula</code> (optional): almost all one-to-one associations map to the primary key of the owning entity. If this is not the case, you can specify another column, columns or expression to join on using an SQL formula. See <code class="literal">org.hibernate.test.onetooneformula</code> for an example. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/9.png" alt="9" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional - defaults to <code class="literal">proxy</code>): by default, single point associations are proxied. <code class="literal">lazy="no-proxy"</code> specifies that the property should be fetched lazily when the instance variable is first accessed. It requires build-time bytecode instrumentation. <code class="literal">lazy="false"</code> specifies that the association will always be eagerly fetched. <span class="emphasis"><em>Note that if <code class="literal">constrained="false"</code>, proxying is impossible and Hibernate will eagerly fetch the association</em></span>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/10.png" alt="10" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">entity-name</code> (optional): the entity name of the associated class. </p></td></tr></table></div></div><p>There are two varieties of one-to-one associations: </p><div class="itemizedlist"><ul><li><p>主キー関連 </p></li><li><p>ユニーク外部キー関連 </p></li></ul></div><p>Primary key associations do not need an extra table column. If two rows are related by the association, then the two table rows share the same primary key value. To relate two objects by a primary key association, ensure that they are assigned the same identifier value. </p><p>For a primary key association, add the following mappings to <code class="literal">Employee</code> and <code class="literal">Person</code> respectively: </p><pre class="programlisting">&lt;one-to-one name="person" class="Person"/&gt;</pre><pre class="programlisting">&lt;one-to-one name="employee" class="Employee" constrained="true"/&gt;</pre><p>Ensure that the primary keys of the related rows in the PERSON and EMPLOYEE tables are equal. You use a special Hibernate identifier generation strategy called <code class="literal">foreign</code>: </p><pre class="programlisting">&lt;class name="person" table="PERSON"&gt;
    &lt;id name="id" column="PERSON_ID"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"&gt;employee&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    ...
    &lt;one-to-one name="employee"
        class="Employee"
        constrained="true"/&gt;
&lt;/class&gt;</pre><p>A newly saved instance of <code class="literal">Person</code> is assigned the same primary key value as the <code class="literal">Employee</code> instance referred with the <code class="literal">employee</code> property of that <code class="literal">Person</code>. </p><p>Alternatively, a foreign key with a unique constraint, from <code class="literal">Employee</code> to <code class="literal">Person</code>, can be expressed as: </p><pre class="programlisting">&lt;many-to-one name="person" class="Person" column="PERSON_ID" unique="true"/&gt;</pre><p>This association can be made bidirectional by adding the following to the <code class="literal">Person</code> mapping: </p><pre class="programlisting">&lt;one-to-one name="employee" class="Employee" property-ref="person"/&gt;</pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-naturalid"/>5.1.14. Natural-id</h3></div></div></div><pre class="programlisting">&lt;natural-id mutable="true|false"/&gt;
        &lt;property ... /&gt;
        &lt;many-to-one ... /&gt;
        ......
&lt;/natural-id&gt;</pre><p>Although we recommend the use of surrogate keys as primary keys, you should try to identify natural keys for all entities. A natural key is a property or combination of properties that is unique and non-null. It is also immutable. Map the properties of the natural key inside the <code class="literal">&lt;natural-id&gt;</code> element. Hibernate will generate the necessary unique key and nullability constraints and, as a result, your mapping will be more self-documenting. </p><p>It is recommended that you implement <code class="literal">equals()</code> and <code class="literal">hashCode()</code> to compare the natural key properties of the entity. </p><p>This mapping is not intended for use with entities that have natural primary keys. </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">mutable</code> (optional - defaults to <code class="literal">false</code>): by default, natural identifier properties are assumed to be immutable (constant). </p></li></ul></div></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-component"/>5.1.15. Component and dynamic-component</h3></div></div></div><p>The <code class="literal">&lt;component&gt;</code> element maps properties of a child object to columns of the table of a parent class. Components can, in turn, declare their own properties, components or collections. See the "Component" examples below: </p><div class="programlistingco"><pre class="programlisting">&lt;component
        name="propertyName"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        class="className"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        insert="true|false"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        update="true|false"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        access="field|property|ClassName"   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        lazy="true|false"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        optimistic-lock="true|false"        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        unique="true|false"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
        node="element-name|."
&gt;

        &lt;property ...../&gt;
        &lt;many-to-one .... /&gt;
        ........
&lt;/component&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the name of the property. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">class</code> (optional - defaults to the property type determined by reflection): the name of the component (child) class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">insert</code>: do the mapped columns appear in SQL <code class="literal">INSERTs</code>? </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">update</code>: do the mapped columns appear in SQL <code class="literal">UPDATEs</code>? </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional - defaults to <code class="literal">false</code>): specifies that this component should be fetched lazily when the instance variable is first accessed. It requires build-time bytecode instrumentation. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">true</code>): specifies that updates to this component either do or do not require acquisition of the optimistic lock. It determines if a version increment should occur when this property is dirty. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unique</code> (optional - defaults to <code class="literal">false</code>): specifies that a unique constraint exists upon all mapped columns of the component. </p></td></tr></table></div></div><p>子の <code class="literal">&lt;property&gt;</code> タグで、 子のクラスのプロパティをテーブルカラムにマッピングします。 </p><p><code class="literal">&lt;component&gt;</code> 要素は、親エンティティへ戻る参照として、 コンポーネントのクラスのプロパティをマッピングする <code class="literal">&lt;parent&gt;</code> サブ要素を許可します。 </p><p>The <code class="literal">&lt;dynamic-component&gt;</code> element allows a <code class="literal">Map</code> to be mapped as a component, where the property names refer to keys of the map. See <a href="#components-dynamic" title="8.5. 動的コンポーネント">項8.5. 「動的コンポーネント」</a> for more information. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-properties"/>5.1.16. Properties</h3></div></div></div><p>The <code class="literal">&lt;properties&gt;</code> element allows the definition of a named, logical grouping of the properties of a class. The most important use of the construct is that it allows a combination of properties to be the target of a <code class="literal">property-ref</code>. It is also a convenient way to define a multi-column unique constraint. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;properties
        name="logicalName"                  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        insert="true|false"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        update="true|false"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        optimistic-lock="true|false"        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        unique="true|false"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
&gt;

        &lt;property ...../&gt;
        &lt;many-to-one .... /&gt;
        ........
&lt;/properties&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the logical name of the grouping. It is <span class="emphasis"><em>not</em></span> an actual property name. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">insert</code>: do the mapped columns appear in SQL <code class="literal">INSERTs</code>? </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">update</code>: do the mapped columns appear in SQL <code class="literal">UPDATEs</code>? </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">true</code>): specifies that updates to these properties either do or do not require acquisition of the optimistic lock. It determines if a version increment should occur when these properties are dirty. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unique</code> (optional - defaults to <code class="literal">false</code>): specifies that a unique constraint exists upon all mapped columns of the component. </p></td></tr></table></div></div><p>例えば、もし以下のような <code class="literal">&lt;properties&gt;</code> マッピングがあった場合： </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="personNumber"/&gt;

    ...
    &lt;properties name="name"
            unique="true" update="false"&gt;
        &lt;property name="firstName"/&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="lastName"/&gt;
    &lt;/properties&gt;
&lt;/class&gt;</pre><p>You might have some legacy data association that refers to this unique key of the <code class="literal">Person</code> table, instead of to the primary key: </p><pre class="programlisting">&lt;many-to-one name="person"
         class="Person" property-ref="name"&gt;
    &lt;column name="firstName"/&gt;
    &lt;column name="initial"/&gt;
    &lt;column name="lastName"/&gt;
&lt;/many-to-one&gt;</pre><p>The use of this outside the context of mapping legacy data is not recommended. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-subclass"/>5.1.17. Subclass</h3></div></div></div><p>Polymorphic persistence requires the declaration of each subclass of the root persistent class. For the table-per-class-hierarchy mapping strategy, the <code class="literal">&lt;subclass&gt;</code> declaration is used. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;subclass
        name="ClassName"                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        discriminator-value="discriminator_value"     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        proxy="ProxyInterface"                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        lazy="true|false"                             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        dynamic-update="true|false"
        dynamic-insert="true|false"
        entity-name="EntityName"
        node="element-name"
        extends="SuperclassName"&gt;

        &lt;property .... /&gt;
        .....
&lt;/subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the fully qualified class name of the subclass. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">discriminator-value</code> (optional - defaults to the class name): a value that distinguishes individual subclasses. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">proxy</code> (optional): specifies a class or interface used for lazy initializing proxies. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional - defaults to <code class="literal">true</code>): setting <code class="literal">lazy="false"</code> disables the use of lazy fetching. </p></td></tr></table></div></div><p>Each subclass declares its own persistent properties and subclasses. <code class="literal">&lt;version&gt;</code> and <code class="literal">&lt;id&gt;</code> properties are assumed to be inherited from the root class. Each subclass in a hierarchy must define a unique <code class="literal">discriminator-value</code>. If this is not specified, the fully qualified Java class name is used. </p><p>For information about inheritance mappings see <a href="#inheritance" title="第9章 Inheritance mapping">章 9. <i xmlns:xlink="http://www.w3.org/1999/xlink">Inheritance mapping</i></a>. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-joinedsubclass"/>5.1.18. Joined-subclass</h3></div></div></div><p>Each subclass can also be mapped to its own table. This is called the table-per-subclass mapping strategy. An inherited state is retrieved by joining with the table of the superclass. To do this you use the <code class="literal">&lt;joined-subclass&gt;</code> element. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;joined-subclass
        name="ClassName"                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        table="tablename"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        proxy="ProxyInterface"              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        lazy="true|false"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        dynamic-update="true|false"
        dynamic-insert="true|false"
        schema="schema"
        catalog="catalog"
        extends="SuperclassName"
        persister="ClassName"
        subselect="SQL expression"
        entity-name="EntityName"
        node="element-name"&gt;

        &lt;key .... &gt;

        &lt;property .... /&gt;
        .....
&lt;/joined-subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the fully qualified class name of the subclass. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">table</code>: the name of the subclass table. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">proxy</code> (optional): specifies a class or interface to use for lazy initializing proxies. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional, defaults to <code class="literal">true</code>): setting <code class="literal">lazy="false"</code> disables the use of lazy fetching. </p></td></tr></table></div></div><p>A discriminator column is not required for this mapping strategy. Each subclass must, however, declare a table column holding the object identifier using the <code class="literal">&lt;key&gt;</code> element. The mapping at the start of the chapter would then be re-written as: </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

        &lt;class name="Cat" table="CATS"&gt;
                &lt;id name="id" column="uid" type="long"&gt;
                        &lt;generator class="hilo"/&gt;
                &lt;/id&gt;
                &lt;property name="birthdate" type="date"/&gt;
                &lt;property name="color" not-null="true"/&gt;
                &lt;property name="sex" not-null="true"/&gt;
                &lt;property name="weight"/&gt;
                &lt;many-to-one name="mate"/&gt;
                &lt;set name="kittens"&gt;
                        &lt;key column="MOTHER"/&gt;
                        &lt;one-to-many class="Cat"/&gt;
                &lt;/set&gt;
                &lt;joined-subclass name="DomesticCat" table="DOMESTIC_CATS"&gt;
                    &lt;key column="CAT"/&gt;
                    &lt;property name="name" type="string"/&gt;
                &lt;/joined-subclass&gt;
        &lt;/class&gt;

        &lt;class name="eg.Dog"&gt;
                &lt;!-- mapping for Dog could go here --&gt;
        &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>For information about inheritance mappings see <a href="#inheritance" title="第9章 Inheritance mapping">章 9. <i xmlns:xlink="http://www.w3.org/1999/xlink">Inheritance mapping</i></a>. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-unionsubclass"/>5.1.19. Union-subclass</h3></div></div></div><p>A third option is to map only the concrete classes of an inheritance hierarchy to tables. This is called the table-per-concrete-class strategy. Each table defines all persistent states of the class, including the inherited state. In Hibernate, it is not necessary to explicitly map such inheritance hierarchies. You can map each class with a separate <code class="literal">&lt;class&gt;</code> declaration. However, if you wish use polymorphic associations (e.g. an association to the superclass of your hierarchy), you need to use the <code class="literal">&lt;union-subclass&gt;</code> mapping. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;union-subclass
        name="ClassName"                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        table="tablename"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        proxy="ProxyInterface"              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        lazy="true|false"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        dynamic-update="true|false"
        dynamic-insert="true|false"
        schema="schema"
        catalog="catalog"
        extends="SuperclassName"
        abstract="true|false"
        persister="ClassName"
        subselect="SQL expression"
        entity-name="EntityName"
        node="element-name"&gt;

        &lt;property .... /&gt;
        .....
&lt;/union-subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the fully qualified class name of the subclass. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">table</code>: the name of the subclass table. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">proxy</code> (optional): specifies a class or interface to use for lazy initializing proxies. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional, defaults to <code class="literal">true</code>): setting <code class="literal">lazy="false"</code> disables the use of lazy fetching. </p></td></tr></table></div></div><p>このマッピング戦略では識別カラムやキーカラムは必要ありません。 </p><p>For information about inheritance mappings see <a href="#inheritance" title="第9章 Inheritance mapping">章 9. <i xmlns:xlink="http://www.w3.org/1999/xlink">Inheritance mapping</i></a>. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-join"/>5.1.20. Join</h3></div></div></div><p>Using the <code class="literal">&lt;join&gt;</code> element, it is possible to map properties of one class to several tables that have a one-to-one relationship. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;join
        table="tablename"                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        schema="owner"                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        catalog="catalog"                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        fetch="join|select"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        inverse="true|false"                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        optional="true|false"&gt;                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>

        &lt;key ... /&gt;

        &lt;property ... /&gt;
        ...
&lt;/join&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">table</code>: the name of the joined table. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">schema</code> (optional): overrides the schema name specified by the root <code class="literal">&lt;hibernate-mapping&gt;</code> element. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">catalog</code> (optional): overrides the catalog name specified by the root <code class="literal">&lt;hibernate-mapping&gt;</code> element. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">fetch</code> (optional - defaults to <code class="literal">join</code>): if set to <code class="literal">join</code>, the default, Hibernate will use an inner join to retrieve a <code class="literal">&lt;join&gt;</code> defined by a class or its superclasses. It will use an outer join for a <code class="literal">&lt;join&gt;</code> defined by a subclass. If set to <code class="literal">select</code> then Hibernate will use a sequential select for a <code class="literal">&lt;join&gt;</code> defined on a subclass. This will be issued only if a row represents an instance of the subclass. Inner joins will still be used to retrieve a <code class="literal">&lt;join&gt;</code> defined by the class and its superclasses. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">inverse</code> (optional - defaults to <code class="literal">false</code>): if enabled, Hibernate will not insert or update the properties defined by this join. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optional</code> (optional - defaults to <code class="literal">false</code>): if enabled, Hibernate will insert a row only if the properties defined by this join are non-null. It will always use an outer join to retrieve the properties. </p></td></tr></table></div></div><p>For example, address information for a person can be mapped to a separate table while preserving value type semantics for all properties: </p><pre class="programlisting">&lt;class name="Person"
    table="PERSON"&gt;

    &lt;id name="id" column="PERSON_ID"&gt;...&lt;/id&gt;

    &lt;join table="ADDRESS"&gt;
        &lt;key column="ADDRESS_ID"/&gt;
        &lt;property name="address"/&gt;
        &lt;property name="zip"/&gt;
        &lt;property name="country"/&gt;
    &lt;/join&gt;
    ...</pre><p>This feature is often only useful for legacy data models. We recommend fewer tables than classes and a fine-grained domain model. However, it is useful for switching between inheritance mapping strategies in a single hierarchy, as explained later. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-key"/>5.1.21. Key</h3></div></div></div><p>The <code class="literal">&lt;key&gt;</code> element has featured a few times within this guide. It appears anywhere the parent mapping element defines a join to a new table that references the primary key of the original table. It also defines the foreign key in the joined table: </p><div class="programlistingco"><pre class="programlisting">&lt;key
        column="columnname"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        on-delete="noaction|cascade"             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        property-ref="propertyName"              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        not-null="true|false"                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        update="true|false"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        unique="true|false"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional): the name of the foreign key column. This can also be specified by nested <code class="literal">&lt;column&gt;</code> element(s). </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">on-delete</code> (optional - defaults to <code class="literal">noaction</code>): specifies whether the foreign key constraint has database-level cascade delete enabled. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">property-ref</code> (optional): specifies that the foreign key refers to columns that are not the primary key of the original table. It is provided for legacy data. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">not-null</code> (optional): specifies that the foreign key columns are not nullable. This is implied whenever the foreign key is also part of the primary key. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">update</code> (optional): specifies that the foreign key should never be updated. This is implied whenever the foreign key is also part of the primary key. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unique</code> (optional): specifies that the foreign key should have a unique constraint. This is implied whenever the foreign key is also the primary key. </p></td></tr></table></div></div><p>For systems where delete performance is important, we recommend that all keys should be defined <code class="literal">on-delete="cascade"</code>. Hibernate uses a database-level <code class="literal">ON CASCADE DELETE</code> constraint, instead of many individual <code class="literal">DELETE</code> statements. Be aware that this feature bypasses Hibernate's usual optimistic locking strategy for versioned data. </p><p>The <code class="literal">not-null</code> and <code class="literal">update</code> attributes are useful when mapping a unidirectional one-to-many association. If you map a unidirectional one-to-many association to a non-nullable foreign key, you <span class="emphasis"><em>must</em></span> declare the key column using <code class="literal">&lt;key not-null="true"&gt;</code>. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-column"/>5.1.22. Column and formula elements</h3></div></div></div><p>Mapping elements which accept a <code class="literal">column</code> attribute will alternatively accept a <code class="literal">&lt;column&gt;</code> subelement. Likewise, <code class="literal">&lt;formula&gt;</code> is an alternative to the <code class="literal">formula</code> attribute. For example: </p><pre class="programlisting">&lt;column
        name="column_name"
        length="N"
        precision="N"
        scale="N"
        not-null="true|false"
        unique="true|false"
        unique-key="multicolumn_unique_key_name"
        index="index_name"
        sql-type="sql_type_name"
        check="SQL expression"
        default="SQL expression"/&gt;</pre><pre class="programlisting">&lt;formula&gt;SQL expression&lt;/formula&gt;</pre><p><code class="literal">column</code> and <code class="literal">formula</code> attributes can even be combined within the same property or association mapping to express, for example, exotic join conditions. </p><pre class="programlisting">&lt;many-to-one name="homeAddress" class="Address"
        insert="false" update="false"&gt;
    &lt;column name="person_id" not-null="true" length="10"/&gt;
    &lt;formula&gt;'MAILING'&lt;/formula&gt;
&lt;/many-to-one&gt;</pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-import"/>5.1.23. Import</h3></div></div></div><p>If your application has two persistent classes with the same name, and you do not want to specify the fully qualified package name in Hibernate queries, classes can be "imported" explicitly, rather than relying upon <code class="literal">auto-import="true"</code>. You can also import classes and interfaces that are not explicitly mapped: </p><pre class="programlisting">&lt;import class="java.lang.Object" rename="Universe"/&gt;</pre><div class="programlistingco"><pre class="programlisting">&lt;import
        class="ClassName"              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        rename="ShortName"             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">class</code>: the fully qualified class name of any Java class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">rename</code> (optional - defaults to the unqualified class name): a name that can be used in the query language. </p></td></tr></table></div></div></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-types-anymapping"/>5.1.24. Any</h3></div></div></div><p>There is one more type of property mapping. The <code class="literal">&lt;any&gt;</code> mapping element defines a polymorphic association to classes from multiple tables. This type of mapping requires more than one column. The first column contains the type of the associated entity. The remaining columns contain the identifier. It is impossible to specify a foreign key constraint for this kind of association. This is not the usual way of mapping polymorphic associations and you should use this only in special cases. For example, for audit logs, user session data, etc. </p><p>The <code class="literal">meta-type</code> attribute allows the application to specify a custom type that maps database column values to persistent classes that have identifier properties of the type specified by <code class="literal">id-type</code>. You must specify the mapping from values of the meta-type to class names. </p><pre class="programlisting">&lt;any name="being" id-type="long" meta-type="string"&gt;
    &lt;meta-value value="TBL_ANIMAL" class="Animal"/&gt;
    &lt;meta-value value="TBL_HUMAN" class="Human"/&gt;
    &lt;meta-value value="TBL_ALIEN" class="Alien"/&gt;
    &lt;column name="table_name"/&gt;
    &lt;column name="id"/&gt;
&lt;/any&gt;</pre><div class="programlistingco"><pre class="programlisting">&lt;any
        name="propertyName"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        id-type="idtypename"                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        meta-type="metatypename"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        cascade="cascade_style"                  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        access="field|property|ClassName"        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        optimistic-lock="true|false"             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
&gt;
        &lt;meta-value ... /&gt;
        &lt;meta-value ... /&gt;
        .....
        &lt;column .... /&gt;
        &lt;column .... /&gt;
        .....
&lt;/any&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>：プロパティ名。 </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">id-type</code>：識別子の型。 </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">meta-type</code> (optional - defaults to <code class="literal">string</code>): any type that is allowed for a discriminator mapping. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">cascade</code>（オプション - デフォルトは <code class="literal">none</code> ）： カスケードのスタイル。 </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">true</code>): specifies that updates to this property either do or do not require acquisition of the optimistic lock. It defines whether a version increment should occur if this property is dirty. </p></td></tr></table></div></div></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-types"/>5.2. Hibernate types</h2></div></div></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-types-entitiesvalues"/>5.2.1. エンティティと値</h3></div></div></div><p>In relation to the persistence service, Java language-level objects are classified into two groups: </p><p>An <span class="emphasis"><em>entity</em></span> exists independently of any other objects holding references to the entity. Contrast this with the usual Java model, where an unreferenced object is garbage collected. Entities must be explicitly saved and deleted. Saves and deletions, however, can be <span class="emphasis"><em>cascaded</em></span> from a parent entity to its children. This is different from the ODMG model of object persistence by reachability and corresponds more closely to how application objects are usually used in large systems. Entities support circular and shared references. They can also be versioned. </p><p>An entity's persistent state consists of references to other entities and instances of <span class="emphasis"><em>value</em></span> types. Values are primitives: collections (not what is inside a collection), components and certain immutable objects. Unlike entities, values in particular collections and components, <span class="emphasis"><em>are</em></span> persisted and deleted by reachability. Since value objects and primitives are persisted and deleted along with their containing entity, they cannot be independently versioned. Values have no independent identity, so they cannot be shared by two entities or collections. </p><p>Until now, we have been using the term "persistent class" to refer to entities. We will continue to do that. Not all user-defined classes with a persistent state, however, are entities. A <span class="emphasis"><em>component</em></span> is a user-defined class with value semantics. A Java property of type <code class="literal">java.lang.String</code> also has value semantics. Given this definition, all types (classes) provided by the JDK have value type semantics in Java, while user-defined types can be mapped with entity or value type semantics. This decision is up to the application developer. An entity class in a domain model will normally have shared references to a single instance of that class, while composition or aggregation usually translates to a value type. </p><p>We will revisit both concepts throughout this reference guide. </p><p>The challenge is to map the Java type system, and the developers' definition of entities and value types, to the SQL/database type system. The bridge between both systems is provided by Hibernate. For entities, <code class="literal">&lt;class&gt;</code>, <code class="literal">&lt;subclass&gt;</code> and so on are used. For value types we use <code class="literal">&lt;property&gt;</code>, <code class="literal">&lt;component&gt;</code>etc., that usually have a <code class="literal">type</code> attribute. The value of this attribute is the name of a Hibernate <span class="emphasis"><em>mapping type</em></span>. Hibernate provides a range of mappings for standard JDK value types out of the box. You can write your own mapping types and implement your own custom conversion strategies. </p><p>With the exception of collections, all built-in Hibernate types support null semantics. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-types-basictypes"/>5.2.2. 基本的な型</h3></div></div></div><p>The built-in <span class="emphasis"><em>basic mapping types</em></span> can be roughly categorized into the following: </p><div class="variablelist"><dl><dt><span class="term"><code class="literal">integer, long, short, float, double, character, byte, boolean, yes_no, true_false</code></span></dt><dd><p>Javaのプリミティブやラッパークラスから適切な（ベンダー固有の） SQLカラム型への型マッピング。 <code class="literal">boolean, yes_no</code> と <code class="literal">true_false</code> は、 すべてJavaの <code class="literal">boolean</code> または <code class="literal">java.lang.Boolean</code> の代替エンコードです。 </p></dd><dt><span class="term"><code class="literal">string</code></span></dt><dd><p><code class="literal">java.lang.String</code> から <code class="literal">VARCHAR</code> （またはOracleの <code class="literal">VARCHAR2</code> ）への型マッピング。 </p></dd><dt><span class="term"><code class="literal">date, time, timestamp</code></span></dt><dd><p><code class="literal">java.util.Date</code> とそのサブクラスからSQL型の <code class="literal">DATE</code>, <code class="literal">TIME</code> , <code class="literal">TIMESTAMP</code> （またはそれらと等価なもの） への型マッピング。 </p></dd><dt><span class="term"><code class="literal">calendar, calendar_date</code></span></dt><dd><p><code class="literal">java.util.Calendar</code> からSQL型 の「 <code class="literal">TIMESTAMP</code> , <code class="literal">DATE</code> (またはそれらと等価なもの）への型マッピング。 </p></dd><dt><span class="term"><code class="literal">big_decimal, big_integer</code></span></dt><dd><p><code class="literal">java.math.BigDecimal</code> と <code class="literal">java.math.BigInteger</code> から <code class="literal">NUMERIC</code>（またはOracleの <code class="literal">NUMBER</code> ）への型マッピング。 </p></dd><dt><span class="term"><code class="literal">locale, timezone, currency</code></span></dt><dd><p><code class="literal">java.util.Locale</code> , <code class="literal">java.util.TimeZone</code> , <code class="literal">java.util.Currency</code> から <code class="literal">VARCHAR</code> （またはOracleの <code class="literal">VARCHAR2</code> ）への型マッピング。 <code class="literal">Locale</code> と <code class="literal">Currency</code> のインスタンスは、 それらのISOコードにマッピングされます。 <code class="literal">TimeZone</code> のインスタンスは、 それらの <code class="literal">ID</code> にマッピングされます。 </p></dd><dt><span class="term"><code class="literal">class</code></span></dt><dd><p><code class="literal">java.lang.Class</code> から <code class="literal">VARCHAR</code> （またはOracleの <code class="literal">VARCHAR2</code> ）への型マッピング。 <code class="literal">Class</code> はその完全修飾された名前にマッピングされます。 </p></dd><dt><span class="term"><code class="literal">binary</code></span></dt><dd><p>バイト配列は、適切なSQLのバイナリ型にマッピングされます。 </p></dd><dt><span class="term"><code class="literal">text</code></span></dt><dd><p>長いJava文字列は、SQLの <code class="literal">CLOB</code> または <code class="literal">TEXT</code> 型にマッピングされます。 </p></dd><dt><span class="term"><code class="literal">serializable</code></span></dt><dd><p>Maps serializable Java types to an appropriate SQL binary type. You can also indicate the Hibernate type <code class="literal">serializable</code> with the name of a serializable Java class or interface that does not default to a basic type. </p></dd><dt><span class="term"><code class="literal">clob, blob</code></span></dt><dd><p>Type mappings for the JDBC classes <code class="literal">java.sql.Clob</code> and <code class="literal">java.sql.Blob</code>. These types can be inconvenient for some applications, since the blob or clob object cannot be reused outside of a transaction. Driver support is patchy and inconsistent. </p></dd><dt><span class="term">
                            <code class="literal">imm_date, imm_time, imm_timestamp, imm_calendar, imm_calendar_date, imm_serializable, imm_binary</code>
                        </span></dt><dd><p>Type mappings for what are considered mutable Java types. This is where Hibernate makes certain optimizations appropriate only for immutable Java types, and the application treats the object as immutable. For example, you should not call <code class="literal">Date.setTime()</code> for an instance mapped as <code class="literal">imm_timestamp</code>. To change the value of the property, and have that change made persistent, the application must assign a new, nonidentical, object to the property. </p></dd></dl></div><p>

            </p><p>Unique identifiers of entities and collections can be of any basic type except <code class="literal">binary</code>, <code class="literal">blob</code> and <code class="literal">clob</code>. Composite identifiers are also allowed. See below for more information. </p><p>基本的な値型には、<code class="literal">org.hibernate.Hibernate</code> で定義された <code class="literal">Type</code> 定数がそれぞれあります。 例えば、<code class="literal">Hibernate.STRING</code> は <code class="literal">string</code> 型を表現しています。 </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-types-custom"/>5.2.3. カスタム型</h3></div></div></div><p>It is relatively easy for developers to create their own value types. For example, you might want to persist properties of type <code class="literal">java.lang.BigInteger</code> to <code class="literal">VARCHAR</code> columns. Hibernate does not provide a built-in type for this. Custom types are not limited to mapping a property, or collection element, to a single table column. So, for example, you might have a Java property <code class="literal">getName()</code>/<code class="literal">setName()</code> of type <code class="literal">java.lang.String</code> that is persisted to the columns <code class="literal">FIRST_NAME</code>, <code class="literal">INITIAL</code>, <code class="literal">SURNAME</code>. </p><p>To implement a custom type, implement either <code class="literal">org.hibernate.UserType</code> or <code class="literal">org.hibernate.CompositeUserType</code> and declare properties using the fully qualified classname of the type. View <code class="literal">org.hibernate.test.DoubleStringType</code> to see the kind of things that are possible. </p><pre class="programlisting">&lt;property name="twoStrings" type="org.hibernate.test.DoubleStringType"&gt;
    &lt;column name="first_string"/&gt;
    &lt;column name="second_string"/&gt;
&lt;/property&gt;</pre><p><code class="literal">&lt;column&gt;</code> タグで、 プロパティを複数のカラムへマッピングできることに注目してください。 </p><p><code class="literal">CompositeUserType</code> , <code class="literal">EnhancedUserType</code> , <code class="literal">UserCollectionType</code> , <code class="literal">UserVersionType</code> インターフェイスは、より特殊な使用法に対してのサポートを提供します。 </p><p>You can even supply parameters to a <code class="literal">UserType</code> in the mapping file. To do this, your <code class="literal">UserType</code> must implement the <code class="literal">org.hibernate.usertype.ParameterizedType</code> interface. To supply parameters to your custom type, you can use the <code class="literal">&lt;type&gt;</code> element in your mapping files. </p><pre class="programlisting">&lt;property name="priority"&gt;
    &lt;type name="com.mycompany.usertypes.DefaultValueIntegerType"&gt;
        &lt;param name="default"&gt;0&lt;/param&gt;
    &lt;/type&gt;
&lt;/property&gt;</pre><p><code class="literal">UserType</code> は、 引数として渡された <code class="literal">Properties</code> オブジェクトから、 <code class="literal">default</code> で指定したパラメータに対する値を検索することができます。 </p><p>If you regularly use a certain <code class="literal">UserType</code>, it is useful to define a shorter name for it. You can do this using the <code class="literal">&lt;typedef&gt;</code> element. Typedefs assign a name to a custom type, and can also contain a list of default parameter values if the type is parameterized. </p><pre class="programlisting">&lt;typedef class="com.mycompany.usertypes.DefaultValueIntegerType" name="default_zero"&gt;
    &lt;param name="default"&gt;0&lt;/param&gt;
&lt;/typedef&gt;</pre><pre class="programlisting">&lt;property name="priority" type="default_zero"/&gt;</pre><p>プロパティのマッピングで型パラメータを使うことで、 typedefで提供されたパラメータをその都度オーバーライドすることが可能です。 </p><p>Even though Hibernate's rich range of built-in types and support for components means you will rarely need to use a custom type, it is considered good practice to use custom types for non-entity classes that occur frequently in your application. For example, a <code class="literal">MonetaryAmount</code> class is a good candidate for a <code class="literal">CompositeUserType</code>, even though it could be mapped as a component. One reason for this is abstraction. With a custom type, your mapping documents would be protected against changes to the way monetary values are represented. </p></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-entityname"/>5.3. １つのクラスに１つ以上のマッピング</h2></div></div></div><p>It is possible to provide more than one mapping for a particular persistent class. In this case, you must specify an <span class="emphasis"><em>entity name</em></span> to disambiguate between instances of the two mapped entities. By default, the entity name is the same as the class name. Hibernate lets you specify the entity name when working with persistent objects, when writing queries, or when mapping associations to the named entity. </p><pre class="programlisting">&lt;class name="Contract" table="Contracts"
        entity-name="CurrentContract"&gt;
    ...
    &lt;set name="history" inverse="true"
            order-by="effectiveEndDate desc"&gt;
        &lt;key column="currentContractId"/&gt;
        &lt;one-to-many entity-name="HistoricalContract"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Contract" table="ContractHistory"
        entity-name="HistoricalContract"&gt;
    ...
    &lt;many-to-one name="currentContract"
            column="currentContractId"
            entity-name="CurrentContract"/&gt;
&lt;/class&gt;</pre><p>Associations are now specified using <code class="literal">entity-name</code> instead of <code class="literal">class</code>. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-quotedidentifiers"/>5.4. バッククォートで囲んだ SQL 識別子</h2></div></div></div><p>You can force Hibernate to quote an identifier in the generated SQL by enclosing the table or column name in backticks in the mapping document. Hibernate will use the correct quotation style for the SQL <code class="literal">Dialect</code>. This is usually double quotes, but the SQL Server uses brackets and MySQL uses backticks. </p><pre class="programlisting">&lt;class name="LineItem" table="`Line Item`"&gt;
    &lt;id name="id" column="`Item Id`"/&gt;&lt;generator class="assigned"/&gt;&lt;/id&gt;
    &lt;property name="itemNumber" column="`Item #`"/&gt;
    ...
&lt;/class&gt;</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-alternatives"/>5.5. メタデータの代替手段</h2></div></div></div><p>XML does not suit all users so there are some alternative ways to define O/R mapping metadata in Hibernate. </p><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-xdoclet"/>5.5.1. XDoclet マークアップの使用</h3></div></div></div><p>Many Hibernate users prefer to embed mapping information directly in sourcecode using XDoclet <code class="literal">@hibernate.tags</code>. We do not cover this approach in this reference guide since it is considered part of XDoclet. However, we include the following example of the <code class="literal">Cat</code> class with XDoclet mappings: </p><pre class="programlisting">package eg;
import java.util.Set;
import java.util.Date;

/**
 * @hibernate.class
 *  table="CATS"
 */
public class Cat {
    private Long id; // identifier
    private Date birthdate;
    private Cat mother;
    private Set kittens
    private Color color;
    private char sex;
    private float weight;

    /*
     * @hibernate.id
     *  generator-class="native"
     *  column="CAT_ID"
     */
    public Long getId() {
        return id;
    }
    private void setId(Long id) {
        this.id=id;
    }

    /**
     * @hibernate.many-to-one
     *  column="PARENT_ID"
     */
    public Cat getMother() {
        return mother;
    }
    void setMother(Cat mother) {
        this.mother = mother;
    }

    /**
     * @hibernate.property
     *  column="BIRTH_DATE"
     */
    public Date getBirthdate() {
        return birthdate;
    }
    void setBirthdate(Date date) {
        birthdate = date;
    }
    /**
     * @hibernate.property
     *  column="WEIGHT"
     */
    public float getWeight() {
        return weight;
    }
    void setWeight(float weight) {
        this.weight = weight;
    }

    /**
     * @hibernate.property
     *  column="COLOR"
     *  not-null="true"
     */
    public Color getColor() {
        return color;
    }
    void setColor(Color color) {
        this.color = color;
    }
    /**
     * @hibernate.set
     *  inverse="true"
     *  order-by="BIRTH_DATE"
     * @hibernate.collection-key
     *  column="PARENT_ID"
     * @hibernate.collection-one-to-many
     */
    public Set getKittens() {
        return kittens;
    }
    void setKittens(Set kittens) {
        this.kittens = kittens;
    }
    // addKitten not needed by Hibernate
    public void addKitten(Cat kitten) {
        kittens.add(kitten);
    }

    /**
     * @hibernate.property
     *  column="SEX"
     *  not-null="true"
     *  update="false"
     */
    public char getSex() {
        return sex;
    }
    void setSex(char sex) {
        this.sex=sex;
    }
}</pre><p>See the Hibernate website for more examples of XDoclet and Hibernate. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-annotations"/>5.5.2. JDK 5.0 アノテーションの使用</h3></div></div></div><p>JDK 5.0 introduced XDoclet-style annotations at the language level that are type-safe and checked at compile time. This mechanism is more powerful than XDoclet annotations and better supported by tools and IDEs. IntelliJ IDEA, for example, supports auto-completion and syntax highlighting of JDK 5.0 annotations. The new revision of the EJB specification (JSR-220) uses JDK 5.0 annotations as the primary metadata mechanism for entity beans. Hibernate3 implements the <code class="literal">EntityManager</code> of JSR-220 (the persistence API). Support for mapping metadata is available via the <span class="emphasis"><em>Hibernate Annotations</em></span> package as a separate download. Both EJB3 (JSR-220) and Hibernate3 metadata is supported. </p><p>以下はEJBのエンティティビーンとして注釈されたPOJOクラスの例です。 </p><pre class="programlisting">@Entity(access = AccessType.FIELD)
public class Customer implements Serializable {

    @Id;
    Long id;

    String firstName;
    String lastName;
    Date birthday;

    @Transient
    Integer age;

    @Embedded
    private Address homeAddress;

    @OneToMany(cascade=CascadeType.ALL)
    @JoinColumn(name="CUSTOMER_ID")
    Set&lt;Order&gt; orders;

    // Getter/setter and business methods
}</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Support for JDK 5.0 Annotations (and JSR-220) is currently under development. Please refer to the Hibernate Annotations module for more details. </p></div></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-generated"/>5.6. Generated properties</h2></div></div></div><p>Generated properties are properties that have their values generated by the database. Typically, Hibernate applications needed to <code class="literal">refresh</code> objects that contain any properties for which the database was generating values. Marking properties as generated, however, lets the application delegate this responsibility to Hibernate. When Hibernate issues an SQL INSERT or UPDATE for an entity that has defined generated properties, it immediately issues a select afterwards to retrieve the generated values. </p><p>Properties marked as generated must additionally be non-insertable and non-updateable. Only <a href="#mapping-declaration-version" title="5.1.9. Version (optional)">versions</a>, <a href="#mapping-declaration-timestamp" title="5.1.10. Timestamp (optional)">timestamps</a>, and <a href="#mapping-declaration-property" title="5.1.11. Property">simple properties</a>, can be marked as generated. </p><p><code class="literal">never</code> (the default): the given property value is not generated within the database. </p><p><code class="literal">insert</code>: the given property value is generated on insert, but is not regenerated on subsequent updates. Properties like created-date fall into this category. Even though <a href="#mapping-declaration-version" title="5.1.9. Version (optional)">version</a> and <a href="#mapping-declaration-timestamp" title="5.1.10. Timestamp (optional)">timestamp</a> properties can be marked as generated, this option is not available. </p><p><code class="literal">always</code>: the property value is generated both on insert and on update. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-database-object"/>5.7. Auxiliary database objects</h2></div></div></div><p>Auxiliary database objects allow for the CREATE and DROP of arbitrary database objects. In conjunction with Hibernate's schema evolution tools, they have the ability to fully define a user schema within the Hibernate mapping files. Although designed specifically for creating and dropping things like triggers or stored procedures, any SQL command that can be run via a <code class="literal">java.sql.Statement.execute()</code> method is valid (for example, ALTERs, INSERTS, etc.). There are essentially two modes for defining auxiliary database objects: </p><p>The first mode is to explicitly list the CREATE and DROP commands in the mapping file: </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    ...
    &lt;database-object&gt;
        &lt;create&gt;CREATE TRIGGER my_trigger ...&lt;/create&gt;
        &lt;drop&gt;DROP TRIGGER my_trigger&lt;/drop&gt;
    &lt;/database-object&gt;
&lt;/hibernate-mapping&gt;</pre><p>The second mode is to supply a custom class that constructs the CREATE and DROP commands. This custom class must implement the <code class="literal">org.hibernate.mapping.AuxiliaryDatabaseObject</code> interface. </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    ...
    &lt;database-object&gt;
        &lt;definition class="MyTriggerDefinition"/&gt;
    &lt;/database-object&gt;
&lt;/hibernate-mapping&gt;</pre><p>Additionally, these database objects can be optionally scoped so that they only apply when certain dialects are used. </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    ...
    &lt;database-object&gt;
        &lt;definition class="MyTriggerDefinition"/&gt;
        &lt;dialect-scope name="org.hibernate.dialect.Oracle9iDialect"/&gt;
        &lt;dialect-scope name="org.hibernate.dialect.Oracle10gDialect"/&gt;
    &lt;/database-object&gt;
&lt;/hibernate-mapping&gt;</pre></div></div><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="collections"/>第6章 Collection mapping</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#collections-persistent">6.1. コレクションの永続化</a></span></dt><dt><span class="sect1"><a href="#collections-mapping">6.2. コレクションのマッピング</a></span></dt><dd><dl><dt><span class="sect2"><a href="#collections-foreignkeys">6.2.1. コレクションの外部キー</a></span></dt><dt><span class="sect2"><a href="#collections-elements">6.2.2. コレクションの要素</a></span></dt><dt><span class="sect2"><a href="#collections-indexed">6.2.3. インデックス付きのコレクション</a></span></dt><dt><span class="sect2"><a href="#collections-ofvalues">6.2.4. 値のコレクションと多対多関連</a></span></dt><dt><span class="sect2"><a href="#collections-onetomany">6.2.5. 一対多関連</a></span></dt></dl></dd><dt><span class="sect1"><a href="#collections-advancedmappings">6.3. 高度なコレクション･マッピング</a></span></dt><dd><dl><dt><span class="sect2"><a href="#collections-sorted">6.3.1. ソートされたコレクション</a></span></dt><dt><span class="sect2"><a href="#collections-bidirectional">6.3.2. 双方向関連</a></span></dt><dt><span class="sect2"><a href="#collections-indexedbidirectional">6.3.3. インデックス付きコレクションと双方向関連</a></span></dt><dt><span class="sect2"><a href="#collections-ternary">6.3.4. 3項関連</a></span></dt><dt><span class="sect2"><a href="#collections-idbag">6.3.5. <code class="literal"><code class="literal">&lt;idbag&gt;</code>の使用</code></a></span></dt></dl></dd><dt><span class="sect1"><a href="#collections-example">6.4. コレクションの例</a></span></dt></dl></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="collections-persistent"/>6.1. コレクションの永続化</h2></div></div></div><p>Hibernate requires that persistent collection-valued fields be declared as an interface type. For example: </p><pre class="programlisting">public class Product {
    private String serialNumber;
    private Set parts = new HashSet();
    
    public Set getParts() { return parts; }
    void setParts(Set parts) { this.parts = parts; }
    public String getSerialNumber() { return serialNumber; }
    void setSerialNumber(String sn) { serialNumber = sn; }
}</pre><p>The actual interface might be <code class="literal">java.util.Set</code>, <code class="literal">java.util.Collection</code>, <code class="literal">java.util.List</code>, <code class="literal">java.util.Map</code>, <code class="literal">java.util.SortedSet</code>, <code class="literal">java.util.SortedMap</code> or anything you like ("anything you like" means you will have to write an implementation of <code class="literal">org.hibernate.usertype.UserCollectionType</code>.) </p><p>Notice how the instance variable was initialized with an instance of <code class="literal">HashSet</code>. This is the best way to initialize collection valued properties of newly instantiated (non-persistent) instances. When you make the instance persistent, by calling <code class="literal">persist()</code> for example, Hibernate will actually replace the <code class="literal">HashSet</code> with an instance of Hibernate's own implementation of <code class="literal">Set</code>. Be aware of the following errors: </p><pre class="programlisting">Cat cat = new DomesticCat();
Cat kitten = new DomesticCat();
....
Set kittens = new HashSet();
kittens.add(kitten);
cat.setKittens(kittens);
session.persist(cat);
kittens = cat.getKittens(); // Okay, kittens collection is a Set
(HashSet) cat.getKittens(); // Error!</pre><p>The persistent collections injected by Hibernate behave like <code class="literal">HashMap</code>, <code class="literal">HashSet</code>, <code class="literal">TreeMap</code>, <code class="literal">TreeSet</code> or <code class="literal">ArrayList</code>, depending on the interface type. </p><p>Collections instances have the usual behavior of value types. They are automatically persisted when referenced by a persistent object and are automatically deleted when unreferenced. If a collection is passed from one persistent object to another, its elements might be moved from one table to another. Two entities cannot share a reference to the same collection instance. Due to the underlying relational model, collection-valued properties do not support null value semantics. Hibernate does not distinguish between a null collection reference and an empty collection. </p><p>Use persistent collections the same way you use ordinary Java collections. However, please ensure you understand the semantics of bidirectional associations (these are discussed later). </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="collections-mapping"/>6.2. コレクションのマッピング</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>ティップ</h2><p>There are quite a range of mappings that can be generated for collections that cover many common relational models. We suggest you experiment with the schema generation tool so that you understand how various mapping declarations translate to database tables. </p></div><p>The Hibernate mapping element used for mapping a collection depends upon the type of interface. For example, a <code class="literal">&lt;set&gt;</code> element is used for mapping properties of type <code class="literal">Set</code>. </p><pre class="programlisting">&lt;class name="Product"&gt;
    &lt;id name="serialNumber" column="productSerialNumber"/&gt;
    &lt;set name="parts"&gt;
        &lt;key column="productSerialNumber" not-null="true"/&gt;
        &lt;one-to-many class="Part"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>マッピング要素には <code class="literal">&lt;set&gt;</code> の他に <code class="literal">&lt;list&gt;</code>、 <code class="literal">&lt;map&gt;</code>、<code class="literal">&lt;bag&gt;</code>、 <code class="literal">&lt;array&gt;</code>、<code class="literal">&lt;primitive-array&gt;</code> があります。 代表として、<code class="literal">&lt;map&gt;</code> 要素を下記に示します。 </p><div class="programlistingco"><pre class="programlisting">&lt;map
    name="propertyName"                                         <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
    table="table_name"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
    schema="schema_name"                                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
    lazy="true|extra|false"                                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
    inverse="true|false"                                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
    cascade="all|none|save-update|delete|all-delete-orphan|delet<span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>e-orphan"
    sort="unsorted|natural|comparatorClass"                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
    order-by="column_name asc|desc"                             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
    where="arbitrary sql where condition"                       <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/9.png" alt="(9)"/></span>
    fetch="join|select|subselect"                               <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/10.png" alt="(10)"/></span>
    batch-size="N"                                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/11.png" alt="(11)"/></span>
    access="field|property|ClassName"                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/12.png" alt="(12)"/></span>
    optimistic-lock="true|false"                                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/13.png" alt="(13)"/></span>
    mutable="true|false"                                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/14.png" alt="(14)"/></span>
    node="element-name|."
    embed-xml="true|false"
&gt;

    &lt;key .... /&gt;
    &lt;map-key .... /&gt;
    &lt;element .... /&gt;
&lt;/map&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the collection property name </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">table</code> (optional - defaults to property name): the name of the collection table. It is not used for one-to-many associations. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">schema</code> (optional): the name of a table schema to override the schema declared on the root element </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional - defaults to <code class="literal">true</code>): disables lazy fetching and specifies that the association is always eagerly fetched. It can also be used to enable "extra-lazy" fetching where most operations do not initialize the collection. This is suitable for large collections. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">inverse</code> (optional - defaults to <code class="literal">false</code>): marks this collection as the "inverse" end of a bidirectional association. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">cascade</code> (optional - defaults to <code class="literal">none</code>): enables operations to cascade to child entities. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">sort</code> (optional): specifies a sorted collection with <code class="literal">natural</code> sort order or a given comparator class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">order-by</code> (optional, JDK1.4 only): specifies a table column or columns that define the iteration order of the <code class="literal">Map</code>, <code class="literal">Set</code> or bag, together with an optional <code class="literal">asc</code> or <code class="literal">desc</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/9.png" alt="9" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">where</code> (optional): specifies an arbitrary SQL <code class="literal">WHERE</code> condition that is used when retrieving or removing the collection. This is useful if the collection needs to contain only a subset of the available data. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/10.png" alt="10" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">fetch</code> (optional, defaults to <code class="literal">select</code>): chooses between outer-join fetching, fetching by sequential select, and fetching by sequential subselect. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/11.png" alt="11" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">batch-size</code> (optional, defaults to <code class="literal">1</code>): specifies a "batch size" for lazily fetching instances of this collection. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/12.png" alt="12" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the collection property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/13.png" alt="13" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">true</code>): specifies that changes to the state of the collection results in increments of the owning entity's version. For one-to-many associations you may want to disable this setting. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/14.png" alt="14" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">mutable</code> (optional - defaults to <code class="literal">true</code>): a value of <code class="literal">false</code> specifies that the elements of the collection never change. This allows for minor performance optimization in some cases. </p></td></tr></table></div></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="collections-foreignkeys"/>6.2.1. コレクションの外部キー</h3></div></div></div><p>Collection instances are distinguished in the database by the foreign key of the entity that owns the collection. This foreign key is referred to as the <span class="emphasis"><em>collection key column</em></span>, or columns, of the collection table. The collection key column is mapped by the <code class="literal">&lt;key&gt;</code> element. </p><p>There can be a nullability constraint on the foreign key column. For most collections, this is implied. For unidirectional one-to-many associations, the foreign key column is nullable by default, so you may need to specify <code class="literal">not-null="true"</code>. </p><pre class="programlisting">&lt;key column="productSerialNumber" not-null="true"/&gt;</pre><p>The foreign key constraint can use <code class="literal">ON DELETE CASCADE</code>. </p><pre class="programlisting">&lt;key column="productSerialNumber" on-delete="cascade"/&gt;</pre><p><code class="literal">&lt;key&gt;</code> 要素のすべての定義については前の章を参照してください。 </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="collections-elements"/>6.2.2. コレクションの要素</h3></div></div></div><p>Collections can contain almost any other Hibernate type, including: basic types, custom types, components and references to other entities. This is an important distinction. An object in a collection might be handled with "value" semantics (its life cycle fully depends on the collection owner), or it might be a reference to another entity with its own life cycle. In the latter case, only the "link" between the two objects is considered to be a state held by the collection. </p><p>格納される型は <span class="emphasis"><em>コレクション要素型</em></span> と呼ばれます。 コレクション要素は、<code class="literal">&lt;element&gt;</code> または <code class="literal">&lt;composite-element&gt;</code> によりマッピングされ、エンティティへの参照の場合には <code class="literal">&lt;one-to-many&gt;</code> または <code class="literal">&lt;many-to-many&gt;</code> によりマッピングされます。 最初の二つは値として要素をマッピングし、次の二つはエンティティの関連をマッピングするのに使われます。 </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="collections-indexed"/>6.2.3. インデックス付きのコレクション</h3></div></div></div><p>All collection mappings, except those with set and bag semantics, need an <span class="emphasis"><em>index column</em></span> in the collection table. An index column is a column that maps to an array index, or <code class="literal">List</code> index, or <code class="literal">Map</code> key. The index of a <code class="literal">Map</code> may be of any basic type, mapped with <code class="literal">&lt;map-key&gt;</code>. It can be an entity reference mapped with <code class="literal">&lt;map-key-many-to-many&gt;</code>, or it can be a composite type mapped with <code class="literal">&lt;composite-map-key&gt;</code>. The index of an array or list is always of type <code class="literal">integer</code> and is mapped using the <code class="literal">&lt;list-index&gt;</code> element. The mapped column contains sequential integers that are numbered from zero by default. </p><div class="programlistingco"><pre class="programlisting">&lt;list-index 
        column="column_name"                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        base="0|1|..."/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">column_name</code> (required): the name of the column holding the collection index values. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">base</code> (optional - defaults to <code class="literal">0</code>): the value of the index column that corresponds to the first element of the list or array. </p></td></tr></table></div></div><div class="programlistingco"><pre class="programlisting">&lt;map-key 
        column="column_name"                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        formula="any SQL expression"        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        type="type_name"                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        node="@attribute-name"
        length="N"/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">column</code> (optional): the name of the column holding the collection index values. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">formula</code> (optional): a SQL formula used to evaluate the key of the map. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">type</code> (required): the type of the map keys. </p></td></tr></table></div></div><div class="programlistingco"><pre class="programlisting">&lt;map-key-many-to-many
        column="column_name"                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        formula="any SQL expression"        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span><span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        class="ClassName"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">column</code> (optional): the name of the foreign key column for the collection index values. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">formula</code> (optional): a SQ formula used to evaluate the foreign key of the map key. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">class</code> (required): the entity class used as the map key. </p></td></tr></table></div></div><p>If your table does not have an index column, and you still wish to use <code class="literal">List</code> as the property type, you can map the property as a Hibernate <span class="emphasis"><em>&lt;bag&gt;</em></span>. A bag does not retain its order when it is retrieved from the database, but it can be optionally sorted or ordered. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="collections-ofvalues"/>6.2.4. 値のコレクションと多対多関連</h3></div></div></div><p>Any collection of values or many-to-many associations requires a dedicated <span class="emphasis"><em>collection table</em></span> with a foreign key column or columns, <span class="emphasis"><em>collection element column</em></span> or columns, and possibly an index column or columns. </p><p>For a collection of values use the <code class="literal">&lt;element&gt;</code> tag. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;element
        column="column_name"                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        formula="any SQL expression"             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        type="typename"                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        length="L"
        precision="P"
        scale="S"
        not-null="true|false"
        unique="true|false"
        node="element-name"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">column</code> (optional): the name of the column holding the collection element values. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">formula</code> (optional): an SQL formula used to evaluate the element. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">type</code> (required): the type of the collection element. </p></td></tr></table></div></div><p> A <span class="emphasis"><em>many-to-many association</em></span> is specified using the <code class="literal">&lt;many-to-many&gt;</code> element. </p><div class="programlistingco"><pre class="programlisting">&lt;many-to-many
        column="column_name"                               <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        formula="any SQL expression"                       <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        class="ClassName"                                  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        fetch="select|join"                                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        unique="true|false"                                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        not-found="ignore|exception"                       <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        entity-name="EntityName"                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        property-ref="propertyNameFromAssociatedClass"     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
        node="element-name"
        embed-xml="true|false"
    /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">column</code> (optional): the name of the element foreign key column. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">formula</code> (optional): an SQL formula used to evaluate the element foreign key value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">class</code> (required): the name of the associated class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">fetch</code> (optional - defaults to <code class="literal">join</code>): enables outer-join or sequential select fetching for this association. This is a special case; for full eager fetching in a single <code class="literal">SELECT</code> of an entity and its many-to-many relationships to other entities, you would enable <code class="literal">join</code> fetching,not only of the collection itself, but also with this attribute on the <code class="literal">&lt;many-to-many&gt;</code> nested element. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">unique</code> (optional): enables the DDL generation of a unique constraint for the foreign-key column. This makes the association multiplicity effectively one-to-many. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">not-found</code> (optional - defaults to <code class="literal">exception</code>): specifies how foreign keys that reference missing rows will be handled: <code class="literal">ignore</code> will treat a missing row as a null association. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">entity-name</code> (optional): the entity name of the associated class, as an alternative to <code class="literal">class</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">property-ref</code> (optional): the name of a property of the associated class that is joined to this foreign key. If not specified, the primary key of the associated class is used. </p></td></tr></table></div></div><p>Here are some examples. </p><p>A set of strings: </p><pre class="programlisting">&lt;set name="names" table="person_names"&gt;
    &lt;key column="person_id"/&gt;
    &lt;element column="person_name" type="string"/&gt;
&lt;/set&gt;</pre><p>A bag containing integers with an iteration order determined by the <code class="literal">order-by</code> attribute: </p><pre class="programlisting">&lt;bag name="sizes" 
        table="item_sizes" 
        order-by="size asc"&gt;
    &lt;key column="item_id"/&gt;
    &lt;element column="size" type="integer"/&gt;
&lt;/bag&gt;</pre><p>An array of entities, in this case, a many-to-many association: </p><pre class="programlisting">&lt;array name="addresses" 
        table="PersonAddress" 
        cascade="persist"&gt;
    &lt;key column="personId"/&gt;
    &lt;list-index column="sortOrder"/&gt;
    &lt;many-to-many column="addressId" class="Address"/&gt;
&lt;/array&gt;</pre><p>文字列と日付のmap </p><pre class="programlisting">&lt;map name="holidays" 
        table="holidays" 
        schema="dbo" 
        order-by="hol_name asc"&gt;
    &lt;key column="id"/&gt;
    &lt;map-key column="hol_name" type="string"/&gt;
    &lt;element column="hol_date" type="date"/&gt;
&lt;/map&gt;</pre><p>A list of components (this is discussed in the next chapter): </p><pre class="programlisting">&lt;list name="carComponents" 
        table="CarComponents"&gt;
    &lt;key column="carId"/&gt;
    &lt;list-index column="sortOrder"/&gt;
    &lt;composite-element class="CarComponent"&gt;
        &lt;property name="price"/&gt;
        &lt;property name="type"/&gt;
        &lt;property name="serialNumber" column="serialNum"/&gt;
    &lt;/composite-element&gt;
&lt;/list&gt;</pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="collections-onetomany"/>6.2.5. 一対多関連</h3></div></div></div><p>A <span class="emphasis"><em>one-to-many association</em></span> links the tables of two classes via a foreign key with no intervening collection table. This mapping loses certain semantics of normal Java collections: </p><div class="itemizedlist"><ul compact="compact"><li><p>An instance of the contained entity class cannot belong to more than one instance of the collection. </p></li><li><p>An instance of the contained entity class cannot appear at more than one value of the collection index. </p></li></ul></div><p>An association from <code class="literal">Product</code> to <code class="literal">Part</code> requires the existence of a foreign key column and possibly an index column to the <code class="literal">Part</code> table. A <code class="literal">&lt;one-to-many&gt;</code> tag indicates that this is a one-to-many association. </p><div class="programlistingco"><pre class="programlisting">&lt;one-to-many 
        class="ClassName"                                  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        not-found="ignore|exception"                       <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        entity-name="EntityName"                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        node="element-name"
        embed-xml="true|false"
    /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">class</code> (required): the name of the associated class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">not-found</code> (optional - defaults to <code class="literal">exception</code>): specifies how cached identifiers that reference missing rows will be handled. <code class="literal">ignore</code> will treat a missing row as a null association. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">entity-name</code> (optional): the entity name of the associated class, as an alternative to <code class="literal">class</code>. </p></td></tr></table></div></div><p>The <code class="literal">&lt;one-to-many&gt;</code> element does not need to declare any columns. Nor is it necessary to specify the <code class="literal">table</code> name anywhere. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>警告</h2><p>If the foreign key column of a <code class="literal">&lt;one-to-many&gt;</code> association is declared <code class="literal">NOT NULL</code>, you must declare the <code class="literal">&lt;key&gt;</code> mapping <code class="literal">not-null="true"</code> or <span class="emphasis"><em>use a bidirectional association</em></span> with the collection mapping marked <code class="literal">inverse="true"</code>. See the discussion of bidirectional associations later in this chapter for more information. </p></div><p>The following example shows a map of <code class="literal">Part</code> entities by name, where <code class="literal">partName</code> is a persistent property of <code class="literal">Part</code>. Notice the use of a formula-based index: </p><pre class="programlisting">&lt;map name="parts"
        cascade="all"&gt;
    &lt;key column="productId" not-null="true"/&gt;
    &lt;map-key formula="partName"/&gt;
    &lt;one-to-many class="Part"/&gt;
&lt;/map&gt;</pre></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="collections-advancedmappings"/>6.3. 高度なコレクション･マッピング</h2></div></div></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="collections-sorted"/>6.3.1. ソートされたコレクション</h3></div></div></div><p>Hibernateは <code class="literal">java.util.SortedMap</code> と <code class="literal">java.util.SortedSet</code> を実装したコレクションをサポートしています。 開発者はマッピング定義ファイルにコンパレータを指定しなければなりません。 </p><pre class="programlisting">&lt;set name="aliases" 
            table="person_aliases" 
            sort="natural"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="string"/&gt;
&lt;/set&gt;

&lt;map name="holidays" sort="my.custom.HolidayComparator"&gt;
    &lt;key column="year_id"/&gt;
    &lt;map-key column="hol_name" type="string"/&gt;
    &lt;element column="hol_date" type="date"/&gt;
&lt;/map&gt;</pre><p><code class="literal">sort</code> 属性に設定できる値は <code class="literal">unsorted</code> と <code class="literal">natural</code> および、<code class="literal">java.util.Comparator</code> を実装したクラスの名前です。 </p><p>ソートされたコレクションは実質的には <code class="literal">java.util.TreeSet</code> や <code class="literal">java.util.TreeMap</code> のように振舞います。 </p><p>If you want the database itself to order the collection elements, use the <code class="literal">order-by</code> attribute of <code class="literal">set</code>, <code class="literal">bag</code> or <code class="literal">map</code> mappings. This solution is only available under JDK 1.4 or higher and is implemented using <code class="literal">LinkedHashSet</code> or <code class="literal">LinkedHashMap</code>. This performs the ordering in the SQL query and not in the memory. </p><pre class="programlisting">&lt;set name="aliases" table="person_aliases" order-by="lower(name) asc"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="string"/&gt;
&lt;/set&gt;

&lt;map name="holidays" order-by="hol_date, hol_name"&gt;
    &lt;key column="year_id"/&gt;
    &lt;map-key column="hol_name" type="string"/&gt;
    &lt;element column="hol_date type="date"/&gt;
&lt;/map&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The value of the <code class="literal">order-by</code> attribute is an SQL ordering, not an HQL ordering. </p></div><p>Associations can even be sorted by arbitrary criteria at runtime using a collection <code class="literal">filter()</code>: </p><pre class="programlisting">sortedUsers = s.createFilter( group.getUsers(), "order by this.name" ).list();</pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="collections-bidirectional"/>6.3.2. 双方向関連</h3></div></div></div><p>A <span class="emphasis"><em>bidirectional association</em></span> allows navigation from both "ends" of the association. Two kinds of bidirectional association are supported: </p><div class="variablelist"><dl><dt><span class="term">one-to-many</span></dt><dd><p>set or bag valued at one end and single-valued at the other </p></dd><dt><span class="term">many-to-many</span></dt><dd><p>両側がsetかbagです。 </p></dd></dl></div><p>

        </p><p>You can specify a bidirectional many-to-many association by mapping two many-to-many associations to the same database table and declaring one end as <span class="emphasis"><em>inverse</em></span>. You cannot select an indexed collection. </p><p>Here is an example of a bidirectional many-to-many association that illustrates how each category can have many items and each item can be in many categories: </p><pre class="programlisting">&lt;class name="Category"&gt;
    &lt;id name="id" column="CATEGORY_ID"/&gt;
    ...
    &lt;bag name="items" table="CATEGORY_ITEM"&gt;
        &lt;key column="CATEGORY_ID"/&gt;
        &lt;many-to-many class="Item" column="ITEM_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;

&lt;class name="Item"&gt;
    &lt;id name="id" column="ITEM_ID"/&gt;
    ...

    &lt;!-- inverse end --&gt;
    &lt;bag name="categories" table="CATEGORY_ITEM" inverse="true"&gt;
        &lt;key column="ITEM_ID"/&gt;
        &lt;many-to-many class="Category" column="CATEGORY_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;</pre><p>Changes made only to the inverse end of the association are <span class="emphasis"><em>not</em></span> persisted. This means that Hibernate has two representations in memory for every bidirectional association: one link from A to B and another link from B to A. This is easier to understand if you think about the Java object model and how a many-to-many relationship in Javais created: </p><pre class="programlisting">
category.getItems().add(item);          // The category now "knows" about the relationship
item.getCategories().add(category);     // The item now "knows" about the relationship

session.persist(item);                   // The relationship won't be saved!
session.persist(category);               // The relationship will be saved</pre><p>関連のinverseではない側は、メモリ上の表現をデータベースに保存するのに使われます。 </p><p>You can define a bidirectional one-to-many association by mapping a one-to-many association to the same table column(s) as a many-to-one association and declaring the many-valued end <code class="literal">inverse="true"</code>. </p><pre class="programlisting">&lt;class name="Parent"&gt;
    &lt;id name="id" column="parent_id"/&gt;
    ....
    &lt;set name="children" inverse="true"&gt;
        &lt;key column="parent_id"/&gt;
        &lt;one-to-many class="Child"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Child"&gt;
    &lt;id name="id" column="child_id"/&gt;
    ....
    &lt;many-to-one name="parent" 
        class="Parent" 
        column="parent_id"
        not-null="true"/&gt;
&lt;/class&gt;</pre><p>Mapping one end of an association with <code class="literal">inverse="true"</code> does not affect the operation of cascades as these are orthogonal concepts. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="collections-indexedbidirectional"/>6.3.3. インデックス付きコレクションと双方向関連</h3></div></div></div><p>A bidirectional association where one end is represented as a <code class="literal">&lt;list&gt;</code> or <code class="literal">&lt;map&gt;</code>, requires special consideration. If there is a property of the child class that maps to the index column you can use <code class="literal">inverse="true"</code> on the collection mapping: </p><pre class="programlisting">&lt;class name="Parent"&gt;
    &lt;id name="id" column="parent_id"/&gt;
    ....
    &lt;map name="children" inverse="true"&gt;
        &lt;key column="parent_id"/&gt;
        &lt;map-key column="name" 
            type="string"/&gt;
        &lt;one-to-many class="Child"/&gt;
    &lt;/map&gt;
&lt;/class&gt;

&lt;class name="Child"&gt;
    &lt;id name="id" column="child_id"/&gt;
    ....
    &lt;property name="name" 
        not-null="true"/&gt;
    &lt;many-to-one name="parent" 
        class="Parent" 
        column="parent_id"
        not-null="true"/&gt;
&lt;/class&gt;</pre><p>If there is no such property on the child class, the association cannot be considered truly bidirectional. That is, there is information available at one end of the association that is not available at the other end. In this case, you cannot map the collection <code class="literal">inverse="true"</code>. Instead, you could use the following mapping: </p><pre class="programlisting">&lt;class name="Parent"&gt;
    &lt;id name="id" column="parent_id"/&gt;
    ....
    &lt;map name="children"&gt;
        &lt;key column="parent_id"
            not-null="true"/&gt;
        &lt;map-key column="name" 
            type="string"/&gt;
        &lt;one-to-many class="Child"/&gt;
    &lt;/map&gt;
&lt;/class&gt;

&lt;class name="Child"&gt;
    &lt;id name="id" column="child_id"/&gt;
    ....
    &lt;many-to-one name="parent" 
        class="Parent" 
        column="parent_id"
        insert="false"
        update="false"
        not-null="true"/&gt;
&lt;/class&gt;</pre><p>Note that in this mapping, the collection-valued end of the association is responsible for updates to the foreign key. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="collections-ternary"/>6.3.4. 3項関連</h3></div></div></div><p>There are three possible approaches to mapping a ternary association. One approach is to use a <code class="literal">Map</code> with an association as its index: </p><pre class="programlisting">&lt;map name="contracts"&gt;
    &lt;key column="employer_id" not-null="true"/&gt;
    &lt;map-key-many-to-many column="employee_id" class="Employee"/&gt;
    &lt;one-to-many class="Contract"/&gt;
&lt;/map&gt;</pre><pre class="programlisting">&lt;map name="connections"&gt;
    &lt;key column="incoming_node_id"/&gt;
    &lt;map-key-many-to-many column="outgoing_node_id" class="Node"/&gt;
    &lt;many-to-many column="connection_id" class="Connection"/&gt;
&lt;/map&gt;</pre><p>A second approach is to remodel the association as an entity class. This is the most common approach. </p><p>A final alternative is to use composite elements, which will be discussed later. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="collections-idbag"/>6.3.5. <code class="literal"><code class="literal">&lt;idbag&gt;</code>の使用</code></h3></div></div></div><p>The majority of the many-to-many associations and collections of values shown previously all map to tables with composite keys, even though it has been have suggested that entities should have synthetic identifiers (surrogate keys). A pure association table does not seem to benefit much from a surrogate key, although a collection of composite values <span class="emphasis"><em>might</em></span>. It is for this reason that Hibernate provides a feature that allows you to map many-to-many associations and collections of values to a table with a surrogate key. </p><p>The <code class="literal">&lt;idbag&gt;</code> element lets you map a <code class="literal">List</code> (or <code class="literal">Collection</code>) with bag semantics. For example: </p><pre class="programlisting">&lt;idbag name="lovers" table="LOVERS"&gt;
    &lt;collection-id column="ID" type="long"&gt;
        &lt;generator class="sequence"/&gt;
    &lt;/collection-id&gt;
    &lt;key column="PERSON1"/&gt;
    &lt;many-to-many column="PERSON2" class="Person" fetch="join"/&gt;
&lt;/idbag&gt;</pre><p>An <code class="literal">&lt;idbag&gt;</code> has a synthetic id generator, just like an entity class. A different surrogate key is assigned to each collection row. Hibernate does not, however, provide any mechanism for discovering the surrogate key value of a particular row. </p><p>The update performance of an <code class="literal">&lt;idbag&gt;</code> supersedes a regular <code class="literal">&lt;bag&gt;</code>. Hibernate can locate individual rows efficiently and update or delete them individually, similar to a list, map or set. </p><p>現在の実装では、<code class="literal">native</code> というid生成戦略を <code class="literal">&lt;idbag&gt;</code> コレクションの識別子に対して使えません。 </p></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="collections-example"/>6.4. コレクションの例</h2></div></div></div><p>This section covers collection examples. </p><p>The following class has a collection of <code class="literal">Child</code> instances: </p><pre class="programlisting">package eg;
import java.util.Set;

public class Parent {
    private long id;
    private Set children;

    public long getId() { return id; }
    private void setId(long id) { this.id=id; }

    private Set getChildren() { return children; }
    private void setChildren(Set children) { this.children=children; }

    ....
    ....
}</pre><p>If each child has, at most, one parent, the most natural mapping is a one-to-many association: </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>これは以下のテーブル定義にマッピングします。 </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null primary key, name varchar(255), parent_id bigint )
alter table child add constraint childfk0 (parent_id) references parent</pre><p>もしparentが <span class="emphasis"><em>要求</em></span> されるなら、双方向の一対多関連を使用してください。 </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" inverse="true"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
        &lt;many-to-one name="parent" class="Parent" column="parent_id" not-null="true"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p><code class="literal">NOT NULL</code> 制約に注意してください。 </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null
                     primary key,
                     name varchar(255),
                     parent_id bigint not null )
alter table child add constraint childfk0 (parent_id) references parent</pre><p>Alternatively, if this association must be unidirectional you can declare the <code class="literal">NOT NULL</code> constraint on the <code class="literal">&lt;key&gt;</code> mapping: </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children"&gt;
            &lt;key column="parent_id" not-null="true"/&gt;
            &lt;one-to-many class="Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>On the other hand, if a child has multiple parents, a many-to-many association is appropriate: </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" table="childset"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;many-to-many class="Child" column="child_id"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>テーブル定義は以下のようになります。 </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null primary key, name varchar(255) )
create table childset ( parent_id bigint not null,
                        child_id bigint not null,
                        primary key ( parent_id, child_id ) )
alter table childset add constraint childsetfk0 (parent_id) references parent
alter table childset add constraint childsetfk1 (child_id) references child</pre><p>For more examples and a complete explanation of a parent/child relationship mapping, see <a href="#example-parentchild" title="第21章 例：親/子供">章 21. <i xmlns:xlink="http://www.w3.org/1999/xlink">例：親/子供</i></a> for more information. </p><p>Even more complex association mappings are covered in the next chapter. </p></div></div><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="associations"/>第7章 関連マッピング</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#assoc-intro">7.1. イントロダクション</a></span></dt><dt><span class="sect1"><a href="#assoc-unidirectional">7.2. 単方向関連</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-unidirectional-m21">7.2.1. Many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-121">7.2.2. One-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-12m">7.2.3. One-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-unidirectional-join">7.3. 結合テーブルを使った単方向関連</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-unidirectional-join-12m">7.3.1. One-to-many</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-m21">7.3.2. Many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-121">7.3.3. One-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-m2m">7.3.4. Many-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-bidirectional">7.4. 双方向関連</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-bidirectional-m21">7.4.1. one-to-many / many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-121">7.4.2. One-to-one</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-bidirectional-join">7.5. 結合テーブルを使った双方向関連</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-bidirectional-join-12m">7.5.1. one-to-many / many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-join-121">7.5.2. 一対一</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-join-m2m">7.5.3. Many-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-complex">7.6. より複雑な関連マッピング</a></span></dt></dl></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="assoc-intro"/>7.1. イントロダクション</h2></div></div></div><p>Association mappings are often the most difficult thing to implement correctly. In this section we examine some canonical cases one by one, starting with unidirectional mappings and then bidirectional cases. We will use <code class="literal">Person</code> and <code class="literal">Address</code> in all the examples. </p><p>Associations will be classified by multiplicity and whether or not they map to an intervening join table. </p><p>Nullable foreign keys are not considered to be good practice in traditional data modelling, so our examples do not use nullable foreign keys. This is not a requirement of Hibernate, and the mappings will work if you drop the nullability constraints. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="assoc-unidirectional"/>7.2. 単方向関連</h2></div></div></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-m21"/>7.2.1. Many-to-one</h3></div></div></div><p><span class="emphasis"><em>単方向多対一関連</em></span> は単方向関連の中で最も一般的なものです。 </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-121"/>7.2.2. One-to-one</h3></div></div></div><p><span class="emphasis"><em>外部キーの単方向一対一関連</em></span> はほとんど同じものです。 唯一違うのは、カラムのユニークな制約です。 </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId" 
        unique="true"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre><p>A <span class="emphasis"><em>unidirectional one-to-one association on a primary key</em></span> usually uses a special id generator In this example, however, we have reversed the direction of the association: </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"&gt;person&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    &lt;one-to-one name="person" constrained="true"/&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table Address ( personId bigint not null primary key )
        </pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-12m"/>7.2.3. One-to-many</h3></div></div></div><p>A <span class="emphasis"><em>unidirectional one-to-many association on a foreign key</em></span> is an unusual case, and is not recommended. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses"&gt;
        &lt;key column="personId" 
            not-null="true"/&gt;
        &lt;one-to-many class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table Address ( addressId bigint not null primary key, personId bigint not null )
        </pre><p>You should instead use a join table for this kind of association. </p></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="assoc-unidirectional-join"/>7.3. 結合テーブルを使った単方向関連</h2></div></div></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-join-12m"/>7.3.1. One-to-many</h3></div></div></div><p>A <span class="emphasis"><em>unidirectional one-to-many association on a join table</em></span> is the preferred option. Specifying <code class="literal">unique="true"</code>, changes the multiplicity from many-to-many to one-to-many. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses" table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            unique="true"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId not null, addressId bigint not null primary key )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-join-m21"/>7.3.2. Many-to-one</h3></div></div></div><p>A <span class="emphasis"><em>unidirectional many-to-one association on a join table</em></span> is common when the association is optional. For example: </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"&gt;
        &lt;key column="personId" unique="true"/&gt;
        &lt;many-to-one name="address"
            column="addressId" 
            not-null="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null primary key, addressId bigint not null )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-join-121"/>7.3.3. One-to-one</h3></div></div></div><p>A <span class="emphasis"><em>unidirectional one-to-one association on a join table</em></span> is possible, but extremely unusual. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"&gt;
        &lt;key column="personId" 
            unique="true"/&gt;
        &lt;many-to-one name="address"
            column="addressId" 
            not-null="true"
            unique="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-join-m2m"/>7.3.4. Many-to-many</h3></div></div></div><p>Finally, here is an example of a <span class="emphasis"><em>unidirectional many-to-many association</em></span>. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses" table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null, addressId bigint not null, primary key (personId, addressId) )
create table Address ( addressId bigint not null primary key )
        </pre></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="assoc-bidirectional"/>7.4. 双方向関連</h2></div></div></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-bidirectional-m21"/>7.4.1. one-to-many / many-to-one</h3></div></div></div><p>A <span class="emphasis"><em>bidirectional many-to-one association</em></span> is the most common kind of association. The following example illustrates the standard parent/child relationship. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="people" inverse="true"&gt;
        &lt;key column="addressId"/&gt;
        &lt;one-to-many class="Person"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null )
create table Address ( addressId bigint not null primary key )
        </pre><p>If you use a <code class="literal">List</code>, or other indexed collection, set the <code class="literal">key</code> column of the foreign key to <code class="literal">not null</code>. Hibernate will manage the association from the collections side to maintain the index of each element, making the other side virtually inverse by setting <code class="literal">update="false"</code> and <code class="literal">insert="false"</code>: </p><pre class="programlisting">&lt;class name="Person"&gt;
   &lt;id name="id"/&gt;
   ...
   &lt;many-to-one name="address"
      column="addressId"
      not-null="true"
      insert="false"
      update="false"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
   &lt;id name="id"/&gt;
   ...
   &lt;list name="people"&gt;
      &lt;key column="addressId" not-null="true"/&gt;
      &lt;list-index column="peopleIdx"/&gt;
      &lt;one-to-many class="Person"/&gt;
   &lt;/list&gt;
&lt;/class&gt;</pre><p>If the underlying foreign key column is <code class="literal">NOT NULL</code>, it is important that you define <code class="literal">not-null="true"</code> on the <code class="literal">&lt;key&gt;</code> element of the collection mapping. Do not only declare <code class="literal">not-null="true"</code> on a possible nested <code class="literal">&lt;column&gt;</code> element, but on the <code class="literal">&lt;key&gt;</code> element. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-bidirectional-121"/>7.4.2. One-to-one</h3></div></div></div><p>A <span class="emphasis"><em>bidirectional one-to-one association on a foreign key</em></span> is common: </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId" 
        unique="true"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
   &lt;one-to-one name="person" 
        property-ref="address"/&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre><p>A <span class="emphasis"><em>bidirectional one-to-one association on a primary key</em></span> uses the special id generator: </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;one-to-one name="address"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"&gt;person&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    &lt;one-to-one name="person" 
        constrained="true"/&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table Address ( personId bigint not null primary key )
        </pre></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="assoc-bidirectional-join"/>7.5. 結合テーブルを使った双方向関連</h2></div></div></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-bidirectional-join-12m"/>7.5.1. one-to-many / many-to-one</h3></div></div></div><p>The following is an example of a <span class="emphasis"><em>bidirectional one-to-many association on a join table</em></span>. The <code class="literal">inverse="true"</code> can go on either end of the association, on the collection, or on the join. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses" 
        table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            unique="true"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        inverse="true" 
        optional="true"&gt;
        &lt;key column="addressId"/&gt;
        &lt;many-to-one name="person"
            column="personId"
            not-null="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null, addressId bigint not null primary key )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-bidirectional-join-121"/>7.5.2. 一対一</h3></div></div></div><p>A <span class="emphasis"><em>bidirectional one-to-one association on a join table</em></span> is possible, but extremely unusual. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"&gt;
        &lt;key column="personId" 
            unique="true"/&gt;
        &lt;many-to-one name="address"
            column="addressId" 
            not-null="true"
            unique="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"
        inverse="true"&gt;
        &lt;key column="addressId" 
            unique="true"/&gt;
        &lt;many-to-one name="person"
            column="personId" 
            not-null="true"
            unique="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-bidirectional-join-m2m"/>7.5.3. Many-to-many</h3></div></div></div><p>Here is an example of a <span class="emphasis"><em>bidirectional many-to-many association</em></span>. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses" table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="people" inverse="true" table="PersonAddress"&gt;
        &lt;key column="addressId"/&gt;
        &lt;many-to-many column="personId"
            class="Person"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null, addressId bigint not null, primary key (personId, addressId) )
create table Address ( addressId bigint not null primary key )
        </pre></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="assoc-complex"/>7.6. より複雑な関連マッピング</h2></div></div></div><p>More complex association joins are <span class="emphasis"><em>extremely</em></span> rare. Hibernate handles more complex situations by using SQL fragments embedded in the mapping document. For example, if a table with historical account information data defines <code class="literal">accountNumber</code>, <code class="literal">effectiveEndDate</code> and <code class="literal">effectiveStartDate</code>columns, it would be mapped as follows: </p><pre class="programlisting">&lt;properties name="currentAccountKey"&gt;
    &lt;property name="accountNumber" type="string" not-null="true"/&gt;
    &lt;property name="currentAccount" type="boolean"&gt;
        &lt;formula&gt;case when effectiveEndDate is null then 1 else 0 end&lt;/formula&gt;
    &lt;/property&gt;
&lt;/properties&gt;
&lt;property name="effectiveEndDate" type="date"/&gt;
&lt;property name="effectiveStateDate" type="date" not-null="true"/&gt;</pre><p>You can then map an association to the <span class="emphasis"><em>current</em></span> instance, the one with null <code class="literal">effectiveEndDate</code>, by using: </p><pre class="programlisting">&lt;many-to-one name="currentAccountInfo" 
        property-ref="currentAccountKey"
        class="AccountInfo"&gt;
    &lt;column name="accountNumber"/&gt;
    &lt;formula&gt;'1'&lt;/formula&gt;
&lt;/many-to-one&gt;</pre><p>In a more complex example, imagine that the association between <code class="literal">Employee</code> and <code class="literal">Organization</code> is maintained in an <code class="literal">Employment</code> table full of historical employment data. An association to the employee's <span class="emphasis"><em>most recent</em></span> employer, the one with the most recent <code class="literal">startDate</code>, could be mapped in the following way: </p><pre class="programlisting">&lt;join&gt;
    &lt;key column="employeeId"/&gt;
    &lt;subselect&gt;
        select employeeId, orgId 
        from Employments 
        group by orgId 
        having startDate = max(startDate)
    &lt;/subselect&gt;
    &lt;many-to-one name="mostRecentEmployer" 
            class="Organization" 
            column="orgId"/&gt;
&lt;/join&gt;</pre><p>This functionality allows a degree of creativity and flexibility, but it is more practical to handle these kinds of cases using HQL or a criteria query. </p></div></div><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="components"/>第8章 コンポーネントのマッピング</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#components-dependentobjects">8.1. 依存オブジェクト</a></span></dt><dt><span class="sect1"><a href="#components-incollections">8.2. 従属するオブジェクトのコレクション</a></span></dt><dt><span class="sect1"><a href="#components-asmapindex">8.3. Mapのインデックスとしてのコンポーネント</a></span></dt><dt><span class="sect1"><a href="#components-compositeid">8.4. 複合識別子としてのコンポーネント</a></span></dt><dt><span class="sect1"><a href="#components-dynamic">8.5. 動的コンポーネント</a></span></dt></dl></div><p>The notion of a <span class="emphasis"><em>component</em></span> is re-used in several different contexts and purposes throughout Hibernate. </p><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="components-dependentobjects"/>8.1. 依存オブジェクト</h2></div></div></div><p>A component is a contained object that is persisted as a value type and not an entity reference. The term "component" refers to the object-oriented notion of composition and not to architecture-level components. For example, you can model a person like this: </p><pre class="programlisting">public class Person {
    private java.util.Date birthday;
    private Name name;
    private String key;
    public String getKey() {
        return key;
    }
    private void setKey(String key) {
        this.key=key;
    }
    public java.util.Date getBirthday() {
        return birthday;
    }
    public void setBirthday(java.util.Date birthday) {
        this.birthday = birthday;
    }
    public Name getName() {
        return name;
    }
    public void setName(Name name) {
        this.name = name;
    }
    ......
    ......
}</pre><pre class="programlisting">public class Name {
    char initial;
    String first;
    String last;
    public String getFirst() {
        return first;
    }
    void setFirst(String first) {
        this.first = first;
    }
    public String getLast() {
        return last;
    }
    void setLast(String last) {
        this.last = last;
    }
    public char getInitial() {
        return initial;
    }
    void setInitial(char initial) {
        this.initial = initial;
    }
}</pre><p>Now <code class="literal">Name</code> can be persisted as a component of <code class="literal">Person</code>. <code class="literal">Name</code> defines getter and setter methods for its persistent properties, but it does not need to declare any interfaces or identifier properties. </p><p>Our Hibernate mapping would look like this: </p><pre class="programlisting">&lt;class name="eg.Person" table="person"&gt;
    &lt;id name="Key" column="pid" type="string"&gt;
        &lt;generator class="uuid"/&gt;
    &lt;/id&gt;
    &lt;property name="birthday" type="date"/&gt;
    &lt;component name="Name" class="eg.Name"&gt; &lt;!-- class attribute optional --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/component&gt;
&lt;/class&gt;</pre><p>Personテーブルは <code class="literal">pid</code>、 <code class="literal">birthday</code>、 <code class="literal">initial</code>、 <code class="literal">first</code>、 <code class="literal">last</code> カラムを持ちます。 </p><p>Like value types, components do not support shared references. In other words, two persons could have the same name, but the two person objects would contain two independent name objects that were only "the same" by value. The null value semantics of a component are <span class="emphasis"><em>ad hoc</em></span>. When reloading the containing object, Hibernate will assume that if all component columns are null, then the entire component is null. This is suitable for most purposes. </p><p>The properties of a component can be of any Hibernate type (collections, many-to-one associations, other components, etc). Nested components should <span class="emphasis"><em>not</em></span> be considered an exotic usage. Hibernate is intended to support a fine-grained object model. </p><p><code class="literal">&lt;component&gt;</code> 要素は親エンティティへの逆参照として、コンポーネントクラスの 属性をマッピングする <code class="literal">&lt;parent&gt;</code> サブ要素を使用できます。 </p><pre class="programlisting">&lt;class name="eg.Person" table="person"&gt;
    &lt;id name="Key" column="pid" type="string"&gt;
        &lt;generator class="uuid"/&gt;
    &lt;/id&gt;
    &lt;property name="birthday" type="date"/&gt;
    &lt;component name="Name" class="eg.Name" unique="true"&gt;
        &lt;parent name="namedPerson"/&gt; &lt;!-- reference back to the Person --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/component&gt;
&lt;/class&gt;</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="components-incollections"/>8.2. 従属するオブジェクトのコレクション</h2></div></div></div><p>Collections of components are supported (e.g. an array of type <code class="literal">Name</code>). Declare your component collection by replacing the <code class="literal">&lt;element&gt;</code> tag with a <code class="literal">&lt;composite-element&gt;</code> tag: </p><pre class="programlisting">&lt;set name="someNames" table="some_names" lazy="true"&gt;
    &lt;key column="id"/&gt;
    &lt;composite-element class="eg.Name"&gt; &lt;!-- class attribute required --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/composite-element&gt;
&lt;/set&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>重要項目</h2><p>If you define a <code class="literal">Set</code> of composite elements, it is important to implement <code class="literal">equals()</code> and <code class="literal">hashCode()</code> correctly. </p></div><p>Composite elements can contain components but not collections. If your composite element contains components, use the <code class="literal">&lt;nested-composite-element&gt;</code> tag. This case is a collection of components which themselves have components. You may want to consider if a one-to-many association is more appropriate. Remodel the composite element as an entity, but be aware that even though the Java model is the same, the relational model and persistence semantics are still slightly different. </p><p>A composite element mapping does not support null-able properties if you are using a <code class="literal">&lt;set&gt;</code>. There is no separate primary key column in the composite element table. Hibernate uses each column's value to identify a record when deleting objects, which is not possible with null values. You have to either use only not-null properties in a composite-element or choose a <code class="literal">&lt;list&gt;</code>, <code class="literal">&lt;map&gt;</code>, <code class="literal">&lt;bag&gt;</code> or <code class="literal">&lt;idbag&gt;</code>. </p><p>A special case of a composite element is a composite element with a nested <code class="literal">&lt;many-to-one&gt;</code> element. This mapping allows you to map extra columns of a many-to-many association table to the composite element class. The following is a many-to-many association from <code class="literal">Order</code> to <code class="literal">Item</code>, where <code class="literal">purchaseDate</code>, <code class="literal">price</code> and <code class="literal">quantity</code> are properties of the association: </p><pre class="programlisting">&lt;class name="eg.Order" .... &gt;
    ....
    &lt;set name="purchasedItems" table="purchase_items" lazy="true"&gt;
        &lt;key column="order_id"&gt;
        &lt;composite-element class="eg.Purchase"&gt;
            &lt;property name="purchaseDate"/&gt;
            &lt;property name="price"/&gt;
            &lt;property name="quantity"/&gt;
            &lt;many-to-one name="item" class="eg.Item"/&gt; &lt;!-- class attribute is optional --&gt;
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>There cannot be a reference to the purchase on the other side for bidirectional association navigation. Components are value types and do not allow shared references. A single <code class="literal">Purchase</code> can be in the set of an <code class="literal">Order</code>, but it cannot be referenced by the <code class="literal">Item</code> at the same time. </p><p>3項関連（あるいは4項など）も可能です。</p><pre class="programlisting">&lt;class name="eg.Order" .... &gt;
    ....
    &lt;set name="purchasedItems" table="purchase_items" lazy="true"&gt;
        &lt;key column="order_id"&gt;
        &lt;composite-element class="eg.OrderLine"&gt;
            &lt;many-to-one name="purchaseDetails class="eg.Purchase"/&gt;
            &lt;many-to-one name="item" class="eg.Item"/&gt;
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>Composite elements can appear in queries using the same syntax as associations to other entities. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="components-asmapindex"/>8.3. Mapのインデックスとしてのコンポーネント</h2></div></div></div><p>The <code class="literal">&lt;composite-map-key&gt;</code> element allows you to map a component class as the key of a <code class="literal">Map</code>. Ensure that you override <code class="literal">hashCode()</code> and <code class="literal">equals()</code> correctly on the component class. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="components-compositeid"/>8.4. 複合識別子としてのコンポーネント</h2></div></div></div><p>You can use a component as an identifier of an entity class. Your component class must satisfy certain requirements: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">java.io.Serializable</code> を実装しなければなりません。 </p></li><li><p>It must re-implement <code class="literal">equals()</code> and <code class="literal">hashCode()</code> consistently with the database's notion of composite key equality. </p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>In Hibernate3, although the second requirement is not an absolutely hard requirement of Hibernate, it is recommended. </p></div><p>You cannot use an <code class="literal">IdentifierGenerator</code> to generate composite keys. Instead the application must assign its own identifiers. </p><p>Use the <code class="literal">&lt;composite-id&gt;</code> tag, with nested <code class="literal">&lt;key-property&gt;</code> elements, in place of the usual <code class="literal">&lt;id&gt;</code> declaration. For example, the <code class="literal">OrderLine</code> class has a primary key that depends upon the (composite) primary key of <code class="literal">Order</code>. </p><pre class="programlisting">&lt;class name="OrderLine"&gt;
    
    &lt;composite-id name="id" class="OrderLineId"&gt;
        &lt;key-property name="lineId"/&gt;
        &lt;key-property name="orderId"/&gt;
        &lt;key-property name="customerId"/&gt;
    &lt;/composite-id&gt;
    
    &lt;property name="name"/&gt;
    
    &lt;many-to-one name="order" class="Order"
            insert="false" update="false"&gt;
        &lt;column name="orderId"/&gt;
        &lt;column name="customerId"/&gt;
    &lt;/many-to-one&gt;
    ....
    
&lt;/class&gt;</pre><p>Any foreign keys referencing the <code class="literal">OrderLine</code> table are now composite. Declare this in your mappings for other classes. An association to <code class="literal">OrderLine</code> is mapped like this: </p><pre class="programlisting">&lt;many-to-one name="orderLine" class="OrderLine"&gt;
&lt;!-- the "class" attribute is optional, as usual --&gt;
    &lt;column name="lineId"/&gt;
    &lt;column name="orderId"/&gt;
    &lt;column name="customerId"/&gt;
&lt;/many-to-one&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>ティップ</h2><p>The <code class="literal">column</code> element is an alternative to the <code class="literal">column</code> attribute everywhere. Using the <code class="literal">column</code> element just gives more declaration options, which are mostly useful when utilizing <code class="literal">hbm2ddl</code> </p></div><p><code class="literal">OrderLine</code> への <code class="literal">many-to-many</code> 関連も 複合外部キーを使います。 </p><pre class="programlisting">&lt;set name="undeliveredOrderLines"&gt;
    &lt;key column name="warehouseId"/&gt;
    &lt;many-to-many class="OrderLine"&gt;
        &lt;column name="lineId"/&gt;
        &lt;column name="orderId"/&gt;
        &lt;column name="customerId"/&gt;
    &lt;/many-to-many&gt;
&lt;/set&gt;</pre><p><code class="literal">Order</code> にある <code class="literal">OrderLine</code> のコレクションは 次のものを使用します。 </p><pre class="programlisting">&lt;set name="orderLines" inverse="true"&gt;
    &lt;key&gt;
        &lt;column name="orderId"/&gt;
        &lt;column name="customerId"/&gt;
    &lt;/key&gt;
    &lt;one-to-many class="OrderLine"/&gt;
&lt;/set&gt;</pre><p>The <code class="literal">&lt;one-to-many&gt;</code> element declares no columns. </p><p><code class="literal">OrderLine</code> 自身がコレクションを持っている場合、 同時に複合外部キーも持っています。 </p><pre class="programlisting">&lt;class name="OrderLine"&gt;
    ....
    ....
    &lt;list name="deliveryAttempts"&gt;
        &lt;key&gt;   &lt;!-- a collection inherits the composite key type --&gt;
            &lt;column name="lineId"/&gt;
            &lt;column name="orderId"/&gt;
            &lt;column name="customerId"/&gt;
        &lt;/key&gt;
        &lt;list-index column="attemptId" base="1"/&gt;
        &lt;composite-element class="DeliveryAttempt"&gt;
            ...
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="components-dynamic"/>8.5. 動的コンポーネント</h2></div></div></div><p>You can also map a property of type <code class="literal">Map</code>: </p><pre class="programlisting">&lt;dynamic-component name="userAttributes"&gt;
    &lt;property name="foo" column="FOO" type="string"/&gt;
    &lt;property name="bar" column="BAR" type="integer"/&gt;
    &lt;many-to-one name="baz" class="Baz" column="BAZ_ID"/&gt;
&lt;/dynamic-component&gt;</pre><p>The semantics of a <code class="literal">&lt;dynamic-component&gt;</code> mapping are identical to <code class="literal">&lt;component&gt;</code>. The advantage of this kind of mapping is the ability to determine the actual properties of the bean at deployment time just by editing the mapping document. Runtime manipulation of the mapping document is also possible, using a DOM parser. You can also access, and change, Hibernate's configuration-time metamodel via the <code class="literal">Configuration</code> object. </p></div></div><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="inheritance"/>第9章 Inheritance mapping</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#inheritance-strategies">9.1. The three strategies</a></span></dt><dd><dl><dt><span class="sect2"><a href="#inheritance-tableperclass">9.1.1. クラス階層ごとのテーブル（table-per-class-hierarchy）</a></span></dt><dt><span class="sect2"><a href="#inheritance-tablepersubclass">9.1.2. サブクラスごとのテーブル（table-per-subclass）</a></span></dt><dt><span class="sect2"><a href="#inheritance-tablepersubclass-discriminator">9.1.3. Table per subclass: using a discriminator</a></span></dt><dt><span class="sect2"><a href="#inheritance-mixing-tableperclass-tablepersubclass">9.1.4. table-per-subclass と table-per-class-hierarchy の混合</a></span></dt><dt><span class="sect2"><a href="#inheritance-tableperconcrete">9.1.5. 具象クラスごとのテーブル（table-per-concrete-class）</a></span></dt><dt><span class="sect2"><a href="#inheritance-tableperconcreate-polymorphism">9.1.6. Table per concrete class using implicit polymorphism</a></span></dt><dt><span class="sect2"><a href="#inheritance-mixingpolymorphism">9.1.7. 他の継承マッピングと暗黙的ポリモーフィズムの組み合わせ</a></span></dt></dl></dd><dt><span class="sect1"><a href="#inheritance-limitations">9.2. 制限</a></span></dt></dl></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="inheritance-strategies"/>9.1. The three strategies</h2></div></div></div><p>Hibernateは3つの基本的な継承のマッピング戦略をサポートします。 </p><div class="itemizedlist"><ul><li><p>クラス階層ごとのテーブル（table-per-class-hierarchy） </p></li><li><p>table per subclass </p></li><li><p>具象クラスごとのテーブル（table-per-concrete-class） </p></li></ul></div><p>加えて4つ目に、Hibernateはわずかに異なる性質を持ったポリモーフィズムをサポートします。 </p><div class="itemizedlist"><ul><li><p>暗黙的ポリモーフィズム </p></li></ul></div><p>It is possible to use different mapping strategies for different branches of the same inheritance hierarchy. You can then make use of implicit polymorphism to achieve polymorphism across the whole hierarchy. However, Hibernate does not support mixing <code class="literal">&lt;subclass&gt;</code>, <code class="literal">&lt;joined-subclass&gt;</code> and <code class="literal">&lt;union-subclass&gt;</code> mappings under the same root <code class="literal">&lt;class&gt;</code> element. It is possible to mix together the table per hierarchy and table per subclass strategies under the the same <code class="literal">&lt;class&gt;</code> element, by combining the <code class="literal">&lt;subclass&gt;</code> and <code class="literal">&lt;join&gt;</code> elements (see below for an example). </p><p>It is possible to define <code class="literal">subclass</code>, <code class="literal">union-subclass</code>, and <code class="literal">joined-subclass</code> mappings in separate mapping documents directly beneath <code class="literal">hibernate-mapping</code>. This allows you to extend a class hierarchy by adding a new mapping file. You must specify an <code class="literal">extends</code> attribute in the subclass mapping, naming a previously mapped superclass. Previously this feature made the ordering of the mapping documents important. Since Hibernate3, the ordering of mapping files is irrelevant when using the extends keyword. The ordering inside a single mapping file still needs to be defined as superclasses before subclasses. </p><pre class="programlisting">
 &lt;hibernate-mapping&gt;
     &lt;subclass name="DomesticCat" extends="Cat" discriminator-value="D"&gt;
          &lt;property name="name" type="string"/&gt;
     &lt;/subclass&gt;
 &lt;/hibernate-mapping&gt;</pre><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-tableperclass"/>9.1.1. クラス階層ごとのテーブル（table-per-class-hierarchy）</h3></div></div></div><p>Suppose we have an interface <code class="literal">Payment</code> with the implementors <code class="literal">CreditCardPayment</code>, <code class="literal">CashPayment</code>, and <code class="literal">ChequePayment</code>. The table per hierarchy mapping would display in the following way: </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        &lt;property name="creditCardType" column="CCTYPE"/&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        ...
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>Exactly one table is required. There is a limitation of this mapping strategy: columns declared by the subclasses, such as <code class="literal">CCTYPE</code>, cannot have <code class="literal">NOT NULL</code> constraints. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-tablepersubclass"/>9.1.2. サブクラスごとのテーブル（table-per-subclass）</h3></div></div></div><p>A table per subclass mapping looks like this: </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;joined-subclass name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="creditCardType" column="CCTYPE"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
&lt;/class&gt;</pre><p>Four tables are required. The three subclass tables have primary key associations to the superclass table so the relational model is actually a one-to-one association. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-tablepersubclass-discriminator"/>9.1.3. Table per subclass: using a discriminator</h3></div></div></div><p>Hibernate's implementation of table per subclass does not require a discriminator column. Other object/relational mappers use a different implementation of table per subclass that requires a type discriminator column in the superclass table. The approach taken by Hibernate is much more difficult to implement, but arguably more correct from a relational point of view. If you want to use a discriminator column with the table per subclass strategy, you can combine the use of <code class="literal">&lt;subclass&gt;</code> and <code class="literal">&lt;join&gt;</code>, as follows: </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        &lt;join table="CREDIT_PAYMENT"&gt;
            &lt;key column="PAYMENT_ID"/&gt;
            &lt;property name="creditCardType" column="CCTYPE"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        &lt;join table="CASH_PAYMENT"&gt;
            &lt;key column="PAYMENT_ID"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        &lt;join table="CHEQUE_PAYMENT" fetch="select"&gt;
            &lt;key column="PAYMENT_ID"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>オプションの <code class="literal">fetch="select"</code> 宣言は、 スーパークラスのクエリ実行時に外部結合を使って、 サブクラスの <code class="literal">ChequePayment</code> データを取得しないように指定するためのものです。 </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-mixing-tableperclass-tablepersubclass"/>9.1.4. table-per-subclass と table-per-class-hierarchy の混合</h3></div></div></div><p>You can even mix the table per hierarchy and table per subclass strategies using the following approach: </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        &lt;join table="CREDIT_PAYMENT"&gt;
            &lt;property name="creditCardType" column="CCTYPE"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        ...
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>いずれのマッピング戦略であっても、ルートである <code class="literal">Payment</code> クラスへの ポリモーフィックな関連は <code class="literal">&lt;many-to-one&gt;</code> を使ってマッピングします。 </p><pre class="programlisting">&lt;many-to-one name="payment" column="PAYMENT_ID" class="Payment"/&gt;</pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-tableperconcrete"/>9.1.5. 具象クラスごとのテーブル（table-per-concrete-class）</h3></div></div></div><p>There are two ways we can map the table per concrete class strategy. First, you can use <code class="literal">&lt;union-subclass&gt;</code>. </p><pre class="programlisting">&lt;class name="Payment"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="sequence"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;union-subclass name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
        &lt;property name="creditCardType" column="CCTYPE"/&gt;
        ...
    &lt;/union-subclass&gt;
    &lt;union-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        ...
    &lt;/union-subclass&gt;
    &lt;union-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        ...
    &lt;/union-subclass&gt;
&lt;/class&gt;</pre><p>サブクラスごとに3つのテーブルが必要です。それぞれのテーブルは、継承プロパティを含んだ、 クラスの全てのプロパティに対するカラムを定義します。 </p><p>The limitation of this approach is that if a property is mapped on the superclass, the column name must be the same on all subclass tables. The identity generator strategy is not allowed in union subclass inheritance. The primary key seed has to be shared across all unioned subclasses of a hierarchy. </p><p>If your superclass is abstract, map it with <code class="literal">abstract="true"</code>. If it is not abstract, an additional table (it defaults to <code class="literal">PAYMENT</code> in the example above), is needed to hold instances of the superclass. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-tableperconcreate-polymorphism"/>9.1.6. Table per concrete class using implicit polymorphism</h3></div></div></div><p>もう一つのアプローチは暗黙的ポリモーフィズムの使用です。 </p><pre class="programlisting">&lt;class name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CREDIT_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CREDIT_AMOUNT"/&gt;
    ...
&lt;/class&gt;

&lt;class name="CashPayment" table="CASH_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CASH_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CASH_AMOUNT"/&gt;
    ...
&lt;/class&gt;

&lt;class name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CHEQUE_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CHEQUE_AMOUNT"/&gt;
    ...
&lt;/class&gt;</pre><p>Notice that the <code class="literal">Payment</code> interface is not mentioned explicitly. Also notice that properties of <code class="literal">Payment</code> are mapped in each of the subclasses. If you want to avoid duplication, consider using XML entities (for example, <code class="literal">[ &lt;!ENTITY allproperties SYSTEM "allproperties.xml"&gt; ]</code> in the <code class="literal">DOCTYPE</code> declaration and <code class="literal">&amp;allproperties;</code> in the mapping). </p><p>このアプローチの欠点は、Hibernateがポリモーフィックなクエリの実行時にSQL <code class="literal">UNION</code> を生成しない点です。 </p><p>このマッピング戦略に対しては、<code class="literal">Payment</code> へのポリモーフィックな関連は 通常、<code class="literal">&lt;any&gt;</code> を使ってマッピングされます。 </p><pre class="programlisting">&lt;any name="payment" meta-type="string" id-type="long"&gt;
    &lt;meta-value value="CREDIT" class="CreditCardPayment"/&gt;
    &lt;meta-value value="CASH" class="CashPayment"/&gt;
    &lt;meta-value value="CHEQUE" class="ChequePayment"/&gt;
    &lt;column name="PAYMENT_CLASS"/&gt;
    &lt;column name="PAYMENT_ID"/&gt;
&lt;/any&gt;</pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-mixingpolymorphism"/>9.1.7. 他の継承マッピングと暗黙的ポリモーフィズムの組み合わせ</h3></div></div></div><p>Since the subclasses are each mapped in their own <code class="literal">&lt;class&gt;</code> element, and since <code class="literal">Payment</code> is just an interface), each of the subclasses could easily be part of another inheritance hierarchy. You can still use polymorphic queries against the <code class="literal">Payment</code> interface. </p><pre class="programlisting">&lt;class name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CREDIT_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="CREDIT_CARD" type="string"/&gt;
    &lt;property name="amount" column="CREDIT_AMOUNT"/&gt;
    ...
    &lt;subclass name="MasterCardPayment" discriminator-value="MDC"/&gt;
    &lt;subclass name="VisaPayment" discriminator-value="VISA"/&gt;
&lt;/class&gt;

&lt;class name="NonelectronicTransaction" table="NONELECTRONIC_TXN"&gt;
    &lt;id name="id" type="long" column="TXN_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    ...
    &lt;joined-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="amount" column="CASH_AMOUNT"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="amount" column="CHEQUE_AMOUNT"/&gt;
        ...
    &lt;/joined-subclass&gt;
&lt;/class&gt;</pre><p>Once again, <code class="literal">Payment</code> is not mentioned explicitly. If we execute a query against the <code class="literal">Payment</code> interface, for example <code class="literal">from Payment</code>, Hibernate automatically returns instances of <code class="literal">CreditCardPayment</code> (and its subclasses, since they also implement <code class="literal">Payment</code>), <code class="literal">CashPayment</code> and <code class="literal">ChequePayment</code>, but not instances of <code class="literal">NonelectronicTransaction</code>. </p></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="inheritance-limitations"/>9.2. 制限</h2></div></div></div><p>There are limitations to the "implicit polymorphism" approach to the table per concrete-class mapping strategy. There are somewhat less restrictive limitations to <code class="literal">&lt;union-subclass&gt;</code> mappings. </p><p>次のテーブルに、Hibernateにおけるtable-per-concrete-classマッピングの 制限や暗黙的ポリモーフィズムの制限を示します。 </p><div class="table"><a id="d0e9130"/><p class="title"><b>表 9.1. 継承マッピングの機能</b></p><div class="table-contents"><table summary="継承マッピングの機能" border="1"><colgroup><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/></colgroup><thead><tr><th align="left">継承戦略</th><th align="left">多対一のポリモーフィズム</th><th align="left">一対一のポリモーフィズム</th><th align="left">一対多のポリモーフィズム</th><th align="left">多対多のポリモーフィズム</th><th align="left">Polymorphic <code class="literal">load()/get()</code></th><th align="left">ポリモーフィズムを使ったクエリ</th><th align="left">ポリモーフィズムを使った結合</th><th align="left">外部結合によるフェッチ</th></tr></thead><tbody><tr><td align="left">table per class-hierarchy</td><td align="left"><code class="literal">&lt;many-to-one&gt;</code></td><td align="left"><code class="literal">&lt;one-to-one&gt;</code></td><td align="left"><code class="literal">&lt;one-to-many&gt;</code></td><td align="left"><code class="literal">&lt;many-to-many&gt;</code></td><td align="left"><code class="literal">s.get(Payment.class, id)</code></td><td align="left"><code class="literal">from Payment p</code></td><td align="left"><code class="literal">from Order o join o.payment p</code></td><td align="left"><span class="emphasis"><em>サポート</em></span></td></tr><tr><td align="left">table per subclass</td><td align="left"><code class="literal">&lt;many-to-one&gt;</code></td><td align="left"><code class="literal">&lt;one-to-one&gt;</code></td><td align="left"><code class="literal">&lt;one-to-many&gt;</code></td><td align="left"><code class="literal">&lt;many-to-many&gt;</code></td><td align="left"><code class="literal">s.get(Payment.class, id)</code></td><td align="left"><code class="literal">from Payment p</code></td><td align="left"><code class="literal">from Order o join o.payment p</code></td><td align="left"><span class="emphasis"><em>サポート</em></span></td></tr><tr><td align="left">table per concrete-class (union-subclass)</td><td align="left"><code class="literal">&lt;many-to-one&gt;</code></td><td align="left"><code class="literal">&lt;one-to-one&gt;</code></td><td align="left"><code class="literal">&lt;one-to-many&gt;</code> (for <code class="literal">inverse="true"</code> only)</td><td align="left"><code class="literal">&lt;many-to-many&gt;</code></td><td align="left"><code class="literal">s.get(Payment.class, id)</code></td><td align="left"><code class="literal">from Payment p</code></td><td align="left"><code class="literal">from Order o join o.payment p</code></td><td align="left"><span class="emphasis"><em>サポート</em></span></td></tr><tr><td align="left">table per concrete class (implicit polymorphism)</td><td align="left"><code class="literal">&lt;any&gt;</code></td><td align="left"><span class="emphasis"><em>サポートしていません</em></span></td><td align="left"><span class="emphasis"><em>サポートしていません</em></span></td><td align="left"><code class="literal">&lt;many-to-any&gt;</code></td><td align="left"><code class="literal">s.createCriteria(Payment.class).add( Restrictions.idEq(id) ).uniqueResult()</code></td><td align="left"><code class="literal">from Payment p</code></td><td align="left"><span class="emphasis"><em>サポートしていません</em></span></td><td align="left"><span class="emphasis"><em>サポートしていません</em></span></td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate"/>第10章 オブジェクトを扱う</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#objectstate-overview">10.1. Hibernateにおけるオブジェクトの状態</a></span></dt><dt><span class="sect1"><a href="#objectstate-makingpersistent">10.2. オブジェクトを永続状態にする</a></span></dt><dt><span class="sect1"><a href="#objectstate-loading">10.3. オブジェクトのロード</a></span></dt><dt><span class="sect1"><a href="#objectstate-querying">10.4. クエリ</a></span></dt><dd><dl><dt><span class="sect2"><a href="#objectstate-querying-executing">10.4.1. クエリの実行</a></span></dt><dt><span class="sect2"><a href="#objectstate-filtering">10.4.2. コレクションのフィルタリング</a></span></dt><dt><span class="sect2"><a href="#objecstate-querying-criteria">10.4.3. クライテリアのクエリ</a></span></dt><dt><span class="sect2"><a href="#objectstate-querying-nativesql">10.4.4. ネイティブSQLのクエリ</a></span></dt></dl></dd><dt><span class="sect1"><a href="#objectstate-modifying">10.5. 永続オブジェクトの修正</a></span></dt><dt><span class="sect1"><a href="#objectstate-detached">10.6. 分離オブジェクトの修正</a></span></dt><dt><span class="sect1"><a href="#objectstate-saveorupdate">10.7. 自動的な状態検出</a></span></dt><dt><span class="sect1"><a href="#objectstate-deleting">10.8. 永続オブジェクトの削除</a></span></dt><dt><span class="sect1"><a href="#objectstate-replicating">10.9. 異なる二つのデータストア間でのオブジェクトのレプリケーション</a></span></dt><dt><span class="sect1"><a href="#objectstate-flushing">10.10. セッションのフラッシュ</a></span></dt><dt><span class="sect1"><a href="#objectstate-transitive">10.11. 連鎖的な永続化</a></span></dt><dt><span class="sect1"><a href="#objectstate-metadata">10.12. メタデータの使用</a></span></dt></dl></div><p>Hibernate is a full object/relational mapping solution that not only shields the developer from the details of the underlying database management system, but also offers <span class="emphasis"><em>state management</em></span> of objects. This is, contrary to the management of SQL <code class="literal">statements</code> in common JDBC/SQL persistence layers, a natural object-oriented view of persistence in Java applications. </p><p>言いかえれば、Hibernateを用いるアプリケーション開発者は、オブジェクトの <span class="emphasis"><em>状態</em></span> については 常に意識すべきであり、SQL文の実行については必ずしもそうではありません。 この部分は、通常、Hibernateが処理し、システムのパフォーマンスをチューニングするときにだけ、 問題になってきます。 </p><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-overview"/>10.1. Hibernateにおけるオブジェクトの状態</h2></div></div></div><p>Hibernateは次のようなオブジェクトの状態を定義し、サポートしています。 </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Transient</em></span> - an object is transient if it has just been instantiated using the <code class="literal">new</code> operator, and it is not associated with a Hibernate <code class="literal">Session</code>. It has no persistent representation in the database and no identifier value has been assigned. Transient instances will be destroyed by the garbage collector if the application does not hold a reference anymore. Use the Hibernate <code class="literal">Session</code> to make an object persistent (and let Hibernate take care of the SQL statements that need to be executed for this transition). </p></li><li><p><span class="emphasis"><em>Persistent</em></span> - a persistent instance has a representation in the database and an identifier value. It might just have been saved or loaded, however, it is by definition in the scope of a <code class="literal">Session</code>. Hibernate will detect any changes made to an object in persistent state and synchronize the state with the database when the unit of work completes. Developers do not execute manual <code class="literal">UPDATE</code> statements, or <code class="literal">DELETE</code> statements when an object should be made transient. </p></li><li><p><span class="emphasis"><em>Detached</em></span> - a detached instance is an object that has been persistent, but its <code class="literal">Session</code> has been closed. The reference to the object is still valid, of course, and the detached instance might even be modified in this state. A detached instance can be reattached to a new <code class="literal">Session</code> at a later point in time, making it (and all the modifications) persistent again. This feature enables a programming model for long running units of work that require user think-time. We call them <span class="emphasis"><em>application transactions</em></span>, i.e., a unit of work from the point of view of the user. </p></li></ul></div><p>We will now discuss the states and state transitions (and the Hibernate methods that trigger a transition) in more detail. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-makingpersistent"/>10.2. オブジェクトを永続状態にする</h2></div></div></div><p>新しくインスタンス化された永続クラスのインスタンスは、 Hibernateでは <span class="emphasis"><em>一時的(transient)</em></span> と見なされます。 以下のように、セッションと関連づけることで、一時的なインスタンスを <span class="emphasis"><em>永続状態(persistent)</em></span> にできます。 </p><pre class="programlisting">DomesticCat fritz = new DomesticCat();
fritz.setColor(Color.GINGER);
fritz.setSex('M');
fritz.setName("Fritz");
Long generatedId = (Long) sess.save(fritz);</pre><p>If <code class="literal">Cat</code> has a generated identifier, the identifier is generated and assigned to the <code class="literal">cat</code> when <code class="literal">save()</code> is called. If <code class="literal">Cat</code> has an <code class="literal">assigned</code> identifier, or a composite key, the identifier should be assigned to the <code class="literal">cat</code> instance before calling <code class="literal">save()</code>. You can also use <code class="literal">persist()</code> instead of <code class="literal">save()</code>, with the semantics defined in the EJB3 early draft. </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">persist()</code> makes a transient instance persistent. However, it does not guarantee that the identifier value will be assigned to the persistent instance immediately, the assignment might happen at flush time. <code class="literal">persist()</code> also guarantees that it will not execute an <code class="literal">INSERT</code> statement if it is called outside of transaction boundaries. This is useful in long-running conversations with an extended Session/persistence context. </p></li><li><p><code class="literal">save()</code> does guarantee to return an identifier. If an INSERT has to be executed to get the identifier ( e.g. "identity" generator, not "sequence"), this INSERT happens immediately, no matter if you are inside or outside of a transaction. This is problematic in a long-running conversation with an extended Session/persistence context. </p></li></ul></div><p>Alternatively, you can assign the identifier using an overloaded version of <code class="literal">save()</code>. </p><pre class="programlisting">DomesticCat pk = new DomesticCat();
pk.setColor(Color.TABBY);
pk.setSex('F');
pk.setName("PK");
pk.setKittens( new HashSet() );
pk.addKitten(fritz);
sess.save( pk, new Long(1234) );</pre><p>If the object you make persistent has associated objects (e.g. the <code class="literal">kittens</code> collection in the previous example), these objects can be made persistent in any order you like unless you have a <code class="literal">NOT NULL</code> constraint upon a foreign key column. There is never a risk of violating foreign key constraints. However, you might violate a <code class="literal">NOT NULL</code> constraint if you <code class="literal">save()</code> the objects in the wrong order. </p><p>Usually you do not bother with this detail, as you will normally use Hibernate's <span class="emphasis"><em>transitive persistence</em></span> feature to save the associated objects automatically. Then, even <code class="literal">NOT NULL</code> constraint violations do not occur - Hibernate will take care of everything. Transitive persistence is discussed later in this chapter. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-loading"/>10.3. オブジェクトのロード</h2></div></div></div><p>The <code class="literal">load()</code> methods of <code class="literal">Session</code> provide a way of retrieving a persistent instance if you know its identifier. <code class="literal">load()</code> takes a class object and loads the state into a newly instantiated instance of that class in a persistent state. </p><pre class="programlisting">Cat fritz = (Cat) sess.load(Cat.class, generatedId);</pre><pre class="programlisting">// you need to wrap primitive identifiers
long id = 1234;
DomesticCat pk = (DomesticCat) sess.load( DomesticCat.class, new Long(id) );</pre><p>あるいは、以下のように、既存のインスタンスに状態をロードすることもできます。 </p><pre class="programlisting">Cat cat = new DomesticCat();
// load pk's state into cat
sess.load( cat, new Long(pkId) );
Set kittens = cat.getKittens();</pre><p>Be aware that <code class="literal">load()</code> will throw an unrecoverable exception if there is no matching database row. If the class is mapped with a proxy, <code class="literal">load()</code> just returns an uninitialized proxy and does not actually hit the database until you invoke a method of the proxy. This is useful if you wish to create an association to an object without actually loading it from the database. It also allows multiple instances to be loaded as a batch if <code class="literal">batch-size</code> is defined for the class mapping. </p><p>If you are not certain that a matching row exists, you should use the <code class="literal">get()</code> method which hits the database immediately and returns null if there is no matching row. </p><pre class="programlisting">Cat cat = (Cat) sess.get(Cat.class, id);
if (cat==null) {
    cat = new Cat();
    sess.save(cat, id);
}
return cat;</pre><p>You can even load an object using an SQL <code class="literal">SELECT ... FOR UPDATE</code>, using a <code class="literal">LockMode</code>. See the API documentation for more information. </p><pre class="programlisting">Cat cat = (Cat) sess.get(Cat.class, id, LockMode.UPGRADE);</pre><p>Any associated instances or contained collections will <span class="emphasis"><em>not</em></span> be selected <code class="literal">FOR UPDATE</code>, unless you decide to specify <code class="literal">lock</code> or <code class="literal">all</code> as a cascade style for the association. </p><p><code class="literal">refresh()</code> メソッドを使うことで、どんなときでも、オブジェクトやそのコレクションを リロードすることができます。 データベースのトリガがテーブルを更新した際に、 そのテーブルに対応するオブジェクトのプロパティを同期する場合、このメソッドが役に立ちます。 </p><pre class="programlisting">sess.save(cat);
sess.flush(); //force the SQL INSERT
sess.refresh(cat); //re-read the state (after the trigger executes)</pre><p>How much does Hibernate load from the database and how many SQL <code class="literal">SELECT</code>s will it use? This depends on the <span class="emphasis"><em>fetching strategy</em></span>. This is explained in <a href="#performance-fetching" title="19.1. フェッチ戦略">項19.1. 「フェッチ戦略」</a>. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-querying"/>10.4. クエリ</h2></div></div></div><p>If you do not know the identifiers of the objects you are looking for, you need a query. Hibernate supports an easy-to-use but powerful object oriented query language (HQL). For programmatic query creation, Hibernate supports a sophisticated Criteria and Example query feature (QBC and QBE). You can also express your query in the native SQL of your database, with optional support from Hibernate for result set conversion into objects. </p><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="objectstate-querying-executing"/>10.4.1. クエリの実行</h3></div></div></div><p>HQLやネイティブなSQLクエリは、 <code class="literal">org.hibernate.Query</code> のインスタンスとして表現されます。 このインタフェースは、パラメータバインディングやResultSetのハンドリングや クエリの実行を行うメソッドを用意しています。 通常、 <code class="literal">Query</code> は、以下に示すように、 その時点の <code class="literal">Session</code> を使って取得します。 </p><pre class="programlisting">List cats = session.createQuery(
    "from Cat as cat where cat.birthdate &lt; ?")
    .setDate(0, date)
    .list();

List mothers = session.createQuery(
    "select mother from Cat as cat join cat.mother as mother where cat.name = ?")
    .setString(0, name)
    .list();

List kittens = session.createQuery(
    "from Cat as cat where cat.mother = ?")
    .setEntity(0, pk)
    .list();

Cat mother = (Cat) session.createQuery(
    "select cat.mother from Cat as cat where cat = ?")
    .setEntity(0, izi)
    .uniqueResult();]]

Query mothersWithKittens = (Cat) session.createQuery(
    "select mother from Cat as mother left join fetch mother.kittens");
Set uniqueMothers = new HashSet(mothersWithKittens.list());</pre><p>A query is usually executed by invoking <code class="literal">list()</code>. The result of the query will be loaded completely into a collection in memory. Entity instances retrieved by a query are in a persistent state. The <code class="literal">uniqueResult()</code> method offers a shortcut if you know your query will only return a single object. Queries that make use of eager fetching of collections usually return duplicates of the root objects, but with their collections initialized. You can filter these duplicates through a <code class="literal">Set</code>. </p><div class="sect3" lang="ja-JP"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-iterate"/>10.4.1.1. 結果をイテレートする</h4></div></div></div><p>Occasionally, you might be able to achieve better performance by executing the query using the <code class="literal">iterate()</code> method. This will usually be the case if you expect that the actual entity instances returned by the query will already be in the session or second-level cache. If they are not already cached, <code class="literal">iterate()</code> will be slower than <code class="literal">list()</code> and might require many database hits for a simple query, usually <span class="emphasis"><em>1</em></span> for the initial select which only returns identifiers, and <span class="emphasis"><em>n</em></span> additional selects to initialize the actual instances. </p><pre class="programlisting">// fetch ids
Iterator iter = sess.createQuery("from eg.Qux q order by q.likeliness").iterate();
while ( iter.hasNext() ) {
    Qux qux = (Qux) iter.next();  // fetch the object
    // something we couldnt express in the query
    if ( qux.calculateComplicatedAlgorithm() ) {
        // delete the current instance
        iter.remove();
        // dont need to process the rest
        break;
    }
}</pre></div><div class="sect3" lang="ja-JP"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-tuples"/>10.4.1.2. オブジェクトの組（tuple）を返すクエリ</h4></div></div></div><p>Hibernate queries sometimes return tuples of objects. Each tuple is returned as an array: </p><pre class="programlisting">Iterator kittensAndMothers = sess.createQuery(
            "select kitten, mother from Cat kitten join kitten.mother mother")
            .list()
            .iterator();

while ( kittensAndMothers.hasNext() ) {
    Object[] tuple = (Object[]) kittensAndMothers.next();
    Cat kitten = (Cat) tuple[0];
    Cat mother = (Cat) tuple[1];
    ....
}</pre></div><div class="sect3" lang="ja-JP"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-scalar"/>10.4.1.3. スカラーの結果</h4></div></div></div><p>Queries can specify a property of a class in the <code class="literal">select</code> clause. They can even call SQL aggregate functions. Properties or aggregates are considered "scalar" results and not entities in persistent state. </p><pre class="programlisting">Iterator results = sess.createQuery(
        "select cat.color, min(cat.birthdate), count(cat) from Cat cat " +
        "group by cat.color")
        .list()
        .iterator();

while ( results.hasNext() ) {
    Object[] row = (Object[]) results.next();
    Color type = (Color) row[0];
    Date oldest = (Date) row[1];
    Integer count = (Integer) row[2];
    .....
}</pre></div><div class="sect3" lang="ja-JP"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-parameters"/>10.4.1.4. パラメータのバインド</h4></div></div></div><p>Methods on <code class="literal">Query</code> are provided for binding values to named parameters or JDBC-style <code class="literal">?</code> parameters. <span class="emphasis"><em>Contrary to JDBC, Hibernate numbers parameters from zero.</em></span> Named parameters are identifiers of the form <code class="literal">:name</code> in the query string. The advantages of named parameters are as follows: </p><div class="itemizedlist"><ul compact="compact"><li><p>名前付きパラメータは、クエリ文字列に登場する順番と無関係です </p></li><li><p>they can occur multiple times in the same query </p></li><li><p>自分自身を説明します </p></li></ul></div><pre class="programlisting">//named parameter (preferred)
Query q = sess.createQuery("from DomesticCat cat where cat.name = :name");
q.setString("name", "Fritz");
Iterator cats = q.iterate();</pre><pre class="programlisting">//positional parameter
Query q = sess.createQuery("from DomesticCat cat where cat.name = ?");
q.setString(0, "Izi");
Iterator cats = q.iterate();</pre><pre class="programlisting">//named parameter list
List names = new ArrayList();
names.add("Izi");
names.add("Fritz");
Query q = sess.createQuery("from DomesticCat cat where cat.name in (:namesList)");
q.setParameterList("namesList", names);
List cats = q.list();</pre></div><div class="sect3" lang="ja-JP"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-pagination"/>10.4.1.5. ページ分け</h4></div></div></div><p>If you need to specify bounds upon your result set, that is, the maximum number of rows you want to retrieve and/or the first row you want to retrieve, you can use methods of the <code class="literal">Query</code> interface: </p><pre class="programlisting">Query q = sess.createQuery("from DomesticCat cat");
q.setFirstResult(20);
q.setMaxResults(10);
List cats = q.list();</pre><p>制限付きのクエリをDBMSのネイティブなSQLに変換する方法を、Hibernateは知っています。 </p></div><div class="sect3" lang="ja-JP"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-scrolling"/>10.4.1.6. スクロール可能なイテレーション</h4></div></div></div><p>If your JDBC driver supports scrollable <code class="literal">ResultSet</code>s, the <code class="literal">Query</code> interface can be used to obtain a <code class="literal">ScrollableResults</code> object that allows flexible navigation of the query results. </p><pre class="programlisting">Query q = sess.createQuery("select cat.name, cat from DomesticCat cat " +
                            "order by cat.name");
ScrollableResults cats = q.scroll();
if ( cats.first() ) {

    // find the first name on each page of an alphabetical list of cats by name
    firstNamesOfPages = new ArrayList();
    do {
        String name = cats.getString(0);
        firstNamesOfPages.add(name);
    }
    while ( cats.scroll(PAGE_SIZE) );

    // Now get the first page of cats
    pageOfCats = new ArrayList();
    cats.beforeFirst();
    int i=0;
    while( ( PAGE_SIZE &gt; i++ ) &amp;&amp; cats.next() ) pageOfCats.add( cats.get(1) );

}
cats.close()</pre><p>Note that an open database connection and cursor is required for this functionality. Use <code class="literal">setMaxResult()</code>/<code class="literal">setFirstResult()</code> if you need offline pagination functionality. </p></div><div class="sect3" lang="ja-JP"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-named"/>10.4.1.7. 名前付きクエリの外出し</h4></div></div></div><p>You can also define named queries in the mapping document. Remember to use a <code class="literal">CDATA</code> section if your query contains characters that could be interpreted as markup. </p><pre class="programlisting">&lt;query name="ByNameAndMaximumWeight"&gt;&lt;![CDATA[
    from eg.DomesticCat as cat
        where cat.name = ?
        and cat.weight &gt; ?
] ]&gt;&lt;/query&gt;</pre><p>パラメータのバインディングと実行は、以下のようなプログラムで行われます。 </p><pre class="programlisting">Query q = sess.getNamedQuery("ByNameAndMaximumWeight");
q.setString(0, name);
q.setInt(1, minWeight);
List cats = q.list();</pre><p>The actual program code is independent of the query language that is used. You can also define native SQL queries in metadata, or migrate existing queries to Hibernate by placing them in mapping files. </p><p>Also note that a query declaration inside a <code class="literal">&lt;hibernate-mapping&gt;</code> element requires a global unique name for the query, while a query declaration inside a <code class="literal">&lt;class&gt;</code> element is made unique automatically by prepending the fully qualified name of the class. For example <code class="literal">eg.Cat.ByNameAndMaximumWeight</code>. </p></div></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="objectstate-filtering"/>10.4.2. コレクションのフィルタリング</h3></div></div></div><p>A collection <span class="emphasis"><em>filter</em></span> is a special type of query that can be applied to a persistent collection or array. The query string can refer to <code class="literal">this</code>, meaning the current collection element. </p><pre class="programlisting">Collection blackKittens = session.createFilter(
    pk.getKittens(), 
    "where this.color = ?")
    .setParameter( Color.BLACK, Hibernate.custom(ColorUserType.class) )
    .list()
);</pre><p>The returned collection is considered a bag that is a copy of the given collection. The original collection is not modified. This is contrary to the implication of the name "filter", but consistent with expected behavior. </p><p>Observe that filters do not require a <code class="literal">from</code> clause, although they can have one if required. Filters are not limited to returning the collection elements themselves. </p><pre class="programlisting">Collection blackKittenMates = session.createFilter(
    pk.getKittens(), 
    "select this.mate where this.color = eg.Color.BLACK.intValue")
    .list();</pre><p>Even an empty filter query is useful, e.g. to load a subset of elements in a large collection: </p><pre class="programlisting">Collection tenKittens = session.createFilter(
    mother.getKittens(), "")
    .setFirstResult(0).setMaxResults(10)
    .list();</pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="objecstate-querying-criteria"/>10.4.3. クライテリアのクエリ</h3></div></div></div><p>HQL is extremely powerful, but some developers prefer to build queries dynamically using an object-oriented API, rather than building query strings. Hibernate provides an intuitive <code class="literal">Criteria</code> query API for these cases: </p><pre class="programlisting">Criteria crit = session.createCriteria(Cat.class);
crit.add( Restrictions.eq( "color", eg.Color.BLACK ) );
crit.setMaxResults(10);
List cats = crit.list();</pre><p><code class="literal">Criteria</code> と <code class="literal">Example</code> APIの詳細は、 <a href="#querycriteria" title="第15章 Criteriaクエリ">章 15. <i xmlns:xlink="http://www.w3.org/1999/xlink">Criteriaクエリ</i></a> に述べられています。 </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="objectstate-querying-nativesql"/>10.4.4. ネイティブSQLのクエリ</h3></div></div></div><p>You can express a query in SQL, using <code class="literal">createSQLQuery()</code> and let Hibernate manage the mapping from result sets to objects. You can at any time call <code class="literal">session.connection()</code> and use the JDBC <code class="literal">Connection</code> directly. If you choose to use the Hibernate API, you must enclose SQL aliases in braces: </p><pre class="programlisting">List cats = session.createSQLQuery("SELECT {cat.*} FROM CAT {cat} WHERE ROWNUM&lt;10")
    .addEntity("cat", Cat.class)
.list();</pre><pre class="programlisting">List cats = session.createSQLQuery(
    "SELECT {cat}.ID AS {cat.id}, {cat}.SEX AS {cat.sex}, " +
           "{cat}.MATE AS {cat.mate}, {cat}.SUBCLASS AS {cat.class}, ... " +
    "FROM CAT {cat} WHERE ROWNUM&lt;10")
    .addEntity("cat", Cat.class)
.list()</pre><p>SQL queries can contain named and positional parameters, just like Hibernate queries. More information about native SQL queries in Hibernate can be found in <a href="#querysql" title="第16章 ネイティブSQL">章 16. <i xmlns:xlink="http://www.w3.org/1999/xlink">ネイティブSQL</i></a>. </p></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-modifying"/>10.5. 永続オブジェクトの修正</h2></div></div></div><p><span class="emphasis"><em>Transactional persistent instances</em></span> (i.e. objects loaded, saved, created or queried by the <code class="literal">Session</code>) can be manipulated by the application, and any changes to persistent state will be persisted when the <code class="literal">Session</code> is <span class="emphasis"><em>flushed</em></span>. This is discussed later in this chapter. There is no need to call a particular method (like <code class="literal">update()</code>, which has a different purpose) to make your modifications persistent. The most straightforward way to update the state of an object is to <code class="literal">load()</code> it and then manipulate it directly while the <code class="literal">Session</code> is open: </p><pre class="programlisting">DomesticCat cat = (DomesticCat) sess.load( Cat.class, new Long(69) );
cat.setName("PK");
sess.flush();  // changes to cat are automatically detected and persisted</pre><p>Sometimes this programming model is inefficient, as it requires in the same session both an SQL <code class="literal">SELECT</code> to load an object and an SQL <code class="literal">UPDATE</code> to persist its updated state. Hibernate offers an alternate approach by using detached instances. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>重要項目</h2><p>Hibernate does not offer its own API for direct execution of <code class="literal">UPDATE</code> or <code class="literal">DELETE</code> statements. Hibernate is a <span class="emphasis"><em>state management</em></span> service, you do not have to think in <span class="emphasis"><em>statements</em></span> to use it. JDBC is a perfect API for executing SQL statements, you can get a JDBC <code class="literal">Connection</code> at any time by calling <code class="literal">session.connection()</code>. Furthermore, the notion of mass operations conflicts with object/relational mapping for online transaction processing-oriented applications. Future versions of Hibernate can, however, provide special mass operation functions. See <a href="#batch" title="第13章 ãããå¦ç">章 13. <i xmlns:xlink="http://www.w3.org/1999/xlink">ãããå¦ç</i></a> for some possible batch operation tricks. </p></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-detached"/>10.6. 分離オブジェクトの修正</h2></div></div></div><p>多くのアプリケーションでは次のことが必要になります。 それは、あるトランザクションでオブジェクトを復元し、操作するためにそれをUI層に送り、 その後に、新しいトランザクションで変更をセーブするといったことです。 並行性の高い環境で、このタイプのアプローチを使うアプリケーションでは、 "期間の長い" 作業単位の隔離性を保証するために、バージョンデータが通常使われます。 </p><p>Hibernateは、 <code class="literal">Session.update()</code> や <code class="literal">Session.merge()</code> メソッドを 使って、分離インスタンスを再追加することで、このモデルに対応します。 </p><pre class="programlisting">// in the first session
Cat cat = (Cat) firstSession.load(Cat.class, catId);
Cat potentialMate = new Cat();
firstSession.save(potentialMate);

// in a higher layer of the application
cat.setMate(potentialMate);

// later, in a new session
secondSession.update(cat);  // update cat
secondSession.update(mate); // update mate</pre><p>識別子<code class="literal">catId</code> を持つ <code class="literal">Cat</code> が、既に <code class="literal">secondSession</code> でロードされていた場合は、再追加しようとしたときに、例外が投げられます。 </p><p>Use <code class="literal">update()</code> if you are certain that the session does not contain an already persistent instance with the same identifier. Use <code class="literal">merge()</code> if you want to merge your modifications at any time without consideration of the state of the session. In other words, <code class="literal">update()</code> is usually the first method you would call in a fresh session, ensuring that the reattachment of your detached instances is the first operation that is executed. </p><p>The application should individually <code class="literal">update()</code> detached instances that are reachable from the given detached instance <span class="emphasis"><em>only</em></span> if it wants their state to be updated. This can be automated using <span class="emphasis"><em>transitive persistence</em></span>. See <a href="#objectstate-transitive" title="10.11. 連鎖的な永続化">項10.11. 「連鎖的な永続化」</a> for more information. </p><p>The <code class="literal">lock()</code> method also allows an application to reassociate an object with a new session. However, the detached instance has to be unmodified. </p><pre class="programlisting">//just reassociate:
sess.lock(fritz, LockMode.NONE);
//do a version check, then reassociate:
sess.lock(izi, LockMode.READ);
//do a version check, using SELECT ... FOR UPDATE, then reassociate:
sess.lock(pk, LockMode.UPGRADE);</pre><p>Note that <code class="literal">lock()</code> can be used with various <code class="literal">LockMode</code>s. See the API documentation and the chapter on transaction handling for more information. Reattachment is not the only usecase for <code class="literal">lock()</code>. </p><p>期間の長い作業単位の、その他のモデルは、??? で述べています。 </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-saveorupdate"/>10.7. 自動的な状態検出</h2></div></div></div><p>Hibernateのユーザは次の2つのケースのどちらにも使える汎用的なメソッドを要求していました。 それは、新しい識別子を生成して一時的なインスタンスをセーブすることと、 その時点の識別子と関連づいている分離インスタンスを更新/再追加することのできるメソッドです。 <code class="literal">saveOrUpdate()</code> はこのような機能を実現したメソッドです。 </p><pre class="programlisting">// in the first session
Cat cat = (Cat) firstSession.load(Cat.class, catID);

// in a higher tier of the application
Cat mate = new Cat();
cat.setMate(mate);

// later, in a new session
secondSession.saveOrUpdate(cat);   // update existing state (cat has a non-null id)
secondSession.saveOrUpdate(mate);  // save the new instance (mate has a null id)</pre><p><code class="literal">saveOrUpdate()</code> の使用方法と意味は、 新しいユーザにとって混乱を招くかもしれません。 まず第一に、あるセッションで使用したインスタンスを別の新しいセッションで使おうとしない限り、 <code class="literal">update()</code> や <code class="literal">saveOrUpdate()</code> や <code class="literal">merge()</code> を使う必要はありません。 アプリケーション全体を通じて、これらのメソッドを全く使わないこともあります。 </p><p>通常、 <code class="literal">update()</code> や <code class="literal">saveOrUpdate()</code> は次のシナリオで 使われます。 </p><div class="itemizedlist"><ul compact="compact"><li><p>アプリケーションが最初のセッションでオブジェクトをロードします。 </p></li><li><p>オブジェクトがUI層に送られます。 </p></li><li><p>オブジェクトに対して変更が加えられます。 </p></li><li><p>オブジェクトがビジネスロジック層に送られます。 </p></li><li><p>アプリケーションは、2番目のセッションで <code class="literal">update()</code> を呼ぶことで、これらの変更を永続化します。 </p></li></ul></div><p><code class="literal">saveOrUpdate()</code> は以下のことを行います。 </p><div class="itemizedlist"><ul compact="compact"><li><p>オブジェクトがこのセッションで、すでに永続化されていれば、何もしません。 </p></li><li><p>そのセッションに関連づいている別のオブジェクトが同じ識別子を持っているなら、 例外を投げます。 </p></li><li><p>オブジェクトの識別子が値を持たないならば、 <code class="literal">save()</code> します。 </p></li><li><p>オブジェクトの識別子が値を持ち、その値が新たにインスタンス化されたオブジェクトのための値である場合、 そのオブジェクトを <code class="literal">save()</code> します。 </p></li><li><p>if the object is versioned by a <code class="literal">&lt;version&gt;</code> or <code class="literal">&lt;timestamp&gt;</code>, and the version property value is the same value assigned to a newly instantiated object, <code class="literal">save()</code> it </p></li><li><p>そうでない場合は、そのオブジェクトを <code class="literal">update()</code> します。 </p></li></ul></div><p>そして、 <code class="literal">merge()</code> は以下のようにとても異なります。 </p><div class="itemizedlist"><ul compact="compact"><li><p>同じ識別子を持つ永続化インスタンスがその時点でセッションと関連付いているならば、 引数で受け取ったオブジェクトの状態を永続化インスタンスにコピーします。 </p></li><li><p>永続化インスタンスがその時点でセッションに関連付いていないなら、 データベースからそれをロードするか、あるいは、新しい永続化インスタンスを作成します。 </p></li><li><p>永続化インスタンスが返されます。 </p></li><li><p>引数として与えたインスタンスはセッションと関連を持ちません。 それは、分離状態のままです。 </p></li></ul></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-deleting"/>10.8. 永続オブジェクトの削除</h2></div></div></div><p><code class="literal">Session.delete()</code> will remove an object's state from the database. Your application, however, can still hold a reference to a deleted object. It is best to think of <code class="literal">delete()</code> as making a persistent instance, transient. </p><pre class="programlisting">sess.delete(cat);</pre><p>You can delete objects in any order, without risk of foreign key constraint violations. It is still possible to violate a <code class="literal">NOT NULL</code> constraint on a foreign key column by deleting objects in the wrong order, e.g. if you delete the parent, but forget to delete the children. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-replicating"/>10.9. 異なる二つのデータストア間でのオブジェクトのレプリケーション</h2></div></div></div><p>It is sometimes useful to be able to take a graph of persistent instances and make them persistent in a different datastore, without regenerating identifier values. </p><pre class="programlisting">//retrieve a cat from one database
Session session1 = factory1.openSession();
Transaction tx1 = session1.beginTransaction();
Cat cat = session1.get(Cat.class, catId);
tx1.commit();
session1.close();

//reconcile with a second database
Session session2 = factory2.openSession();
Transaction tx2 = session2.beginTransaction();
session2.replicate(cat, ReplicationMode.LATEST_VERSION);
tx2.commit();
session2.close();</pre><p>The <code class="literal">ReplicationMode</code> determines how <code class="literal">replicate()</code> will deal with conflicts with existing rows in the database: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">ReplicationMode.IGNORE</code>: ignores the object when there is an existing database row with the same identifier </p></li><li><p><code class="literal">ReplicationMode.OVERWRITE</code>: overwrites any existing database row with the same identifier </p></li><li><p><code class="literal">ReplicationMode.EXCEPTION</code>: throws an exception if there is an existing database row with the same identifier </p></li><li><p><code class="literal">ReplicationMode.LATEST_VERSION</code>: overwrites the row if its version number is earlier than the version number of the object, or ignore the object otherwise </p></li></ul></div><p>次のようなケースで、この機能を使用します。 異なるデータベースインスタンスに入れられたデータの同期、 製品更新時におけるシステム設定情報の更新、非ACIDトランザクションのなかで加えられた変更のロールバックなどです。 </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-flushing"/>10.10. セッションのフラッシュ</h2></div></div></div><p>Sometimes the <code class="literal">Session</code> will execute the SQL statements needed to synchronize the JDBC connection's state with the state of objects held in memory. This process, called <span class="emphasis"><em>flush</em></span>, occurs by default at the following points: </p><div class="itemizedlist"><ul compact="compact"><li><p>クエリを実行する前 </p></li><li><p><code class="literal">org.hibernate.Transaction.commit()</code> を実行したとき </p></li><li><p><code class="literal">Session.flush()</code> を実行したとき </p></li></ul></div><p>The SQL statements are issued in the following order: </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>all entity insertions in the same order the corresponding objects were saved using <code class="literal">Session.save()</code> </p></li><li><p>すべてのエンティティの更新 </p></li><li><p>すべてのコレクションの削除 </p></li><li><p>すべてのコレクションの要素に対する削除、更新、挿入 </p></li><li><p>すべてのコレクションの挿入 </p></li><li><p>all entity deletions in the same order the corresponding objects were deleted using <code class="literal">Session.delete()</code> </p></li></ol></div><p>An exception is that objects using <code class="literal">native</code> ID generation are inserted when they are saved. </p><p>Except when you explicitly <code class="literal">flush()</code>, there are absolutely no guarantees about <span class="emphasis"><em>when</em></span> the <code class="literal">Session</code> executes the JDBC calls, only the <span class="emphasis"><em>order</em></span> in which they are executed. However, Hibernate does guarantee that the <code class="literal">Query.list(..)</code> will never return stale or incorrect data. </p><p>It is possible to change the default behavior so that flush occurs less frequently. The <code class="literal">FlushMode</code> class defines three different modes: only flush at commit time when the Hibernate <code class="literal">Transaction</code> API is used, flush automatically using the explained routine, or never flush unless <code class="literal">flush()</code> is called explicitly. The last mode is useful for long running units of work, where a <code class="literal">Session</code> is kept open and disconnected for a long time (see <a href="#transactions-optimistic-longsession" title="11.3.2. 拡張セッションと自動バージョニング">項11.3.2. 「拡張セッションと自動バージョニング」</a>). </p><pre class="programlisting">sess = sf.openSession();
Transaction tx = sess.beginTransaction();
sess.setFlushMode(FlushMode.COMMIT); // allow queries to return stale state

Cat izi = (Cat) sess.load(Cat.class, id);
izi.setName(iznizi);

// might return stale data
sess.find("from Cat as cat left outer join cat.kittens kitten");

// change to izi is not flushed!
...
tx.commit(); // flush occurs
sess.close();</pre><p>フラッシュのとき、例外が発生するかもしれません。 （例えば、DML操作が制約を違反するような場合です。） 例外処理を理解するためには、Hibernateのトランザクションの振る舞いを理解する必要があるため、 <a href="#transactions" title="第11章 Transactions and Concurrency">章 11. <i xmlns:xlink="http://www.w3.org/1999/xlink">Transactions and Concurrency</i></a> で説明します。 </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-transitive"/>10.11. 連鎖的な永続化</h2></div></div></div><p>個々のオブジェクトをセーブしたり、削除したり、再追加したりすることは かなり面倒です。特に、関連するオブジェクトを扱うような場合には際立ちます。 よくあるのは、親子関係を扱うケースです。 以下の例を考えてみましょう。 </p><p>If the children in a parent/child relationship would be value typed (e.g. a collection of addresses or strings), their life cycle would depend on the parent and no further action would be required for convenient "cascading" of state changes. When the parent is saved, the value-typed child objects are saved and when the parent is deleted, the children will be deleted, etc. This works for operations such as the removal of a child from the collection. Since value-typed objects cannot have shared references, Hibernate will detect this and delete the child from the database. </p><p>Now consider the same scenario with parent and child objects being entities, not value-types (e.g. categories and items, or parent and child cats). Entities have their own life cycle and support shared references. Removing an entity from the collection does not mean it can be deleted), and there is by default no cascading of state from one entity to any other associated entities. Hibernate does not implement <span class="emphasis"><em>persistence by reachability</em></span> by default. </p><p>HibernateのSessionの基本操作（ <code class="literal">persist(), merge(), saveOrUpdate(), delete(), lock(), refresh(), evict(), replicate()</code> が含まれます）に対して、 それぞれに対応するカスケードスタイルがあります。 それぞれのカスケードスタイルには、 <code class="literal">create, merge, save-update, delete, lock, refresh, evict, replicate</code> という名前がついています。 もし、関連に沿ってカスケードさせたい操作があるなら、マッピングファイルにそう指定しなければなりません。 例えば、以下のようにします。 </p><pre class="programlisting">&lt;one-to-one name="person" cascade="persist"/&gt;</pre><p>カスケードスタイルは、組み合わせることができます。 </p><pre class="programlisting">&lt;one-to-one name="person" cascade="persist,delete,lock"/&gt;</pre><p>You can even use <code class="literal">cascade="all"</code> to specify that <span class="emphasis"><em>all</em></span> operations should be cascaded along the association. The default <code class="literal">cascade="none"</code> specifies that no operations are to be cascaded. </p><p>特殊なカスケードスタイル <code class="literal">delete-orphan</code> は、一対多関連にだけ 適用できます。 これは、関連から削除された子供のオブジェクトに対して、 <code class="literal">delete()</code> 操作が適用されることを意味します。 </p><p>おすすめ： </p><div class="itemizedlist"><ul compact="compact"><li><p>It does not usually make sense to enable cascade on a <code class="literal">&lt;many-to-one&gt;</code> or <code class="literal">&lt;many-to-many&gt;</code> association. Cascade is often useful for <code class="literal">&lt;one-to-one&gt;</code> and <code class="literal">&lt;one-to-many&gt;</code> associations. </p></li><li><p>子供オブジェクトの寿命が親オブジェクトの寿命に制限を受けるならば、 <code class="literal">cascade="all,delete-orphan"</code> を指定し、 子供オブジェクトを <span class="emphasis"><em>ライフサイクルオブジェクト</em></span> にします。 </p></li><li><p>. それ以外の場合は、カスケードはほとんど必要ないでしょう。 しかし、同じトランザクションのなかで親と子が一緒に動作することが多いと思い、 いくらかのコードを書く手間を省きたいのであれば、 <code class="literal">cascade="persist,merge,save-update"</code> を使うことを考えましょう。 </p></li></ul></div><p><code class="literal">cascade="all"</code> でマッピングした関連（単値関連やコレクション）は、 <span class="emphasis"><em>親子</em></span> スタイルの関連とマークされます。 それは、親のセーブ/更新/削除が、子のセーブ/更新/削除を引き起こす関係のことです。 </p><p>Furthermore, a mere reference to a child from a persistent parent will result in save/update of the child. This metaphor is incomplete, however. A child which becomes unreferenced by its parent is <span class="emphasis"><em>not</em></span> automatically deleted, except in the case of a <code class="literal">&lt;one-to-many&gt;</code> association mapped with <code class="literal">cascade="delete-orphan"</code>. The precise semantics of cascading operations for a parent/child relationship are as follows: </p><div class="itemizedlist"><ul compact="compact"><li><p>親が <code class="literal">persist()</code> に渡されたならば、 すべての子は <code class="literal">persist()</code> に渡されます。 </p></li><li><p><code class="literal">merge()</code> に渡されたならば、 すべての子は <code class="literal">merge()</code> に渡されます。 </p></li><li><p>親が <code class="literal">save()</code> 、 <code class="literal">update()</code> 、 <code class="literal">saveOrUpdate()</code> に渡されたならば、すべての子は <code class="literal">saveOrUpdate()</code> に渡されます。 </p></li><li><p>一時的または分離状態の子が、永続化された親に参照されたならば、 <code class="literal">saveOrUpdate()</code> に渡されます。 </p></li><li><p>親が削除されたならば、すべての子は、 <code class="literal">delete()</code> に渡されます。 </p></li><li><p>子が永続化された親から参照されなくなったときは、 <span class="emphasis"><em>特に何も起こりません</em></span> 。 よって、アプリケーションが必要であれば、明示的に削除する必要があります。 ただし、 <code class="literal">cascade="delete-orphan"</code> の場合を除きます。 この場合、「親のない」子は削除されます。 </p></li></ul></div><p>Finally, note that cascading of operations can be applied to an object graph at <span class="emphasis"><em>call time</em></span> or at <span class="emphasis"><em>flush time</em></span>. All operations, if enabled, are cascaded to associated entities reachable when the operation is executed. However, <code class="literal">save-update</code> and <code class="literal">delete-orphan</code> are transitive for all associated entities reachable during flush of the <code class="literal">Session</code>. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-metadata"/>10.12. メタデータの使用</h2></div></div></div><p>Hibernate requires a rich meta-level model of all entity and value types. This model can be useful to the application itself. For example, the application might use Hibernate's metadata to implement a "smart" deep-copy algorithm that understands which objects should be copied (eg. mutable value types) and which objects that should not (e.g. immutable value types and, possibly, associated entities). </p><p>Hibernate exposes metadata via the <code class="literal">ClassMetadata</code> and <code class="literal">CollectionMetadata</code> interfaces and the <code class="literal">Type</code> hierarchy. Instances of the metadata interfaces can be obtained from the <code class="literal">SessionFactory</code>. </p><pre class="programlisting">Cat fritz = ......;
ClassMetadata catMeta = sessionfactory.getClassMetadata(Cat.class);

Object[] propertyValues = catMeta.getPropertyValues(fritz);
String[] propertyNames = catMeta.getPropertyNames();
Type[] propertyTypes = catMeta.getPropertyTypes();

// get a Map of all properties which are not collections or associations
Map namedValues = new HashMap();
for ( int i=0; i&lt;propertyNames.length; i++ ) {
    if ( !propertyTypes[i].isEntityType() &amp;&amp; !propertyTypes[i].isCollectionType() ) {
        namedValues.put( propertyNames[i], propertyValues[i] );
    }
}</pre></div></div><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="transactions"/>第11章 Transactions and Concurrency</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#transactions-basics">11.1. sessionスコープとtransactionスコープ</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-basics-uow">11.1.1. 作業単位（Unit of work）</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-apptx">11.1.2. 長い対話</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-identity">11.1.3. オブジェクト識別子を考える</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-issues">11.1.4. 一般的な問題</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-demarcation">11.2. データベーストランザクション境界</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-demarcation-nonmanaged">11.2.1. 管理されていない環境</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-jta">11.2.2. JTAを使用する</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-exceptions">11.2.3. 例外ハンドリング</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-timeout">11.2.4. トランザクションのタイムアウト</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-optimistic">11.3. 楽観的同時実行制御</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-optimistic-manual">11.3.1. アプリケーションによるバージョンチェック</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-longsession">11.3.2. 拡張セッションと自動バージョニング</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-detached">11.3.3. デタッチされたオブジェクトと自動バージョニング</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-customizing">11.3.4. 自動バージョニングのカスタマイズ</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-locking">11.4. Pessimistic locking</a></span></dt><dt><span class="sect1"><a href="#transactions-connection-release">11.5. Connection release modes</a></span></dt></dl></div><p>The most important point about Hibernate and concurrency control is that it is easy to understand. Hibernate directly uses JDBC connections and JTA resources without adding any additional locking behavior. It is recommended that you spend some time with the JDBC, ANSI, and transaction isolation specification of your database management system. </p><p>Hibernate does not lock objects in memory. Your application can expect the behavior as defined by the isolation level of your database transactions. Through <code class="literal">Session</code>, which is also a transaction-scoped cache, Hibernate provides repeatable reads for lookup by identifier and entity queries and not reporting queries that return scalar values. </p><p>In addition to versioning for automatic optimistic concurrency control, Hibernate also offers, using the <code class="literal">SELECT FOR UPDATE</code> syntax, a (minor) API for pessimistic locking of rows. Optimistic concurrency control and this API are discussed later in this chapter. </p><p>The discussion of concurrency control in Hibernate begins with the granularity of <code class="literal">Configuration</code>, <code class="literal">SessionFactory</code>, and <code class="literal">Session</code>, as well as database transactions and long conversations. </p><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-basics"/>11.1. sessionスコープとtransactionスコープ</h2></div></div></div><p>A <code class="literal">SessionFactory</code> is an expensive-to-create, threadsafe object, intended to be shared by all application threads. It is created once, usually on application startup, from a <code class="literal">Configuration</code> instance. </p><p>A <code class="literal">Session</code> is an inexpensive, non-threadsafe object that should be used once and then discarded for: a single request, a conversation or a single unit of work. A <code class="literal">Session</code> will not obtain a JDBC <code class="literal">Connection</code>, or a <code class="literal">Datasource</code>, unless it is needed. It will not consume any resources until used. </p><p>In order to reduce lock contention in the database, a database transaction has to be as short as possible. Long database transactions will prevent your application from scaling to a highly concurrent load. It is not recommended that you hold a database transaction open during user think time until the unit of work is complete. </p><p>What is the scope of a unit of work? Can a single Hibernate <code class="literal">Session</code> span several database transactions, or is this a one-to-one relationship of scopes? When should you open and close a <code class="literal">Session</code> and how do you demarcate the database transaction boundaries? These questions are addressed in the following sections. </p><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-uow"/>11.1.1. 作業単位（Unit of work）</h3></div></div></div><p>First, let's define a unit of work. A unit of work is a design pattern described by Martin Fowler as 「<span class="quote"> [maintaining] a list of objects affected by a business transaction and coordinates the writing out of changes and the resolution of concurrency problems. </span>」[<a href="#biblio-PoEAA"><span class="citation">PoEAA</span></a>] In other words, its a series of operations we wish to carry out against the database together. Basically, it is a transaction, though fulfilling a unit of work will often span multiple physical database transactions (see <a href="#transactions-basics-apptx" title="11.1.2. 長い対話">項11.1.2. 「長い対話」</a>). So really we are talking about a more abstract notion of a transaction. The term "business transaction" is also sometimes used in lieu of unit of work. </p><p>Do not use the <span class="emphasis"><em>session-per-operation</em></span> antipattern: do not open and close a <code class="literal">Session</code> for every simple database call in a single thread. The same is true for database transactions. Database calls in an application are made using a planned sequence; they are grouped into atomic units of work. This also means that auto-commit after every single SQL statement is useless in an application as this mode is intended for ad-hoc SQL console work. Hibernate disables, or expects the application server to disable, auto-commit mode immediately. Database transactions are never optional. All communication with a database has to occur inside a transaction. Auto-commit behavior for reading data should be avoided, as many small transactions are unlikely to perform better than one clearly defined unit of work. The latter is also more maintainable and extensible. </p><p>The most common pattern in a multi-user client/server application is <span class="emphasis"><em>session-per-request</em></span>. In this model, a request from the client is sent to the server, where the Hibernate persistence layer runs. A new Hibernate <code class="literal">Session</code> is opened, and all database operations are executed in this unit of work. On completion of the work, and once the response for the client has been prepared, the session is flushed and closed. Use a single database transaction to serve the clients request, starting and committing it when you open and close the <code class="literal">Session</code>. The relationship between the two is one-to-one and this model is a perfect fit for many applications. </p><p>The challenge lies in the implementation. Hibernate provides built-in management of the "current session" to simplify this pattern. Start a transaction when a server request has to be processed, and end the transaction before the response is sent to the client. Common solutions are <code class="literal">ServletFilter</code>, AOP interceptor with a pointcut on the service methods, or a proxy/interception container. An EJB container is a standardized way to implement cross-cutting aspects such as transaction demarcation on EJB session beans, declaratively with CMT. If you use programmatic transaction demarcation, for ease of use and code portability use the Hibernate <code class="literal">Transaction</code> API shown later in this chapter. </p><p>Your application code can access a "current session" to process the request by calling <code class="literal">sessionFactory.getCurrentSession()</code>. You will always get a <code class="literal">Session</code> scoped to the current database transaction. This has to be configured for either resource-local or JTA environments, see <a href="#architecture-current-session" title="2.5. Contextual sessions">項2.5. 「Contextual sessions」</a>. </p><p>You can extend the scope of a <code class="literal">Session</code> and database transaction until the "view has been rendered". This is especially useful in servlet applications that utilize a separate rendering phase after the request has been processed. Extending the database transaction until view rendering, is achieved by implementing your own interceptor. However, this will be difficult if you rely on EJBs with container-managed transactions. A transaction will be completed when an EJB method returns, before rendering of any view can start. See the Hibernate website and forum for tips and examples relating to this <span class="emphasis"><em>Open Session in View</em></span> pattern. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-apptx"/>11.1.2. 長い対話</h3></div></div></div><p>The session-per-request pattern is not the only way of designing units of work. Many business processes require a whole series of interactions with the user that are interleaved with database accesses. In web and enterprise applications, it is not acceptable for a database transaction to span a user interaction. Consider the following example: </p><div class="itemizedlist"><ul><li><p>The first screen of a dialog opens. The data seen by the user has been loaded in a particular <code class="literal">Session</code> and database transaction. The user is free to modify the objects. </p></li><li><p>The user clicks "Save" after 5 minutes and expects their modifications to be made persistent. The user also expects that they were the only person editing this information and that no conflicting modification has occurred. </p></li></ul></div><p>From the point of view of the user, we call this unit of work a long-running <span class="emphasis"><em>conversation</em></span> or <span class="emphasis"><em>application transaction</em></span>. There are many ways to implement this in your application. </p><p>A first naive implementation might keep the <code class="literal">Session</code> and database transaction open during user think time, with locks held in the database to prevent concurrent modification and to guarantee isolation and atomicity. This is an anti-pattern, since lock contention would not allow the application to scale with the number of concurrent users. </p><p>You have to use several database transactions to implement the conversation. In this case, maintaining isolation of business processes becomes the partial responsibility of the application tier. A single conversation usually spans several database transactions. It will be atomic if only one of these database transactions (the last one) stores the updated data. All others simply read data (for example, in a wizard-style dialog spanning several request/response cycles). This is easier to implement than it might sound, especially if you utilize some of Hibernate's features: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Automatic Versioning</em></span>: Hibernate can perform automatic optimistic concurrency control for you. It can automatically detect if a concurrent modification occurred during user think time. Check for this at the end of the conversation. </p></li><li><p><span class="emphasis"><em>Detached Objects</em></span>: if you decide to use the <span class="emphasis"><em>session-per-request</em></span> pattern, all loaded instances will be in the detached state during user think time. Hibernate allows you to reattach the objects and persist the modifications. The pattern is called <span class="emphasis"><em>session-per-request-with-detached-objects</em></span>. Automatic versioning is used to isolate concurrent modifications. </p></li><li><p><span class="emphasis"><em>Extended (or Long) Session</em></span>: the Hibernate <code class="literal">Session</code> can be disconnected from the underlying JDBC connection after the database transaction has been committed and reconnected when a new client request occurs. This pattern is known as <span class="emphasis"><em>session-per-conversation</em></span> and makes even reattachment unnecessary. Automatic versioning is used to isolate concurrent modifications and the <code class="literal">Session</code> will not be allowed to be flushed automatically, but explicitly. </p></li></ul></div><p>Both <span class="emphasis"><em>session-per-request-with-detached-objects</em></span> and <span class="emphasis"><em>session-per-conversation</em></span> have advantages and disadvantages. These disadvantages are discussed later in this chapter in the context of optimistic concurrency control. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-identity"/>11.1.3. オブジェクト識別子を考える</h3></div></div></div><p>An application can concurrently access the same persistent state in two different <code class="literal">Session</code>s. However, an instance of a persistent class is never shared between two <code class="literal">Session</code> instances. It is for this reason that there are two different notions of identity: </p><div class="variablelist"><dl><dt><span class="term">データベース識別子</span></dt><dd><p>
                            <code class="literal">foo.getId().equals( bar.getId() )</code>
                        </p></dd><dt><span class="term">JVM識別子</span></dt><dd><p>
                            <code class="literal">foo==bar</code>
                        </p></dd></dl></div><p>For objects attached to a <span class="emphasis"><em>particular</em></span> <code class="literal">Session</code> (i.e., in the scope of a <code class="literal">Session</code>), the two notions are equivalent and JVM identity for database identity is guaranteed by Hibernate. While the application might concurrently access the "same" (persistent identity) business object in two different sessions, the two instances will actually be "different" (JVM identity). Conflicts are resolved using an optimistic approach and automatic versioning at flush/commit time. </p><p>This approach leaves Hibernate and the database to worry about concurrency. It also provides the best scalability, since guaranteeing identity in single-threaded units of work means that it does not need expensive locking or other means of synchronization. The application does not need to synchronize on any business object, as long as it maintains a single thread per <code class="literal">Session</code>. Within a <code class="literal">Session</code> the application can safely use <code class="literal">==</code> to compare objects. </p><p>However, an application that uses <code class="literal">==</code> outside of a <code class="literal">Session</code> might produce unexpected results. This might occur even in some unexpected places. For example, if you put two detached instances into the same <code class="literal">Set</code>, both might have the same database identity (i.e., they represent the same row). JVM identity, however, is by definition not guaranteed for instances in a detached state. The developer has to override the <code class="literal">equals()</code> and <code class="literal">hashCode()</code> methods in persistent classes and implement their own notion of object equality. There is one caveat: never use the database identifier to implement equality. Use a business key that is a combination of unique, usually immutable, attributes. The database identifier will change if a transient object is made persistent. If the transient instance (usually together with detached instances) is held in a <code class="literal">Set</code>, changing the hashcode breaks the contract of the <code class="literal">Set</code>. Attributes for business keys do not have to be as stable as database primary keys; you only have to guarantee stability as long as the objects are in the same <code class="literal">Set</code>. See the Hibernate website for a more thorough discussion of this issue. Please note that this is not a Hibernate issue, but simply how Java object identity and equality has to be implemented. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-issues"/>11.1.4. 一般的な問題</h3></div></div></div><p>Do not use the anti-patterns <span class="emphasis"><em>session-per-user-session</em></span> or <span class="emphasis"><em>session-per-application</em></span> (there are, however, rare exceptions to this rule). Some of the following issues might also arise within the recommended patterns, so ensure that you understand the implications before making a design decision: </p><div class="itemizedlist"><ul><li><p>A <code class="literal">Session</code> is not thread-safe. Things that work concurrently, like HTTP requests, session beans, or Swing workers, will cause race conditions if a <code class="literal">Session</code> instance is shared. If you keep your Hibernate <code class="literal">Session</code> in your <code class="literal">HttpSession</code> (this is discussed later in the chapter), you should consider synchronizing access to your Http session. Otherwise, a user that clicks reload fast enough can use the same <code class="literal">Session</code> in two concurrently running threads. </p></li><li><p>An exception thrown by Hibernate means you have to rollback your database transaction and close the <code class="literal">Session</code> immediately (this is discussed in more detail later in the chapter). If your <code class="literal">Session</code> is bound to the application, you have to stop the application. Rolling back the database transaction does not put your business objects back into the state they were at the start of the transaction. This means that the database state and the business objects will be out of sync. Usually this is not a problem, because exceptions are not recoverable and you will have to start over after rollback anyway. </p></li><li><p>The <code class="literal">Session</code> caches every object that is in a persistent state (watched and checked for dirty state by Hibernate). If you keep it open for a long time or simply load too much data, it will grow endlessly until you get an OutOfMemoryException. One solution is to call <code class="literal">clear()</code> and <code class="literal">evict()</code> to manage the <code class="literal">Session</code> cache, but you should consider a Stored Procedure if you need mass data operations. Some solutions are shown in <a href="#batch" title="第13章 ãããå¦ç">章 13. <i xmlns:xlink="http://www.w3.org/1999/xlink">ãããå¦ç</i></a>. Keeping a <code class="literal">Session</code> open for the duration of a user session also means a higher probability of stale data. </p></li></ul></div></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-demarcation"/>11.2. データベーストランザクション境界</h2></div></div></div><p>Database, or system, transaction boundaries are always necessary. No communication with the database can occur outside of a database transaction (this seems to confuse many developers who are used to the auto-commit mode). Always use clear transaction boundaries, even for read-only operations. Depending on your isolation level and database capabilities this might not be required, but there is no downside if you always demarcate transactions explicitly. Certainly, a single database transaction is going to perform better than many small transactions, even for reading data. </p><p>A Hibernate application can run in non-managed (i.e., standalone, simple Web- or Swing applications) and managed J2EE environments. In a non-managed environment, Hibernate is usually responsible for its own database connection pool. The application developer has to manually set transaction boundaries (begin, commit, or rollback database transactions) themselves. A managed environment usually provides container-managed transactions (CMT), with the transaction assembly defined declaratively (in deployment descriptors of EJB session beans, for example). Programmatic transaction demarcation is then no longer necessary. </p><p>However, it is often desirable to keep your persistence layer portable between non-managed resource-local environments, and systems that can rely on JTA but use BMT instead of CMT. In both cases use programmatic transaction demarcation. Hibernate offers a wrapper API called <code class="literal">Transaction</code> that translates into the native transaction system of your deployment environment. This API is actually optional, but we strongly encourage its use unless you are in a CMT session bean. </p><p>Ending a <code class="literal">Session</code> usually involves four distinct phases: </p><div class="itemizedlist"><ul compact="compact"><li><p>セッションのフラッシュ </p></li><li><p>トランザクションのコミット </p></li><li><p>セッションのクローズ </p></li><li><p>例外のハンドリング </p></li></ul></div><p>We discussed Flushing the session earlier, so we will now have a closer look at transaction demarcation and exception handling in both managed and non-managed environments. </p><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-nonmanaged"/>11.2.1. 管理されていない環境</h3></div></div></div><p>If a Hibernate persistence layer runs in a non-managed environment, database connections are usually handled by simple (i.e., non-DataSource) connection pools from which Hibernate obtains connections as needed. The session/transaction handling idiom looks like this: </p><pre class="programlisting">// Non-managed environment idiom
Session sess = factory.openSession();
Transaction tx = null;
try {
    tx = sess.beginTransaction();

    // do some work
    ...

    tx.commit();
}
catch (RuntimeException e) {
    if (tx != null) tx.rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}</pre><p>You do not have to <code class="literal">flush()</code> the <code class="literal">Session</code> explicitly: the call to <code class="literal">commit()</code> automatically triggers the synchronization depending on the <a href="#objectstate-flushing" title="10.10. セッションのフラッシュ">FlushMode</a> for the session. A call to <code class="literal">close()</code> marks the end of a session. The main implication of <code class="literal">close()</code> is that the JDBC connection will be relinquished by the session. This Java code is portable and runs in both non-managed and JTA environments. </p><p>As outlined earlier, a much more flexible solution is Hibernate's built-in "current session" context management: </p><pre class="programlisting">// Non-managed environment idiom with getCurrentSession()
try {
    factory.getCurrentSession().beginTransaction();

    // do some work
    ...

    factory.getCurrentSession().getTransaction().commit();
}
catch (RuntimeException e) {
    factory.getCurrentSession().getTransaction().rollback();
    throw e; // or display error message
}</pre><p>You will not see these code snippets in a regular application; fatal (system) exceptions should always be caught at the "top". In other words, the code that executes Hibernate calls in the persistence layer, and the code that handles <code class="literal">RuntimeException</code> (and usually can only clean up and exit), are in different layers. The current context management by Hibernate can significantly simplify this design by accessing a <code class="literal">SessionFactory</code>. Exception handling is discussed later in this chapter. </p><p>You should select <code class="literal">org.hibernate.transaction.JDBCTransactionFactory</code>, which is the default, and for the second example select <code class="literal">"thread"</code> as your <code class="literal">hibernate.current_session_context_class</code>. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-jta"/>11.2.2. JTAを使用する</h3></div></div></div><p>If your persistence layer runs in an application server (for example, behind EJB session beans), every datasource connection obtained by Hibernate will automatically be part of the global JTA transaction. You can also install a standalone JTA implementation and use it without EJB. Hibernate offers two strategies for JTA integration. </p><p>If you use bean-managed transactions (BMT), Hibernate will tell the application server to start and end a BMT transaction if you use the <code class="literal">Transaction</code> API. The transaction management code is identical to the non-managed environment. </p><pre class="programlisting">// BMT idiom
Session sess = factory.openSession();
Transaction tx = null;
try {
    tx = sess.beginTransaction();

    // do some work
    ...

    tx.commit();
}
catch (RuntimeException e) {
    if (tx != null) tx.rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}</pre><p>If you want to use a transaction-bound <code class="literal">Session</code>, that is, the <code class="literal">getCurrentSession()</code> functionality for easy context propagation, use the JTA <code class="literal">UserTransaction</code> API directly: </p><pre class="programlisting">// BMT idiom with getCurrentSession()
try {
    UserTransaction tx = (UserTransaction)new InitialContext()
                            .lookup("java:comp/UserTransaction");

    tx.begin();

    // Do some work on Session bound to transaction
    factory.getCurrentSession().load(...);
    factory.getCurrentSession().persist(...);

    tx.commit();
}
catch (RuntimeException e) {
    tx.rollback();
    throw e; // or display error message
}</pre><p>With CMT, transaction demarcation is completed in session bean deployment descriptors, not programmatically. The code is reduced to: </p><pre class="programlisting">// CMT idiom
 Session sess = factory.getCurrentSession();

 // do some work
 ...
</pre><p>In a CMT/EJB, even rollback happens automatically. An unhandled <code class="literal">RuntimeException</code> thrown by a session bean method tells the container to set the global transaction to rollback. <span class="emphasis"><em>You do not need to use the Hibernate <code class="literal">Transaction</code> API at all with BMT or CMT, and you get automatic propagation of the "current" Session bound to the transaction.</em></span> </p><p>When configuring Hibernate's transaction factory, choose <code class="literal">org.hibernate.transaction.JTATransactionFactory</code> if you use JTA directly (BMT), and <code class="literal">org.hibernate.transaction.CMTTransactionFactory</code> in a CMT session bean. Remember to also set <code class="literal">hibernate.transaction.manager_lookup_class</code>. Ensure that your <code class="literal">hibernate.current_session_context_class</code> is either unset (backwards compatibility), or is set to <code class="literal">"jta"</code>. </p><p>The <code class="literal">getCurrentSession()</code> operation has one downside in a JTA environment. There is one caveat to the use of <code class="literal">after_statement</code> connection release mode, which is then used by default. Due to a limitation of the JTA spec, it is not possible for Hibernate to automatically clean up any unclosed <code class="literal">ScrollableResults</code> or <code class="literal">Iterator</code> instances returned by <code class="literal">scroll()</code> or <code class="literal">iterate()</code>. You <span class="emphasis"><em>must</em></span> release the underlying database cursor by calling <code class="literal">ScrollableResults.close()</code> or <code class="literal">Hibernate.close(Iterator)</code> explicitly from a <code class="literal">finally</code> block. Most applications can easily avoid using <code class="literal">scroll()</code> or <code class="literal">iterate()</code> from the JTA or CMT code.) </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-exceptions"/>11.2.3. 例外ハンドリング</h3></div></div></div><p>If the <code class="literal">Session</code> throws an exception, including any <code class="literal">SQLException</code>, immediately rollback the database transaction, call <code class="literal">Session.close()</code> and discard the <code class="literal">Session</code> instance. Certain methods of <code class="literal">Session</code> will <span class="emphasis"><em>not</em></span> leave the session in a consistent state. No exception thrown by Hibernate can be treated as recoverable. Ensure that the <code class="literal">Session</code> will be closed by calling <code class="literal">close()</code> in a <code class="literal">finally</code> block. </p><p>The <code class="literal">HibernateException</code>, which wraps most of the errors that can occur in a Hibernate persistence layer, is an unchecked exception. It was not in older versions of Hibernate. In our opinion, we should not force the application developer to catch an unrecoverable exception at a low layer. In most systems, unchecked and fatal exceptions are handled in one of the first frames of the method call stack (i.e., in higher layers) and either an error message is presented to the application user or some other appropriate action is taken. Note that Hibernate might also throw other unchecked exceptions that are not a <code class="literal">HibernateException</code>. These are not recoverable and appropriate action should be taken. </p><p>Hibernate wraps <code class="literal">SQLException</code>s thrown while interacting with the database in a <code class="literal">JDBCException</code>. In fact, Hibernate will attempt to convert the exception into a more meaningful subclass of <code class="literal">JDBCException</code>. The underlying <code class="literal">SQLException</code> is always available via <code class="literal">JDBCException.getCause()</code>. Hibernate converts the <code class="literal">SQLException</code> into an appropriate <code class="literal">JDBCException</code> subclass using the <code class="literal">SQLExceptionConverter</code> attached to the <code class="literal">SessionFactory</code>. By default, the <code class="literal">SQLExceptionConverter</code> is defined by the configured dialect. However, it is also possible to plug in a custom implementation. See the javadocs for the <code class="literal">SQLExceptionConverterFactory</code> class for details. The standard <code class="literal">JDBCException</code> subtypes are: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">JDBCConnectionException</code>: indicates an error with the underlying JDBC communication. </p></li><li><p><code class="literal">SQLGrammarException</code>: indicates a grammar or syntax problem with the issued SQL. </p></li><li><p><code class="literal">ConstraintViolationException</code>: indicates some form of integrity constraint violation. </p></li><li><p><code class="literal">LockAcquisitionException</code>: indicates an error acquiring a lock level necessary to perform the requested operation. </p></li><li><p><code class="literal">GenericJDBCException</code>: a generic exception which did not fall into any of the other categories. </p></li></ul></div></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-timeout"/>11.2.4. トランザクションのタイムアウト</h3></div></div></div><p>An important feature provided by a managed environment like EJB, that is never provided for non-managed code, is transaction timeout. Transaction timeouts ensure that no misbehaving transaction can indefinitely tie up resources while returning no response to the user. Outside a managed (JTA) environment, Hibernate cannot fully provide this functionality. However, Hibernate can at least control data access operations, ensuring that database level deadlocks and queries with huge result sets are limited by a defined timeout. In a managed environment, Hibernate can delegate transaction timeout to JTA. This functionality is abstracted by the Hibernate <code class="literal">Transaction</code> object. </p><pre class="programlisting">
Session sess = factory.openSession();
try {
    //set transaction timeout to 3 seconds
    sess.getTransaction().setTimeout(3);
    sess.getTransaction().begin();

    // do some work
    ...

    sess.getTransaction().commit()
}
catch (RuntimeException e) {
    sess.getTransaction().rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}</pre><p><code class="literal">setTimeout()</code> cannot be called in a CMT bean, where transaction timeouts must be defined declaratively. </p></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-optimistic"/>11.3. 楽観的同時実行制御</h2></div></div></div><p>The only approach that is consistent with high concurrency and high scalability, is optimistic concurrency control with versioning. Version checking uses version numbers, or timestamps, to detect conflicting updates and to prevent lost updates. Hibernate provides three possible approaches to writing application code that uses optimistic concurrency. The use cases we discuss are in the context of long conversations, but version checking also has the benefit of preventing lost updates in single database transactions. </p><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-manual"/>11.3.1. アプリケーションによるバージョンチェック</h3></div></div></div><p>In an implementation without much help from Hibernate, each interaction with the database occurs in a new <code class="literal">Session</code> and the developer is responsible for reloading all persistent instances from the database before manipulating them. The application is forced to carry out its own version checking to ensure conversation transaction isolation. This approach is the least efficient in terms of database access. It is the approach most similar to entity EJBs. </p><pre class="programlisting">// foo is an instance loaded by a previous Session
session = factory.openSession();
Transaction t = session.beginTransaction();

int oldVersion = foo.getVersion();
session.load( foo, foo.getKey() ); // load the current state
if ( oldVersion != foo.getVersion() ) throw new StaleObjectStateException();
foo.setProperty("bar");

t.commit();
session.close();</pre><p><code class="literal">&lt;version&gt;</code> を使って、<code class="literal">version</code> プロパティをマッピングします。 Hibernateは、エンティティがダーティである場合、フラッシュし、 その間に <code class="literal">version</code> プロパティを自動的にインクリメントします。 </p><p>If you are operating in a low-data-concurrency environment, and do not require version checking, you can use this approach and skip the version check. In this case, <span class="emphasis"><em>last commit wins</em></span> is the default strategy for long conversations. Be aware that this might confuse the users of the application, as they might experience lost updates without error messages or a chance to merge conflicting changes. </p><p>Manual version checking is only feasible in trivial circumstances and not practical for most applications. Often not only single instances, but complete graphs of modified objects, have to be checked. Hibernate offers automatic version checking with either an extended <code class="literal">Session</code> or detached instances as the design paradigm. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-longsession"/>11.3.2. 拡張セッションと自動バージョニング</h3></div></div></div><p>A single <code class="literal">Session</code> instance and its persistent instances that are used for the whole conversation are known as <span class="emphasis"><em>session-per-conversation</em></span>. Hibernate checks instance versions at flush time, throwing an exception if concurrent modification is detected. It is up to the developer to catch and handle this exception. Common options are the opportunity for the user to merge changes or to restart the business conversation with non-stale data. </p><p>The <code class="literal">Session</code> is disconnected from any underlying JDBC connection when waiting for user interaction. This approach is the most efficient in terms of database access. The application does not version check or reattach detached instances, nor does it have to reload instances in every database transaction. </p><pre class="programlisting">// foo is an instance loaded earlier by the old session
Transaction t = session.beginTransaction(); // Obtain a new JDBC connection, start transaction

foo.setProperty("bar");

session.flush();    // Only for last transaction in conversation
t.commit();         // Also return JDBC connection
session.close();    // Only for last transaction in conversation</pre><p>The <code class="literal">foo</code> object knows which <code class="literal">Session</code> it was loaded in. Beginning a new database transaction on an old session obtains a new connection and resumes the session. Committing a database transaction disconnects a session from the JDBC connection and returns the connection to the pool. After reconnection, to force a version check on data you are not updating, you can call <code class="literal">Session.lock()</code> with <code class="literal">LockMode.READ</code> on any objects that might have been updated by another transaction. You do not need to lock any data that you <span class="emphasis"><em>are</em></span> updating. Usually you would set <code class="literal">FlushMode.MANUAL</code> on an extended <code class="literal">Session</code>, so that only the last database transaction cycle is allowed to actually persist all modifications made in this conversation. Only this last database transaction will include the <code class="literal">flush()</code> operation, and then <code class="literal">close()</code> the session to end the conversation. </p><p>This pattern is problematic if the <code class="literal">Session</code> is too big to be stored during user think time (for example, an <code class="literal">HttpSession</code> should be kept as small as possible). As the <code class="literal">Session</code> is also the first-level cache and contains all loaded objects, we can probably use this strategy only for a few request/response cycles. Use a <code class="literal">Session</code> only for a single conversation as it will soon have stale data. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Earlier versions of Hibernate required explicit disconnection and reconnection of a <code class="literal">Session</code>. These methods are deprecated, as beginning and ending a transaction has the same effect. </p></div><p>Keep the disconnected <code class="literal">Session</code> close to the persistence layer. Use an EJB stateful session bean to hold the <code class="literal">Session</code> in a three-tier environment. Do not transfer it to the web layer, or even serialize it to a separate tier, to store it in the <code class="literal">HttpSession</code>. </p><p>The extended session pattern, or <span class="emphasis"><em>session-per-conversation</em></span>, is more difficult to implement with automatic current session context management. You need to supply your own implementation of the <code class="literal">CurrentSessionContext</code> for this. See the Hibernate Wiki for examples. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-detached"/>11.3.3. デタッチされたオブジェクトと自動バージョニング</h3></div></div></div><p>新しい <code class="literal">Session</code>により、永続化ストア（訳注：ＤＢ）との対話が発生します。 また一方、同じ永続性インスタンスが、データベースとの対話ごとに再利用されます。 アプリケーションは、元々は他の <code class="literal">Session</code> でロードされ、 デタッチされたインスタンスの状態を操作します。 そして、<code class="literal">Session.update()</code> もしくは、<code class="literal">Session.saveOrUpdate()</code>、 <code class="literal">Session.merge()</code> を使って、それらのインスタンスを再追加します。 </p><pre class="programlisting">// foo is an instance loaded by a previous Session
foo.setProperty("bar");
session = factory.openSession();
Transaction t = session.beginTransaction();
session.saveOrUpdate(foo); // Use merge() if "foo" might have been loaded already
t.commit();
session.close();</pre><p>Again, Hibernate will check instance versions during flush, throwing an exception if conflicting updates occurred. </p><p>You can also call <code class="literal">lock()</code> instead of <code class="literal">update()</code>, and use <code class="literal">LockMode.READ</code> (performing a version check and bypassing all caches) if you are sure that the object has not been modified. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-customizing"/>11.3.4. 自動バージョニングのカスタマイズ</h3></div></div></div><p>You can disable Hibernate's automatic version increment for particular properties and collections by setting the <code class="literal">optimistic-lock</code> mapping attribute to <code class="literal">false</code>. Hibernate will then no longer increment versions if the property is dirty. </p><p>Legacy database schemas are often static and cannot be modified. Or, other applications might access the same database and will not know how to handle version numbers or even timestamps. In both cases, versioning cannot rely on a particular column in a table. To force a version check with a comparison of the state of all fields in a row but without a version or timestamp property mapping, turn on <code class="literal">optimistic-lock="all"</code> in the <code class="literal">&lt;class&gt;</code> mapping. This conceptually only works if Hibernate can compare the old and the new state (i.e., if you use a single long <code class="literal">Session</code> and not session-per-request-with-detached-objects). </p><p>Concurrent modification can be permitted in instances where the changes that have been made do not overlap. If you set <code class="literal">optimistic-lock="dirty"</code> when mapping the <code class="literal">&lt;class&gt;</code>, Hibernate will only compare dirty fields during flush. </p><p>In both cases, with dedicated version/timestamp columns or with a full/dirty field comparison, Hibernate uses a single <code class="literal">UPDATE</code> statement, with an appropriate <code class="literal">WHERE</code> clause, per entity to execute the version check and update the information. If you use transitive persistence to cascade reattachment to associated entities, Hibernate may execute unnecessary updates. This is usually not a problem, but <span class="emphasis"><em>on update</em></span> triggers in the database might be executed even when no changes have been made to detached instances. You can customize this behavior by setting <code class="literal">select-before-update="true"</code> in the <code class="literal">&lt;class&gt;</code> mapping, forcing Hibernate to <code class="literal">SELECT</code> the instance to ensure that changes did occur before updating the row. </p></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-locking"/>11.4. Pessimistic locking</h2></div></div></div><p>It is not intended that users spend much time worrying about locking strategies. It is usually enough to specify an isolation level for the JDBC connections and then simply let the database do all the work. However, advanced users may wish to obtain exclusive pessimistic locks or re-obtain locks at the start of a new transaction. </p><p>Hibernate will always use the locking mechanism of the database; it never lock objects in memory. </p><p>The <code class="literal">LockMode</code> class defines the different lock levels that can be acquired by Hibernate. A lock is obtained by the following mechanisms: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">LockMode.WRITE</code> は、 Hibernateが行を更新もしくは挿入する際に自動的に得られます。 </p></li><li><p><code class="literal">LockMode.UPGRADE</code> can be acquired upon explicit user request using <code class="literal">SELECT ... FOR UPDATE</code> on databases which support that syntax. </p></li><li><p><code class="literal">LockMode.UPGRADE_NOWAIT</code> can be acquired upon explicit user request using a <code class="literal">SELECT ... FOR UPDATE NOWAIT</code> under Oracle. </p></li><li><p><code class="literal">LockMode.READ</code> is acquired automatically when Hibernate reads data under Repeatable Read or Serializable isolation level. It can be re-acquired by explicit user request. </p></li><li><p><code class="literal">LockMode.NONE</code> は、ロックしないことを表します。 <code class="literal">Transaction</code> の終わりに、 すべてのオブジェクトはこのロックモードに切り替わります。 <code class="literal">update()</code> や <code class="literal">saveOrUpdate()</code> を呼び出すことによって、 セッションに関連付けられたオブジェクトも、このロックモードで出発します。 </p></li></ul></div><p>「明示的なユーザー要求」とは、下記の方法の１つで言い表せます。 </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">LockMode</code> を指定した <code class="literal">Session.load()</code> の呼び出し。 </p></li><li><p><code class="literal">Session.lock()</code> の呼び出し。 </p></li><li><p><code class="literal">Query.setLockMode()</code> の呼び出し。 </p></li></ul></div><p><code class="literal">UPGRADE</code> もしくは <code class="literal">UPGRADE_NOWAIT</code> が指定された <code class="literal">Session.load()</code> が呼び出され、 かつ要求されたオブジェクトがセッションによってまだロードされていなかった場合は、 <code class="literal">SELECT ... FOR UPDATE</code> を使って、オブジェクトがロードされます。 <code class="literal">load()</code> で呼び出されたオブジェクトが、 要求されているより制限が少ないロックですでにロードされていた場合は、 Hibernateはそのオブジェクトのために、<code class="literal">lock()</code> を呼び出します。 </p><p><code class="literal">Session.lock()</code> performs a version number check if the specified lock mode is <code class="literal">READ</code>, <code class="literal">UPGRADE</code> or <code class="literal">UPGRADE_NOWAIT</code>. In the case of <code class="literal">UPGRADE</code> or <code class="literal">UPGRADE_NOWAIT</code>, <code class="literal">SELECT ... FOR UPDATE</code> is used. </p><p>If the requested lock mode is not supported by the database, Hibernate uses an appropriate alternate mode instead of throwing an exception. This ensures that applications are portable. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-connection-release"/>11.5. Connection release modes</h2></div></div></div><p>One of the legacies of Hibernate 2.x JDBC connection management meant that a <code class="literal">Session</code> would obtain a connection when it was first required and then maintain that connection until the session was closed. Hibernate 3.x introduced the notion of connection release modes that would instruct a session how to handle its JDBC connections. The following discussion is pertinent only to connections provided through a configured <code class="literal">ConnectionProvider</code>. User-supplied connections are outside the breadth of this discussion. The different release modes are identified by the enumerated values of <code class="literal">org.hibernate.ConnectionReleaseMode</code>: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">ON_CLOSE</code>: is the legacy behavior described above. The Hibernate session obtains a connection when it first needs to perform some JDBC access and maintains that connection until the session is closed. </p></li><li><p><code class="literal">AFTER_TRANSACTION</code>: releases connections after a <code class="literal">org.hibernate.Transaction</code> has been completed. </p></li><li><p><code class="literal">AFTER_STATEMENT</code> (also referred to as aggressive release): releases connections after every statement execution. This aggressive releasing is skipped if that statement leaves open resources associated with the given session. Currently the only situation where this occurs is through the use of <code class="literal">org.hibernate.ScrollableResults</code>. </p></li></ul></div><p>The configuration parameter <code class="literal">hibernate.connection.release_mode</code> is used to specify which release mode to use. The possible values are as follows: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">auto</code> (the default): this choice delegates to the release mode returned by the <code class="literal">org.hibernate.transaction.TransactionFactory.getDefaultReleaseMode()</code> method. For JTATransactionFactory, this returns ConnectionReleaseMode.AFTER_STATEMENT; for JDBCTransactionFactory, this returns ConnectionReleaseMode.AFTER_TRANSACTION. Do not change this default behavior as failures due to the value of this setting tend to indicate bugs and/or invalid assumptions in user code. </p></li><li><p><code class="literal">on_close</code>: uses ConnectionReleaseMode.ON_CLOSE. This setting is left for backwards compatibility, but its use is discouraged. </p></li><li><p><code class="literal">after_transaction</code>: uses ConnectionReleaseMode.AFTER_TRANSACTION. This setting should not be used in JTA environments. Also note that with ConnectionReleaseMode.AFTER_TRANSACTION, if a session is considered to be in auto-commit mode, connections will be released as if the release mode were AFTER_STATEMENT. </p></li><li><p><code class="literal">after_statement</code>: uses ConnectionReleaseMode.AFTER_STATEMENT. Additionally, the configured <code class="literal">ConnectionProvider</code> is consulted to see if it supports this setting (<code class="literal">supportsAggressiveRelease()</code>). If not, the release mode is reset to ConnectionReleaseMode.AFTER_TRANSACTION. This setting is only safe in environments where we can either re-acquire the same underlying JDBC connection each time you make a call into <code class="literal">ConnectionProvider.getConnection()</code> or in auto-commit environments where it does not matter if we re-establish the same connection. </p></li></ul></div></div></div><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="events"/>第12章 インターセプタとイベント</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#objectstate-interceptors">12.1. インターセプタ</a></span></dt><dt><span class="sect1"><a href="#objectstate-events">12.2. イベントシステム</a></span></dt><dt><span class="sect1"><a href="#objectstate-decl-security">12.3. Hibernateの宣言的なセキュリティ</a></span></dt></dl></div><p>It is useful for the application to react to certain events that occur inside Hibernate. This allows for the implementation of generic functionality and the extension of Hibernate functionality. </p><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-interceptors"/>12.1. インターセプタ</h2></div></div></div><p>The <code class="literal">Interceptor</code> interface provides callbacks from the session to the application, allowing the application to inspect and/or manipulate properties of a persistent object before it is saved, updated, deleted or loaded. One possible use for this is to track auditing information. For example, the following <code class="literal">Interceptor</code> automatically sets the <code class="literal">createTimestamp</code> when an <code class="literal">Auditable</code> is created and updates the <code class="literal">lastUpdateTimestamp</code> property when an <code class="literal">Auditable</code> is updated. </p><p>You can either implement <code class="literal">Interceptor</code> directly or extend <code class="literal">EmptyInterceptor</code>. </p><pre class="programlisting">package org.hibernate.test;

import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;

import org.hibernate.EmptyInterceptor;
import org.hibernate.Transaction;
import org.hibernate.type.Type;

public class AuditInterceptor extends EmptyInterceptor {

    private int updates;
    private int creates;
    private int loads;

    public void onDelete(Object entity,
                         Serializable id,
                         Object[] state,
                         String[] propertyNames,
                         Type[] types) {
        // do nothing
    }

    public boolean onFlushDirty(Object entity,
                                Serializable id,
                                Object[] currentState,
                                Object[] previousState,
                                String[] propertyNames,
                                Type[] types) {

        if ( entity instanceof Auditable ) {
            updates++;
            for ( int i=0; i &lt; propertyNames.length; i++ ) {
                if ( "lastUpdateTimestamp".equals( propertyNames[i] ) ) {
                    currentState[i] = new Date();
                    return true;
                }
            }
        }
        return false;
    }

    public boolean onLoad(Object entity,
                          Serializable id,
                          Object[] state,
                          String[] propertyNames,
                          Type[] types) {
        if ( entity instanceof Auditable ) {
            loads++;
        }
        return false;
    }

    public boolean onSave(Object entity,
                          Serializable id,
                          Object[] state,
                          String[] propertyNames,
                          Type[] types) {

        if ( entity instanceof Auditable ) {
            creates++;
            for ( int i=0; i&lt;propertyNames.length; i++ ) {
                if ( "createTimestamp".equals( propertyNames[i] ) ) {
                    state[i] = new Date();
                    return true;
                }
            }
        }
        return false;
    }

    public void afterTransactionCompletion(Transaction tx) {
        if ( tx.wasCommitted() ) {
            System.out.println("Creations: " + creates + ", Updates: " + updates, "Loads: " + loads);
        }
        updates=0;
        creates=0;
        loads=0;
    }

}</pre><p>There are two kinds of inteceptors: <code class="literal">Session</code>-scoped and <code class="literal">SessionFactory</code>-scoped. </p><p><code class="literal">Session</code> スコープのインターセプタは、 セッションをオープンするときに指定します。 <code class="literal">Interceptor</code> を引数に取るSessionFactory.openSession() のオーバーロードメソッドの一つを使います。 </p><pre class="programlisting">Session session = sf.openSession( new AuditInterceptor() );</pre><p>A <code class="literal">SessionFactory</code>-scoped interceptor is registered with the <code class="literal">Configuration</code> object prior to building the <code class="literal">SessionFactory</code>. Unless a session is opened explicitly specifying the interceptor to use, the supplied interceptor will be applied to all sessions opened from that <code class="literal">SessionFactory</code>. <code class="literal">SessionFactory</code>-scoped interceptors must be thread safe. Ensure that you do not store session-specific states, since multiple sessions will use this interceptor potentially concurrently. </p><pre class="programlisting">new Configuration().setInterceptor( new AuditInterceptor() );</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-events"/>12.2. イベントシステム</h2></div></div></div><p>If you have to react to particular events in your persistence layer, you can also use the Hibernate3 <span class="emphasis"><em>event</em></span> architecture. The event system can be used in addition, or as a replacement, for interceptors. </p><p>All the methods of the <code class="literal">Session</code> interface correlate to an event. You have a <code class="literal">LoadEvent</code>, a <code class="literal">FlushEvent</code>, etc. Consult the XML configuration-file DTD or the <code class="literal">org.hibernate.event</code> package for the full list of defined event types. When a request is made of one of these methods, the Hibernate <code class="literal">Session</code> generates an appropriate event and passes it to the configured event listeners for that type. Out-of-the-box, these listeners implement the same processing in which those methods always resulted. However, you are free to implement a customization of one of the listener interfaces (i.e., the <code class="literal">LoadEvent</code> is processed by the registered implementation of the <code class="literal">LoadEventListener</code> interface), in which case their implementation would be responsible for processing any <code class="literal">load()</code> requests made of the <code class="literal">Session</code>. </p><p>The listeners should be considered singletons. This means they are shared between requests, and should not save any state as instance variables. </p><p>A custom listener implements the appropriate interface for the event it wants to process and/or extend one of the convenience base classes (or even the default event listeners used by Hibernate out-of-the-box as these are declared non-final for this purpose). Custom listeners can either be registered programmatically through the <code class="literal">Configuration</code> object, or specified in the Hibernate configuration XML. Declarative configuration through the properties file is not supported. Here is an example of a custom load event listener: </p><pre class="programlisting">public class MyLoadListener implements LoadEventListener {
    // this is the single method defined by the LoadEventListener interface
    public void onLoad(LoadEvent event, LoadEventListener.LoadType loadType)
            throws HibernateException {
        if ( !MySecurity.isAuthorized( event.getEntityClassName(), event.getEntityId() ) ) {
            throw MySecurityException("Unauthorized access");
        }
    }
}</pre><p>デフォルトリスナ以外のリスナを使うには、Hibernateへの設定も必要です： </p><pre class="programlisting">&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
        ...
        &lt;event type="load"&gt;
            &lt;listener class="com.eg.MyLoadListener"/&gt;
            &lt;listener class="org.hibernate.event.def.DefaultLoadEventListener"/&gt;
        &lt;/event&gt;
    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;</pre><p>Instead, you can register it programmatically: </p><pre class="programlisting">Configuration cfg = new Configuration();
LoadEventListener[] stack = { new MyLoadListener(), new DefaultLoadEventListener() };
cfg.EventListeners().setLoadEventListeners(stack);</pre><p>Listeners registered declaratively cannot share instances. If the same class name is used in multiple <code class="literal">&lt;listener/&gt;</code> elements, each reference will result in a separate instance of that class. If you need to share listener instances between listener types you must use the programmatic registration approach. </p><p>Why implement an interface and define the specific type during configuration? A listener implementation could implement multiple event listener interfaces. Having the type additionally defined during registration makes it easier to turn custom listeners on or off during configuration. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-decl-security"/>12.3. Hibernateの宣言的なセキュリティ</h2></div></div></div><p>Usually, declarative security in Hibernate applications is managed in a session facade layer. Hibernate3 allows certain actions to be permissioned via JACC, and authorized via JAAS. This is an optional functionality that is built on top of the event architecture. </p><p>まず最初に、適切なイベントリスナを設定してJAAS認証を使えるようにしなければなりません。 </p><pre class="programlisting">&lt;listener type="pre-delete" class="org.hibernate.secure.JACCPreDeleteEventListener"/&gt;
&lt;listener type="pre-update" class="org.hibernate.secure.JACCPreUpdateEventListener"/&gt;
&lt;listener type="pre-insert" class="org.hibernate.secure.JACCPreInsertEventListener"/&gt;
&lt;listener type="pre-load" class="org.hibernate.secure.JACCPreLoadEventListener"/&gt;</pre><p>Note that <code class="literal">&lt;listener type="..." class="..."/&gt;</code> is shorthand for <code class="literal">&lt;event type="..."&gt;&lt;listener class="..."/&gt;&lt;/event&gt;</code> when there is exactly one listener for a particular event type. </p><p>Next, while still in <code class="literal">hibernate.cfg.xml</code>, bind the permissions to roles: </p><pre class="programlisting">&lt;grant role="admin" entity-name="User" actions="insert,update,read"/&gt;
&lt;grant role="su" entity-name="User" actions="*"/&gt;</pre><p>このロール名は使用するJACCプロバイダに理解されるロールです。 </p></div></div><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="batch"/>第13章 ãããå¦ç</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#batch-inserts">13.1. ãããæ¿å¥</a></span></dt><dt><span class="sect1"><a href="#batch-update">13.2. ãããæ´æ°</a></span></dt><dt><span class="sect1"><a href="#batch-statelesssession">13.3. StatelessSessionã¤ã³ã¿ã¼ãã§ã¤ã¹</a></span></dt><dt><span class="sect1"><a href="#batch-direct">13.4. DMLã¹ã¿ã¤ã«ã®æä½</a></span></dt></dl></div><p>A naive approach to inserting 100,000 rows in the database using Hibernate might look like this: </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
for ( int i=0; i&lt;100000; i++ ) {
    Customer customer = new Customer(.....);
    session.save(customer);
}
tx.commit();
session.close();</pre><p>This would fall over with an <code class="literal">OutOfMemoryException</code> somewhere around the 50,000th row. That is because Hibernate caches all the newly inserted <code class="literal">Customer</code> instances in the session-level cache. In this chapter we will show you how to avoid this problem. </p><p>If you are undertaking batch processing you will need to enable the use of JDBC batching. This is absolutely essential if you want to achieve optimal performance. Set the JDBC batch size to a reasonable number (10-50, for example): </p><pre class="programlisting">hibernate.jdbc.batch_size 20</pre><p><a id="disablebatching"/>Hibernate disables insert batching at the JDBC level transparently if you use an <code class="literal">identity</code> identifier generator. </p><p>You can also do this kind of work in a process where interaction with the second-level cache is completely disabled: </p><pre class="programlisting">hibernate.cache.use_second_level_cache false</pre><p>ããããããã¯çµ¶å¯¾ã«å¿è¦ã¨ããããã§ã¯ããã¾ããã ãªããªãæç¤ºçã« <code class="literal">CacheMode</code> ãè¨­å®ãã¦ã äºæ¬¡ã­ã£ãã·ã¥ã¨ã®ç¸äºä½ç¨ãç¡å¹ã«ãããã¨ãã§ããããã§ãã </p><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="batch-inserts"/>13.1. ãããæ¿å¥</h2></div></div></div><p>When making new objects persistent <code class="literal">flush()</code> and then <code class="literal">clear()</code> the session regularly in order to control the size of the first-level cache. </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
   
for ( int i=0; i&lt;100000; i++ ) {
    Customer customer = new Customer(.....);
    session.save(customer);
    if ( i % 20 == 0 ) { //20, same as the JDBC batch size
        //flush a batch of inserts and release memory:
        session.flush();
        session.clear();
    }
}
   
tx.commit();
session.close();</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="batch-update"/>13.2. ãããæ´æ°</h2></div></div></div><p>For retrieving and updating data, the same ideas apply. In addition, you need to use <code class="literal">scroll()</code> to take advantage of server-side cursors for queries that return many rows of data. </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
   
ScrollableResults customers = session.getNamedQuery("GetCustomers")
    .setCacheMode(CacheMode.IGNORE)
    .scroll(ScrollMode.FORWARD_ONLY);
int count=0;
while ( customers.next() ) {
    Customer customer = (Customer) customers.get(0);
    customer.updateStuff(...);
    if ( ++count % 20 == 0 ) {
        //flush a batch of updates and release memory:
        session.flush();
        session.clear();
    }
}
   
tx.commit();
session.close();</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="batch-statelesssession"/>13.3. StatelessSessionã¤ã³ã¿ã¼ãã§ã¤ã¹</h2></div></div></div><p>Alternatively, Hibernate provides a command-oriented API that can be used for streaming data to and from the database in the form of detached objects. A <code class="literal">StatelessSession</code> has no persistence context associated with it and does not provide many of the higher-level life cycle semantics. In particular, a stateless session does not implement a first-level cache nor interact with any second-level or query cache. It does not implement transactional write-behind or automatic dirty checking. Operations performed using a stateless session never cascade to associated instances. Collections are ignored by a stateless session. Operations performed via a stateless session bypass Hibernate's event model and interceptors. Due to the lack of a first-level cache, Stateless sessions are vulnerable to data aliasing effects. A stateless session is a lower-level abstraction that is much closer to the underlying JDBC. </p><pre class="programlisting">StatelessSession session = sessionFactory.openStatelessSession();
Transaction tx = session.beginTransaction();
   
ScrollableResults customers = session.getNamedQuery("GetCustomers")
    .scroll(ScrollMode.FORWARD_ONLY);
while ( customers.next() ) {
    Customer customer = (Customer) customers.get(0);
    customer.updateStuff(...);
    session.update(customer);
}
   
tx.commit();
session.close();</pre><p>In this code example, the <code class="literal">Customer</code> instances returned by the query are immediately detached. They are never associated with any persistence context. </p><p>The <code class="literal">insert(), update()</code> and <code class="literal">delete()</code> operations defined by the <code class="literal">StatelessSession</code> interface are considered to be direct database row-level operations. They result in the immediate execution of a SQL <code class="literal">INSERT, UPDATE</code> or <code class="literal">DELETE</code> respectively. They have different semantics to the <code class="literal">save(), saveOrUpdate()</code> and <code class="literal">delete()</code> operations defined by the <code class="literal">Session</code> interface. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="batch-direct"/>13.4. DMLã¹ã¿ã¤ã«ã®æä½</h2></div></div></div><p>As already discussed, automatic and transparent object/relational mapping is concerned with the management of the object state. The object state is available in memory. This means that manipulating data directly in the database (using the SQL <code class="literal">Data Manipulation Language</code> (DML) the statements: <code class="literal">INSERT</code>, <code class="literal">UPDATE</code>, <code class="literal">DELETE</code>) will not affect in-memory state. However, Hibernate provides methods for bulk SQL-style DML statement execution that is performed through the Hibernate Query Language (<a href="#queryhql" title="第14章 HQL: The Hibernate Query Language">HQL</a>). </p><p>The pseudo-syntax for <code class="literal">UPDATE</code> and <code class="literal">DELETE</code> statements is: <code class="literal">( UPDATE | DELETE ) FROM? EntityName (WHERE where_conditions)?</code>. </p><p>Some points to note: </p><div class="itemizedlist"><ul compact="compact"><li><p>fromç¯ã«ããã¦ãFROMã­ã¼ã¯ã¼ãã¯ãªãã·ã§ã³ã§ãã </p></li><li><p>There can only be a single entity named in the from-clause. It can, however, be aliased. If the entity name is aliased, then any property references must be qualified using that alias. If the entity name is not aliased, then it is illegal for any property references to be qualified. </p></li><li><p>No <a href="#queryhql-joins-forms" title="14.4. 結合構文の形式">joins</a>, either implicit or explicit, can be specified in a bulk HQL query. Sub-queries can be used in the where-clause, where the subqueries themselves may contain joins. </p></li><li><p>whereç¯ã¯ãªãã·ã§ã³ã§ãã </p></li></ul></div><p>As an example, to execute an HQL <code class="literal">UPDATE</code>, use the <code class="literal">Query.executeUpdate()</code> method. The method is named for those familiar with JDBC's <code class="literal">PreparedStatement.executeUpdate()</code>: </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

String hqlUpdate = "update Customer c set c.name = :newName where c.name = :oldName";
// or String hqlUpdate = "update Customer set name = :newName where name = :oldName";
int updatedEntities = s.createQuery( hqlUpdate )
        .setString( "newName", newName )
        .setString( "oldName", oldName )
        .executeUpdate();
tx.commit();
session.close();</pre><p>In keeping with the EJB3 specification, HQL <code class="literal">UPDATE</code> statements, by default, do not effect the <a href="#mapping-declaration-version" title="5.1.9. Version (optional)">version</a> or the <a href="#mapping-declaration-timestamp" title="5.1.10. Timestamp (optional)">timestamp</a> property values for the affected entities. However, you can force Hibernate to reset the <code class="literal">version</code> or <code class="literal">timestamp</code> property values through the use of a <code class="literal">versioned update</code>. This is achieved by adding the <code class="literal">VERSIONED</code> keyword after the <code class="literal">UPDATE</code> keyword. </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
String hqlVersionedUpdate = "update versioned Customer set name = :newName where name = :oldName";
int updatedEntities = s.createQuery( hqlUpdate )
        .setString( "newName", newName )
        .setString( "oldName", oldName )
        .executeUpdate();
tx.commit();
session.close();</pre><p>Custom version types, <code class="literal">org.hibernate.usertype.UserVersionType</code>, are not allowed in conjunction with a <code class="literal">update versioned</code> statement. </p><p>HQLã® <code class="literal">DELETE</code> ãå®è¡ããã«ã¯ã åã <code class="literal">Query.executeUpdate()</code> ã¡ã½ãããä½¿ã£ã¦ãã ããï¼ </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

String hqlDelete = "delete Customer c where c.name = :oldName";
// or String hqlDelete = "delete Customer where name = :oldName";
int deletedEntities = s.createQuery( hqlDelete )
        .setString( "oldName", oldName )
        .executeUpdate();
tx.commit();
session.close();</pre><p>The <code class="literal">int</code> value returned by the <code class="literal">Query.executeUpdate()</code> method indicates the number of entities effected by the operation. This may or may not correlate to the number of rows effected in the database. An HQL bulk operation might result in multiple actual SQL statements being executed (for joined-subclass, for example). The returned number indicates the number of actual entities affected by the statement. Going back to the example of joined-subclass, a delete against one of the subclasses may actually result in deletes against not just the table to which that subclass is mapped, but also the "root" table and potentially joined-subclass tables further down the inheritance hierarchy. </p><p><code class="literal">INSERT</code> æã®çä¼¼æ§æã¯ï¼ <code class="literal">INSERT INTO ã¨ã³ãã£ãã£å ãã­ããã£ãªã¹ã selectæ</code> ã§ãã æ³¨æãã¹ãç¹ãããã¤ãããã¾ãï¼ </p><div class="itemizedlist"><ul compact="compact"><li><p>INSERT INTO ... SELECT ... ã®å½¢å¼ã ãããµãã¼ãããã¦ãã¾ãã INSERT INTO ... VALUES ... ã®å½¢å¼ã¯ãµãã¼ãããã¦ãã¾ããã </p><p>The properties_list is analogous to the <code class="literal">column specification</code> in the SQL <code class="literal">INSERT</code> statement. For entities involved in mapped inheritance, only properties directly defined on that given class-level can be used in the properties_list. Superclass properties are not allowed and subclass properties do not make sense. In other words, <code class="literal">INSERT</code> statements are inherently non-polymorphic. </p></li><li><p>select_statement can be any valid HQL select query, with the caveat that the return types must match the types expected by the insert. Currently, this is checked during query compilation rather than allowing the check to relegate to the database. This might, however, cause problems between Hibernate <code class="literal">Type</code>s which are <span class="emphasis"><em>equivalent</em></span> as opposed to <span class="emphasis"><em>equal</em></span>. This might cause issues with mismatches between a property defined as a <code class="literal">org.hibernate.type.DateType</code> and a property defined as a <code class="literal">org.hibernate.type.TimestampType</code>, even though the database might not make a distinction or might be able to handle the conversion. </p></li><li><p>For the id property, the insert statement gives you two options. You can either explicitly specify the id property in the properties_list, in which case its value is taken from the corresponding select expression, or omit it from the properties_list, in which case a generated value is used. This latter option is only available when using id generators that operate in the database; attempting to use this option with any "in memory" type generators will cause an exception during parsing. For the purposes of this discussion, in-database generators are considered to be <code class="literal">org.hibernate.id.SequenceGenerator</code> (and its subclasses) and any implementers of <code class="literal">org.hibernate.id.PostInsertIdentifierGenerator</code>. The most notable exception here is <code class="literal">org.hibernate.id.TableHiLoGenerator</code>, which cannot be used because it does not expose a selectable way to get its values. </p></li><li><p>For properties mapped as either <code class="literal">version</code> or <code class="literal">timestamp</code>, the insert statement gives you two options. You can either specify the property in the properties_list, in which case its value is taken from the corresponding select expressions, or omit it from the properties_list, in which case the <code class="literal">seed value</code> defined by the <code class="literal">org.hibernate.type.VersionType</code> is used. </p></li></ul></div><p>The following is an example of an HQL <code class="literal">INSERT</code> statement execution: </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

String hqlInsert = "insert into DelinquentAccount (id, name) select c.id, c.name from Customer c where ...";
int createdEntities = s.createQuery( hqlInsert )
        .executeUpdate();
tx.commit();
session.close();</pre></div></div><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql"/>第14章 HQL: The Hibernate Query Language</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#queryhql-casesensitivity">14.1. 大文字と小文字の区別</a></span></dt><dt><span class="sect1"><a href="#queryhql-from">14.2. from節</a></span></dt><dt><span class="sect1"><a href="#queryhql-joins">14.3. 関連と結合</a></span></dt><dt><span class="sect1"><a href="#queryhql-joins-forms">14.4. 結合構文の形式</a></span></dt><dt><span class="sect1"><a href="#queryhql-identifier-property">14.5. Referring to identifier property</a></span></dt><dt><span class="sect1"><a href="#queryhql-select">14.6. Select節</a></span></dt><dt><span class="sect1"><a href="#queryhql-aggregation">14.7. 集約関数</a></span></dt><dt><span class="sect1"><a href="#queryhql-polymorphism">14.8. ポリモーフィックなクエリ</a></span></dt><dt><span class="sect1"><a href="#queryhql-where">14.9. where節</a></span></dt><dt><span class="sect1"><a href="#queryhql-expressions">14.10. Expressions 式</a></span></dt><dt><span class="sect1"><a href="#queryhql-ordering">14.11. order by節</a></span></dt><dt><span class="sect1"><a href="#queryhql-grouping">14.12. group by節</a></span></dt><dt><span class="sect1"><a href="#queryhql-subqueries">14.13. 副問い合わせ</a></span></dt><dt><span class="sect1"><a href="#queryhql-examples">14.14. HQLの例</a></span></dt><dt><span class="sect1"><a href="#queryhql-bulk">14.15. 大量のUPDATEとDELETE</a></span></dt><dt><span class="sect1"><a href="#queryhql-tipstricks">14.16. Tips &amp; Tricks</a></span></dt><dt><span class="sect1"><a href="#queryhql-components">14.17. translator-credits</a></span></dt><dt><span class="sect1"><a href="#queryhql-tuple">14.18. Row value constructor syntax</a></span></dt></dl></div><p>Hibernate uses a powerful query language (HQL) that is similar in appearance to SQL. Compared with SQL, however, HQL is fully object-oriented and understands notions like inheritance, polymorphism and association. </p><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-casesensitivity"/>14.1. 大文字と小文字の区別</h2></div></div></div><p>With the exception of names of Java classes and properties, queries are case-insensitive. So <code class="literal">SeLeCT</code> is the same as <code class="literal">sELEct</code> is the same as <code class="literal">SELECT</code>, but <code class="literal">org.hibernate.eg.FOO</code> is not <code class="literal">org.hibernate.eg.Foo</code>, and <code class="literal">foo.barSet</code> is not <code class="literal">foo.BARSET</code>. </p><p>This manual uses lowercase HQL keywords. Some users find queries with uppercase keywords more readable, but this convention is unsuitable for queries embedded in Java code. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-from"/>14.2. from節</h2></div></div></div><p>もっとも単純なHibernateクエリは次の形式です。 </p><pre class="programlisting">from eg.Cat</pre><p>This returns all instances of the class <code class="literal">eg.Cat</code>. You do not usually need to qualify the class name, since <code class="literal">auto-import</code> is the default. For example: </p><pre class="programlisting">from Cat</pre><p>In order to refer to the <code class="literal">Cat</code> in other parts of the query, you will need to assign an <span class="emphasis"><em>alias</em></span>. For example: </p><pre class="programlisting">from Cat as cat</pre><p>This query assigns the alias <code class="literal">cat</code> to <code class="literal">Cat</code> instances, so you can use that alias later in the query. The <code class="literal">as</code> keyword is optional. You could also write: </p><pre class="programlisting">from Cat cat</pre><p>Multiple classes can appear, resulting in a cartesian product or "cross" join. </p><pre class="programlisting">from Formula, Parameter</pre><pre class="programlisting">from Formula as form, Parameter as param</pre><p>It is good practice to name query aliases using an initial lowercase as this is consistent with Java naming standards for local variables (e.g. <code class="literal">domesticCat</code>). </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-joins"/>14.3. 関連と結合</h2></div></div></div><p>You can also assign aliases to associated entities or to elements of a collection of values using a <code class="literal">join</code>. For example: </p><pre class="programlisting">from Cat as cat
    inner join cat.mate as mate
    left outer join cat.kittens as kitten</pre><pre class="programlisting">from Cat as cat left join cat.mate.kittens as kittens</pre><pre class="programlisting">from Formula form full join form.parameter param</pre><p>The supported join types are borrowed from ANSI SQL: </p><div class="itemizedlist"><ul compact="compact"><li><p>
                    <code class="literal">inner join</code>
                </p></li><li><p>
                    <code class="literal">left outer join</code>
                </p></li><li><p>
                    <code class="literal">right outer join</code>
                </p></li><li><p><code class="literal">full join</code> (たいていの場合使いづらい) </p></li></ul></div><p><code class="literal">inner join</code>、<code class="literal">left outer join</code>、<code class="literal">right outer join</code>には省略形を使うこともできます。 </p><pre class="programlisting">from Cat as cat
    join cat.mate as mate
    left join cat.kittens as kitten</pre><p>HQLの <code class="literal">with</code> キーワードを使うと、結合条件を付け加えることができます。 </p><pre class="programlisting">from Cat as cat
    left join cat.kittens as kitten
        with kitten.bodyWeight &gt; 10.0</pre><p>A "fetch" join allows associations or collections of values to be initialized along with their parent objects using a single select. This is particularly useful in the case of a collection. It effectively overrides the outer join and lazy declarations of the mapping file for associations and collections. See <a href="#performance-fetching" title="19.1. フェッチ戦略">項19.1. 「フェッチ戦略」</a> for more information. </p><pre class="programlisting">from Cat as cat
    inner join fetch cat.mate
    left join fetch cat.kittens</pre><p>A fetch join does not usually need to assign an alias, because the associated objects should not be used in the <code class="literal">where</code> clause (or any other clause). The associated objects are also not returned directly in the query results. Instead, they may be accessed via the parent object. The only reason you might need an alias is if you are recursively join fetching a further collection: </p><pre class="programlisting">from Cat as cat
    inner join fetch cat.mate
    left join fetch cat.kittens child
    left join fetch child.kittens</pre><p>The <code class="literal">fetch</code> construct cannot be used in queries called using <code class="literal">iterate()</code> (though <code class="literal">scroll()</code> can be used). <code class="literal">Fetch</code> should be used together with <code class="literal">setMaxResults()</code> or <code class="literal">setFirstResult()</code>, as these operations are based on the result rows which usually contain duplicates for eager collection fetching, hence, the number of rows is not what you would expect. <code class="literal">Fetch</code> should also not be used together with impromptu <code class="literal">with</code> condition. It is possible to create a cartesian product by join fetching more than one collection in a query, so take care in this case. Join fetching multiple collection roles can produce unexpected results for bag mappings, so user discretion is advised when formulating queries in this case. Finally, note that <code class="literal">full join fetch</code> and <code class="literal">right join fetch</code> are not meaningful. </p><p>If you are using property-level lazy fetching (with bytecode instrumentation), it is possible to force Hibernate to fetch the lazy properties in the first query immediately using <code class="literal">fetch all properties</code>. </p><pre class="programlisting">from Document fetch all properties order by name</pre><pre class="programlisting">from Document doc fetch all properties where lower(doc.name) like '%cats%'</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-joins-forms"/>14.4. 結合構文の形式</h2></div></div></div><p>HQLは２つの関連結合形式をサポートします：<code class="literal">暗黙的</code> と <code class="literal">明示的</code>。 </p><p>The queries shown in the previous section all use the <code class="literal">explicit</code> form, that is, where the join keyword is explicitly used in the from clause. This is the recommended form. </p><p><code class="literal">暗黙的</code> フォームは、joinキーワードを使いません。代わりに、参照する関連に ドット表記を使います。<code class="literal">暗黙的</code> 結合は、さまざまなHQLに出てきます。 <code class="literal">暗黙的</code> 結合の結果は、SQLステートメントの内部結合結果です。 </p><pre class="programlisting">from Cat as cat where cat.mate.name like '%s%'</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-identifier-property"/>14.5. Referring to identifier property</h2></div></div></div><p>There are 2 ways to refer to an entity's identifier property: </p><div class="itemizedlist"><ul compact="compact"><li><p>The special property (lowercase) <code class="literal">id</code> may be used to reference the identifier property of an entity <span class="emphasis"><em>provided that the entity does not define a non-identifier property named id</em></span>. </p></li><li><p>If the entity defines a named identifier property, you can use that property name. </p></li></ul></div><p>References to composite identifier properties follow the same naming rules. If the entity has a non-identifier property named id, the composite identifier property can only be referenced by its defined named. Otherwise, the special <code class="literal">id</code> property can be used to reference the identifier property. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>重要項目</h2><p>Please note that, starting in version 3.2.2, this has changed significantly. In previous versions, <code class="literal">id</code> <span class="emphasis"><em>always</em></span> referred to the identifier property regardless of its actual name. A ramification of that decision was that non-identifier properties named <code class="literal">id</code> could never be referenced in Hibernate queries. </p></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-select"/>14.6. Select節</h2></div></div></div><p>The <code class="literal">select</code> clause picks which objects and properties to return in the query result set. Consider the following: </p><pre class="programlisting">select mate
from Cat as cat
    inner join cat.mate as mate</pre><p>The query will select <code class="literal">mate</code>s of other <code class="literal">Cat</code>s. You can express this query more compactly as: </p><pre class="programlisting">select cat.mate from Cat cat</pre><p>Queries can return properties of any value type including properties of component type: </p><pre class="programlisting">select cat.name from DomesticCat cat
where cat.name like 'fri%'</pre><pre class="programlisting">select cust.name.firstName from Customer as cust</pre><p>Queries can return multiple objects and/or properties as an array of type <code class="literal">Object[]</code>: </p><pre class="programlisting">select mother, offspr, mate.name
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>Or as a <code class="literal">List</code>: </p><pre class="programlisting">select new list(mother, offspr, mate.name)
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>Or - assuming that the class <code class="literal">Family</code> has an appropriate constructor - as an actual typesafe Java object: </p><pre class="programlisting">select new Family(mother, mate, offspr)
from DomesticCat as mother
    join mother.mate as mate
    left join mother.kittens as offspr</pre><p>You can assign aliases to selected expressions using <code class="literal">as</code>: </p><pre class="programlisting">select max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n
from Cat cat</pre><p><code class="literal">select new map</code> と一緒に使うときに最も役立ちます： </p><pre class="programlisting">select new map( max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n )
from Cat cat</pre><p>このクエリは別名からselectした値へ <code class="literal">Map</code> を返します。 </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-aggregation"/>14.7. 集約関数</h2></div></div></div><p>HQL queries can even return the results of aggregate functions on properties: </p><pre class="programlisting">select avg(cat.weight), sum(cat.weight), max(cat.weight), count(cat)
from Cat cat</pre><p>The supported aggregate functions are: </p><div class="itemizedlist"><ul compact="compact"><li><p>
                    <code class="literal">avg(...), sum(...), min(...), max(...)</code>
                </p></li><li><p>
                    <code class="literal">count(*)</code>
                </p></li><li><p>
                    <code class="literal">count(...), count(distinct ...), count(all...)</code>
                </p></li></ul></div><p>You can use arithmetic operators, concatenation, and recognized SQL functions in the select clause: </p><pre class="programlisting">select cat.weight + sum(kitten.weight)
from Cat cat
    join cat.kittens kitten
group by cat.id, cat.weight</pre><pre class="programlisting">select firstName||' '||initial||' '||upper(lastName) from Person</pre><p>The <code class="literal">distinct</code> and <code class="literal">all</code> keywords can be used and have the same semantics as in SQL. </p><pre class="programlisting">select distinct cat.name from Cat cat

select count(distinct cat.name), count(cat) from Cat cat</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-polymorphism"/>14.8. ポリモーフィックなクエリ</h2></div></div></div><p>次のようなクエリ： </p><pre class="programlisting">from Cat as cat</pre><p>returns instances not only of <code class="literal">Cat</code>, but also of subclasses like <code class="literal">DomesticCat</code>. Hibernate queries can name <span class="emphasis"><em>any</em></span> Java class or interface in the <code class="literal">from</code> clause. The query will return instances of all persistent classes that extend that class or implement the interface. The following query would return all persistent objects: </p><pre class="programlisting">from java.lang.Object o</pre><p><code class="literal">Named</code> インターフェイスは様々な永続クラスによって実装されます。: </p><pre class="programlisting">from Named n, Named m where n.name = m.name</pre><p>These last two queries will require more than one SQL <code class="literal">SELECT</code>. This means that the <code class="literal">order by</code> clause does not correctly order the whole result set. It also means you cannot call these queries using <code class="literal">Query.scroll()</code>. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-where"/>14.9. where節</h2></div></div></div><p>The <code class="literal">where</code> clause allows you to refine the list of instances returned. If no alias exists, you can refer to properties by name: </p><pre class="programlisting">from Cat where name='Fritz'</pre><p>もし別名がある場合、修飾名を使ってください。 </p><pre class="programlisting">from Cat as cat where cat.name='Fritz'</pre><p>This returns instances of <code class="literal">Cat</code> named 'Fritz'. </p><p>The following query: </p><pre class="programlisting">select foo
from Foo foo, Bar bar
where foo.startDate = bar.date</pre><p> returns all instances of <code class="literal">Foo</code> with an instance of <code class="literal">bar</code> with a <code class="literal">date</code> property equal to the <code class="literal">startDate</code> property of the <code class="literal">Foo</code>. Compound path expressions make the <code class="literal">where</code> clause extremely powerful. Consider the following: </p><pre class="programlisting">from Cat cat where cat.mate.name is not null</pre><p>This query translates to an SQL query with a table (inner) join. For example: </p><pre class="programlisting">from Foo foo
where foo.bar.baz.customer.address.city is not null</pre><p>would result in a query that would require four table joins in SQL. </p><p>The <code class="literal">=</code> operator can be used to compare not only properties, but also instances: </p><pre class="programlisting">from Cat cat, Cat rival where cat.mate = rival.mate</pre><pre class="programlisting">select cat, mate
from Cat cat, Cat mate
where cat.mate = mate</pre><p>The special property (lowercase) <code class="literal">id</code> can be used to reference the unique identifier of an object. See <a href="#queryhql-identifier-property" title="14.5. Referring to identifier property">項14.5. 「Referring to identifier property」</a> for more information. </p><pre class="programlisting">from Cat as cat where cat.id = 123

from Cat as cat where cat.mate.id = 69</pre><p>The second query is efficient and does not require a table join. </p><p>Properties of composite identifiers can also be used. Consider the following example where <code class="literal">Person</code> has composite identifiers consisting of <code class="literal">country</code> and <code class="literal">medicareNumber</code>: </p><pre class="programlisting">from bank.Person person
where person.id.country = 'AU'
    and person.id.medicareNumber = 123456</pre><pre class="programlisting">from bank.Account account
where account.owner.id.country = 'AU'
    and account.owner.id.medicareNumber = 123456</pre><p>Once again, the second query does not require a table join. </p><p>See <a href="#queryhql-identifier-property" title="14.5. Referring to identifier property">項14.5. 「Referring to identifier property」</a> for more information regarding referencing identifier properties) </p><p>The special property <code class="literal">class</code> accesses the discriminator value of an instance in the case of polymorphic persistence. A Java class name embedded in the where clause will be translated to its discriminator value. </p><pre class="programlisting">from Cat cat where cat.class = DomesticCat</pre><p>You can also use components or composite user types, or properties of said component types. See <a href="#queryhql-components" title="14.17. translator-credits">項14.17. 「translator-credits」</a> for more information. </p><p>An "any" type has the special properties <code class="literal">id</code> and <code class="literal">class</code> that allows you to express a join in the following way (where <code class="literal">AuditLog.item</code> is a property mapped with <code class="literal">&lt;any&gt;</code>): </p><pre class="programlisting">from AuditLog log, Payment payment
where log.item.class = 'Payment' and log.item.id = payment.id</pre><p>The <code class="literal">log.item.class</code> and <code class="literal">payment.class</code> would refer to the values of completely different database columns in the above query. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-expressions"/>14.10. Expressions 式</h2></div></div></div><p>Expressions used in the <code class="literal">where</code> clause include the following: </p><div class="itemizedlist"><ul compact="compact"><li><p>mathematical operators: <code class="literal">+, -, *, /</code> </p></li><li><p>binary comparison operators: <code class="literal">=, &gt;=, &lt;=, &lt;&gt;, !=, like</code> </p></li><li><p>論理演算子：<code class="literal">and, or, not</code> </p></li><li><p>Parentheses <code class="literal">( )</code> that indicates grouping </p></li><li><p><code class="literal">in</code>, <code class="literal">not in</code>, <code class="literal">between</code>, <code class="literal">is null</code>, <code class="literal">is not null</code>, <code class="literal">is empty</code>, <code class="literal">is not empty</code>, <code class="literal">member of</code> and <code class="literal">not member of</code> </p></li><li><p>"シンプル"なcase <code class="literal">case ... when ... then ... else ... end</code>、 "探索的"なcase <code class="literal">case when ... then ... else ... end</code> </p></li><li><p>ストリングの連結 <code class="literal">...||...</code> または <code class="literal">concat(...,...)</code> </p></li><li><p><code class="literal">current_date()</code>, <code class="literal">current_time()</code>, and <code class="literal">current_timestamp()</code> </p></li><li><p><code class="literal">second(...)</code>, <code class="literal">minute(...)</code>, <code class="literal">hour(...)</code>, <code class="literal">day(...)</code>, <code class="literal">month(...)</code>, and <code class="literal">year(...)</code> </p></li><li><p>EJB-QL 3.0で定義されている関数や演算子: <code class="literal">substring(), trim(), lower(), upper(), length(), locate(), abs(), sqrt(), bit_length()</code> </p></li><li><p><code class="literal">coalesce()</code> と <code class="literal">nullif()</code> </p></li><li><p>数字や時間の値をStringにコンバートする <code class="literal">str()</code>） </p></li><li><p>2番目の引数がHibernate型の名前である <code class="literal">cast(... as ...)</code> と <code class="literal">extract(... from ...)</code>。 ただし使用するデータベースがANSI <code class="literal">cast()</code> と <code class="literal">extract()</code> をサポートする場合に限ります。 </p></li><li><p>結合したインデックス付きのコレクションの別名に適用されるHQLの <code class="literal">index()</code> 関数。 </p></li><li><p>HQL functions that take collection-valued path expressions: <code class="literal">size(), minelement(), maxelement(), minindex(), maxindex()</code>, along with the special <code class="literal">elements()</code> and <code class="literal">indices</code> functions that can be quantified using <code class="literal">some, all, exists, any, in</code>. </p></li><li><p>Any database-supported SQL scalar function like <code class="literal">sign()</code>, <code class="literal">trunc()</code>, <code class="literal">rtrim()</code>, and <code class="literal">sin()</code> </p></li><li><p>JDBCスタイルの位置パラメータ <code class="literal">?</code> </p></li><li><p>named parameters <code class="literal">:name</code>, <code class="literal">:start_date</code>, and <code class="literal">:x1</code> </p></li><li><p>SQLリテラル：<code class="literal">'foo'</code>, <code class="literal">69</code>, <code class="literal">6.66E+2</code>, <code class="literal">'1970-01-01 10:00:01.0'</code> </p></li><li><p>Javaの <code class="literal">public static final</code> 定数：<code class="literal">eg.Color.TABBY</code> </p></li></ul></div><p><code class="literal">in</code> and <code class="literal">between</code> can be used as follows: </p><pre class="programlisting">from DomesticCat cat where cat.name between 'A' and 'B'</pre><pre class="programlisting">from DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )</pre><p>The negated forms can be written as follows: </p><pre class="programlisting">from DomesticCat cat where cat.name not between 'A' and 'B'</pre><pre class="programlisting">from DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )</pre><p>Similarly, <code class="literal">is null</code> and <code class="literal">is not null</code> can be used to test for null values. </p><p>Booleans can be easily used in expressions by declaring HQL query substitutions in Hibernate configuration: </p><pre class="programlisting">&lt;property name="hibernate.query.substitutions"&gt;true 1, false 0&lt;/property&gt;</pre><p>こうすることで下記のHQLをSQLに変換するときに <code class="literal">true</code> , <code class="literal">false</code> キーワードは <code class="literal">1</code> , <code class="literal">0</code> に置き換えられます。: </p><pre class="programlisting">from Cat cat where cat.alive = true</pre><p>You can test the size of a collection with the special property <code class="literal">size</code> or the special <code class="literal">size()</code> function. </p><pre class="programlisting">from Cat cat where cat.kittens.size &gt; 0</pre><pre class="programlisting">from Cat cat where size(cat.kittens) &gt; 0</pre><p>For indexed collections, you can refer to the minimum and maximum indices using <code class="literal">minindex</code> and <code class="literal">maxindex</code> functions. Similarly, you can refer to the minimum and maximum elements of a collection of basic type using the <code class="literal">minelement</code> and <code class="literal">maxelement</code> functions. For example: </p><pre class="programlisting">from Calendar cal where maxelement(cal.holidays) &gt; current_date</pre><pre class="programlisting">from Order order where maxindex(order.items) &gt; 100</pre><pre class="programlisting">from Order order where minelement(order.items) &gt; 10000</pre><p>The SQL functions <code class="literal">any, some, all, exists, in</code> are supported when passed the element or index set of a collection (<code class="literal">elements</code> and <code class="literal">indices</code> functions) or the result of a subquery (see below): </p><pre class="programlisting">select mother from Cat as mother, Cat as kit
where kit in elements(foo.kittens)</pre><pre class="programlisting">select p from NameList list, Person p
where p.name = some elements(list.names)</pre><pre class="programlisting">from Cat cat where exists elements(cat.kittens)</pre><pre class="programlisting">from Player p where 3 &gt; all elements(p.scores)</pre><pre class="programlisting">from Show show where 'fizard' in indices(show.acts)</pre><p>Note that these constructs - <code class="literal">size</code>, <code class="literal">elements</code>, <code class="literal">indices</code>, <code class="literal">minindex</code>, <code class="literal">maxindex</code>, <code class="literal">minelement</code>, <code class="literal">maxelement</code> - can only be used in the where clause in Hibernate3. </p><p>Elements of indexed collections (arrays, lists, and maps) can be referred to by index in a where clause only: </p><pre class="programlisting">from Order order where order.items[0].id = 1234</pre><pre class="programlisting">select person from Person person, Calendar calendar
where calendar.holidays['national day'] = person.birthDay
    and person.nationality.calendar = calendar</pre><pre class="programlisting">select item from Item item, Order order
where order.items[ order.deliveredItemIndices[0] ] = item and order.id = 11</pre><pre class="programlisting">select item from Item item, Order order
where order.items[ maxindex(order.items) ] = item and order.id = 11</pre><p>The expression inside <code class="literal">[]</code> can even be an arithmetic expression: </p><pre class="programlisting">select item from Item item, Order order
where order.items[ size(order.items) - 1 ] = item</pre><p>HQL also provides the built-in <code class="literal">index()</code> function for elements of a one-to-many association or collection of values. </p><pre class="programlisting">select item, index(item) from Order order
    join order.items item
where index(item) &lt; 5</pre><p>Scalar SQL functions supported by the underlying database can be used: </p><pre class="programlisting">from DomesticCat cat where upper(cat.name) like 'FRI%'</pre><p>Consider how much longer and less readable the following query would be in SQL: </p><pre class="programlisting">select cust
from Product prod,
    Store store
    inner join store.customers cust
where prod.name = 'widget'
    and store.location.name in ( 'Melbourne', 'Sydney' )
    and prod = all elements(cust.currentOrder.lineItems)</pre><p><span class="emphasis"><em>ヒント:</em></span> 例えばこのように出来ます。 </p><pre class="programlisting">SELECT cust.name, cust.address, cust.phone, cust.id, cust.current_order
FROM customers cust,
    stores store,
    locations loc,
    store_customers sc,
    product prod
WHERE prod.name = 'widget'
    AND store.loc_id = loc.id
    AND loc.name IN ( 'Melbourne', 'Sydney' )
    AND sc.store_id = store.id
    AND sc.cust_id = cust.id
    AND prod.id = ALL(
        SELECT item.prod_id
        FROM line_items item, orders o
        WHERE item.order_id = o.id
            AND cust.current_order = o.id
    )</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-ordering"/>14.11. order by節</h2></div></div></div><p>The list returned by a query can be ordered by any property of a returned class or components: </p><pre class="programlisting">from DomesticCat cat
order by cat.name asc, cat.weight desc, cat.birthdate</pre><p>オプションの <code class="literal">asc</code> と <code class="literal">desc</code> はそれぞれ昇順か降順の整列を示します。 </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-grouping"/>14.12. group by節</h2></div></div></div><p>A query that returns aggregate values can be grouped by any property of a returned class or components: </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat)
from Cat cat
group by cat.color</pre><pre class="programlisting">select foo.id, avg(name), max(name)
from Foo foo join foo.names name
group by foo.id</pre><p><code class="literal">having</code> 節も使えます。 </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat)
from Cat cat
group by cat.color
having cat.color in (eg.Color.TABBY, eg.Color.BLACK)</pre><p>SQL functions and aggregate functions are allowed in the <code class="literal">having</code> and <code class="literal">order by</code> clauses if they are supported by the underlying database (i.e., not in MySQL). </p><pre class="programlisting">select cat
from Cat cat
    join cat.kittens kitten
group by cat.id, cat.name, cat.other, cat.properties
having avg(kitten.weight) &gt; 100
order by count(kitten) asc, sum(kitten.weight) desc</pre><p>Neither the <code class="literal">group by</code> clause nor the <code class="literal">order by</code> clause can contain arithmetic expressions. Hibernate also does not currently expand a grouped entity, so you cannot write <code class="literal">group by cat</code> if all properties of <code class="literal">cat</code> are non-aggregated. You have to list all non-aggregated properties explicitly. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-subqueries"/>14.13. 副問い合わせ</h2></div></div></div><p>サブセレクトをサポートするデータベースのため、Hibernateは副問い合わせをサポートしています。 副問い合わせは括弧で囲まなければなりません（SQLの集約関数呼び出しによる事が多いです）。 関連副問い合わせ(外部クエリ中の別名を参照する副問い合わせのこと)さえ許可されます。 </p><pre class="programlisting">from Cat as fatcat
where fatcat.weight &gt; (
    select avg(cat.weight) from DomesticCat cat
)</pre><pre class="programlisting">from DomesticCat as cat
where cat.name = some (
    select name.nickName from Name as name
)</pre><pre class="programlisting">from Cat as cat
where not exists (
    from Cat as mate where mate.mate = cat
)</pre><pre class="programlisting">from DomesticCat as cat
where cat.name not in (
    select name.nickName from Name as name
)</pre><pre class="programlisting">select cat.id, (select max(kit.weight) from cat.kitten kit)
from Cat as cat</pre><p>Note that HQL subqueries can occur only in the select or where clauses. </p><p>Note that subqueries can also utilize <code class="literal">row value constructor</code> syntax. See <a href="#queryhql-tuple" title="14.18. Row value constructor syntax">項14.18. 「Row value constructor syntax」</a> for more information. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-examples"/>14.14. HQLの例</h2></div></div></div><p>Hibernate queries can be quite powerful and complex. In fact, the power of the query language is one of Hibernate's main strengths. The following example queries are similar to queries that have been used on recent projects. Please note that most queries you will write will be much simpler than the following examples. </p><p>The following query returns the order id, number of items, the given minimum total value and the total value of the order for all unpaid orders for a particular customer. The results are ordered by total value. In determining the prices, it uses the current catalog. The resulting SQL query, against the <code class="literal">ORDER</code>, <code class="literal">ORDER_LINE</code>, <code class="literal">PRODUCT</code>, <code class="literal">CATALOG</code> and <code class="literal">PRICE</code> tables has four inner joins and an (uncorrelated) subselect. </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog.effectiveDate &lt; sysdate
    and catalog.effectiveDate &gt;= all (
        select cat.effectiveDate
        from Catalog as cat
        where cat.effectiveDate &lt; sysdate
    )
group by order
having sum(price.amount) &gt; :minAmount
order by sum(price.amount) desc</pre><p>何て巨大なクエリなのでしょう! 普段私は副問い合わせをあまり使いません。したがって私のクエリは実際には以下のようになります。: </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog = :currentCatalog
group by order
having sum(price.amount) &gt; :minAmount
order by sum(price.amount) desc</pre><p>次のクエリは各ステータスの支払い数を数えます。ただしすべての支払いが現在の利用者による 最新のステータス変更である <code class="literal">AWAITING_APPROVAL</code> である場合を除きます。 このクエリは2つの内部結合と <code class="literal">PAYMENT</code>, <code class="literal">PAYMENT_STATUS</code> および <code class="literal">PAYMENT_STATUS_CHANGE</code> テーブルに対する関連副問い合わせを備えたSQLクエリに変換されます。 </p><pre class="programlisting">select count(payment), status.name
from Payment as payment
    join payment.currentStatus as status
    join payment.statusChanges as statusChange
where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL
    or (
        statusChange.timeStamp = (
            select max(change.timeStamp)
            from PaymentStatusChange change
            where change.payment = payment
        )
        and statusChange.user &lt;&gt; :currentUser
    )
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>If the <code class="literal">statusChanges</code> collection was mapped as a list, instead of a set, the query would have been much simpler to write. </p><pre class="programlisting">select count(payment), status.name
from Payment as payment
    join payment.currentStatus as status
where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL
    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user &lt;&gt; :currentUser
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>次のクエリは現在のユーザが所属する組織に対するアカウントおよび未払いの支払いを すべて返すMS SQL Server の <code class="literal">isNull()</code> 関数を使用しています。 このクエリは3つの内部結合と1つの外部結合 、 そして <code class="literal">ACCOUNT</code>, <code class="literal">PAYMENT</code>, <code class="literal">PAYMENT_STATUS</code>, <code class="literal">ACCOUNT_TYPE</code>, <code class="literal">ORGANIZATION</code> および <code class="literal">ORG_USER</code> テーブルに対する副問い合わせ持ったSQLに変換されます。 </p><pre class="programlisting">select account, payment
from Account as account
    left outer join account.payments as payment
where :currentUser in elements(account.holder.users)
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre><p>いくつかのデータベースについては、(関連させられた)副問い合わせの使用を避ける必要があるでしょう。 </p><pre class="programlisting">select account, payment
from Account as account
    join account.holder.users as user
    left outer join account.payments as payment
where :currentUser = user
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-bulk"/>14.15. 大量のUPDATEとDELETE</h2></div></div></div><p>HQL now supports <code class="literal">update</code>, <code class="literal">delete</code> and <code class="literal">insert ... select ...</code> statements. See <a href="#batch-direct" title="13.4. DMLã¹ã¿ã¤ã«ã®æä½">項13.4. 「DMLã¹ã¿ã¤ã«ã®æä½」</a> for more information. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-tipstricks"/>14.16. Tips &amp; Tricks</h2></div></div></div><p>You can count the number of query results without returning them: </p><pre class="programlisting">( (Integer) session.createQuery("select count(*) from ....").iterate().next() ).intValue()</pre><p>コレクションのサイズにより結果を並べ替えるためには以下のクエリを使用します。: </p><pre class="programlisting">select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
order by count(msg)</pre><p>使用しているデータベースがサブセレクトをサポートする場合、クエリのwhere節でサイズによる選択条件を設定できます: </p><pre class="programlisting">from User usr where size(usr.messages) &gt;= 1</pre><p>If your database does not support subselects, use the following query: </p><pre class="programlisting">select usr.id, usr.name
from User usr.name
    join usr.messages msg
group by usr.id, usr.name
having count(msg) &gt;= 1</pre><p>As this solution cannot return a <code class="literal">User</code> with zero messages because of the inner join, the following form is also useful: </p><pre class="programlisting">select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
having count(msg) = 0</pre><p>JavaBeanのプロパティは、名前付きのクエリパラメータに結びつけることが出来ます。： </p><pre class="programlisting">Query q = s.createQuery("from foo Foo as foo where foo.name=:name and foo.size=:size");
q.setProperties(fooBean); // fooBean has getName() and getSize()
List foos = q.list();</pre><p>コレクションはフィルタ付き <code class="literal">Query</code> インターフェイスを使用することでページをつけることができます。: </p><pre class="programlisting">Query q = s.createFilter( collection, "" ); // the trivial filter
q.setMaxResults(PAGE_SIZE);
q.setFirstResult(PAGE_SIZE * pageNumber);
List page = q.list();</pre><p>Collection elements can be ordered or grouped using a query filter: </p><pre class="programlisting">Collection orderedCollection = s.filter( collection, "order by this.amount" );
Collection counts = s.filter( collection, "select this.type, count(this) group by this.type" );</pre><p>コレクションを初期化せずにコレクションのサイズを得ることができます。: </p><pre class="programlisting">( (Integer) session.createQuery("select count(*) from ....").iterate().next() ).intValue();</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-components"/>14.17. translator-credits</h2></div></div></div><p>Components can be used similarly to the simple value types that are used in HQL queries. They can appear in the <code class="literal">select</code> clause as follows: </p><pre class="programlisting">select p.name from Person p</pre><pre class="programlisting">select p.name.first from Person p</pre><p>where the Person's name property is a component. Components can also be used in the <code class="literal">where</code> clause: </p><pre class="programlisting">from Person p where p.name = :name</pre><pre class="programlisting">from Person p where p.name.first = :firstName</pre><p>Components can also be used in the <code class="literal">order by</code> clause: </p><pre class="programlisting">from Person p order by p.name</pre><pre class="programlisting">from Person p order by p.name.first</pre><p>Another common use of components is in <a href="#queryhql-tuple" title="14.18. Row value constructor syntax">row value constructors</a>. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-tuple"/>14.18. Row value constructor syntax</h2></div></div></div><p>HQL supports the use of ANSI SQL <code class="literal">row value constructor</code> syntax, sometimes referred to AS <code class="literal">tuple</code> syntax, even though the underlying database may not support that notion. Here, we are generally referring to multi-valued comparisons, typically associated with components. Consider an entity Person which defines a name component: </p><pre class="programlisting">from Person p where p.name.first='John' and p.name.last='Jingleheimer-Schmidt'</pre><p>That is valid syntax although it is a little verbose. You can make this more concise by using <code class="literal">row value constructor</code> syntax: </p><pre class="programlisting">from Person p where p.name=('John', 'Jingleheimer-Schmidt')</pre><p>It can also be useful to specify this in the <code class="literal">select</code> clause: </p><pre class="programlisting">select p.name from Person p</pre><p>Using <code class="literal">row value constructor</code> syntax can also be beneficial when using subqueries that need to compare against multiple values: </p><pre class="programlisting">from Cat as cat
where not ( cat.name, cat.color ) in (
    select cat.name, cat.color from DomesticCat cat
)</pre><p>One thing to consider when deciding if you want to use this syntax, is that the query will be dependent upon the ordering of the component sub-properties in the metadata. </p></div></div><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria"/>第15章 Criteriaクエリ</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#querycriteria-creating">15.1. <code class="literal">Criteria</code> インスタンスの作成</a></span></dt><dt><span class="sect1"><a href="#querycriteria-narrowing">15.2. リザルトセットの絞込み</a></span></dt><dt><span class="sect1"><a href="#querycriteria-ordering">15.3. 結果の整列</a></span></dt><dt><span class="sect1"><a href="#querycriteria-associations">15.4. 関連</a></span></dt><dt><span class="sect1"><a href="#querycriteria-dynamicfetching">15.5. 関連の動的フェッチ</a></span></dt><dt><span class="sect1"><a href="#querycriteria-examples">15.6. クエリの例</a></span></dt><dt><span class="sect1"><a href="#querycriteria-projection">15.7. 射影、集約、グループ化</a></span></dt><dt><span class="sect1"><a href="#querycriteria-detachedqueries">15.8. クエリおよびサブクエリの分離</a></span></dt><dt><span class="sect1"><a href="#query-criteria-naturalid">15.9. 自然識別子によるクエリ</a></span></dt></dl></div><p>Hibernateには、直感的で拡張可能なcriteriaクエリAPIが用意されています。 </p><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-creating"/>15.1. <code class="literal">Criteria</code> インスタンスの作成</h2></div></div></div><p><code class="literal">org.hibernate.Criteria</code> インターフェイスは特定の永続性クラスに対するクエリを表現します。 <code class="literal">Session</code> は <code class="literal">Criteria</code> インスタンスのファクトリです。 </p><pre class="programlisting">Criteria crit = sess.createCriteria(Cat.class);
crit.setMaxResults(50);
List cats = crit.list();</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-narrowing"/>15.2. リザルトセットの絞込み</h2></div></div></div><p><code class="literal">org.hibernate.criterion.Criterion</code> インターフェイスのインスタンスは、 個別のクエリクライテリオン（問い合わせの判定基準）を表します。 <code class="literal">org.hibernate.criterion.Restrictions</code> クラスは、ある組み込みの <code class="literal">Criterion</code> 型を取得するためのファクトリメソッドを持っています。 </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "Fritz%") )
    .add( Restrictions.between("weight", minWeight, maxWeight) )
    .list();</pre><p>Restrictions can be grouped logically. </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "Fritz%") )
    .add( Restrictions.or(
        Restrictions.eq( "age", new Integer(0) ),
        Restrictions.isNull("age")
    ) )
    .list();</pre><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.in( "name", new String[] { "Fritz", "Izi", "Pk" } ) )
    .add( Restrictions.disjunction()
        .add( Restrictions.isNull("age") )
        .add( Restrictions.eq("age", new Integer(0) ) )
        .add( Restrictions.eq("age", new Integer(1) ) )
        .add( Restrictions.eq("age", new Integer(2) ) )
    ) )
    .list();</pre><p>There are a range of built-in criterion types (<code class="literal">Restrictions</code> subclasses). One of the most useful allows you to specify SQL directly. </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.sqlRestriction("lower({alias}.name) like lower(?)", "Fritz%", Hibernate.STRING) )
    .list();</pre><p><code class="literal">{alias}</code> というプレースホルダは、 問い合わせを受けたエンティティの行の別名によって置き換えられます。 </p><p>You can also obtain a criterion from a <code class="literal">Property</code> instance. You can create a <code class="literal">Property</code> by calling <code class="literal">Property.forName()</code>: </p><pre class="programlisting">
Property age = Property.forName("age");
List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.disjunction()
        .add( age.isNull() )
        .add( age.eq( new Integer(0) ) )
        .add( age.eq( new Integer(1) ) )
        .add( age.eq( new Integer(2) ) )
    ) )
    .add( Property.forName("name").in( new String[] { "Fritz", "Izi", "Pk" } ) )
    .list();</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-ordering"/>15.3. 結果の整列</h2></div></div></div><p>You can order the results using <code class="literal">org.hibernate.criterion.Order</code>. </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "F%")
    .addOrder( Order.asc("name") )
    .addOrder( Order.desc("age") )
    .setMaxResults(50)
    .list();</pre><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Property.forName("name").like("F%") )
    .addOrder( Property.forName("name").asc() )
    .addOrder( Property.forName("age").desc() )
    .setMaxResults(50)
    .list();</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-associations"/>15.4. 関連</h2></div></div></div><p>By navigating associations using <code class="literal">createCriteria()</code> you can specify constraints upon related entities: </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "F%") )
    .createCriteria("kittens")
        .add( Restrictions.like("name", "F%") )
    .list();</pre><p>The second <code class="literal">createCriteria()</code> returns a new instance of <code class="literal">Criteria</code> that refers to the elements of the <code class="literal">kittens</code> collection. </p><p>There is also an alternate form that is useful in certain circumstances: </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .createAlias("kittens", "kt")
    .createAlias("mate", "mt")
    .add( Restrictions.eqProperty("kt.name", "mt.name") )
    .list();</pre><p>（<code class="literal">createAlias()</code> は新しい <code class="literal">Criteria</code> インスタンスを作成しません。） </p><p>The kittens collections held by the <code class="literal">Cat</code> instances returned by the previous two queries are <span class="emphasis"><em>not</em></span> pre-filtered by the criteria. If you want to retrieve just the kittens that match the criteria, you must use a <code class="literal">ResultTransformer</code>. </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .createCriteria("kittens", "kt")
        .add( Restrictions.eq("name", "F%") )
    .setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP)
    .list();
Iterator iter = cats.iterator();
while ( iter.hasNext() ) {
    Map map = (Map) iter.next();
    Cat cat = (Cat) map.get(Criteria.ROOT_ALIAS);
    Cat kitten = (Cat) map.get("kt");
}</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-dynamicfetching"/>15.5. 関連の動的フェッチ</h2></div></div></div><p>You can specify association fetching semantics at runtime using <code class="literal">setFetchMode()</code>. </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "Fritz%") )
    .setFetchMode("mate", FetchMode.EAGER)
    .setFetchMode("kittens", FetchMode.EAGER)
    .list();</pre><p>このクエリは外部結合により <code class="literal">mate</code> と <code class="literal">kittens</code> の両方をフェッチします。 より多くの情報は <a href="#performance-fetching" title="19.1. フェッチ戦略">項19.1. 「フェッチ戦略」</a> を参照してください。 </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-examples"/>15.6. クエリの例</h2></div></div></div><p><code class="literal">org.hibernate.criterion.Example</code> クラスは、 与えられたインスタンスからクエリクライテリオンを構築できます。 </p><pre class="programlisting">Cat cat = new Cat();
cat.setSex('F');
cat.setColor(Color.BLACK);
List results = session.createCriteria(Cat.class)
    .add( Example.create(cat) )
    .list();</pre><p>バージョンプロパティ、識別子、関連は無視されます。 デフォルトではnull値のプロパティは除外されます。 </p><p>どのように <code class="literal">Example</code> を適用するか 調整することができます。 </p><pre class="programlisting">Example example = Example.create(cat)
    .excludeZeroes()           //exclude zero valued properties
    .excludeProperty("color")  //exclude the property named "color"
    .ignoreCase()              //perform case insensitive string comparisons
    .enableLike();             //use like for string comparisons
List results = session.createCriteria(Cat.class)
    .add(example)
    .list();</pre><p>関連オブジェクトにcriteriaを指定するために、Exampleを使うことも可能です。 </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .add( Example.create(cat) )
    .createCriteria("mate")
        .add( Example.create( cat.getMate() ) )
    .list();</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-projection"/>15.7. 射影、集約、グループ化</h2></div></div></div><p>The class <code class="literal">org.hibernate.criterion.Projections</code> is a factory for <code class="literal">Projection</code> instances. You can apply a projection to a query by calling <code class="literal">setProjection()</code>. </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.rowCount() )
    .add( Restrictions.eq("color", Color.BLACK) )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.projectionList()
        .add( Projections.rowCount() )
        .add( Projections.avg("weight") )
        .add( Projections.max("weight") )
        .add( Projections.groupProperty("color") )
    )
    .list();</pre><p>必要であっても、criteriaクエリに「group by」を明示する必要はありません。 ある種のProjection型は <span class="emphasis"><em>グループ化射影</em></span> として定義され、 SQLの <code class="literal">group by</code> 節にも現れます。 </p><p>An alias can be assigned to a projection so that the projected value can be referred to in restrictions or orderings. Here are two different ways to do this: </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.alias( Projections.groupProperty("color"), "colr" ) )
    .addOrder( Order.asc("colr") )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.groupProperty("color").as("colr") )
    .addOrder( Order.asc("colr") )
    .list();</pre><p><code class="literal">alias()</code> と <code class="literal">as()</code> メソッドは、 Projectionインスタンスを別の名前の <code class="literal">Projection</code> インスタンスで ラップするだけです。 ショートカットとして、射影を射影リストに追加する際に、別名をつけられます。 </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.projectionList()
        .add( Projections.rowCount(), "catCountByColor" )
        .add( Projections.avg("weight"), "avgWeight" )
        .add( Projections.max("weight"), "maxWeight" )
        .add( Projections.groupProperty("color"), "color" )
    )
    .addOrder( Order.desc("catCountByColor") )
    .addOrder( Order.desc("avgWeight") )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Domestic.class, "cat")
    .createAlias("kittens", "kit")
    .setProjection( Projections.projectionList()
        .add( Projections.property("cat.name"), "catName" )
        .add( Projections.property("kit.name"), "kitName" )
    )
    .addOrder( Order.asc("catName") )
    .addOrder( Order.asc("kitName") )
    .list();</pre><p>射影の式に <code class="literal">Property.forName()</code> も使用できます。 </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Property.forName("name") )
    .add( Property.forName("color").eq(Color.BLACK) )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.projectionList()
        .add( Projections.rowCount().as("catCountByColor") )
        .add( Property.forName("weight").avg().as("avgWeight") )
        .add( Property.forName("weight").max().as("maxWeight") )
        .add( Property.forName("color").group().as("color" )
    )
    .addOrder( Order.desc("catCountByColor") )
    .addOrder( Order.desc("avgWeight") )
    .list();</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-detachedqueries"/>15.8. クエリおよびサブクエリの分離</h2></div></div></div><p>The <code class="literal">DetachedCriteria</code> class allows you to create a query outside the scope of a session and then execute it using an arbitrary <code class="literal">Session</code>. </p><pre class="programlisting">DetachedCriteria query = DetachedCriteria.forClass(Cat.class)
    .add( Property.forName("sex").eq('F') );
    
Session session = ....;
Transaction txn = session.beginTransaction();
List results = query.getExecutableCriteria(session).setMaxResults(100).list();
txn.commit();
session.close();</pre><p>A <code class="literal">DetachedCriteria</code> can also be used to express a subquery. Criterion instances involving subqueries can be obtained via <code class="literal">Subqueries</code> or <code class="literal">Property</code>. </p><pre class="programlisting">DetachedCriteria avgWeight = DetachedCriteria.forClass(Cat.class)
    .setProjection( Property.forName("weight").avg() );
session.createCriteria(Cat.class)
    .add( Property.forName("weight").gt(avgWeight) )
    .list();</pre><pre class="programlisting">DetachedCriteria weights = DetachedCriteria.forClass(Cat.class)
    .setProjection( Property.forName("weight") );
session.createCriteria(Cat.class)
    .add( Subqueries.geAll("weight", weights) )
    .list();</pre><p>Correlated subqueries are also possible: </p><pre class="programlisting">DetachedCriteria avgWeightForSex = DetachedCriteria.forClass(Cat.class, "cat2")
    .setProjection( Property.forName("weight").avg() )
    .add( Property.forName("cat2.sex").eqProperty("cat.sex") );
session.createCriteria(Cat.class, "cat")
    .add( Property.forName("weight").gt(avgWeightForSex) )
    .list();</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="query-criteria-naturalid"/>15.9. 自然識別子によるクエリ</h2></div></div></div><p>For most queries, including criteria queries, the query cache is not efficient because query cache invalidation occurs too frequently. However, there is a special kind of query where you can optimize the cache invalidation algorithm: lookups by a constant natural key. In some applications, this kind of query occurs frequently. The criteria API provides special provision for this use case. </p><p>First, map the natural key of your entity using <code class="literal">&lt;natural-id&gt;</code> and enable use of the second-level cache. </p><pre class="programlisting">&lt;class name="User"&gt;
    &lt;cache usage="read-write"/&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;natural-id&gt;
        &lt;property name="name"/&gt;
        &lt;property name="org"/&gt;
    &lt;/natural-id&gt;
    &lt;property name="password"/&gt;
&lt;/class&gt;</pre><p>This functionality is not intended for use with entities with <span class="emphasis"><em>mutable</em></span> natural keys. </p><p>Once you have enabled the Hibernate query cache, the <code class="literal">Restrictions.naturalId()</code> allows you to make use of the more efficient cache algorithm. </p><pre class="programlisting">session.createCriteria(User.class)
    .add( Restrictions.naturalId()
        .set("name", "gavin")
        .set("org", "hb") 
    ).setCacheable(true)
    .uniqueResult();</pre></div></div><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="querysql"/>第16章 ネイティブSQL</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#querysql-creating">16.1. <code class="literal">SQLQuery</code> の使用</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e13308">16.1.1. スカラーのクエリ</a></span></dt><dt><span class="sect2"><a href="#d0e13358">16.1.2. エンティティのクエリ</a></span></dt><dt><span class="sect2"><a href="#d0e13394">16.1.3. 関連とコレクションの操作</a></span></dt><dt><span class="sect2"><a href="#d0e13425">16.1.4. 複数エンティティの取得</a></span></dt><dt><span class="sect2"><a href="#d0e13566">16.1.5. 管理されていないエンティティの取得</a></span></dt><dt><span class="sect2"><a href="#d0e13587">16.1.6. 継承の制御</a></span></dt><dt><span class="sect2"><a href="#d0e13592">16.1.7. パラメータ</a></span></dt></dl></dd><dt><span class="sect1"><a href="#querysql-namedqueries">16.2. 名前付きSQLクエリ</a></span></dt><dd><dl><dt><span class="sect2"><a href="#propertyresults">16.2.1. 列と列の別名を明示的に指定するために return-property を使う</a></span></dt><dt><span class="sect2"><a href="#sp_query">16.2.2. 問い合わせするためにストアドプロシージャを使う</a></span></dt></dl></dd><dt><span class="sect1"><a href="#querysql-cud">16.3. 作成、更新、削除のためのカスタムSQL</a></span></dt><dt><span class="sect1"><a href="#querysql-load">16.4. ロードのためのカスタムSQL</a></span></dt></dl></div><p>You can also express queries in the native SQL dialect of your database. This is useful if you want to utilize database-specific features such as query hints or the <code class="literal">CONNECT</code> keyword in Oracle. It also provides a clean migration path from a direct SQL/JDBC based application to Hibernate.</p><p>Hibernate3 allows you to specify handwritten SQL, including stored procedures, for all create, update, delete, and load operations.</p><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="querysql-creating"/>16.1. <code class="literal">SQLQuery</code> の使用</h2></div></div></div><p>Execution of native SQL queries is controlled via the <code class="literal">SQLQuery</code> interface, which is obtained by calling <code class="literal">Session.createSQLQuery()</code>. The following sections describe how to use this API for querying.</p><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13308"/>16.1.1. スカラーのクエリ</h3></div></div></div><p>最も基本的なSQLクエリはスカラー（値）のリストを得ることです。</p><pre class="programlisting">sess.createSQLQuery("SELECT * FROM CATS").list();
sess.createSQLQuery("SELECT ID, NAME, BIRTHDATE FROM CATS").list();
</pre><p>These will return a List of Object arrays (Object[]) with scalar values for each column in the CATS table. Hibernate will use ResultSetMetadata to deduce the actual order and types of the returned scalar values.</p><p>To avoid the overhead of using <code class="literal">ResultSetMetadata</code>, or simply to be more explicit in what is returned, one can use <code class="literal">addScalar()</code>:</p><pre class="programlisting">sess.createSQLQuery("SELECT * FROM CATS")
 .addScalar("ID", Hibernate.LONG)
 .addScalar("NAME", Hibernate.STRING)
 .addScalar("BIRTHDATE", Hibernate.DATE)
</pre><p>このクエリで指定されているものを下記に示します。</p><div class="itemizedlist"><ul><li><p>SQLクエリ文字列</p></li><li><p>返されるカラムと型</p></li></ul></div><p>This will return Object arrays, but now it will not use <code class="literal">ResultSetMetadata</code> but will instead explicitly get the ID, NAME and BIRTHDATE column as respectively a Long, String and a Short from the underlying resultset. This also means that only these three columns will be returned, even though the query is using <code class="literal">*</code> and could return more than the three listed columns.</p><p>スカラーの型情報を省くこともできます。</p><pre class="programlisting">sess.createSQLQuery("SELECT * FROM CATS")
 .addScalar("ID", Hibernate.LONG)
 .addScalar("NAME")
 .addScalar("BIRTHDATE")
</pre><p>This is essentially the same query as before, but now <code class="literal">ResultSetMetaData</code> is used to determine the type of NAME and BIRTHDATE, where as the type of ID is explicitly specified.</p><p>How the java.sql.Types returned from ResultSetMetaData is mapped to Hibernate types is controlled by the Dialect. If a specific type is not mapped, or does not result in the expected type, it is possible to customize it via calls to <code class="literal">registerHibernateType</code> in the Dialect.</p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13358"/>16.1.2. エンティティのクエリ</h3></div></div></div><p>ここまでのクエリは、すべてスカラー値を返すものでした。 基本的に、リザルトセットから「未加工」の値を返します。 以降では、<code class="literal">addEntity()</code> により、ネイティブSQLクエリから エンティティオブジェクトを取得する方法を示します。</p><pre class="programlisting">sess.createSQLQuery("SELECT * FROM CATS").addEntity(Cat.class);
sess.createSQLQuery("SELECT ID, NAME, BIRTHDATE FROM CATS").addEntity(Cat.class);
</pre><p>このクエリで指定されているものを下記に示します。</p><div class="itemizedlist"><ul><li><p>SQLクエリ文字列</p></li><li><p>クエリが返すエンティティとSQLテーブルの別名</p></li></ul></div><p>CatがID, NAME, BIRTHDATEのカラムを使ってクラスにマッピングされる場合、 上記のクエリはどちらも、要素がCatエンティティであるリストを返します。</p><p>エンティティを別のエンティティに <code class="literal">多対一</code> でマッピングしている場合は、 ネイティブクエリを実行する際に、この別のエンティティを返すことも要求します。 さもなければ、データベース固有の「column not found(カラムが見つかりません)」エラーが発生します。 * 表記を使用した際は、追加のカラムが自動的に返されますが、 次の例のように、<code class="literal">Dog</code> に <code class="literal">多対一</code> であることを 明示することを私たちは好みます。</p><pre class="programlisting">sess.createSQLQuery("SELECT ID, NAME, BIRTHDATE, DOG_ID FROM CATS").addEntity(Cat.class);
</pre><p>これにより cat.getDog() が正しく機能します。</p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13394"/>16.1.3. 関連とコレクションの操作</h3></div></div></div><p>プロキシを初期化するための余分な処理を避けるため、 <code class="literal">Dog</code> の中で即時結合できます。 これは <code class="literal">addJoin()</code> メソッドにより行います。 関連もしくはコレクションに結合できます。</p><pre class="programlisting">sess.createSQLQuery("SELECT c.ID, NAME, BIRTHDATE, DOG_ID, D_ID, D_NAME FROM CATS c, DOGS d WHERE c.DOG_ID = d.D_ID")
 .addEntity("cat", Cat.class)
 .addJoin("cat.dog");
</pre><p>In this example, the returned <code class="literal">Cat</code>'s will have their <code class="literal">dog</code> property fully initialized without any extra roundtrip to the database. Notice that you added an alias name ("cat") to be able to specify the target property path of the join. It is possible to do the same eager joining for collections, e.g. if the <code class="literal">Cat</code> had a one-to-many to <code class="literal">Dog</code> instead.</p><pre class="programlisting">sess.createSQLQuery("SELECT ID, NAME, BIRTHDATE, D_ID, D_NAME, CAT_ID FROM CATS c, DOGS d WHERE c.ID = d.CAT_ID")
 .addEntity("cat", Cat.class)
 .addJoin("cat.dogs");
</pre><p>At this stage you are reaching the limits of what is possible with native queries, without starting to enhance the sql queries to make them usable in Hibernate. Problems can arise when returning multiple entities of the same type or when the default alias/column names are not enough. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13425"/>16.1.4. 複数エンティティの取得</h3></div></div></div><p>Until now, the result set column names are assumed to be the same as the column names specified in the mapping document. This can be problematic for SQL queries that join multiple tables, since the same column names can appear in more than one table.</p><p>下記のような（失敗しそうな）クエリでは、 カラム別名インジェクション（column alias injection）が必要です。</p><pre class="programlisting">sess.createSQLQuery("SELECT c.*, m.*  FROM CATS c, CATS m WHERE c.MOTHER_ID = c.ID")
 .addEntity("cat", Cat.class)
 .addEntity("mother", Cat.class)
</pre><p>The query was intended to return two Cat instances per row: a cat and its mother. The query will, however, fail because there is a conflict of names; the instances are mapped to the same column names. Also, on some databases the returned column aliases will most likely be on the form "c.ID", "c.NAME", etc. which are not equal to the columns specified in the mappings ("ID" and "NAME"). </p><p>下記の形式は、カラム名が重複しても大丈夫です。</p><pre class="programlisting">sess.createSQLQuery("SELECT {cat.*}, {mother.*}  FROM CATS c, CATS m WHERE c.MOTHER_ID = c.ID")
 .addEntity("cat", Cat.class)
 .addEntity("mother", Cat.class)
</pre><p>このクエリで指定されているものを下記に示します。</p><div class="itemizedlist"><ul><li><p>SQLクエリ文字列 （Hibernateがカラムの別名を挿入するためのプレースホルダを含む）</p></li><li><p>クエリによって返されるエンティティ</p></li></ul></div><p>The {cat.*} and {mother.*} notation used above is a shorthand for "all properties". Alternatively, you can list the columns explicitly, but even in this case Hibernate injects the SQL column aliases for each property. The placeholder for a column alias is just the property name qualified by the table alias. In the following example, you retrieve Cats and their mothers from a different table (cat_log) to the one declared in the mapping metadata. You can even use the property aliases in the where clause.</p><pre class="programlisting">String sql = "SELECT ID as {c.id}, NAME as {c.name}, " + 
         "BIRTHDATE as {c.birthDate}, MOTHER_ID as {c.mother}, {mother.*} " +
         "FROM CAT_LOG c, CAT_LOG m WHERE {c.mother} = c.ID";

List loggedCats = sess.createSQLQuery(sql)
        .addEntity("cat", Cat.class)
        .addEntity("mother", Cat.class).list()
</pre><div class="sect3" lang="ja-JP"><div class="titlepage"><div><div><h4 class="title"><a id="querysql-aliasreferences"/>16.1.4.1. 別名とプロパティのリファレンス</h4></div></div></div><p>In most cases the above alias injection is needed. For queries relating to more complex mappings, like composite properties, inheritance discriminators, collections etc., you can use specific aliases that allow Hibernate to inject the proper aliases.</p><p>The following table shows the different ways you can use the alias injection. Please note that the alias names in the result are simply examples; each alias will have a unique and probably different name when used.</p><div class="table"><a id="aliasinjection-summary"/><p class="title"><b>表 16.1. 別名に挿入する名前</b></p><div class="table-contents"><table summary="別名に挿入する名前" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>説明</th><th>構文</th><th>例</th></tr></thead><tbody><tr><td>単純なプロパティ</td><td><code class="literal">{[aliasname].[propertyname]}</code></td><td><code class="literal">A_NAME as {item.name}</code></td></tr><tr><td>複合プロパティ</td><td><code class="literal">{[aliasname].[componentname].[propertyname]}</code></td><td><code class="literal">CURRENCY as {item.amount.currency}, VALUE as {item.amount.value}</code></td></tr><tr><td>エンティティのクラスを識別する値</td><td><code class="literal">{[aliasname].class}</code></td><td><code class="literal">DISC as {item.class}</code></td></tr><tr><td>エンティティの全プロパティ</td><td><code class="literal">{[aliasname].*}</code></td><td><code class="literal">{item.*}</code></td></tr><tr><td>コレクションのキー</td><td><code class="literal">{[aliasname].key}</code></td><td><code class="literal">ORGID as {coll.key}</code></td></tr><tr><td>コレクションのID</td><td><code class="literal">{[aliasname].id}</code></td><td><code class="literal">EMPID as {coll.id}</code></td></tr><tr><td>コレクションの要素</td><td><code class="literal">{[aliasname].element}</code></td><td><code class="literal">XID as {coll.element}</code></td></tr><tr><td>property of the element in the collection</td><td><code class="literal">{[aliasname].element.[propertyname]}</code></td><td><code class="literal">NAME as {coll.element.name}</code></td></tr><tr><td>コレクションの要素の全プロパティ</td><td><code class="literal">{[aliasname].element.*}</code></td><td><code class="literal">{coll.element.*}</code></td></tr><tr><td>コレクションの全プロパティ</td><td><code class="literal">{[aliasname].*}</code></td><td><code class="literal">{coll.*}</code></td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13566"/>16.1.5. 管理されていないエンティティの取得</h3></div></div></div><p>It is possible to apply a ResultTransformer to native SQL queries, allowing it to return non-managed entities.</p><pre class="programlisting">sess.createSQLQuery("SELECT NAME, BIRTHDATE FROM CATS")
        .setResultTransformer(Transformers.aliasToBean(CatDTO.class))</pre><p>このクエリで指定されているものを下記に示します。</p><div class="itemizedlist"><ul><li><p>SQLクエリ文字列</p></li><li><p>結果を変換したもの</p></li></ul></div><p>上記のクエリは、インスタンス化し、NAME と BIRTHDATE の値を 対応するプロパティもしくはフィールドに挿入した <code class="literal">CatDTO</code> のリストを返します。 </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13587"/>16.1.6. 継承の制御</h3></div></div></div><p>Native SQL queries which query for entities that are mapped as part of an inheritance must include all properties for the baseclass and all its subclasses.</p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13592"/>16.1.7. パラメータ</h3></div></div></div><p>Native SQL queries support positional as well as named parameters:</p><pre class="programlisting">Query query = sess.createSQLQuery("SELECT * FROM CATS WHERE NAME like ?").addEntity(Cat.class);
List pusList = query.setString(0, "Pus%").list();
     
query = sess.createSQLQuery("SELECT * FROM CATS WHERE NAME like :name").addEntity(Cat.class);
List pusList = query.setString("name", "Pus%").list();          </pre></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="querysql-namedqueries"/>16.2. 名前付きSQLクエリ</h2></div></div></div><p>Named SQL queries can be defined in the mapping document and called in exactly the same way as a named HQL query. In this case, you do <span class="emphasis"><em>not</em></span> need to call <code class="literal">addEntity()</code>.</p><pre class="programlisting">&lt;sql-query name="persons"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex}
    FROM PERSON person
    WHERE person.NAME LIKE :namePattern
&lt;/sql-query&gt;</pre><pre class="programlisting">List people = sess.getNamedQuery("persons")
    .setString("namePattern", namePattern)
    .setMaxResults(50)
    .list();</pre><p>The <code class="literal">&lt;return-join&gt;</code> element is use to join associations and the <code class="literal">&lt;load-collection&gt;</code> element is used to define queries which initialize collections, </p><pre class="programlisting">&lt;sql-query name="personsWith"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    &lt;return-join alias="address" property="person.mailingAddress"/&gt;
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex},
           address.STREET AS {address.street},
           address.CITY AS {address.city},
           address.STATE AS {address.state},
           address.ZIP AS {address.zip}
    FROM PERSON person
    JOIN ADDRESS address
        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'
    WHERE person.NAME LIKE :namePattern
&lt;/sql-query&gt;</pre><p>名前付きSQLクエリはスカラ値を返すこともできます。 <code class="literal">&lt;return-scalar&gt;</code> 要素を使って、 列の別名とHibernateの型を宣言しなければなりません。</p><pre class="programlisting">&lt;sql-query name="mySqlQuery"&gt;
    &lt;return-scalar column="name" type="string"/&gt;
    &lt;return-scalar column="age" type="long"/&gt;
    SELECT p.NAME AS name,
           p.AGE AS age,
    FROM PERSON p WHERE p.NAME LIKE 'Hiber%'
&lt;/sql-query&gt;</pre><p>You can externalize the resultset mapping information in a <code class="literal">&lt;resultset&gt;</code> element which will allow you to either reuse them across several named queries or through the <code class="literal">setResultSetMapping()</code> API.</p><pre class="programlisting">&lt;resultset name="personAddress"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    &lt;return-join alias="address" property="person.mailingAddress"/&gt;
&lt;/resultset&gt;

&lt;sql-query name="personsWith" resultset-ref="personAddress"&gt;
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex},
           address.STREET AS {address.street},
           address.CITY AS {address.city},
           address.STATE AS {address.state},
           address.ZIP AS {address.zip}
    FROM PERSON person
    JOIN ADDRESS address
        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'
    WHERE person.NAME LIKE :namePattern
&lt;/sql-query&gt;</pre><p>You can, alternatively, use the resultset mapping information in your hbm files directly in java code.</p><pre class="programlisting">List cats = sess.createSQLQuery(
        "select {cat.*}, {kitten.*} from cats cat, cats kitten where kitten.mother = cat.id"
    )
    .setResultSetMapping("catAndKitten")
    .list();</pre><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="propertyresults"/>16.2.1. 列と列の別名を明示的に指定するために return-property を使う</h3></div></div></div><p>You can explicitly tell Hibernate what column aliases to use with <code class="literal">&lt;return-property&gt;</code>, instead of using the <code class="literal">{}</code>-syntax to let Hibernate inject its own aliases.For example:</p><pre class="programlisting">&lt;sql-query name="mySqlQuery"&gt;
    &lt;return alias="person" class="eg.Person"&gt;
        &lt;return-property name="name" column="myName"/&gt;
        &lt;return-property name="age" column="myAge"/&gt;
        &lt;return-property name="sex" column="mySex"/&gt;
    &lt;/return&gt;
    SELECT person.NAME AS myName,
           person.AGE AS myAge,
           person.SEX AS mySex,
    FROM PERSON person WHERE person.NAME LIKE :name
&lt;/sql-query&gt;
</pre><p><code class="literal">&lt;return-property&gt;</code> also works with multiple columns. This solves a limitation with the <code class="literal">{}</code>-syntax which cannot allow fine grained control of multi-column properties.</p><pre class="programlisting">&lt;sql-query name="organizationCurrentEmployments"&gt;
    &lt;return alias="emp" class="Employment"&gt;
        &lt;return-property name="salary"&gt;
            &lt;return-column name="VALUE"/&gt;
            &lt;return-column name="CURRENCY"/&gt;
        &lt;/return-property&gt;
        &lt;return-property name="endDate" column="myEndDate"/&gt;
    &lt;/return&gt;
        SELECT EMPLOYEE AS {emp.employee}, EMPLOYER AS {emp.employer},
        STARTDATE AS {emp.startDate}, ENDDATE AS {emp.endDate},
        REGIONCODE as {emp.regionCode}, EID AS {emp.id}, VALUE, CURRENCY
        FROM EMPLOYMENT
        WHERE EMPLOYER = :id AND ENDDATE IS NULL
        ORDER BY STARTDATE ASC
&lt;/sql-query&gt;</pre><p>In this example <code class="literal">&lt;return-property&gt;</code> was used in combination with the <code class="literal">{}</code>-syntax for injection. This allows users to choose how they want to refer column and properties.</p><p>マッピングに discriminator が含まれている場合、 discriminator の列を指定するために、&lt;return-discriminator&gt; を使わなければなりません。</p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="sp_query"/>16.2.2. 問い合わせするためにストアドプロシージャを使う</h3></div></div></div><p>Hibernate3 provides support for queries via stored procedures and functions. Most of the following documentation is equivalent for both. The stored procedure/function must return a resultset as the first out-parameter to be able to work with Hibernate. An example of such a stored function in Oracle 9 and higher is as follows:</p><pre class="programlisting">CREATE OR REPLACE FUNCTION selectAllEmployments
    RETURN SYS_REFCURSOR
AS
    st_cursor SYS_REFCURSOR;
BEGIN
    OPEN st_cursor FOR
 SELECT EMPLOYEE, EMPLOYER,
 STARTDATE, ENDDATE,
 REGIONCODE, EID, VALUE, CURRENCY
 FROM EMPLOYMENT;
      RETURN  st_cursor;
 END;</pre><p>Hibernateでこのクエリを使うためには、 名前付きクエリでマッピングする必要があります。</p><pre class="programlisting">&lt;sql-query name="selectAllEmployees_SP" callable="true"&gt;
    &lt;return alias="emp" class="Employment"&gt;
        &lt;return-property name="employee" column="EMPLOYEE"/&gt;
        &lt;return-property name="employer" column="EMPLOYER"/&gt;
        &lt;return-property name="startDate" column="STARTDATE"/&gt;
        &lt;return-property name="endDate" column="ENDDATE"/&gt;
        &lt;return-property name="regionCode" column="REGIONCODE"/&gt;
        &lt;return-property name="id" column="EID"/&gt;
        &lt;return-property name="salary"&gt;
            &lt;return-column name="VALUE"/&gt;
            &lt;return-column name="CURRENCY"/&gt;
        &lt;/return-property&gt;
    &lt;/return&gt;
    { ? = call selectAllEmployments() }
&lt;/sql-query&gt;</pre><p>Stored procedures currently only return scalars and entities. <code class="literal">&lt;return-join&gt;</code> and <code class="literal">&lt;load-collection&gt;</code> are not supported.</p><div class="sect3" lang="ja-JP"><div class="titlepage"><div><div><h4 class="title"><a id="querysql-limits-storedprocedures"/>16.2.2.1. ストアドプロシージャを使う上でのルールと制限</h4></div></div></div><p>You cannot use stored procedures with Hibernate unless you follow some procedure/function rules. If they do not follow those rules they are not usable with Hibernate. If you still want to use these procedures you have to execute them via <code class="literal">session.connection()</code>. The rules are different for each database, since database vendors have different stored procedure semantics/syntax.</p><p>Stored procedure queries cannot be paged with <code class="literal">setFirstResult()/setMaxResults()</code>.</p><p>The recommended call form is standard SQL92: <code class="literal">{ ? = call functionName(&lt;parameters&gt;) }</code> or <code class="literal">{ ? = call procedureName(&lt;parameters&gt;}</code>. Native call syntax is not supported.</p><p>Oracleには下記のルールが適用されます。</p><div class="itemizedlist"><ul compact="compact"><li><p>A function must return a result set. The first parameter of a procedure must be an <code class="literal">OUT</code> that returns a result set. This is done by using a <code class="literal">SYS_REFCURSOR</code> type in Oracle 9 or 10. In Oracle you need to define a <code class="literal">REF CURSOR</code> type. See Oracle literature for further information.</p></li></ul></div><p>SybaseとMS SQLサーバーに適用されるルールを下記に示します。</p><div class="itemizedlist"><ul compact="compact"><li><p>The procedure must return a result set. Note that since these servers can return multiple result sets and update counts, Hibernate will iterate the results and take the first result that is a result set as its return value. Everything else will be discarded.</p></li><li><p>プロシージャの中で <code class="literal">SET NOCOUNT ON</code> を有効にできれば、 おそらく効率がよくなるでしょう。 しかし、これは必要条件ではありません。</p></li></ul></div></div></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="querysql-cud"/>16.3. 作成、更新、削除のためのカスタムSQL</h2></div></div></div><p>Hibernate3は作成、更新、削除処理のためのカスタムSQL文を使用できます。 クラスとコレクションの永続化機構は、コンフィグレーション時に生成された文字列 （insertsql、deletesql、updatesqlなど）のセットをすでに保持しています。 これらの文字列より、 <code class="literal">&lt;sql-insert&gt;</code>、 <code class="literal">&lt;sql-delete&gt;</code>、 <code class="literal">&lt;sql-update&gt;</code> というマッピングタグが優先されます。</p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true"/&gt;
    &lt;sql-insert&gt;INSERT INTO PERSON (NAME, ID) VALUES ( UPPER(?), ? )&lt;/sql-insert&gt;
    &lt;sql-update&gt;UPDATE PERSON SET NAME=UPPER(?) WHERE ID=?&lt;/sql-update&gt;
    &lt;sql-delete&gt;DELETE FROM PERSON WHERE ID=?&lt;/sql-delete&gt;
&lt;/class&gt;</pre><p>The SQL is directly executed in your database, so you can use any dialect you like. This will reduce the portability of your mapping if you use database specific SQL.</p><p><code class="literal">callable</code> 属性をセットすれば、 ストアドプロシージャを使用できます。</p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true"/&gt;
    &lt;sql-insert callable="true"&gt;{call createPerson (?, ?)}&lt;/sql-insert&gt;
    &lt;sql-delete callable="true"&gt;{? = call deletePerson (?)}&lt;/sql-delete&gt;
    &lt;sql-update callable="true"&gt;{? = call updatePerson (?, ?)}&lt;/sql-update&gt;
&lt;/class&gt;</pre><p>The order of the positional parameters is vital, as they must be in the same sequence as Hibernate expects them.</p><p>You can view the expected order by enabling debug logging for the <code class="literal">org.hibernate.persister.entity</code> level. With this level enabled, Hibernate will print out the static SQL that is used to create, update, delete etc. entities. To view the expected sequence, do not include your custom SQL in the mapping files, as this will override the Hibernate generated static SQL.</p><p>The stored procedures are in most cases required to return the number of rows inserted, updated and deleted, as Hibernate has some runtime checks for the success of the statement. Hibernate always registers the first statement parameter as a numeric output parameter for the CUD operations:</p><pre class="programlisting">CREATE OR REPLACE FUNCTION updatePerson (uid IN NUMBER, uname IN VARCHAR2)
    RETURN NUMBER IS
BEGIN

    update PERSON
    set
        NAME = uname,
    where
        ID = uid;

    return SQL%ROWCOUNT;

END updatePerson;</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="querysql-load"/>16.4. ロードのためのカスタムSQL</h2></div></div></div><p>You can also declare your own SQL (or HQL) queries for entity loading:</p><pre class="programlisting">&lt;sql-query name="person"&gt;
    &lt;return alias="pers" class="Person" lock-mode="upgrade"/&gt;
    SELECT NAME AS {pers.name}, ID AS {pers.id}
    FROM PERSON
    WHERE ID=?
    FOR UPDATE
&lt;/sql-query&gt;</pre><p>This is just a named query declaration, as discussed earlier. You can reference this named query in a class mapping:</p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true"/&gt;
    &lt;loader query-ref="person"/&gt;
&lt;/class&gt;</pre><p>これはストアドプロシージャでさえも動作します。</p><p>You can even define a query for collection loading:</p><pre class="programlisting">&lt;set name="employments" inverse="true"&gt;
    &lt;key/&gt;
    &lt;one-to-many class="Employment"/&gt;
    &lt;loader query-ref="employments"/&gt;
&lt;/set&gt;</pre><pre class="programlisting">&lt;sql-query name="employments"&gt;
    &lt;load-collection alias="emp" role="Person.employments"/&gt;
    SELECT {emp.*}
    FROM EMPLOYMENT emp
    WHERE EMPLOYER = :id
    ORDER BY STARTDATE ASC, EMPLOYEE ASC
&lt;/sql-query&gt;</pre><p>You can also define an entity loader that loads a collection by join fetching:</p><pre class="programlisting">&lt;sql-query name="person"&gt;
    &lt;return alias="pers" class="Person"/&gt;
    &lt;return-join alias="emp" property="pers.employments"/&gt;
    SELECT NAME AS {pers.*}, {emp.*}
    FROM PERSON pers
    LEFT OUTER JOIN EMPLOYMENT emp
        ON pers.ID = emp.PERSON_ID
    WHERE ID=?
&lt;/sql-query&gt;</pre></div></div><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="filters"/>第17章 データのフィルタリング</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#objectstate-filters">17.1. Hibernateのフィルタ</a></span></dt></dl></div><p>Hibernate3 provides an innovative new approach to handling data with "visibility" rules. A <span class="emphasis"><em>Hibernate filter</em></span> is a global, named, parameterized filter that can be enabled or disabled for a particular Hibernate session. </p><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-filters"/>17.1. Hibernateのフィルタ</h2></div></div></div><p>Hibernate3 has the ability to pre-define filter criteria and attach those filters at both a class level and a collection level. A filter criteria allows you to define a restriction clause similar to the existing "where" attribute available on the class and various collection elements. These filter conditions, however, can be parameterized. The application can then decide at runtime whether certain filters should be enabled and what their parameter values should be. Filters can be used like database views, but they are parameterized inside the application. </p><p>フィルタを使うためにはまず、適切なマッピング要素に定義、追加しなくてはなりません。 フィルタを定義するためには、 <code class="literal">&lt;hibernate-mapping/&gt;</code> 要素内で <code class="literal">&lt;filter-def/&gt;</code> 要素を使用します。： </p><pre class="programlisting">&lt;filter-def name="myFilter"&gt;
    &lt;filter-param name="myFilterParam" type="string"/&gt;
&lt;/filter-def&gt;</pre><p>This filter can then be attached to a class: </p><pre class="programlisting">&lt;class name="myClass" ...&gt;
    ...
    &lt;filter name="myFilter" condition=":myFilterParam = MY_FILTERED_COLUMN"/&gt;
&lt;/class&gt;</pre><p>Or, to a collection: </p><pre class="programlisting">&lt;set ...&gt;
    &lt;filter name="myFilter" condition=":myFilterParam = MY_FILTERED_COLUMN"/&gt;
&lt;/set&gt;</pre><p>Or, to both or multiples of each at the same time. </p><p>The methods on <code class="literal">Session</code> are: <code class="literal">enableFilter(String filterName)</code>, <code class="literal">getEnabledFilter(String filterName)</code>, and <code class="literal">disableFilter(String filterName)</code>. By default, filters are <span class="emphasis"><em>not</em></span> enabled for a given session. Filters must be enabled through use of the <code class="literal">Session.enableFilter()</code> method, which returns an instance of the <code class="literal">Filter</code> interface. If you used the simple filter defined above, it would look like this: </p><pre class="programlisting">session.enableFilter("myFilter").setParameter("myFilterParam", "some-value");</pre><p>Methods on the org.hibernate.Filter interface do allow the method-chaining common to much of Hibernate. </p><p>The following is a full example, using temporal data with an effective record date pattern: </p><pre class="programlisting">&lt;filter-def name="effectiveDate"&gt;
    &lt;filter-param name="asOfDate" type="date"/&gt;
&lt;/filter-def&gt;

&lt;class name="Employee" ...&gt;
...
    &lt;many-to-one name="department" column="dept_id" class="Department"/&gt;
    &lt;property name="effectiveStartDate" type="date" column="eff_start_dt"/&gt;
    &lt;property name="effectiveEndDate" type="date" column="eff_end_dt"/&gt;
...
    &lt;!--
        Note that this assumes non-terminal records have an eff_end_dt set to
        a max db date for simplicity-sake
    --&gt;
    &lt;filter name="effectiveDate"
            condition=":asOfDate BETWEEN eff_start_dt and eff_end_dt"/&gt;
&lt;/class&gt;

&lt;class name="Department" ...&gt;
...
    &lt;set name="employees" lazy="true"&gt;
        &lt;key column="dept_id"/&gt;
        &lt;one-to-many class="Employee"/&gt;
        &lt;filter name="effectiveDate"
                condition=":asOfDate BETWEEN eff_start_dt and eff_end_dt"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>In order to ensure that you are provided with currently effective records, enable the filter on the session prior to retrieving employee data: </p><pre class="programlisting">Session session = ...;
session.enableFilter("effectiveDate").setParameter("asOfDate", new Date());
List results = session.createQuery("from Employee as e where e.salary &gt; :targetSalary")
         .setLong("targetSalary", new Long(1000000))
         .list();
</pre><p>Even though a salary constraint was mentioned explicitly on the results in the above HQL, because of the enabled filter, the query will return only currently active employees who have a salary greater than one million dollars. </p><p>If you want to use filters with outer joining, either through HQL or load fetching, be careful of the direction of the condition expression. It is safest to set this up for left outer joining. Place the parameter first followed by the column name(s) after the operator. </p><p>After being defined, a filter might be attached to multiple entities and/or collections each with its own condition. This can be problematic when the conditions are the same each time. Using <code class="literal">&lt;filter-def/&gt;</code> allows you to definine a default condition, either as an attribute or CDATA: </p><pre class="programlisting">&lt;filter-def name="myFilter" condition="abc &gt; xyz"&gt;...&lt;/filter-def&gt;
&lt;filter-def name="myOtherFilter"&gt;abc=xyz&lt;/filter-def&gt;</pre><p>This default condition will be used whenever the filter is attached to something without specifying a condition. This means you can give a specific condition as part of the attachment of the filter that overrides the default condition in that particular case. </p></div></div><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="xml"/>第18章 XMLマッピング</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#xml-intro">18.1. XMLデータでの作業</a></span></dt><dd><dl><dt><span class="sect2"><a href="#xml-intro-mapping">18.1.1. XMLとクラスのマッピングを同時に指定する</a></span></dt><dt><span class="sect2"><a href="#xml-onlyxml">18.1.2. XMLマッピングだけを指定する</a></span></dt></dl></dd><dt><span class="sect1"><a href="#xml-mapping">18.2. XMLマッピングのメタデータ</a></span></dt><dt><span class="sect1"><a href="#xml-manipulation">18.3. XMLデータを扱う</a></span></dt></dl></div><p><span class="emphasis"><em>XML Mapping is an experimental feature in Hibernate 3.0 and is currently under active development. </em></span></p><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="xml-intro"/>18.1. XMLデータでの作業</h2></div></div></div><p>Hibernate allows you to work with persistent XML data in much the same way you work with persistent POJOs. A parsed XML tree can be thought of as another way of representing the relational data at the object level, instead of POJOs. </p><p>HibernateはXMLツリーを操作するためのAPIとしてdom4jをサポートしています。 データベースからdom4jのツリーを復元するクエリを書くことができ、 ツリーに対して行った修正は自動的にデータベースと同期されます。 またXMLドキュメントを取得することができ、dom4jを使ってドキュメントをパースし、 Hibernateの任意の基本操作を使ってデータベースへ書き込むことができます。： つまり、<code class="literal">persist(), saveOrUpdate(), merge(), delete(), replicate()</code> 操作です(マージはまだサポートしていません)。 </p><p>データのインポート/エクスポート、 JMSによるエンティティデータの外部化やSOAP、XSLTベースのレポートなど、 この機能には多くの用途があります。 </p><p>A single mapping can be used to simultaneously map properties of a class and nodes of an XML document to the database, or, if there is no class to map, it can be used to map just the XML. </p><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="xml-intro-mapping"/>18.1.1. XMLとクラスのマッピングを同時に指定する</h3></div></div></div><p>これはPOJOとXMLを同時にマッピングする例です。： </p><pre class="programlisting">&lt;class name="Account" 
        table="ACCOUNTS" 
        node="account"&gt;
        
    &lt;id name="accountId" 
            column="ACCOUNT_ID" 
            node="@id"/&gt;
            
    &lt;many-to-one name="customer" 
            column="CUSTOMER_ID" 
            node="customer/@id" 
            embed-xml="false"/&gt;
            
    &lt;property name="balance" 
            column="BALANCE" 
            node="balance"/&gt;
            
    ...
    
&lt;/class&gt;</pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="xml-onlyxml"/>18.1.2. XMLマッピングだけを指定する</h3></div></div></div><p>これはPOJOクラスがないマッピングの例です。： </p><pre class="programlisting">&lt;class entity-name="Account" 
        table="ACCOUNTS" 
        node="account"&gt;
        
    &lt;id name="id" 
            column="ACCOUNT_ID" 
            node="@id" 
            type="string"/&gt;
            
    &lt;many-to-one name="customerId" 
            column="CUSTOMER_ID" 
            node="customer/@id" 
            embed-xml="false" 
            entity-name="Customer"/&gt;
            
    &lt;property name="balance" 
            column="BALANCE" 
            node="balance" 
            type="big_decimal"/&gt;
            
    ...
    
&lt;/class&gt;</pre><p>This mapping allows you to access the data as a dom4j tree, or as a graph of property name/value pairs or java <code class="literal">Map</code>s. The property names are purely logical constructs that can be referred to in HQL queries. </p></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="xml-mapping"/>18.2. XMLマッピングのメタデータ</h2></div></div></div><p>A range of Hibernate mapping elements accept the <code class="literal">node</code> attribute. This lets you specify the name of an XML attribute or element that holds the property or entity data. The format of the <code class="literal">node</code> attribute must be one of the following: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">"element-name"</code>: map to the named XML element</p></li><li><p><code class="literal">"@attribute-name"</code>: map to the named XML attribute</p></li><li><p><code class="literal">"."</code>: map to the parent element</p></li><li><p><code class="literal">"element-name/@attribute-name"</code>: map to the named attribute of the named element </p></li></ul></div><p>For collections and single valued associations, there is an additional <code class="literal">embed-xml</code> attribute. If <code class="literal">embed-xml="true"</code>, the default, the XML tree for the associated entity (or collection of value type) will be embedded directly in the XML tree for the entity that owns the association. Otherwise, if <code class="literal">embed-xml="false"</code>, then only the referenced identifier value will appear in the XML for single point associations and collections will not appear at all. </p><p>Do not leave <code class="literal">embed-xml="true"</code> for too many associations, since XML does not deal well with circularity. </p><pre class="programlisting">&lt;class name="Customer" 
        table="CUSTOMER" 
        node="customer"&gt;
        
    &lt;id name="id" 
            column="CUST_ID" 
            node="@id"/&gt;
            
    &lt;map name="accounts" 
            node="." 
            embed-xml="true"&gt;
        &lt;key column="CUSTOMER_ID" 
                not-null="true"/&gt;
        &lt;map-key column="SHORT_DESC" 
                node="@short-desc" 
                type="string"/&gt;
        &lt;one-to-many entity-name="Account"
                embed-xml="false" 
                node="account"/&gt;
    &lt;/map&gt;
    
    &lt;component name="name" 
            node="name"&gt;
        &lt;property name="firstName" 
                node="first-name"/&gt;
        &lt;property name="initial" 
                node="initial"/&gt;
        &lt;property name="lastName" 
                node="last-name"/&gt;
    &lt;/component&gt;
    
    ...
    
&lt;/class&gt;</pre><p>In this case, the collection of account ids is embedded, but not the actual account data. The following HQL query: </p><pre class="programlisting">from Customer c left join fetch c.accounts where c.lastName like :lastName</pre><p>would return datasets such as this: </p><pre class="programlisting">&lt;customer id="123456789"&gt;
    &lt;account short-desc="Savings"&gt;987632567&lt;/account&gt;
    &lt;account short-desc="Credit Card"&gt;985612323&lt;/account&gt;
    &lt;name&gt;
        &lt;first-name&gt;Gavin&lt;/first-name&gt;
        &lt;initial&gt;A&lt;/initial&gt;
        &lt;last-name&gt;King&lt;/last-name&gt;
    &lt;/name&gt;
    ...
&lt;/customer&gt;</pre><p><code class="literal">&lt;one-to-many&gt;</code> マッピングで <code class="literal">embed-xml="true"</code> と設定した場合、 データはこのようになるでしょう。 </p><pre class="programlisting">&lt;customer id="123456789"&gt;
    &lt;account id="987632567" short-desc="Savings"&gt;
        &lt;customer id="123456789"/&gt;
        &lt;balance&gt;100.29&lt;/balance&gt;
    &lt;/account&gt;
    &lt;account id="985612323" short-desc="Credit Card"&gt;
        &lt;customer id="123456789"/&gt;
        &lt;balance&gt;-2370.34&lt;/balance&gt;
    &lt;/account&gt;
    &lt;name&gt;
        &lt;first-name&gt;Gavin&lt;/first-name&gt;
        &lt;initial&gt;A&lt;/initial&gt;
        &lt;last-name&gt;King&lt;/last-name&gt;
    &lt;/name&gt;
    ...
&lt;/customer&gt;</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="xml-manipulation"/>18.3. XMLデータを扱う</h2></div></div></div><p>You can also re-read and update XML documents in the application. You can do this by obtaining a dom4j session: </p><pre class="programlisting">Document doc = ....;
       
Session session = factory.openSession();
Session dom4jSession = session.getSession(EntityMode.DOM4J);
Transaction tx = session.beginTransaction();

List results = dom4jSession
    .createQuery("from Customer c left join fetch c.accounts where c.lastName like :lastName")
    .list();
for ( int i=0; i&lt;results.size(); i++ ) {
    //add the customer data to the XML document
    Element customer = (Element) results.get(i);
    doc.add(customer);
}

tx.commit();
session.close();</pre><pre class="programlisting">Session session = factory.openSession();
Session dom4jSession = session.getSession(EntityMode.DOM4J);
Transaction tx = session.beginTransaction();

Element cust = (Element) dom4jSession.get("Customer", customerId);
for ( int i=0; i&lt;results.size(); i++ ) {
    Element customer = (Element) results.get(i);
    //change the customer name in the XML and database
    Element name = customer.element("name");
    name.element("first-name").setText(firstName);
    name.element("initial").setText(initial);
    name.element("last-name").setText(lastName);
}

tx.commit();
session.close();</pre><p>When implementing XML-based data import/export, it is useful to combine this feature with Hibernate's <code class="literal">replicate()</code> operation. </p></div></div><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="performance"/>第19章 パフォーマンスの改善</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#performance-fetching">19.1. フェッチ戦略</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-fetching-lazy">19.1.1. 遅延関連の働き</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-custom">19.1.2. フェッチ戦略のチューニング</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-proxies">19.1.3. 単一端関連プロキシ</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-initialization">19.1.4. コレクションとプロキシの初期化</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-batch">19.1.5. バッチフェッチの使用</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-subselect">19.1.6. サブセレクトフェッチの使用</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-lazyproperties">19.1.7. 遅延プロパティフェッチの使用</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-cache">19.2. 第2レベルキャッシュ</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-cache-mapping">19.2.1. キャッシュのマッピング</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readonly">19.2.2. read only戦略</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readwrite">19.2.3. read/write戦略</a></span></dt><dt><span class="sect2"><a href="#performance-cache-nonstrict">19.2.4. 厳密ではないread/write戦略</a></span></dt><dt><span class="sect2"><a href="#performance-cache-transactional">19.2.5. transactional戦略</a></span></dt><dt><span class="sect2"><a href="#performance-cache-compat-matrix">19.2.6. Cache-provider/concurrency-strategy compatibility</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-sessioncache">19.3. キャッシュの管理</a></span></dt><dt><span class="sect1"><a href="#performance-querycache">19.4. クエリキャッシュ</a></span></dt><dt><span class="sect1"><a href="#performance-collections">19.5. コレクションのパフォーマンスの理解</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-collections-taxonomy">19.5.1. 分類</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficientupdate">19.5.2. 更新にもっとも効率的なコレクション list、map、idbag、set</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficentinverse">19.5.3. inverseコレクションにもっとも最適なbagとlist</a></span></dt><dt><span class="sect2"><a href="#performance-collections-oneshotdelete">19.5.4. 一括削除</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-monitoring">19.6. パフォーマンスのモニタリング</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-monitoring-sf">19.6.1. SessionFactoryのモニタリング</a></span></dt><dt><span class="sect2"><a href="#performance-monitoring-metrics">19.6.2. メトリクス</a></span></dt></dl></dd></dl></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="performance-fetching"/>19.1. フェッチ戦略</h2></div></div></div><p>Hibernate uses a <span class="emphasis"><em>fetching strategy</em></span> to retrieve associated objects if the application needs to navigate the association. Fetch strategies can be declared in the O/R mapping metadata, or over-ridden by a particular HQL or <code class="literal">Criteria</code> query. </p><p>Hibernate3は次に示すフェッチ戦略を定義しています。 </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Join fetching</em></span>: Hibernate retrieves the associated instance or collection in the same <code class="literal">SELECT</code>, using an <code class="literal">OUTER JOIN</code>. </p></li><li><p><span class="emphasis"><em>Select fetching</em></span>: a second <code class="literal">SELECT</code> is used to retrieve the associated entity or collection. Unless you explicitly disable lazy fetching by specifying <code class="literal">lazy="false"</code>, this second select will only be executed when you access the association. </p></li><li><p><span class="emphasis"><em>Subselect fetching</em></span>: a second <code class="literal">SELECT</code> is used to retrieve the associated collections for all entities retrieved in a previous query or fetch. Unless you explicitly disable lazy fetching by specifying <code class="literal">lazy="false"</code>, this second select will only be executed when you access the association. </p></li><li><p><span class="emphasis"><em>Batch fetching</em></span>: an optimization strategy for select fetching. Hibernate retrieves a batch of entity instances or collections in a single <code class="literal">SELECT</code> by specifying a list of primary or foreign keys. </p></li></ul></div><p>Hibernateは次に示す戦略とも区別をします。 </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Immediate fetching</em></span>: an association, collection or attribute is fetched immediately when the owner is loaded. </p></li><li><p><span class="emphasis"><em>Lazy collection fetching</em></span>: a collection is fetched when the application invokes an operation upon that collection. This is the default for collections. </p></li><li><p><span class="emphasis"><em>"Extra-lazy" collection fetching</em></span>: individual elements of the collection are accessed from the database as needed. Hibernate tries not to fetch the whole collection into memory unless absolutely needed. It is suitable for large collections. </p></li><li><p><span class="emphasis"><em>Proxy fetching</em></span>: a single-valued association is fetched when a method other than the identifier getter is invoked upon the associated object. </p></li><li><p><span class="emphasis"><em>"No-proxy" fetching</em></span>: a single-valued association is fetched when the instance variable is accessed. Compared to proxy fetching, this approach is less lazy; the association is fetched even when only the identifier is accessed. It is also more transparent, since no proxy is visible to the application. This approach requires buildtime bytecode instrumentation and is rarely necessary. </p></li><li><p><span class="emphasis"><em>Lazy attribute fetching</em></span>: an attribute or single valued association is fetched when the instance variable is accessed. This approach requires buildtime bytecode instrumentation and is rarely necessary. </p></li></ul></div><p>We have two orthogonal notions here: <span class="emphasis"><em>when</em></span> is the association fetched and <span class="emphasis"><em>how</em></span> is it fetched. It is important that you do not confuse them. We use <code class="literal">fetch</code> to tune performance. We can use <code class="literal">lazy</code> to define a contract for what data is always available in any detached instance of a particular class. </p><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-lazy"/>19.1.1. 遅延関連の働き</h3></div></div></div><p>By default, Hibernate3 uses lazy select fetching for collections and lazy proxy fetching for single-valued associations. These defaults make sense for most associations in the majority of applications. </p><p>If you set <code class="literal">hibernate.default_batch_fetch_size</code>, Hibernate will use the batch fetch optimization for lazy fetching. This optimization can also be enabled at a more granular level. </p><p>Please be aware that access to a lazy association outside of the context of an open Hibernate session will result in an exception. For example: </p><pre class="programlisting">s = sessions.openSession();
Transaction tx = s.beginTransaction();
            
User u = (User) s.createQuery("from User u where u.name=:userName")
    .setString("userName", userName).uniqueResult();
Map permissions = u.getPermissions();

tx.commit();
s.close();

Integer accessLevel = (Integer) permissions.get("accounts");  // Error!</pre><p>Since the permissions collection was not initialized when the <code class="literal">Session</code> was closed, the collection will not be able to load its state. <span class="emphasis"><em>Hibernate does not support lazy initialization for detached objects</em></span>. This can be fixed by moving the code that reads from the collection to just before the transaction is committed. </p><p>Alternatively, you can use a non-lazy collection or association, by specifying <code class="literal">lazy="false"</code> for the association mapping. However, it is intended that lazy initialization be used for almost all collections and associations. If you define too many non-lazy associations in your object model, Hibernate will fetch the entire database into memory in every transaction. </p><p>On the other hand, you can use join fetching, which is non-lazy by nature, instead of select fetching in a particular transaction. We will now explain how to customize the fetching strategy. In Hibernate3, the mechanisms for choosing a fetch strategy are identical for single-valued associations and collections. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-custom"/>19.1.2. フェッチ戦略のチューニング</h3></div></div></div><p>セレクトフェッチ（デフォルト）はN+1セレクト問題という大きな弱点があるため、 マッピング定義で結合フェッチを有効にすることができます。 </p><pre class="programlisting">&lt;set name="permissions" 
            fetch="join"&gt;
    &lt;key column="userId"/&gt;
    &lt;one-to-many class="Permission"/&gt;
&lt;/set</pre><pre class="programlisting">&lt;many-to-one name="mother" class="Cat" fetch="join"/&gt;</pre><p>マッピング定義で定義した <code class="literal">フェッチ</code> 戦略は次のものに影響します。 </p><div class="itemizedlist"><ul><li><p><code class="literal">get()</code> や <code class="literal">load()</code> による復元 </p></li><li><p>関連にナビゲートしたときに発生する暗黙的な復元 </p></li><li><p><code class="literal">Criteria</code> クエリ </p></li><li><p><code class="literal">サブセレクト</code> フェッチを使うHQLクエリ </p></li></ul></div><p>Irrespective of the fetching strategy you use, the defined non-lazy graph is guaranteed to be loaded into memory. This might, however, result in several immediate selects being used to execute a particular HQL query. </p><p>Usually, the mapping document is not used to customize fetching. Instead, we keep the default behavior, and override it for a particular transaction, using <code class="literal">left join fetch</code> in HQL. This tells Hibernate to fetch the association eagerly in the first select, using an outer join. In the <code class="literal">Criteria</code> query API, you would use <code class="literal">setFetchMode(FetchMode.JOIN)</code>. </p><p>If you want to change the fetching strategy used by <code class="literal">get()</code> or <code class="literal">load()</code>, you can use a <code class="literal">Criteria</code> query. For example: </p><pre class="programlisting">User user = (User) session.createCriteria(User.class)
                .setFetchMode("permissions", FetchMode.JOIN)
                .add( Restrictions.idEq(userId) )
                .uniqueResult();</pre><p>This is Hibernate's equivalent of what some ORM solutions call a "fetch plan". </p><p>A completely different approach to problems with N+1 selects is to use the second-level cache. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-proxies"/>19.1.3. 単一端関連プロキシ</h3></div></div></div><p>Lazy fetching for collections is implemented using Hibernate's own implementation of persistent collections. However, a different mechanism is needed for lazy behavior in single-ended associations. The target entity of the association must be proxied. Hibernate implements lazy initializing proxies for persistent objects using runtime bytecode enhancement which is accessed via the CGLIB library. </p><p>At startup, Hibernate3 generates proxies by default for all persistent classes and uses them to enable lazy fetching of <code class="literal">many-to-one</code> and <code class="literal">one-to-one</code> associations. </p><p>The mapping file may declare an interface to use as the proxy interface for that class, with the <code class="literal">proxy</code> attribute. By default, Hibernate uses a subclass of the class. <span class="emphasis"><em>The proxied class must implement a default constructor with at least package visibility. This constructor is recommended for all persistent classes</em></span>. </p><p>There are potential problems to note when extending this approach to polymorphic classes.For example: </p><pre class="programlisting">&lt;class name="Cat" proxy="Cat"&gt;
    ......
    &lt;subclass name="DomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>第一に、 <code class="literal">Cat</code> のインスタンスは <code class="literal">DomesticCat</code> にキャストできません。たとえ基となるインスタンスが <code class="literal">DomesticCat</code> であったとしてもです。 </p><pre class="programlisting">Cat cat = (Cat) session.load(Cat.class, id);  // instantiate a proxy (does not hit the db)
if ( cat.isDomesticCat() ) {                  // hit the db to initialize the proxy
    DomesticCat dc = (DomesticCat) cat;       // Error!
    ....
}</pre><p>Secondly, it is possible to break proxy <code class="literal">==</code>: </p><pre class="programlisting">Cat cat = (Cat) session.load(Cat.class, id);            // instantiate a Cat proxy
DomesticCat dc = 
        (DomesticCat) session.load(DomesticCat.class, id);  // acquire new DomesticCat proxy!
System.out.println(cat==dc);                            // false</pre><p>しかし、これは見かけほど悪い状況というわけではありません。たとえ異なったプロキシオブジェクトへの 二つの参照があったとしても、基となるインスタンスは同じオブジェクトです。 </p><pre class="programlisting">cat.setWeight(11.0);  // hit the db to initialize the proxy
System.out.println( dc.getWeight() );  // 11.0</pre><p>Third, you cannot use a CGLIB proxy for a <code class="literal">final</code> class or a class with any <code class="literal">final</code> methods. </p><p>Finally, if your persistent object acquires any resources upon instantiation (e.g. in initializers or default constructor), then those resources will also be acquired by the proxy. The proxy class is an actual subclass of the persistent class. </p><p>These problems are all due to fundamental limitations in Java's single inheritance model. To avoid these problems your persistent classes must each implement an interface that declares its business methods. You should specify these interfaces in the mapping file where <code class="literal">CatImpl</code> implements the interface <code class="literal">Cat</code> and <code class="literal">DomesticCatImpl</code> implements the interface <code class="literal">DomesticCat</code>. For example: </p><pre class="programlisting">&lt;class name="CatImpl" proxy="Cat"&gt;
    ......
    &lt;subclass name="DomesticCatImpl" proxy="DomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>Then proxies for instances of <code class="literal">Cat</code> and <code class="literal">DomesticCat</code> can be returned by <code class="literal">load()</code> or <code class="literal">iterate()</code>. </p><pre class="programlisting">Cat cat = (Cat) session.load(CatImpl.class, catid);
Iterator iter = session.createQuery("from CatImpl as cat where cat.name='fritz'").iterate();
Cat fritz = (Cat) iter.next();</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p><code class="literal">list()</code> does not usually return proxies. </p></div><p>関連も遅延初期化されます。これはプロパティを <code class="literal">Cat</code> 型で宣言しなければ ならないことを意味します。 <code class="literal">CatImpl</code> ではありません。 </p><p>Certain operations do <span class="emphasis"><em>not</em></span> require proxy initialization: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">equals()</code>: if the persistent class does not override <code class="literal">equals()</code> </p></li><li><p><code class="literal">hashCode()</code>: if the persistent class does not override <code class="literal">hashCode()</code> </p></li><li><p>識別子のgetterメソッド </p></li></ul></div><p>Hibernateは <code class="literal">equals()</code> や <code class="literal">hashCode()</code> をオーバーライドした 永続クラスを検出します。 </p><p>By choosing <code class="literal">lazy="no-proxy"</code> instead of the default <code class="literal">lazy="proxy"</code>, you can avoid problems associated with typecasting. However, buildtime bytecode instrumentation is required, and all operations will result in immediate proxy initialization. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-initialization"/>19.1.4. コレクションとプロキシの初期化</h3></div></div></div><p>A <code class="literal">LazyInitializationException</code> will be thrown by Hibernate if an uninitialized collection or proxy is accessed outside of the scope of the <code class="literal">Session</code>, i.e., when the entity owning the collection or having the reference to the proxy is in the detached state. </p><p>Sometimes a proxy or collection needs to be initialized before closing the <code class="literal">Session</code>. You can force initialization by calling <code class="literal">cat.getSex()</code> or <code class="literal">cat.getKittens().size()</code>, for example. However, this can be confusing to readers of the code and it is not convenient for generic code. </p><p>The static methods <code class="literal">Hibernate.initialize()</code> and <code class="literal">Hibernate.isInitialized()</code>, provide the application with a convenient way of working with lazily initialized collections or proxies. <code class="literal">Hibernate.initialize(cat)</code> will force the initialization of a proxy, <code class="literal">cat</code>, as long as its <code class="literal">Session</code> is still open. <code class="literal">Hibernate.initialize( cat.getKittens() )</code> has a similar effect for the collection of kittens. </p><p>Another option is to keep the <code class="literal">Session</code> open until all required collections and proxies have been loaded. In some application architectures, particularly where the code that accesses data using Hibernate, and the code that uses it are in different application layers or different physical processes, it can be a problem to ensure that the <code class="literal">Session</code> is open when a collection is initialized. There are two basic ways to deal with this issue: </p><div class="itemizedlist"><ul><li><p>In a web-based application, a servlet filter can be used to close the <code class="literal">Session</code> only at the end of a user request, once the rendering of the view is complete (the <span class="emphasis"><em>Open Session in View</em></span> pattern). Of course, this places heavy demands on the correctness of the exception handling of your application infrastructure. It is vitally important that the <code class="literal">Session</code> is closed and the transaction ended before returning to the user, even when an exception occurs during rendering of the view. See the Hibernate Wiki for examples of this "Open Session in View" pattern. </p></li><li><p>In an application with a separate business tier, the business logic must "prepare" all collections that the web tier needs before returning. This means that the business tier should load all the data and return all the data already initialized to the presentation/web tier that is required for a particular use case. Usually, the application calls <code class="literal">Hibernate.initialize()</code> for each collection that will be needed in the web tier (this call must occur before the session is closed) or retrieves the collection eagerly using a Hibernate query with a <code class="literal">FETCH</code> clause or a <code class="literal">FetchMode.JOIN</code> in <code class="literal">Criteria</code>. This is usually easier if you adopt the <span class="emphasis"><em>Command</em></span> pattern instead of a <span class="emphasis"><em>Session Facade</em></span>. </p></li><li><p>You can also attach a previously loaded object to a new <code class="literal">Session</code> with <code class="literal">merge()</code> or <code class="literal">lock()</code> before accessing uninitialized collections or other proxies. Hibernate does not, and certainly <span class="emphasis"><em>should</em></span> not, do this automatically since it would introduce impromptu transaction semantics. </p></li></ul></div><p>Sometimes you do not want to initialize a large collection, but still need some information about it, like its size, for example, or a subset of the data. </p><p>コレクションフィルタを使うことで、初期化せずにコレクションのサイズを取得することが出来ます。 </p><pre class="programlisting">( (Integer) s.createFilter( collection, "select count(*)" ).list().get(0) ).intValue()</pre><p><code class="literal">createFilter()</code> メソッドは、コレクション全体を初期化する必要なしに、コレクションの サブセットを復元するために効果的に使えます。 </p><pre class="programlisting">s.createFilter( lazyCollection, "").setFirstResult(0).setMaxResults(10).list();</pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-batch"/>19.1.5. バッチフェッチの使用</h3></div></div></div><p>Using batch fetching, Hibernate can load several uninitialized proxies if one proxy is accessed. Batch fetching is an optimization of the lazy select fetching strategy. There are two ways you can configure batch fetching: on the class level and the collection level. </p><p>Batch fetching for classes/entities is easier to understand. Consider the following example: at runtime you have 25 <code class="literal">Cat</code> instances loaded in a <code class="literal">Session</code>, and each <code class="literal">Cat</code> has a reference to its <code class="literal">owner</code>, a <code class="literal">Person</code>. The <code class="literal">Person</code> class is mapped with a proxy, <code class="literal">lazy="true"</code>. If you now iterate through all cats and call <code class="literal">getOwner()</code> on each, Hibernate will, by default, execute 25 <code class="literal">SELECT</code> statements to retrieve the proxied owners. You can tune this behavior by specifying a <code class="literal">batch-size</code> in the mapping of <code class="literal">Person</code>: </p><pre class="programlisting">&lt;class name="Person" batch-size="10"&gt;...&lt;/class&gt;</pre><p>Hibernate will now execute only three queries: the pattern is 10, 10, 5. </p><p>You can also enable batch fetching of collections. For example, if each <code class="literal">Person</code> has a lazy collection of <code class="literal">Cat</code>s, and 10 persons are currently loaded in the <code class="literal">Session</code>, iterating through all persons will generate 10 <code class="literal">SELECT</code>s, one for every call to <code class="literal">getCats()</code>. If you enable batch fetching for the <code class="literal">cats</code> collection in the mapping of <code class="literal">Person</code>, Hibernate can pre-fetch collections: </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;set name="cats" batch-size="3"&gt;
        ...
    &lt;/set&gt;
&lt;/class&gt;</pre><p><code class="literal">batch-size</code> が3なので、Hibernateは4回の <code class="literal">SELECT</code> で3個、3個、3個、1個をロードします。繰り返すと、属性の値は特定の <code class="literal">Session</code> の中の初期化されていないコレクションの期待数に依存します。 </p><p>Batch fetching of collections is particularly useful if you have a nested tree of items, i.e. the typical bill-of-materials pattern. However, a <span class="emphasis"><em>nested set</em></span> or a <span class="emphasis"><em>materialized path</em></span> might be a better option for read-mostly trees. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-subselect"/>19.1.6. サブセレクトフェッチの使用</h3></div></div></div><p>If one lazy collection or single-valued proxy has to be fetched, Hibernate will load all of them, re-running the original query in a subselect. This works in the same way as batch-fetching but without the piecemeal loading. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-lazyproperties"/>19.1.7. 遅延プロパティフェッチの使用</h3></div></div></div><p>Hibernate3 supports the lazy fetching of individual properties. This optimization technique is also known as <span class="emphasis"><em>fetch groups</em></span>. Please note that this is mostly a marketing feature; optimizing row reads is much more important than optimization of column reads. However, only loading some properties of a class could be useful in extreme cases. For example, when legacy tables have hundreds of columns and the data model cannot be improved. </p><p>遅延プロパティ読み込みを有効にするには、対象のプロパティのマッピングで <code class="literal">lazy</code> 属性をセットしてください。 </p><pre class="programlisting">&lt;class name="Document"&gt;
       &lt;id name="id"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true" length="50"/&gt;
    &lt;property name="summary" not-null="true" length="200" lazy="true"/&gt;
    &lt;property name="text" not-null="true" length="2000" lazy="true"/&gt;
&lt;/class&gt;</pre><p>Lazy property loading requires buildtime bytecode instrumentation. If your persistent classes are not enhanced, Hibernate will ignore lazy property settings and return to immediate fetching. </p><p>バイトコード組み込みは以下のAntタスクを使ってください。 </p><pre class="programlisting">&lt;target name="instrument" depends="compile"&gt;
    &lt;taskdef name="instrument" classname="org.hibernate.tool.instrument.InstrumentTask"&gt;
        &lt;classpath path="${jar.path}"/&gt;
        &lt;classpath path="${classes.dir}"/&gt;
        &lt;classpath refid="lib.class.path"/&gt;
    &lt;/taskdef&gt;

    &lt;instrument verbose="true"&gt;
        &lt;fileset dir="${testclasses.dir}/org/hibernate/auction/model"&gt;
            &lt;include name="*.class"/&gt;
        &lt;/fileset&gt;
    &lt;/instrument&gt;
&lt;/target&gt;</pre><p>A different way of avoiding unnecessary column reads, at least for read-only transactions, is to use the projection features of HQL or Criteria queries. This avoids the need for buildtime bytecode processing and is certainly a preferred solution. </p><p>You can force the usual eager fetching of properties using <code class="literal">fetch all properties</code> in HQL. </p></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="performance-cache"/>19.2. 第2レベルキャッシュ</h2></div></div></div><p>A Hibernate <code class="literal">Session</code> is a transaction-level cache of persistent data. It is possible to configure a cluster or JVM-level (<code class="literal">SessionFactory</code>-level) cache on a class-by-class and collection-by-collection basis. You can even plug in a clustered cache. Be aware that caches are not aware of changes made to the persistent store by another application. They can, however, be configured to regularly expire cached data. </p><p>You have the option to tell Hibernate which caching implementation to use by specifying the name of a class that implements <code class="literal">org.hibernate.cache.CacheProvider</code> using the property <code class="literal">hibernate.cache.provider_class</code>. Hibernate is bundled with a number of built-in integrations with the open-source cache providers that are listed below. You can also implement your own and plug it in as outlined above. Note that versions prior to 3.2 use EhCache as the default cache provider. </p><div class="table"><a id="cacheproviders"/><p class="title"><b>表 19.1. キャッシュプロバイダ</b></p><div class="table-contents"><table summary="キャッシュプロバイダ" border="1"><colgroup><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/></colgroup><thead><tr><th align="left">キャッシュ</th><th align="left">プロバイダクラス</th><th align="left">タイプ</th><th align="left">クラスタセーフ</th><th align="left">クエリキャッシュのサポート</th></tr></thead><tbody><tr><td align="left">Hashtable（製品用として意図していません）</td><td align="left"><code class="literal">org.hibernate.cache.HashtableCacheProvider</code></td><td align="left">メモリ</td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">EHCache</td><td align="left"><code class="literal">org.hibernate.cache.EhCacheProvider</code></td><td align="left">メモリ、ディスク</td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">OSCache</td><td align="left"><code class="literal">org.hibernate.cache.OSCacheProvider</code></td><td align="left">メモリ、ディスク</td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">SwarmCache</td><td align="left"><code class="literal">org.hibernate.cache.SwarmCacheProvider</code></td><td align="left">クラスタ（ipマルチキャスト）</td><td align="left">yes（クラスタ無効化）</td><td align="left"> </td></tr><tr><td align="left">JBoss Cache 1.x</td><td align="left"><code class="literal">org.hibernate.cache.TreeCacheProvider</code></td><td align="left">クラスタ（ipマルチキャスト）、トランザクショナル</td><td align="left">yes（複製）</td><td align="left">yes（時刻同期が必要）</td></tr><tr><td align="left">JBoss Cache 2</td><td align="left"><code class="literal">org.hibernate.cache.jbc2.JBossCacheRegionFactory</code></td><td align="left">クラスタ（ipマルチキャスト）、トランザクショナル</td><td align="left">yes (replication or invalidation)</td><td align="left">yes（時刻同期が必要）</td></tr></tbody></table></div></div><br class="table-break"/><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-mapping"/>19.2.1. キャッシュのマッピング</h3></div></div></div><p>クラスやコレクションのマッピングの <code class="literal">&lt;cache&gt;</code> 要素は以下の形式です。 </p><div class="programlistingco"><pre class="programlisting">&lt;cache 
    usage="transactional|read-write|nonstrict-read-write|read-only"  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
    region="RegionName"                                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
    include="all|non-lazy"                                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">usage</code> (required) specifies the caching strategy: <code class="literal">transactional</code>, <code class="literal">read-write</code>, <code class="literal">nonstrict-read-write</code> or <code class="literal">read-only</code> </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">region</code> (optional: defaults to the class or collection role name): specifies the name of the second level cache region </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">include</code> (optional: defaults to <code class="literal">all</code>) <code class="literal">non-lazy</code>: specifies that properties of the entity mapped with <code class="literal">lazy="true"</code> cannot be cached when attribute-level lazy fetching is enabled </p></td></tr></table></div></div><p>Alternatively, you can specify <code class="literal">&lt;class-cache&gt;</code> and <code class="literal">&lt;collection-cache&gt;</code> elements in <code class="literal">hibernate.cfg.xml</code>. </p><p><code class="literal">usage</code> 属性は <span class="emphasis"><em>キャッシュの並列性戦略</em></span> を指定します。 </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-readonly"/>19.2.2. read only戦略</h3></div></div></div><p>If your application needs to read, but not modify, instances of a persistent class, a <code class="literal">read-only</code> cache can be used. This is the simplest and optimal performing strategy. It is even safe for use in a cluster. </p><pre class="programlisting">&lt;class name="eg.Immutable" mutable="false"&gt;
    &lt;cache usage="read-only"/&gt;
    ....
&lt;/class&gt;</pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-readwrite"/>19.2.3. read/write戦略</h3></div></div></div><p>If the application needs to update data, a <code class="literal">read-write</code> cache might be appropriate. This cache strategy should never be used if serializable transaction isolation level is required. If the cache is used in a JTA environment, you must specify the property <code class="literal">hibernate.transaction.manager_lookup_class</code> and naming a strategy for obtaining the JTA <code class="literal">TransactionManager</code>. In other environments, you should ensure that the transaction is completed when <code class="literal">Session.close()</code> or <code class="literal">Session.disconnect()</code> is called. If you want to use this strategy in a cluster, you should ensure that the underlying cache implementation supports locking. The built-in cache providers <span class="emphasis"><em>do not</em></span> support locking. </p><pre class="programlisting">&lt;class name="eg.Cat" .... &gt;
    &lt;cache usage="read-write"/&gt;
    ....
    &lt;set name="kittens" ... &gt;
        &lt;cache usage="read-write"/&gt;
        ....
    &lt;/set&gt;
&lt;/class&gt;</pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-nonstrict"/>19.2.4. 厳密ではないread/write戦略</h3></div></div></div><p>If the application only occasionally needs to update data (i.e. if it is extremely unlikely that two transactions would try to update the same item simultaneously), and strict transaction isolation is not required, a <code class="literal">nonstrict-read-write</code> cache might be appropriate. If the cache is used in a JTA environment, you must specify <code class="literal">hibernate.transaction.manager_lookup_class</code>. In other environments, you should ensure that the transaction is completed when <code class="literal">Session.close()</code> or <code class="literal">Session.disconnect()</code> is called. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-transactional"/>19.2.5. transactional戦略</h3></div></div></div><p>The <code class="literal">transactional</code> cache strategy provides support for fully transactional cache providers such as JBoss TreeCache. Such a cache can only be used in a JTA environment and you must specify <code class="literal">hibernate.transaction.manager_lookup_class</code>. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-compat-matrix"/>19.2.6. Cache-provider/concurrency-strategy compatibility</h3></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>重要項目</h2><p>None of the cache providers support all of the cache concurrency strategies. </p></div><p>The following table shows which providers are compatible with which concurrency strategies. </p><div class="table"><a id="d0e14835"/><p class="title"><b>表 19.2. 同時並行性キャッシュ戦略のサポート</b></p><div class="table-contents"><table summary="同時並行性キャッシュ戦略のサポート" border="1"><colgroup><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/></colgroup><thead><tr><th align="left">キャッシュ</th><th align="left">read-only</th><th align="left">厳密ではないread-write</th><th align="left">read-write</th><th align="left">transactional</th></tr></thead><tbody><tr><td align="left">Hashtable（製品用として意図していません）</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td></tr><tr><td align="left">EHCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td></tr><tr><td align="left">OSCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td></tr><tr><td align="left">SwarmCache</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">JBoss Cache 1.x</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">JBoss Cache 2</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td><td align="left">yes</td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="performance-sessioncache"/>19.3. キャッシュの管理</h2></div></div></div><p>Whenever you pass an object to <code class="literal">save()</code>, <code class="literal">update()</code> or <code class="literal">saveOrUpdate()</code>, and whenever you retrieve an object using <code class="literal">load()</code>, <code class="literal">get()</code>, <code class="literal">list()</code>, <code class="literal">iterate()</code> or <code class="literal">scroll()</code>, that object is added to the internal cache of the <code class="literal">Session</code>. </p><p>When <code class="literal">flush()</code> is subsequently called, the state of that object will be synchronized with the database. If you do not want this synchronization to occur, or if you are processing a huge number of objects and need to manage memory efficiently, the <code class="literal">evict()</code> method can be used to remove the object and its collections from the first-level cache. </p><pre class="programlisting">ScrollableResult cats = sess.createQuery("from Cat as cat").scroll(); //a huge result set
while ( cats.next() ) {
    Cat cat = (Cat) cats.get(0);
    doSomethingWithACat(cat);
    sess.evict(cat);
}</pre><p><code class="literal">Session</code> はインスタンスがセッションキャッシュに含まれるかどうかを判断するための <code class="literal">contains()</code> メソッドも提供します。 </p><p>To evict all objects from the session cache, call <code class="literal">Session.clear()</code> </p><p>二次キャッシュのために、 <code class="literal">SessionFactory</code> には インスタンス、クラス全体、コレクションのインスタンス、コレクション全体をキャッシュから 削除するためのメソッドがそれぞれ定義されています。 </p><pre class="programlisting">sessionFactory.evict(Cat.class, catId); //evict a particular Cat
sessionFactory.evict(Cat.class);  //evict all Cats
sessionFactory.evictCollection("Cat.kittens", catId); //evict a particular collection of kittens
sessionFactory.evictCollection("Cat.kittens"); //evict all kitten collections</pre><p>The <code class="literal">CacheMode</code> controls how a particular session interacts with the second-level cache: </p><div class="itemizedlist"><ul><li><p><code class="literal">CacheMode.NORMAL</code>: will read items from and write items to the second-level cache </p></li><li><p><code class="literal">CacheMode.GET</code>: will read items from the second-level cache. Do not write to the second-level cache except when updating data </p></li><li><p><code class="literal">CacheMode.PUT</code>: will write items to the second-level cache. Do not read from the second-level cache </p></li><li><p><code class="literal">CacheMode.REFRESH</code>: will write items to the second-level cache. Do not read from the second-level cache. Bypass the effect of <code class="literal">hibernate.cache.use_minimal_puts</code> forcing a refresh of the second-level cache for all items read from the database </p></li></ul></div><p>二次キャッシュの内容やクエリキャッシュ領域を見るために、 <code class="literal">Statistics</code> APIを 使ってください。 </p><pre class="programlisting">Map cacheEntries = sessionFactory.getStatistics()
        .getSecondLevelCacheStatistics(regionName)
        .getEntries();</pre><p>You will need to enable statistics and, optionally, force Hibernate to keep the cache entries in a more readable format: </p><pre class="programlisting">hibernate.generate_statistics true
hibernate.cache.use_structured_entries true</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="performance-querycache"/>19.4. クエリキャッシュ</h2></div></div></div><p>Query result sets can also be cached. This is only useful for queries that are run frequently with the same parameters. You will first need to enable the query cache: </p><pre class="programlisting">hibernate.cache.use_query_cache true</pre><p>This setting creates two new cache regions: one holding cached query result sets (<code class="literal">org.hibernate.cache.StandardQueryCache</code>), the other holding timestamps of the most recent updates to queryable tables (<code class="literal">org.hibernate.cache.UpdateTimestampsCache</code>). Note that the query cache does not cache the state of the actual entities in the result set; it caches only identifier values and results of value type. The query cache should always be used in conjunction with the second-level cache. </p><p>Most queries do not benefit from caching, so by default, queries are not cached. To enable caching, call <code class="literal">Query.setCacheable(true)</code>. This call allows the query to look for existing cache results or add its results to the cache when it is executed. </p><p>If you require fine-grained control over query cache expiration policies, you can specify a named cache region for a particular query by calling <code class="literal">Query.setCacheRegion()</code>. </p><pre class="programlisting">List blogs = sess.createQuery("from Blog blog where blog.blogger = :blogger")
    .setEntity("blogger", blogger)
    .setMaxResults(15)
    .setCacheable(true)
    .setCacheRegion("frontpages")
    .list();</pre><p>クエリが自身のクエリキャッシュ領域のリフレッシュを強制しなければならないなら、 <code class="literal">Query.setCacheMode(CacheMode.REFRESH)</code> を呼び出すべきです。これは 元となるデータが別のプロセスによって更新されたり（すなわちHibernateを通じて更新されない）、 アプリケーションに特定のクエリリザルトセットを選択してリフレッシュさせる場合に特に有用です。 さらに有用なもう一つの方法は、 <code class="literal">SessionFactory.evictQueries()</code> によってクエリキャッシュ領域を消去することです。 </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="performance-collections"/>19.5. コレクションのパフォーマンスの理解</h2></div></div></div><p>In the previous sections we have covered collections and their applications. In this section we explore some more issues in relation to collections at runtime. </p><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-taxonomy"/>19.5.1. 分類</h3></div></div></div><p>Hibernateは3つの基本的なコレクションの種類を定義しています。</p><div class="itemizedlist"><ul><li><p>値のコレクション</p></li><li><p>one-to-many associations</p></li><li><p>many-to-many associations</p></li></ul></div><p>この分類はさまざまなテーブルや外部キー関連を区別しますが、私たちが知る必要のある 関連モデルについてほとんどなにも教えてくれません。関連構造やパフォーマンスの特徴を 完全に理解するには、Hibernateがコレクションの行を更新、削除するために使う主キーの 構造もまた考えなければなりません。これは以下の分類を提示します。 </p><div class="itemizedlist"><ul><li><p>インデックス付きコレクション</p></li><li><p>set</p></li><li><p>bag</p></li></ul></div><p>All indexed collections (maps, lists, and arrays) have a primary key consisting of the <code class="literal">&lt;key&gt;</code> and <code class="literal">&lt;index&gt;</code> columns. In this case, collection updates are extremely efficient. The primary key can be efficiently indexed and a particular row can be efficiently located when Hibernate tries to update or delete it. </p><p>Sets have a primary key consisting of <code class="literal">&lt;key&gt;</code> and element columns. This can be less efficient for some types of collection element, particularly composite elements or large text or binary fields, as the database may not be able to index a complex primary key as efficiently. However, for one-to-many or many-to-many associations, particularly in the case of synthetic identifiers, it is likely to be just as efficient. If you want <code class="literal">SchemaExport</code> to actually create the primary key of a <code class="literal">&lt;set&gt;</code>, you must declare all columns as <code class="literal">not-null="true"</code>. </p><p><code class="literal">&lt;idbag&gt;</code> mappings define a surrogate key, so they are efficient to update. In fact, they are the best case. </p><p>Bags are the worst case since they permit duplicate element values and, as they have no index column, no primary key can be defined. Hibernate has no way of distinguishing between duplicate rows. Hibernate resolves this problem by completely removing in a single <code class="literal">DELETE</code> and recreating the collection whenever it changes. This can be inefficient. </p><p>For a one-to-many association, the "primary key" may not be the physical primary key of the database table. Even in this case, the above classification is still useful. It reflects how Hibernate "locates" individual rows of the collection. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-mostefficientupdate"/>19.5.2. 更新にもっとも効率的なコレクション list、map、idbag、set</h3></div></div></div><p>From the discussion above, it should be clear that indexed collections and sets allow the most efficient operation in terms of adding, removing and updating elements. </p><p>There is, arguably, one more advantage that indexed collections have over sets for many-to-many associations or collections of values. Because of the structure of a <code class="literal">Set</code>, Hibernate does not <code class="literal">UPDATE</code> a row when an element is "changed". Changes to a <code class="literal">Set</code> always work via <code class="literal">INSERT</code> and <code class="literal">DELETE</code> of individual rows. Once again, this consideration does not apply to one-to-many associations. </p><p>After observing that arrays cannot be lazy, you can conclude that lists, maps and idbags are the most performant (non-inverse) collection types, with sets not far behind. You can expect sets to be the most common kind of collection in Hibernate applications. This is because the "set" semantics are most natural in the relational model. </p><p>However, in well-designed Hibernate domain models, most collections are in fact one-to-many associations with <code class="literal">inverse="true"</code>. For these associations, the update is handled by the many-to-one end of the association, and so considerations of collection update performance simply do not apply. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-mostefficentinverse"/>19.5.3. inverseコレクションにもっとも最適なbagとlist</h3></div></div></div><p>There is a particular case, however, in which bags, and also lists, are much more performant than sets. For a collection with <code class="literal">inverse="true"</code>, the standard bidirectional one-to-many relationship idiom, for example, we can add elements to a bag or list without needing to initialize (fetch) the bag elements. This is because, unlike a <code class="literal">set</code>, <code class="literal">Collection.add()</code> or <code class="literal">Collection.addAll()</code> must always return true for a bag or <code class="literal">List</code>. This can make the following common code much faster: </p><pre class="programlisting">Parent p = (Parent) sess.load(Parent.class, id);
Child c = new Child();
c.setParent(p);
p.getChildren().add(c);  //no need to fetch the collection!
sess.flush();</pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-oneshotdelete"/>19.5.4. 一括削除</h3></div></div></div><p>Deleting collection elements one by one can sometimes be extremely inefficient. Hibernate knows not to do that in the case of an newly-empty collection (if you called <code class="literal">list.clear()</code>, for example). In this case, Hibernate will issue a single <code class="literal">DELETE</code>. </p><p>Suppose you added a single element to a collection of size twenty and then remove two elements. Hibernate will issue one <code class="literal">INSERT</code> statement and two <code class="literal">DELETE</code> statements, unless the collection is a bag. This is certainly desirable. </p><p>しかし、18個の要素を削除して2つを残し、それから3つ新しい要素を追加するとします。 このとき二つの方法があります。 </p><div class="itemizedlist"><ul><li><p>18行を一つ一つ削除して、3行を追加する</p></li><li><p>remove the whole collection in one SQL <code class="literal">DELETE</code> and insert all five current elements one by one</p></li></ul></div><p>Hibernate cannot know that the second option is probably quicker. It would probably be undesirable for Hibernate to be that intuitive as such behavior might confuse database triggers, etc. </p><p>Fortunately, you can force this behavior (i.e. the second strategy) at any time by discarding (i.e. dereferencing) the original collection and returning a newly instantiated collection with all the current elements. </p><p>One-shot-delete does not apply to collections mapped <code class="literal">inverse="true"</code>. </p></div></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="performance-monitoring"/>19.6. パフォーマンスのモニタリング</h2></div></div></div><p>最適化はモニタリングやパフォーマンスを示す数値がなければ十分に行えません。 Hibernateは内部処理のすべての範囲の数値を提供します。 Hibernateの統計情報は <code class="literal">SessionFactory</code> 単位で取得可能です。 </p><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-monitoring-sf"/>19.6.1. SessionFactoryのモニタリング</h3></div></div></div><p><code class="literal">SessionFactory</code> のメトリクスにアクセスするには2つの方法があります。 最初の方法は、 <code class="literal">sessionFactory.getStatistics()</code> を呼び出し、 自分で <code class="literal">Statistics</code> の読み込みや表示を行います。 </p><p>Hibernate can also use JMX to publish metrics if you enable the <code class="literal">StatisticsService</code> MBean. You can enable a single MBean for all your <code class="literal">SessionFactory</code> or one per factory. See the following code for minimalistic configuration examples: </p><pre class="programlisting">// MBean service registration for a specific SessionFactory
Hashtable tb = new Hashtable();
tb.put("type", "statistics");
tb.put("sessionFactory", "myFinancialApp");
ObjectName on = new ObjectName("hibernate", tb); // MBean object name

StatisticsService stats = new StatisticsService(); // MBean implementation
stats.setSessionFactory(sessionFactory); // Bind the stats to a SessionFactory
server.registerMBean(stats, on); // Register the Mbean on the server</pre><pre class="programlisting">// MBean service registration for all SessionFactory's
Hashtable tb = new Hashtable();
tb.put("type", "statistics");
tb.put("sessionFactory", "all");
ObjectName on = new ObjectName("hibernate", tb); // MBean object name

StatisticsService stats = new StatisticsService(); // MBean implementation
server.registerMBean(stats, on); // Register the MBean on the server</pre><p>You can activate and deactivate the monitoring for a <code class="literal">SessionFactory</code>: </p><div class="itemizedlist"><ul><li><p>設定時には、 <code class="literal">hibernate.generate_statistics</code> を <code class="literal">false</code> にします </p></li></ul></div><div class="itemizedlist"><ul><li><p>実行時に、 <code class="literal">sf.getStatistics().setStatisticsEnabled(true)</code> または <code class="literal">hibernateStatsBean.setStatisticsEnabled(true)</code> を呼び出します </p></li></ul></div><p>Statistics can be reset programmatically using the <code class="literal">clear()</code> method. A summary can be sent to a logger (info level) using the <code class="literal">logSummary()</code> method. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="performance-monitoring-metrics"/>19.6.2. メトリクス</h3></div></div></div><p>Hibernate provides a number of metrics, from basic information to more specialized information that is only relevant in certain scenarios. All available counters are described in the <code class="literal">Statistics</code> interface API, in three categories: </p><div class="itemizedlist"><ul><li><p>メトリクスは一般的な <code class="literal">Session</code> の使い方と関係しています。 オープンしたセッションの数がJDBCコネクションと関連しているのと同じです。 </p></li><li><p>Metrics related to the entities, collections, queries, and caches as a whole (aka global metrics). </p></li><li><p>メトリクスの詳細は特定のエンティティ、コレクション、クエリ、キャッシュ領域に関係しています。 </p></li></ul></div><p>For example, you can check the cache hit, miss, and put ratio of entities, collections and queries, and the average time a query needs. Be aware that the number of milliseconds is subject to approximation in Java. Hibernate is tied to the JVM precision and on some platforms this might only be accurate to 10 seconds. </p><p>Simple getters are used to access the global metrics (i.e. not tied to a particular entity, collection, cache region, etc.). You can access the metrics of a particular entity, collection or cache region through its name, and through its HQL or SQL representation for queries. Please refer to the <code class="literal">Statistics</code>, <code class="literal">EntityStatistics</code>, <code class="literal">CollectionStatistics</code>, <code class="literal">SecondLevelCacheStatistics</code>, and <code class="literal">QueryStatistics</code> API Javadoc for more information. The following code is a simple example: </p><pre class="programlisting">Statistics stats = HibernateUtil.sessionFactory.getStatistics();

double queryCacheHitCount  = stats.getQueryCacheHitCount();
double queryCacheMissCount = stats.getQueryCacheMissCount();
double queryCacheHitRatio =
  queryCacheHitCount / (queryCacheHitCount + queryCacheMissCount);

log.info("Query Hit ratio:" + queryCacheHitRatio);

EntityStatistics entityStats =
  stats.getEntityStatistics( Cat.class.getName() );
long changes =
        entityStats.getInsertCount()
        + entityStats.getUpdateCount()
        + entityStats.getDeleteCount();
log.info(Cat.class.getName() + " changed " + changes + "times"  );</pre><p>You can work on all entities, collections, queries and region caches, by retrieving the list of names of entities, collections, queries and region caches using the following methods: <code class="literal">getQueries()</code>, <code class="literal">getEntityNames()</code>, <code class="literal">getCollectionRoleNames()</code>, and <code class="literal">getSecondLevelCacheRegionNames()</code>. </p></div></div></div><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="toolsetguide"/>第20章 Toolset Guide ツールセットガイド</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#toolsetguide-s1">20.1. スキーマの自動生成</a></span></dt><dd><dl><dt><span class="sect2"><a href="#toolsetguide-s1-2">20.1.1. スキーマのカスタマイズ</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-3">20.1.2. ツールの実行</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-4">20.1.3. プロパティ</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-5">20.1.4. Antを使用する</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-6">20.1.5. インクリメンタルなスキーマ更新</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-7">20.1.6. インクリメンタルなスキーマ更新に対するAntの使用</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-8">20.1.7. Schema validation</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-9">20.1.8. スキーマのバリデーションにAntを使用します</a></span></dt></dl></dd></dl></div><p>Roundtrip engineering with Hibernate is possible using a set of Eclipse plugins, commandline tools, and Ant tasks. </p><p><span class="emphasis"><em>Hibernate Tools</em></span> currently include plugins for the Eclipse IDE as well as Ant tasks for reverse engineering of existing databases: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Mapping Editor:</em></span> an editor for Hibernate XML mapping files that supports auto-completion and syntax highlighting. It also supports semantic auto-completion for class names and property/field names, making it more versatile than a normal XML editor. </p></li><li><p><span class="emphasis"><em>Console:</em></span> the console is a new view in Eclipse. In addition to a tree overview of your console configurations, you are also provided with an interactive view of your persistent classes and their relationships. The console allows you to execute HQL queries against your database and browse the result directly in Eclipse. </p></li><li><p><span class="emphasis"><em>Development Wizards:</em></span> several wizards are provided with the Hibernate Eclipse tools. You can use a wizard to quickly generate Hibernate configuration (cfg.xml) files, or to reverse engineer an existing database schema into POJO source files and Hibernate mapping files. The reverse engineering wizard supports customizable templates. </p></li><li><p>

        </p></li></ul></div><p>Please refer to the <span class="emphasis"><em>Hibernate Tools</em></span> package documentation for more information. </p><p>However, the Hibernate main package comes bundled with an integrated tool : <span class="emphasis"><em>SchemaExport</em></span> aka <code class="literal">hbm2ddl</code>.It can even be used from "inside" Hibernate. </p><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="toolsetguide-s1"/>20.1. スキーマの自動生成</h2></div></div></div><p>DDL can be generated from your mapping files by a Hibernate utility. The generated schema includes referential integrity constraints, primary and foreign keys, for entity and collection tables. Tables and sequences are also created for mapped identifier generators. </p><p>You <span class="emphasis"><em>must</em></span> specify a SQL <code class="literal">Dialect</code> via the <code class="literal">hibernate.dialect</code> property when using this tool, as DDL is highly vendor-specific. </p><p>First, you must customize your mapping files to improve the generated schema. The next section covers schema customization. </p><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-2"/>20.1.1. スキーマのカスタマイズ</h3></div></div></div><p>Many Hibernate mapping elements define optional attributes named <code class="literal">length</code>, <code class="literal">precision</code> and <code class="literal">scale</code>. You can set the length, precision and scale of a column with this attribute. </p><pre class="programlisting">&lt;property name="zip" length="5"/&gt;</pre><pre class="programlisting">&lt;property name="balance" precision="12" scale="2"/&gt;</pre><p>Some tags also accept a <code class="literal">not-null</code> attribute for generating a <code class="literal">NOT NULL</code> constraint on table columns, and a <code class="literal">unique</code> attribute for generating <code class="literal">UNIQUE</code> constraint on table columns. </p><pre class="programlisting">&lt;many-to-one name="bar" column="barId" not-null="true"/&gt;</pre><pre class="programlisting">&lt;element column="serialNumber" type="long" not-null="true" unique="true"/&gt;</pre><p>A <code class="literal">unique-key</code> attribute can be used to group columns in a single, unique key constraint. Currently, the specified value of the <code class="literal">unique-key</code> attribute is <span class="emphasis"><em>not</em></span> used to name the constraint in the generated DDL. It is only used to group the columns in the mapping file. </p><pre class="programlisting">&lt;many-to-one name="org" column="orgId" unique-key="OrgEmployeeId"/&gt;
&lt;property name="employeeId" unique-key="OrgEmployee"/&gt;</pre><p>An <code class="literal">index</code> attribute specifies the name of an index that will be created using the mapped column or columns. Multiple columns can be grouped into the same index by simply specifying the same index name. </p><pre class="programlisting">&lt;property name="lastName" index="CustName"/&gt;
&lt;property name="firstName" index="CustName"/&gt;</pre><p>A <code class="literal">foreign-key</code> attribute can be used to override the name of any generated foreign key constraint. </p><pre class="programlisting">&lt;many-to-one name="bar" column="barId" foreign-key="FKFooBar"/&gt;</pre><p>多くのマッピング要素は、子 <code class="literal">&lt;column&gt;</code> 要素を記述できます。これは複数カラム型のマッピングには特に有用です。 </p><pre class="programlisting">&lt;property name="name" type="my.customtypes.Name"/&gt;
    &lt;column name="last" not-null="true" index="bar_idx" length="30"/&gt;
    &lt;column name="first" not-null="true" index="bar_idx" length="20"/&gt;
    &lt;column name="initial"/&gt;
&lt;/property&gt;</pre><p>The <code class="literal">default</code> attribute allows you to specify a default value for a column.You should assign the same value to the mapped property before saving a new instance of the mapped class. </p><pre class="programlisting">&lt;property name="credits" type="integer" insert="false"&gt;
    &lt;column name="credits" default="10"/&gt;
&lt;/property&gt;</pre><pre class="programlisting">&lt;version name="version" type="integer" insert="false"&gt;
    &lt;column name="version" default="0"/&gt;
&lt;/property&gt;</pre><p><code class="literal">sql-type</code> 属性で、デフォルトのHibernate型からSQLのデータ型へのマッピングをオーバーライドできます。 </p><pre class="programlisting">&lt;property name="balance" type="float"&gt;
    &lt;column name="balance" sql-type="decimal(13,3)"/&gt;
&lt;/property&gt;</pre><p><code class="literal">check</code> 属性でチェック制約を指定することができます。 </p><pre class="programlisting">&lt;property name="foo" type="integer"&gt;
    &lt;column name="foo" check="foo &gt; 10"/&gt;
&lt;/property&gt;</pre><pre class="programlisting">&lt;class name="Foo" table="foos" check="bar &lt; 100.0"&gt;
    ...
    &lt;property name="bar" type="float"/&gt;
&lt;/class&gt;</pre><p>The following table summarizes these optional attributes.</p><div class="table"><a id="schemattributes-summary"/><p class="title"><b>表 20.1. まとめ</b></p><div class="table-contents"><table summary="まとめ" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>属性</th><th>値</th><th>説明</th></tr></thead><tbody><tr><td><code class="literal">length</code></td><td>数値</td><td>カラムの長さ</td></tr><tr><td><code class="literal">precision</code></td><td>数値</td><td>カラムのDECIMAL型の精度（precision）</td></tr><tr><td><code class="literal">scale</code></td><td>数値</td><td>カラムのDECIMAL型のスケール（scale）</td></tr><tr><td><code class="literal">not-null</code></td><td><code class="literal">true|false</code></td><td>specifies that the column should be non-nullable</td></tr><tr><td><code class="literal">unique</code></td><td><code class="literal">true|false</code></td><td>カラムがユニーク制約を持つことを指定します</td></tr><tr><td><code class="literal">index</code></td><td><code class="literal">インデックス名</code></td><td>(複数カラムの)インデックスの名前を指定します</td></tr><tr><td><code class="literal">unique-key</code></td><td><code class="literal">ユニークキー名</code></td><td>複数カラムのユニーク制約の名前を指定します</td></tr><tr><td><code class="literal">foreign-key</code></td><td><code class="literal">外部キー名</code></td><td>specifies the name of the foreign key constraint generated for an association, for a <code class="literal">&lt;one-to-one&gt;</code>, <code class="literal">&lt;many-to-one&gt;</code>, <code class="literal">&lt;key&gt;</code>, or <code class="literal">&lt;many-to-many&gt;</code> mapping element. Note that <code class="literal">inverse="true"</code> sides will not be considered by <code class="literal">SchemaExport</code>. </td></tr><tr><td><code class="literal">sql-type</code></td><td><code class="literal">SQLのカラム型</code></td><td>overrides the default column type (attribute of <code class="literal">&lt;column&gt;</code> element only) </td></tr><tr><td><code class="literal">default</code></td><td>SQL式</td><td>カラムのデフォルト値を指定します </td></tr><tr><td><code class="literal">check</code></td><td>SQL式</td><td>カラムかテーブルにSQLのチェック制約を作成します </td></tr></tbody></table></div></div><br class="table-break"/><p><code class="literal">&lt;comment&gt;</code> 要素で生成するスキーマにコメントを指定することができます。 </p><pre class="programlisting">&lt;class name="Customer" table="CurCust"&gt;
    &lt;comment&gt;Current customers only&lt;/comment&gt;
    ...
&lt;/class&gt;</pre><pre class="programlisting">&lt;property name="balance"&gt;
    &lt;column name="bal"&gt;
        &lt;comment&gt;Balance in USD&lt;/comment&gt;
    &lt;/column&gt;
&lt;/property&gt;</pre><p>This results in a <code class="literal">comment on table</code> or <code class="literal">comment on column</code> statement in the generated DDL where supported. </p></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-3"/>20.1.2. ツールの実行</h3></div></div></div><p><code class="literal">SchemaExport</code> は標準出力に対してDDLスクリプトを書き出し、DDL文を実行したりもします。 </p><p>The following table displays the <code class="literal">SchemaExport</code> command line options</p><p><code class="literal">java -cp </code><span class="emphasis"><em>hibernate_classpaths</em></span> <code class="literal">org.hibernate.tool.hbm2ddl.SchemaExport</code> <span class="emphasis"><em>options mapping_files</em></span> </p><div class="table"><a id="d0e15657"/><p class="title"><b>表 20.2. <code class="literal">SchemaExport</code> Command Line Options <code class="literal">SchemaExport</code> のコマンドラインオプション</b></p><div class="table-contents"><table summary="SchemaExport Command Line Options SchemaExport のコマンドラインオプション" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>オプション</th><th>説明</th></tr></thead><tbody><tr><td><code class="literal">--quiet</code></td><td>do not output the script to stdout</td></tr><tr><td><code class="literal">--drop</code></td><td>テーブルの削除だけを行います</td></tr><tr><td><code class="literal">--create</code></td><td>テーブルの生成のみを行います。</td></tr><tr><td><code class="literal">--text</code></td><td>do not export to the database</td></tr><tr><td><code class="literal">--output=my_schema.ddl</code></td><td>DDLスクリプトをファイルに出力します</td></tr><tr><td><code class="literal">--naming=eg.MyNamingStrategy</code></td><td>select a <code class="literal">NamingStrategy</code></td></tr><tr><td><code class="literal">--config=hibernate.cfg.xml</code></td><td>XMLファイルからHibernateの定義情報を読み込みます</td></tr><tr><td><code class="literal">--properties=hibernate.properties</code></td><td>read database properties from a file</td></tr><tr><td><code class="literal">--format</code></td><td>スクリプト内に生成するSQLを読みやすいようにフォーマットします</td></tr><tr><td><code class="literal">--delimiter=x</code></td><td>スクリプトの行区切り文字を設定します</td></tr></tbody></table></div></div><br class="table-break"/><p>You can even embed <code class="literal">SchemaExport</code> in your application: </p><pre class="programlisting">Configuration cfg = ....;
new SchemaExport(cfg).create(false, true);</pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-4"/>20.1.3. プロパティ</h3></div></div></div><p>Database properties can be specified: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">-D</code><span class="emphasis"><em>&lt;property&gt;</em></span> を使って、システムプロパティとして</p></li><li><p><code class="literal">hibernate.properties</code> ファイル内で</p></li><li><p><code class="literal">--properties</code> を使って指定したプロパティファイル内で</p></li></ul></div><p>必要なプロパティは以下のものです： </p><div class="table"><a id="d0e15769"/><p class="title"><b>表 20.3. SchemaExportコネクションプロパティ</b></p><div class="table-contents"><table summary="SchemaExportコネクションプロパティ" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>プロパティ名</th><th>説明</th></tr></thead><tbody><tr><td><code class="literal">hibernate.connection.driver_class</code></td><td>jdbcのドライバークラス</td></tr><tr><td><code class="literal">hibernate.connection.url</code></td><td>jdbcのurl</td></tr><tr><td><code class="literal">hibernate.connection.username</code></td><td>データベースのユーザ</td></tr><tr><td><code class="literal">hibernate.connection.password</code></td><td>ユーザパスワード</td></tr><tr><td><code class="literal">hibernate.dialect</code></td><td>データベース方言</td></tr></tbody></table></div></div><br class="table-break"/></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-5"/>20.1.4. Antを使用する</h3></div></div></div><p>Antのビルドスクリプトから <code class="literal">SchemaExport</code> を呼び出すことができます。: </p><pre class="programlisting">&lt;target name="schemaexport"&gt;
    &lt;taskdef name="schemaexport"
        classname="org.hibernate.tool.hbm2ddl.SchemaExportTask"
        classpathref="class.path"/&gt;
    
    &lt;schemaexport
        properties="hibernate.properties"
        quiet="no"
        text="no"
        drop="no"
        delimiter=";"
        output="schema-export.sql"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemaexport&gt;
&lt;/target&gt;</pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-6"/>20.1.5. インクリメンタルなスキーマ更新</h3></div></div></div><p>The <code class="literal">SchemaUpdate</code> tool will update an existing schema with "incremental" changes. The <code class="literal">SchemaUpdate</code> depends upon the JDBC metadata API and, as such, will not work with all JDBC drivers. </p><p><code class="literal">java -cp </code><span class="emphasis"><em>hibernate_classpaths</em></span> <code class="literal">org.hibernate.tool.hbm2ddl.SchemaUpdate</code> <span class="emphasis"><em>options mapping_files</em></span> </p><div class="table"><a id="d0e15845"/><p class="title"><b>表 20.4. <code class="literal">SchemaUpdate</code> のコマンドライン･オプション</b></p><div class="table-contents"><table summary="SchemaUpdate のコマンドライン･オプション" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>オプション</th><th>説明</th></tr></thead><tbody><tr><td><code class="literal">--quiet</code></td><td>do not output the script to stdout</td></tr><tr><td><code class="literal">--text</code></td><td>do not export the script to the database</td></tr><tr><td><code class="literal">--naming=eg.MyNamingStrategy</code></td><td>select a <code class="literal">NamingStrategy</code></td></tr><tr><td><code class="literal">--properties=hibernate.properties</code></td><td>read database properties from a file</td></tr><tr><td><code class="literal">--config=hibernate.cfg.xml</code></td><td>specify a <code class="literal">.cfg.xml</code> file</td></tr></tbody></table></div></div><br class="table-break"/><p>You can embed <code class="literal">SchemaUpdate</code> in your application: </p><pre class="programlisting">Configuration cfg = ....;
new SchemaUpdate(cfg).execute(false);</pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-7"/>20.1.6. インクリメンタルなスキーマ更新に対するAntの使用</h3></div></div></div><p>Antスクリプトから <code class="literal">SchemaUpdate</code> を呼び出すことができます： </p><pre class="programlisting">&lt;target name="schemaupdate"&gt;
    &lt;taskdef name="schemaupdate"
        classname="org.hibernate.tool.hbm2ddl.SchemaUpdateTask"
        classpathref="class.path"/&gt;
    
    &lt;schemaupdate
        properties="hibernate.properties"
        quiet="no"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemaupdate&gt;
&lt;/target&gt;</pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-8"/>20.1.7. Schema validation</h3></div></div></div><p>The <code class="literal">SchemaValidator</code> tool will validate that the existing database schema "matches" your mapping documents. The <code class="literal">SchemaValidator</code> depends heavily upon the JDBC metadata API and, as such, will not work with all JDBC drivers. This tool is extremely useful for testing. </p><p><code class="literal">java -cp </code><span class="emphasis"><em>hibernate_classpaths</em></span> <code class="literal">org.hibernate.tool.hbm2ddl.SchemaValidator</code> <span class="emphasis"><em>options mapping_files</em></span> </p><div class="table"><a id="d0e15935"/><p class="title"><b>表 20.5. <code class="literal">SchemaValidator</code> のコマンドライン・オプション</b></p><div class="table-contents"><table summary="SchemaValidator のコマンドライン・オプション" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>オプション</th><th>説明</th></tr></thead><tbody><tr><td><code class="literal">--naming=eg.MyNamingStrategy</code></td><td>select a <code class="literal">NamingStrategy</code></td></tr><tr><td><code class="literal">--properties=hibernate.properties</code></td><td>read database properties from a file</td></tr><tr><td><code class="literal">--config=hibernate.cfg.xml</code></td><td>specify a <code class="literal">.cfg.xml</code> file</td></tr></tbody></table></div></div><br class="table-break"/><p>You can embed <code class="literal">SchemaValidator</code> in your application: </p><pre class="programlisting">Configuration cfg = ....;
new SchemaValidator(cfg).validate();</pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-9"/>20.1.8. スキーマのバリデーションにAntを使用します</h3></div></div></div><p>Antスクリプトから <code class="literal">SchemaValidator</code> を呼び出せます: </p><pre class="programlisting">&lt;target name="schemavalidate"&gt;
    &lt;taskdef name="schemavalidator"
        classname="org.hibernate.tool.hbm2ddl.SchemaValidatorTask"
        classpathref="class.path"/&gt;
    
    &lt;schemavalidator
        properties="hibernate.properties"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemavalidator&gt;
&lt;/target&gt;</pre></div></div></div><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild"/>第21章 例：親/子供</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#example-parentchild-collections">21.1. コレクションに関する注意</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-bidir">21.2. 双方向一対多</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-cascades">21.3. ライフサイクルのカスケード</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-update">21.4. カスケードと <code class="literal">unsaved-value</code></a></span></dt><dt><span class="sect1"><a href="#example-parentchild-conclusion">21.5. 結論</a></span></dt></dl></div><p>One of the first things that new users want to do with Hibernate is to model a parent/child type relationship. There are two different approaches to this. The most convenient approach, especially for new users, is to model both <code class="literal">Parent</code> and <code class="literal">Child</code> as entity classes with a <code class="literal">&lt;one-to-many&gt;</code> association from <code class="literal">Parent</code> to <code class="literal">Child</code>. The alternative approach is to declare the <code class="literal">Child</code> as a <code class="literal">&lt;composite-element&gt;</code>. The default semantics of a one-to-many association in Hibernate are much less close to the usual semantics of a parent/child relationship than those of a composite element mapping. We will explain how to use a <span class="emphasis"><em>bidirectional one-to-many association with cascades</em></span> to model a parent/child relationship efficiently and elegantly. </p><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-collections"/>21.1. コレクションに関する注意</h2></div></div></div><p>Hibernate collections are considered to be a logical part of their owning entity and not of the contained entities. Be aware that this is a critical distinction that has the following consequences: </p><div class="itemizedlist"><ul><li><p>When you remove/add an object from/to a collection, the version number of the collection owner is incremented. </p></li><li><p>If an object that was removed from a collection is an instance of a value type (e.g. a composite element), that object will cease to be persistent and its state will be completely removed from the database. Likewise, adding a value type instance to the collection will cause its state to be immediately persistent. </p></li><li><p>Conversely, if an entity is removed from a collection (a one-to-many or many-to-many association), it will not be deleted by default. This behavior is completely consistent; a change to the internal state of another entity should not cause the associated entity to vanish. Likewise, adding an entity to a collection does not cause that entity to become persistent, by default. </p></li></ul></div><p>Adding an entity to a collection, by default, merely creates a link between the two entities. Removing the entity will remove the link. This is appropriate for all sorts of cases. However, it is not appropriate in the case of a parent/child relationship. In this case, the life of the child is bound to the life cycle of the parent. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-bidir"/>21.2. 双方向一対多</h2></div></div></div><p><code class="literal">Parent</code> から <code class="literal">Child</code> への単純な <code class="literal">&lt;one-to-many&gt;</code> 関連から始めるとします。 </p><pre class="programlisting">&lt;set name="children"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>If we were to execute the following code: </p><pre class="programlisting">Parent p = .....;
Child c = new Child();
p.getChildren().add(c);
session.save(c);
session.flush();</pre><p>Hibernateは二つのSQL文を発行します: </p><div class="itemizedlist"><ul><li><p><code class="literal">c</code>に対するレコードを生成する<code class="literal">INSERT</code></p></li><li><p><code class="literal">p</code>から<code class="literal">c</code>へのリンクを作成する<code class="literal">UPDATE</code> </p></li></ul></div><p>This is not only inefficient, but also violates any <code class="literal">NOT NULL</code> constraint on the <code class="literal">parent_id</code> column. You can fix the nullability constraint violation by specifying <code class="literal">not-null="true"</code> in the collection mapping: </p><pre class="programlisting">&lt;set name="children"&gt;
    &lt;key column="parent_id" not-null="true"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>しかしこの解決策は推奨できません。 </p><p>The underlying cause of this behavior is that the link (the foreign key <code class="literal">parent_id</code>) from <code class="literal">p</code> to <code class="literal">c</code> is not considered part of the state of the <code class="literal">Child</code> object and is therefore not created in the <code class="literal">INSERT</code>. The solution is to make the link part of the <code class="literal">Child</code> mapping. </p><pre class="programlisting">&lt;many-to-one name="parent" column="parent_id" not-null="true"/&gt;</pre><p>You also need to add the <code class="literal">parent</code> property to the <code class="literal">Child</code> class. </p><p>Now that the <code class="literal">Child</code> entity is managing the state of the link, we tell the collection not to update the link. We use the <code class="literal">inverse</code> attribute to do this: </p><pre class="programlisting">&lt;set name="children" inverse="true"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>The following code would be used to add a new <code class="literal">Child</code>: </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
c.setParent(p);
p.getChildren().add(c);
session.save(c);
session.flush();</pre><p>Only one SQL <code class="literal">INSERT</code> would now be issued. </p><p>You could also create an <code class="literal">addChild()</code> method of <code class="literal">Parent</code>. </p><pre class="programlisting">public void addChild(Child c) {
    c.setParent(this);
    children.add(c);
}</pre><p>The code to add a <code class="literal">Child</code> looks like this: </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
p.addChild(c);
session.save(c);
session.flush();</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-cascades"/>21.3. ライフサイクルのカスケード</h2></div></div></div><p>You can address the frustrations of the explicit call to <code class="literal">save()</code> by using cascades. </p><pre class="programlisting">&lt;set name="children" inverse="true" cascade="all"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>This simplifies the code above to: </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
p.addChild(c);
session.flush();</pre><p>Similarly, we do not need to iterate over the children when saving or deleting a <code class="literal">Parent</code>. The following removes <code class="literal">p</code> and all its children from the database. </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
session.delete(p);
session.flush();</pre><p>However, the following code: </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = (Child) p.getChildren().iterator().next();
p.getChildren().remove(c);
c.setParent(null);
session.flush();</pre><p>will not remove <code class="literal">c</code> from the database. In this case, it will only remove the link to <code class="literal">p</code> and cause a <code class="literal">NOT NULL</code> constraint violation. You need to explicitly <code class="literal">delete()</code> the <code class="literal">Child</code>. </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = (Child) p.getChildren().iterator().next();
p.getChildren().remove(c);
session.delete(c);
session.flush();</pre><p>In our case, a <code class="literal">Child</code> cannot exist without its parent. So if we remove a <code class="literal">Child</code> from the collection, we do want it to be deleted. To do this, we must use <code class="literal">cascade="all-delete-orphan"</code>. </p><pre class="programlisting">&lt;set name="children" inverse="true" cascade="all-delete-orphan"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>Even though the collection mapping specifies <code class="literal">inverse="true"</code>, cascades are still processed by iterating the collection elements. If you need an object be saved, deleted or updated by cascade, you must add it to the collection. It is not enough to simply call <code class="literal">setParent()</code>. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-update"/>21.4. カスケードと <code class="literal">unsaved-value</code></h2></div></div></div><p>Suppose we loaded up a <code class="literal">Parent</code> in one <code class="literal">Session</code>, made some changes in a UI action and wanted to persist these changes in a new session by calling <code class="literal">update()</code>. The <code class="literal">Parent</code> will contain a collection of children and, since the cascading update is enabled, Hibernate needs to know which children are newly instantiated and which represent existing rows in the database. We will also assume that both <code class="literal">Parent</code> and <code class="literal">Child</code> have generated identifier properties of type <code class="literal">Long</code>. Hibernate will use the identifier and version/timestamp property value to determine which of the children are new. (See <a href="#objectstate-saveorupdate" title="10.7. 自動的な状態検出">項10.7. 「自動的な状態検出」</a>.) <span class="emphasis"><em>In Hibernate3, it is no longer necessary to specify an <code class="literal">unsaved-value</code> explicitly.</em></span> </p><p>The following code will update <code class="literal">parent</code> and <code class="literal">child</code> and insert <code class="literal">newChild</code>: </p><pre class="programlisting">//parent and child were both loaded in a previous session
parent.addChild(child);
Child newChild = new Child();
parent.addChild(newChild);
session.update(parent);
session.flush();</pre><p>This may be suitable for the case of a generated identifier, but what about assigned identifiers and composite identifiers? This is more difficult, since Hibernate cannot use the identifier property to distinguish between a newly instantiated object, with an identifier assigned by the user, and an object loaded in a previous session. In this case, Hibernate will either use the timestamp or version property, or will actually query the second-level cache or, worst case, the database, to see if the row exists. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-conclusion"/>21.5. 結論</h2></div></div></div><p>The sections we have just covered can be a bit confusing. However, in practice, it all works out nicely. Most Hibernate applications use the parent/child pattern in many places. </p><p>We mentioned an alternative in the first paragraph. None of the above issues exist in the case of <code class="literal">&lt;composite-element&gt;</code> mappings, which have exactly the semantics of a parent/child relationship. Unfortunately, there are two big limitations with composite element classes: composite elements cannot own collections and they should not be the child of any entity other than the unique parent. </p></div></div><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="example-weblog"/>第22章 例: Weblogアプリケーション</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#example-weblog-classes">22.1. 永続クラス</a></span></dt><dt><span class="sect1"><a href="#example-weblog-mappings">22.2. Hibernateのマッピング</a></span></dt><dt><span class="sect1"><a href="#example-weblog-code">22.3. Hibernateのコード</a></span></dt></dl></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="example-weblog-classes"/>22.1. 永続クラス</h2></div></div></div><p>The persistent classes here represent a weblog and an item posted in a weblog. They are to be modelled as a standard parent/child relationship, but we will use an ordered bag, instead of a set: </p><pre class="programlisting">package eg;

import java.util.List;

public class Blog {
    private Long _id;
    private String _name;
    private List _items;

    public Long getId() {
        return _id;
    }
    public List getItems() {
        return _items;
    }
    public String getName() {
        return _name;
    }
    public void setId(Long long1) {
        _id = long1;
    }
    public void setItems(List list) {
        _items = list;
    }
    public void setName(String string) {
        _name = string;
    }
}</pre><pre class="programlisting">package eg;

import java.text.DateFormat;
import java.util.Calendar;

public class BlogItem {
    private Long _id;
    private Calendar _datetime;
    private String _text;
    private String _title;
    private Blog _blog;

    public Blog getBlog() {
        return _blog;
    }
    public Calendar getDatetime() {
        return _datetime;
    }
    public Long getId() {
        return _id;
    }
    public String getText() {
        return _text;
    }
    public String getTitle() {
        return _title;
    }
    public void setBlog(Blog blog) {
        _blog = blog;
    }
    public void setDatetime(Calendar calendar) {
        _datetime = calendar;
    }
    public void setId(Long long1) {
        _id = long1;
    }
    public void setText(String string) {
        _text = string;
    }
    public void setTitle(String string) {
        _title = string;
    }
}</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="example-weblog-mappings"/>22.2. Hibernateのマッピング</h2></div></div></div><p>The XML mappings are now straightforward. For example: </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

    &lt;class
        name="Blog"
        table="BLOGS"&gt;

        &lt;id
            name="id"
            column="BLOG_ID"&gt;

            &lt;generator class="native"/&gt;

        &lt;/id&gt;

        &lt;property
            name="name"
            column="NAME"
            not-null="true"
            unique="true"/&gt;

        &lt;bag
            name="items"
            inverse="true"
            order-by="DATE_TIME"
            cascade="all"&gt;

            &lt;key column="BLOG_ID"/&gt;
            &lt;one-to-many class="BlogItem"/&gt;

        &lt;/bag&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

    &lt;class
        name="BlogItem"
        table="BLOG_ITEMS"
        dynamic-update="true"&gt;

        &lt;id
            name="id"
            column="BLOG_ITEM_ID"&gt;

            &lt;generator class="native"/&gt;

        &lt;/id&gt;

        &lt;property
            name="title"
            column="TITLE"
            not-null="true"/&gt;

        &lt;property
            name="text"
            column="TEXT"
            not-null="true"/&gt;

        &lt;property
            name="datetime"
            column="DATE_TIME"
            not-null="true"/&gt;

        &lt;many-to-one
            name="blog"
            column="BLOG_ID"
            not-null="true"/&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="example-weblog-code"/>22.3. Hibernateのコード</h2></div></div></div><p>The following class demonstrates some of the kinds of things we can do with these classes using Hibernate: </p><pre class="programlisting">package eg;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Iterator;
import java.util.List;

import org.hibernate.HibernateException;
import org.hibernate.Query;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;
import org.hibernate.tool.hbm2ddl.SchemaExport;

public class BlogMain {
    
    private SessionFactory _sessions;
    
    public void configure() throws HibernateException {
        _sessions = new Configuration()
            .addClass(Blog.class)
            .addClass(BlogItem.class)
            .buildSessionFactory();
    }
    
    public void exportTables() throws HibernateException {
        Configuration cfg = new Configuration()
            .addClass(Blog.class)
            .addClass(BlogItem.class);
        new SchemaExport(cfg).create(true, true);
    }
    
    public Blog createBlog(String name) throws HibernateException {
        
        Blog blog = new Blog();
        blog.setName(name);
        blog.setItems( new ArrayList() );
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.persist(blog);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return blog;
    }
    
    public BlogItem createBlogItem(Blog blog, String title, String text)
                        throws HibernateException {
        
        BlogItem item = new BlogItem();
        item.setTitle(title);
        item.setText(text);
        item.setBlog(blog);
        item.setDatetime( Calendar.getInstance() );
        blog.getItems().add(item);
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.update(blog);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return item;
    }
    
    public BlogItem createBlogItem(Long blogid, String title, String text)
                        throws HibernateException {
        
        BlogItem item = new BlogItem();
        item.setTitle(title);
        item.setText(text);
        item.setDatetime( Calendar.getInstance() );
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            Blog blog = (Blog) session.load(Blog.class, blogid);
            item.setBlog(blog);
            blog.getItems().add(item);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return item;
    }
    
    public void updateBlogItem(BlogItem item, String text)
                    throws HibernateException {
        
        item.setText(text);
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.update(item);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
    }
    
    public void updateBlogItem(Long itemid, String text)
                    throws HibernateException {
    
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            BlogItem item = (BlogItem) session.load(BlogItem.class, itemid);
            item.setText(text);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
    }
    
    public List listAllBlogNamesAndItemCounts(int max)
                    throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        List result = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "select blog.id, blog.name, count(blogItem) " +
                "from Blog as blog " +
                "left outer join blog.items as blogItem " +
                "group by blog.name, blog.id " +
                "order by max(blogItem.datetime)"
            );
            q.setMaxResults(max);
            result = q.list();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return result;
    }
    
    public Blog getBlogAndAllItems(Long blogid)
                    throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        Blog blog = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "from Blog as blog " +
                "left outer join fetch blog.items " +
                "where blog.id = :blogid"
            );
            q.setParameter("blogid", blogid);
            blog  = (Blog) q.uniqueResult();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return blog;
    }
    
    public List listBlogsAndRecentItems() throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        List result = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "from Blog as blog " +
                "inner join blog.items as blogItem " +
                "where blogItem.datetime &gt; :minDate"
            );

            Calendar cal = Calendar.getInstance();
            cal.roll(Calendar.MONTH, false);
            q.setCalendar("minDate", cal);
            
            result = q.list();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return result;
    }
}</pre></div></div><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="example-mappings"/>第23章 例：いろいろなマッピング</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#example-mappings-emp">23.1. 雇用者/従業員</a></span></dt><dt><span class="sect1"><a href="#example-mappings-authorwork">23.2. 作者/作品</a></span></dt><dt><span class="sect1"><a href="#example-mappings-customerorderproduct">23.3. 顧客/注文/製品</a></span></dt><dt><span class="sect1"><a href="#misc">23.4. 種々雑多なマッピング例</a></span></dt><dd><dl><dt><span class="sect2"><a href="#example-mappings-typed-onetone">23.4.1. 「型付けされた」一対一関連</a></span></dt><dt><span class="sect2"><a href="#example-mappings-composite-key">23.4.2. 複合キーの例</a></span></dt><dt><span class="sect2"><a href="#example-mappings-composite-key-manytomany">23.4.3. 複合キー属性を共有する多対多</a></span></dt><dt><span class="sect2"><a href="#example-mappings-content-discrimination">23.4.4. discriminationに基づく内容</a></span></dt><dt><span class="sect2"><a href="#example-mappings-association-alternatekeys">23.4.5. 代替キーの関連</a></span></dt></dl></dd></dl></div><p>This chapters explores some more complex association mappings. </p><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="example-mappings-emp"/>23.1. 雇用者/従業員</h2></div></div></div><p>The following model of the relationship between <code class="literal">Employer</code> and <code class="literal">Employee</code> uses an entity class (<code class="literal">Employment</code>) to represent the association. You can do this when there might be more than one period of employment for the same two parties. Components are used to model monetary values and employee names. </p><div class="mediaobject" align="center"><img src="../images/EmployerEmployee.png" align="middle"/></div><p>Here is a possible mapping document: </p><pre class="programlisting">&lt;hibernate-mapping&gt;
        
    &lt;class name="Employer" table="employers"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employer_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

    &lt;class name="Employment" table="employment_periods"&gt;

        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employment_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="startDate" column="start_date"/&gt;
        &lt;property name="endDate" column="end_date"/&gt;

        &lt;component name="hourlyRate" class="MonetaryAmount"&gt;
            &lt;property name="amount"&gt;
                &lt;column name="hourly_rate" sql-type="NUMERIC(12, 2)"/&gt;
            &lt;/property&gt;
            &lt;property name="currency" length="12"/&gt;
        &lt;/component&gt;

        &lt;many-to-one name="employer" column="employer_id" not-null="true"/&gt;
        &lt;many-to-one name="employee" column="employee_id" not-null="true"/&gt;

    &lt;/class&gt;

    &lt;class name="Employee" table="employees"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employee_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="taxfileNumber"/&gt;
        &lt;component name="name" class="Name"&gt;
            &lt;property name="firstName"/&gt;
            &lt;property name="initial"/&gt;
            &lt;property name="lastName"/&gt;
        &lt;/component&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>Here is the table schema generated by <code class="literal">SchemaExport</code>. </p><pre class="programlisting">create table employers (
    id BIGINT not null, 
    name VARCHAR(255), 
    primary key (id)
)

create table employment_periods (
    id BIGINT not null,
    hourly_rate NUMERIC(12, 2),
    currency VARCHAR(12), 
    employee_id BIGINT not null, 
    employer_id BIGINT not null, 
    end_date TIMESTAMP, 
    start_date TIMESTAMP, 
    primary key (id)
)

create table employees (
    id BIGINT not null, 
    firstName VARCHAR(255), 
    initial CHAR(1), 
    lastName VARCHAR(255), 
    taxfileNumber VARCHAR(255), 
    primary key (id)
)

alter table employment_periods 
    add constraint employment_periodsFK0 foreign key (employer_id) references employers
alter table employment_periods 
    add constraint employment_periodsFK1 foreign key (employee_id) references employees
create sequence employee_id_seq
create sequence employment_id_seq
create sequence employer_id_seq</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="example-mappings-authorwork"/>23.2. 作者/作品</h2></div></div></div><p>Consider the following model of the relationships between <code class="literal">Work</code>, <code class="literal">Author</code> and <code class="literal">Person</code>. In the example, the relationship between <code class="literal">Work</code> and <code class="literal">Author</code> is represented as a many-to-many association and the relationship between <code class="literal">Author</code> and <code class="literal">Person</code> is represented as one-to-one association. Another possibility would be to have <code class="literal">Author</code> extend <code class="literal">Person</code>. </p><div class="mediaobject" align="center"><img src="../images/AuthorWork.png" align="middle"/></div><p>以下のマッピングドキュメントはこのような関係を正確に表現しています。 </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Work" table="works" discriminator-value="W"&gt;

        &lt;id name="id" column="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;discriminator column="type" type="character"/&gt;

        &lt;property name="title"/&gt;
        &lt;set name="authors" table="author_work"&gt;
            &lt;key column name="work_id"/&gt;
            &lt;many-to-many class="Author" column name="author_id"/&gt;
        &lt;/set&gt;

        &lt;subclass name="Book" discriminator-value="B"&gt;
            &lt;property name="text"/&gt;
        &lt;/subclass&gt;

        &lt;subclass name="Song" discriminator-value="S"&gt;
            &lt;property name="tempo"/&gt;
            &lt;property name="genre"/&gt;
        &lt;/subclass&gt;

    &lt;/class&gt;

    &lt;class name="Author" table="authors"&gt;

        &lt;id name="id" column="id"&gt;
            &lt;!-- The Author must have the same identifier as the Person --&gt;
            &lt;generator class="assigned"/&gt; 
        &lt;/id&gt;

        &lt;property name="alias"/&gt;
        &lt;one-to-one name="person" constrained="true"/&gt;

        &lt;set name="works" table="author_work" inverse="true"&gt;
            &lt;key column="author_id"/&gt;
            &lt;many-to-many class="Work" column="work_id"/&gt;
        &lt;/set&gt;

    &lt;/class&gt;

    &lt;class name="Person" table="persons"&gt;
        &lt;id name="id" column="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>There are four tables in this mapping: <code class="literal">works</code>, <code class="literal">authors</code> and <code class="literal">persons</code> hold work, author and person data respectively. <code class="literal">author_work</code> is an association table linking authors to works. Here is the table schema, as generated by <code class="literal">SchemaExport</code>: </p><pre class="programlisting">create table works (
    id BIGINT not null generated by default as identity, 
    tempo FLOAT, 
    genre VARCHAR(255), 
    text INTEGER, 
    title VARCHAR(255), 
    type CHAR(1) not null, 
    primary key (id)
)

create table author_work (
    author_id BIGINT not null, 
    work_id BIGINT not null, 
    primary key (work_id, author_id)
)

create table authors (
    id BIGINT not null generated by default as identity, 
    alias VARCHAR(255), 
    primary key (id)
)

create table persons (
    id BIGINT not null generated by default as identity, 
    name VARCHAR(255), 
    primary key (id)
)

alter table authors 
    add constraint authorsFK0 foreign key (id) references persons
alter table author_work 
    add constraint author_workFK0 foreign key (author_id) references authors
alter table author_work
    add constraint author_workFK1 foreign key (work_id) references works</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="example-mappings-customerorderproduct"/>23.3. 顧客/注文/製品</h2></div></div></div><p>In this section we consider a model of the relationships between <code class="literal">Customer</code>, <code class="literal">Order</code>, <code class="literal">Line Item</code> and <code class="literal">Product</code>. There is a one-to-many association between <code class="literal">Customer</code> and <code class="literal">Order</code>, but how can you represent <code class="literal">Order</code> / <code class="literal">LineItem</code> / <code class="literal">Product</code>? In the example, <code class="literal">LineItem</code> is mapped as an association class representing the many-to-many association between <code class="literal">Order</code> and <code class="literal">Product</code>. In Hibernate this is called a composite element. </p><div class="mediaobject" align="center"><img src="../images/CustomerOrderProduct.png" align="middle"/></div><p>The mapping document will look like this: </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Customer" table="customers"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
        &lt;set name="orders" inverse="true"&gt;
            &lt;key column="customer_id"/&gt;
            &lt;one-to-many class="Order"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Order" table="orders"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="date"/&gt;
        &lt;many-to-one name="customer" column="customer_id"/&gt;
        &lt;list name="lineItems" table="line_items"&gt;
            &lt;key column="order_id"/&gt;
            &lt;list-index column="line_number"/&gt;
            &lt;composite-element class="LineItem"&gt;
                &lt;property name="quantity"/&gt;
                &lt;many-to-one name="product" column="product_id"/&gt;
            &lt;/composite-element&gt;
        &lt;/list&gt;
    &lt;/class&gt;

    &lt;class name="Product" table="products"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="serialNumber"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p><code class="literal">customers</code> , <code class="literal">orders</code> , <code class="literal">line_items</code> , <code class="literal">products</code> はそれぞれ、顧客、注文、注文明細、製品のデータを保持します。 <code class="literal">line_items</code> は注文と製品をリンクする関連テーブルとしても働きます。 </p><pre class="programlisting">create table customers (
    id BIGINT not null generated by default as identity, 
    name VARCHAR(255), 
    primary key (id)
)

create table orders (
    id BIGINT not null generated by default as identity, 
    customer_id BIGINT, 
    date TIMESTAMP, 
    primary key (id)
)

create table line_items (
    line_number INTEGER not null, 
    order_id BIGINT not null, 
    product_id BIGINT, 
    quantity INTEGER, 
    primary key (order_id, line_number)
)

create table products (
    id BIGINT not null generated by default as identity, 
    serialNumber VARCHAR(255), 
    primary key (id)
)

alter table orders 
    add constraint ordersFK0 foreign key (customer_id) references customers
alter table line_items
    add constraint line_itemsFK0 foreign key (product_id) references products
alter table line_items
    add constraint line_itemsFK1 foreign key (order_id) references orders</pre></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="misc"/>23.4. 種々雑多なマッピング例</h2></div></div></div><p>These examples are available from the Hibernate test suite. You will find many other useful example mappings there by searching in the <code class="literal">test</code> folder of the Hibernate distribution. </p><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="example-mappings-typed-onetone"/>23.4.1. 「型付けされた」一対一関連</h3></div></div></div><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="name"/&gt;
    &lt;one-to-one name="address" 
            cascade="all"&gt;
        &lt;formula&gt;name&lt;/formula&gt;
        &lt;formula&gt;'HOME'&lt;/formula&gt;
    &lt;/one-to-one&gt;
    &lt;one-to-one name="mailingAddress" 
            cascade="all"&gt;
        &lt;formula&gt;name&lt;/formula&gt;
        &lt;formula&gt;'MAILING'&lt;/formula&gt;
    &lt;/one-to-one&gt;
&lt;/class&gt;

&lt;class name="Address" batch-size="2" 
        check="addressType in ('MAILING', 'HOME', 'BUSINESS')"&gt;
    &lt;composite-id&gt;
        &lt;key-many-to-one name="person" 
                column="personName"/&gt;
        &lt;key-property name="type" 
                column="addressType"/&gt;
    &lt;/composite-id&gt;
    &lt;property name="street" type="text"/&gt;
    &lt;property name="state"/&gt;
    &lt;property name="zip"/&gt;
&lt;/class&gt;</pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="example-mappings-composite-key"/>23.4.2. 複合キーの例</h3></div></div></div><pre class="programlisting">&lt;class name="Customer"&gt;

    &lt;id name="customerId"
        length="10"&gt;
        &lt;generator class="assigned"/&gt;
    &lt;/id&gt;

    &lt;property name="name" not-null="true" length="100"/&gt;
    &lt;property name="address" not-null="true" length="200"/&gt;

    &lt;list name="orders"
            inverse="true"
            cascade="save-update"&gt;
        &lt;key column="customerId"/&gt;
        &lt;index column="orderNumber"/&gt;
        &lt;one-to-many class="Order"/&gt;
    &lt;/list&gt;

&lt;/class&gt;

&lt;class name="Order" table="CustomerOrder" lazy="true"&gt;
    &lt;synchronize table="LineItem"/&gt;
    &lt;synchronize table="Product"/&gt;
    
    &lt;composite-id name="id" 
            class="Order$Id"&gt;
        &lt;key-property name="customerId" length="10"/&gt;
        &lt;key-property name="orderNumber"/&gt;
    &lt;/composite-id&gt;
    
    &lt;property name="orderDate" 
            type="calendar_date"
            not-null="true"/&gt;
    
    &lt;property name="total"&gt;
        &lt;formula&gt;
            ( select sum(li.quantity*p.price) 
            from LineItem li, Product p 
            where li.productId = p.productId 
                and li.customerId = customerId 
                and li.orderNumber = orderNumber )
        &lt;/formula&gt;
    &lt;/property&gt;
    
    &lt;many-to-one name="customer"
            column="customerId"
            insert="false"
            update="false" 
            not-null="true"/&gt;
        
    &lt;bag name="lineItems"
            fetch="join" 
            inverse="true"
            cascade="save-update"&gt;
        &lt;key&gt;
            &lt;column name="customerId"/&gt;
            &lt;column name="orderNumber"/&gt;
        &lt;/key&gt;
        &lt;one-to-many class="LineItem"/&gt;
    &lt;/bag&gt;
    
&lt;/class&gt;
    
&lt;class name="LineItem"&gt;
    
    &lt;composite-id name="id" 
            class="LineItem$Id"&gt;
        &lt;key-property name="customerId" length="10"/&gt;
        &lt;key-property name="orderNumber"/&gt;
        &lt;key-property name="productId" length="10"/&gt;
    &lt;/composite-id&gt;
    
    &lt;property name="quantity"/&gt;
    
    &lt;many-to-one name="order"
            insert="false"
            update="false" 
            not-null="true"&gt;
        &lt;column name="customerId"/&gt;
        &lt;column name="orderNumber"/&gt;
    &lt;/many-to-one&gt;
    
    &lt;many-to-one name="product"
            insert="false"
            update="false" 
            not-null="true"
            column="productId"/&gt;
        
&lt;/class&gt;

&lt;class name="Product"&gt;
    &lt;synchronize table="LineItem"/&gt;

    &lt;id name="productId"
        length="10"&gt;
        &lt;generator class="assigned"/&gt;
    &lt;/id&gt;
    
    &lt;property name="description" 
        not-null="true" 
        length="200"/&gt;
    &lt;property name="price" length="3"/&gt;
    &lt;property name="numberAvailable"/&gt;
    
    &lt;property name="numberOrdered"&gt;
        &lt;formula&gt;
            ( select sum(li.quantity) 
            from LineItem li 
            where li.productId = productId )
        &lt;/formula&gt;
    &lt;/property&gt;
    
&lt;/class&gt;</pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="example-mappings-composite-key-manytomany"/>23.4.3. 複合キー属性を共有する多対多</h3></div></div></div><pre class="programlisting">&lt;class name="User" table="`User`"&gt;
    &lt;composite-id&gt;
        &lt;key-property name="name"/&gt;
        &lt;key-property name="org"/&gt;
    &lt;/composite-id&gt;
    &lt;set name="groups" table="UserGroup"&gt;
        &lt;key&gt;
            &lt;column name="userName"/&gt;
            &lt;column name="org"/&gt;
        &lt;/key&gt;
        &lt;many-to-many class="Group"&gt;
            &lt;column name="groupName"/&gt;
            &lt;formula&gt;org&lt;/formula&gt;
        &lt;/many-to-many&gt;
    &lt;/set&gt;
&lt;/class&gt;
    
&lt;class name="Group" table="`Group`"&gt;
    &lt;composite-id&gt;
        &lt;key-property name="name"/&gt;
        &lt;key-property name="org"/&gt;
    &lt;/composite-id&gt;
    &lt;property name="description"/&gt;
    &lt;set name="users" table="UserGroup" inverse="true"&gt;
        &lt;key&gt;
            &lt;column name="groupName"/&gt;
            &lt;column name="org"/&gt;
        &lt;/key&gt;
        &lt;many-to-many class="User"&gt;
            &lt;column name="userName"/&gt;
            &lt;formula&gt;org&lt;/formula&gt;
        &lt;/many-to-many&gt;
    &lt;/set&gt;
&lt;/class&gt;
</pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="example-mappings-content-discrimination"/>23.4.4. discriminationに基づく内容</h3></div></div></div><pre class="programlisting">&lt;class name="Person"
    discriminator-value="P"&gt;
    
    &lt;id name="id" 
        column="person_id" 
        unsaved-value="0"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    
            
    &lt;discriminator 
        type="character"&gt;
        &lt;formula&gt;
            case 
                when title is not null then 'E' 
                when salesperson is not null then 'C' 
                else 'P' 
            end
        &lt;/formula&gt;
    &lt;/discriminator&gt;

    &lt;property name="name" 
        not-null="true"
        length="80"/&gt;
        
    &lt;property name="sex" 
        not-null="true"
        update="false"/&gt;
    
    &lt;component name="address"&gt;
        &lt;property name="address"/&gt;
        &lt;property name="zip"/&gt;
        &lt;property name="country"/&gt;
    &lt;/component&gt;
    
    &lt;subclass name="Employee" 
        discriminator-value="E"&gt;
            &lt;property name="title"
                length="20"/&gt;
            &lt;property name="salary"/&gt;
            &lt;many-to-one name="manager"/&gt;
    &lt;/subclass&gt;
    
    &lt;subclass name="Customer" 
        discriminator-value="C"&gt;
            &lt;property name="comments"/&gt;
            &lt;many-to-one name="salesperson"/&gt;
    &lt;/subclass&gt;
    
&lt;/class&gt;</pre></div><div class="sect2" lang="ja-JP"><div class="titlepage"><div><div><h3 class="title"><a id="example-mappings-association-alternatekeys"/>23.4.5. 代替キーの関連</h3></div></div></div><pre class="programlisting">&lt;class name="Person"&gt;
    
    &lt;id name="id"&gt;
        &lt;generator class="hilo"/&gt;
    &lt;/id&gt;
    
    &lt;property name="name" length="100"/&gt;
    
    &lt;one-to-one name="address" 
        property-ref="person"
        cascade="all"
        fetch="join"/&gt;
    
    &lt;set name="accounts" 
        inverse="true"&gt;
        &lt;key column="userId"
            property-ref="userId"/&gt;
        &lt;one-to-many class="Account"/&gt;
    &lt;/set&gt;
    
    &lt;property name="userId" length="8"/&gt;

&lt;/class&gt;

&lt;class name="Address"&gt;

    &lt;id name="id"&gt;
        &lt;generator class="hilo"/&gt;
    &lt;/id&gt;

    &lt;property name="address" length="300"/&gt;
    &lt;property name="zip" length="5"/&gt;
    &lt;property name="country" length="25"/&gt;
    &lt;many-to-one name="person" unique="true" not-null="true"/&gt;

&lt;/class&gt;

&lt;class name="Account"&gt;
    &lt;id name="accountId" length="32"&gt;
        &lt;generator class="uuid"/&gt;
    &lt;/id&gt;
    
    &lt;many-to-one name="user"
        column="userId"
        property-ref="userId"/&gt;
    
    &lt;property name="type" not-null="true"/&gt;
    
&lt;/class&gt;</pre></div></div></div><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="best-practices"/>第24章 ベストプラクティス</h2></div></div></div><div class="variablelist"><dl><dt><span class="term">Write fine-grained classes and map them using <code class="literal">&lt;component&gt;</code>:</span></dt><dd><p><code class="literal">street</code>（通り）, <code class="literal">suburb</code> （都市）, <code class="literal">state</code>（州）, <code class="literal">postcode</code> （郵便番号）をカプセル化する <code class="literal">Address</code>（住所）クラスを使いましょう。 そうすればコードが再利用しやすくなり、リファクタリングも簡単になります。 </p></dd><dt><span class="term">Declare identifier properties on persistent classes:</span></dt><dd><p>Hibernate makes identifier properties optional. There are a range of reasons why you should use them. We recommend that identifiers be 'synthetic', that is, generated with no business meaning. </p></dd><dt><span class="term">Identify natural keys:</span></dt><dd><p>すべてのエンティティに対して自然キーを見つけて、 <code class="literal">&lt;natural-id&gt;</code> でマッピングしましょう。 自然キーを構成するプロパティを比較するために、 <code class="literal">equals()</code> と <code class="literal">hashCode()</code> を実装しましょう。 </p></dd><dt><span class="term">Place each class mapping in its own file:</span></dt><dd><p>Do not use a single monolithic mapping document. Map <code class="literal">com.eg.Foo</code> in the file <code class="literal">com/eg/Foo.hbm.xml</code>. This makes sense, particularly in a team environment. </p></dd><dt><span class="term">Load mappings as resources:</span></dt><dd><p>マッピングを、それらがマッピングするするクラスと一緒に配置しましょう。 </p></dd><dt><span class="term">Consider externalizing query strings:</span></dt><dd><p>This is recommended if your queries call non-ANSI-standard SQL functions. Externalizing the query strings to mapping files will make the application more portable. </p></dd><dt><span class="term">バインド変数を使いましょう。</span></dt><dd><p>As in JDBC, always replace non-constant values by "?". Do not use string manipulation to bind a non-constant value in a query. You should also consider using named parameters in queries. </p></dd><dt><span class="term">Do not manage your own JDBC connections:</span></dt><dd><p>Hibernate allows the application to manage JDBC connections, but his approach should be considered a last-resort. If you cannot use the built-in connection providers, consider providing your own implementation of <code class="literal">org.hibernate.connection.ConnectionProvider</code>. </p></dd><dt><span class="term">Consider using a custom type:</span></dt><dd><p>Suppose you have a Java type from a library that needs to be persisted but does not provide the accessors needed to map it as a component. You should consider implementing <code class="literal">org.hibernate.UserType</code>. This approach frees the application code from implementing transformations to/from a Hibernate type. </p></dd><dt><span class="term">Use hand-coded JDBC in bottlenecks:</span></dt><dd><p>In performance-critical areas of the system, some kinds of operations might benefit from direct JDBC. Do not assume, however, that JDBC is necessarily faster. Please wait until you <span class="emphasis"><em>know</em></span> something is a bottleneck. If you need to use direct JDBC, you can open a Hibernate <code class="literal">Session</code> and usingfile:///usr/share/doc/HTML/en-US/index.html that JDBC connection. This way you can still use the same transaction strategy and underlying connection provider. </p></dd><dt><span class="term">Understand <code class="literal">Session</code> flushing:</span></dt><dd><p>Sometimes the Session synchronizes its persistent state with the database. Performance will be affected if this process occurs too often. You can sometimes minimize unnecessary flushing by disabling automatic flushing, or even by changing the order of queries and other operations within a particular transaction. </p></dd><dt><span class="term">In a three tiered architecture, consider using detached objects:</span></dt><dd><p>When using a servlet/session bean architecture, you can pass persistent objects loaded in the session bean to and from the servlet/JSP layer. Use a new session to service each request. Use <code class="literal">Session.merge()</code> or <code class="literal">Session.saveOrUpdate()</code> to synchronize objects with the database. </p></dd><dt><span class="term">In a two tiered architecture, consider using long persistence contexts:</span></dt><dd><p>Database Transactions have to be as short as possible for best scalability. However, it is often necessary to implement long running <span class="emphasis"><em>application transactions</em></span>, a single unit-of-work from the point of view of a user. An application transaction might span several client request/response cycles. It is common to use detached objects to implement application transactions. An appropriate alternative in a two tiered architecture, is to maintain a single open persistence contact session for the whole life cycle of the application transaction. Then simply disconnect from the JDBC connection at the end of each request and reconnect at the beginning of the subsequent request. Never share a single session across more than one application transaction or you will be working with stale data. </p></dd><dt><span class="term">Do not treat exceptions as recoverable:</span></dt><dd><p>This is more of a necessary practice than a "best" practice. When an exception occurs, roll back the <code class="literal">Transaction</code> and close the <code class="literal">Session</code>. If you do not do this, Hibernate cannot guarantee that in-memory state accurately represents the persistent state. For example, do not use <code class="literal">Session.load()</code> to determine if an instance with the given identifier exists on the database; use <code class="literal">Session.get()</code> or a query instead. </p></dd><dt><span class="term">Prefer lazy fetching for associations:</span></dt><dd><p>Use eager fetching sparingly. Use proxies and lazy collections for most associations to classes that are not likely to be completely held in the second-level cache. For associations to cached classes, where there is an a extremely high probability of a cache hit, explicitly disable eager fetching using <code class="literal">lazy="false"</code>. When join fetching is appropriate to a particular use case, use a query with a <code class="literal">left join fetch</code>. </p></dd><dt><span class="term">Use the <span class="emphasis"><em>open session in view</em></span> pattern, or a disciplined <span class="emphasis"><em>assembly phase</em></span> to avoid problems with unfetched data: </span></dt><dd><p>Hibernate frees the developer from writing tedious <span class="emphasis"><em>Data Transfer Objects</em></span> (DTO). In a traditional EJB architecture, DTOs serve dual purposes: first, they work around the problem that entity beans are not serializable; second, they implicitly define an assembly phase where all data to be used by the view is fetched and marshalled into the DTOs before returning control to the presentation tier. Hibernate eliminates the first purpose. Unless you are prepared to hold the persistence context (the session) open across the view rendering process, you will still need an assembly phase. Think of your business methods as having a strict contract with the presentation tier about what data is available in the detached objects. This is not a limitation of Hibernate. It is a fundamental requirement of safe transactional data access. </p></dd><dt><span class="term">Consider abstracting your business logic from Hibernate:</span></dt><dd><p>Hide Hibernate data-access code behind an interface. Combine the <span class="emphasis"><em>DAO</em></span> and <span class="emphasis"><em>Thread Local Session</em></span> patterns. You can even have some classes persisted by handcoded JDBC associated to Hibernate via a <code class="literal">UserType</code>. This advice is, however, intended for "sufficiently large" applications. It is not appropriate for an application with five tables. </p></dd><dt><span class="term">Do not use exotic association mappings:</span></dt><dd><p>Practical test cases for real many-to-many associations are rare. Most of the time you need additional information stored in the "link table". In this case, it is much better to use two one-to-many associations to an intermediate link class. In fact, most associations are one-to-many and many-to-one. For this reason, you should proceed cautiously when using any other association style. </p></dd><dt><span class="term">Prefer bidirectional associations:</span></dt><dd><p>単方向関連は双方向に比べて検索が難しくなります。 大きなアプリケーションでは、 ほとんどすべての関連が双方向にナビゲーションできなければなりません。 </p></dd></dl></div></div><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="portability"/>第25章 Database Portability Considerations</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#portability-basics">25.1. Portability Basics</a></span></dt><dt><span class="sect1"><a href="#portability-dialect">25.2. Dialect</a></span></dt><dt><span class="sect1"><a href="#portability-dialectresolver">25.3. Dialect resolution</a></span></dt><dt><span class="sect1"><a href="#portability-idgen">25.4. Identifier generation</a></span></dt><dt><span class="sect1"><a href="#portability-functions">25.5. Database functions</a></span></dt><dt><span class="sect1"><a href="#portability-types">25.6. Type mappings</a></span></dt></dl></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="portability-basics"/>25.1. Portability Basics</h2></div></div></div><p>One of the selling points of Hibernate (and really Object/Relational Mapping as a whole) is the notion of database portability. This could mean an internal IT user migrating from one database vendor to another, or it could mean a framework or deployable application consuming Hibernate to simultaneously target multiple database products by their users. Regardless of the exact scenario, the basic idea is that you want Hibernate to help you run against any number of databases without changes to your code, and ideally without any changes to the mapping metadata. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="portability-dialect"/>25.2. Dialect</h2></div></div></div><p>The first line of portability for Hibernate is the dialect, which is a specialization of the <code class="classname">org.hibernate.dialect.Dialect</code> contract. A dialect encapsulates all the differences in how Hibernate must communicate with a particular database to accomplish some task like getting a sequence value or structuring a SELECT query. Hibernate bundles a wide range of dialects for many of the most popular databases. If you find that your particular database is not among them, it is not terribly difficult to write your own. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="portability-dialectresolver"/>25.3. Dialect resolution</h2></div></div></div><p>Originally, Hibernate would always require that users specify which dialect to use. In the case of users looking to simultaneously target multiple databases with their build that was problematic. Generally this required their users to configure the Hibernate dialect or defining their own method of setting that value. </p><p>Starting with version 3.2, Hibernate introduced the notion of automatically detecting the dialect to use based on the <code class="interfacename">java.sql.DatabaseMetaData</code> obtained from a <code class="interfacename">java.sql.Connection</code> to that database. This was much better, expect that this resolution was limited to databases Hibernate know about ahead of time and was in no way configurable or overrideable. </p><p>Starting with version 3.3, Hibernate has a fare more powerful way to automatically determine which dialect to should be used by relying on a series of delegates which implement the <code class="interfacename">org.hibernate.dialect.resolver.DialectResolver</code> which defines only a single method:</p><pre class="programlisting">public Dialect resolveDialect(DatabaseMetaData metaData) throws JDBCConnectionException</pre><p>. The basic contract here is that if the resolver 'understands' the given database metadata then it returns the corresponding Dialect; if not it returns null and the process continues to the next resolver. The signature also identifies <code class="exceptionname">org.hibernate.exception.JDBCConnectionException</code> as possibly being thrown. A JDBCConnectionException here is interpreted to imply a "non transient" (aka non-recoverable) connection problem and is used to indicate an immediate stop to resolution attempts. All other exceptions result in a warning and continuing on to the next resolver. </p><p>The cool part about these resolvers is that users can also register their own custom resolvers which will be processed ahead of the built-in Hibernate ones. This might be useful in a number of different situations: it allows easy integration for auto-detection of dialects beyond those shipped with HIbernate itself; it allows you to specify to use a custom dialect when a particular database is recognized; etc. To register one or more resolvers, simply specify them (seperated by commas, tabs or spaces) using the 'hibernate.dialect_resolvers' configuration setting (see the <code class="constant">DIALECT_RESOLVERS</code> constant on <code class="classname">org.hibernate.cfg.Environment</code>). </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="portability-idgen"/>25.4. Identifier generation</h2></div></div></div><p>When considering portability between databases, another important decision is selecting the identifier generation stratagy you want to use. Originally Hibernate provided the <span class="emphasis"><em>native</em></span> generator for this purpose, which was intended to select between a <span class="emphasis"><em>sequence</em></span>, <span class="emphasis"><em>identity</em></span>, or <span class="emphasis"><em>table</em></span> strategy depending on the capability of the underlying database. However, an insidious implication of this approach comes about when targtetting some databases which support <span class="emphasis"><em>identity</em></span> generation and some which do not. <span class="emphasis"><em>identity</em></span> generation relies on the SQL definition of an IDENTITY (or auto-increment) column to manage the identifier value; it is what is known as a post-insert generation strategy becauase the insert must actually happen before we can know the identifier value. Because Hibernate relies on this identifier value to uniquely reference entities within a persistence context it must then issue the insert immediately when the users requests the entitiy be associated with the session (like via save() e.g.) regardless of current transactional semantics. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p> Hibernate was changed slightly once the implication of this was better understood so that the insert is delayed in cases where that is feasible. </p></div><p> The underlying issue is that the actual semanctics of the application itself changes in these cases. </p><p>Starting with version 3.2.3, Hibernate comes with a set of <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://in.relation.to/2082.lace">enhanced</a> identifier generators targetting portability in a much different way. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p> There are specifically 2 bundled <span class="emphasis"><em>enhanced</em></span>generators: </p><div class="itemizedlist"><ul><li><p> <code class="classname">org.hibernate.id.enhanced.SequenceStyleGenerator</code> </p></li><li><p> <code class="classname">org.hibernate.id.enhanced.TableGenerator</code> </p></li></ul></div><p> </p></div><p> The idea behind these generators is to port the actual semantics of the identifer value generation to the different databases. For example, the <code class="classname">org.hibernate.id.enhanced.SequenceStyleGenerator</code> mimics the behavior of a sequence on databases which do not support sequences by using a table. </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="portability-functions"/>25.5. Database functions</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>警告</h2><p>This is an area in Hibernate in need of improvement. In terms of portability concerns, this function handling currently works pretty well from HQL; however, it is quite lacking in all other aspects. </p></div><p>SQL functions can be referenced in many ways by users. However, not all databases support the same set of functions. Hibernate, provides a means of mapping a <span class="emphasis"><em>logical</em></span> function name to a a delegate which knows how to render that particular function, perhaps even using a totally different physical function call. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>重要項目</h2><p>Technically this function registration is handled through the <code class="classname">org.hibernate.dialect.function.SQLFunctionRegistry</code> class which is intended to allow users to provide custom function definitions without having to provide a custom dialect. This specific behavior is not fully completed as of yet. </p><p>It is sort of implemented such that users can programatically register functions with the <code class="classname">org.hibernate.cfg.Configuration</code> and those functions will be recognized for HQL. </p></div><p>
        </p></div><div class="sect1" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="portability-types"/>25.6. Type mappings</h2></div></div></div><p>This section scheduled for completion at a later date... </p></div></div><div class="bibliography"><div class="titlepage"><div><div><h2 class="title"><a id="d0e16864"/>References</h2></div></div></div><div class="biblioentry"><a id="biblio-PoEAA"/><p>[<abbr class="abbrev">PoEAA</abbr>] <span class="title"><i>Patterns of Enterprise Application Architecture</i>. </span><span class="isbn">0-321-12742-0. </span><span class="authorgroup">： <span class="surname">Fowler</span> <span class="firstname">Martin</span> [FAMILY Given]. </span><span class="copyright">製作著作 © 2003 Pearson Education, Inc.. </span><span class="publisher"><span class="publishername">Addison-Wesley Publishing Company. </span></span></p></div><div class="biblioentry"><a id="biblio-JPwH"/><p>[<abbr class="abbrev">JPwH</abbr>] <span class="title"><i>Java Persistence with Hibernate</i>. </span><span class="subtitle">Second Edition of Hibernate in Action. </span><span class="isbn">1-932394-88-5. </span><span class="bibliomisc">
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.manning.com/bauer2">http://www.manning.com/bauer2</a>
        . </span><span class="authorgroup">： <span class="surname">Bauer</span> <span class="firstname">Christian</span> [FAMILY Given] 、 <span class="surname">King</span> <span class="firstname">Gavin</span> [FAMILY Given]. </span><span class="copyright">製作著作 © 2007 Manning Publications Co.. </span><span class="publisher"><span class="publishername">Manning Publications Co.. </span></span></p></div></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">製作著作 © 2004 Red Hat Middleware, LLC.</p></a></body></html>