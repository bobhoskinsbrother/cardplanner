<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">HIBERNATE - Persistance relationnelle en Java standard</title><link rel="stylesheet" href="css/hibernate-single.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.72.0"/></head><body><div class="book" lang="fr-FR"><div class="titlepage"><div><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><div><h1 class="title"><a id="d0e2"/>HIBERNATE - Persistance relationnelle en Java standard</h1></div><div><h2 class="subtitle">Documentation de référence d'Hibernate</h2></div><div><div xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="authorgroup"><div class="authors">par <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Gavin</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">King</span>, <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Christian</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Bauer</span>, <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Max</span> <span xmlns="http://www.w3.org/1999/xhtml" class="othername">Rydahl</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Andersen</span>, <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Emmanuel</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Bernard</span>, et <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Steve</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Ebersole</span></div><div class="editors"/><div class="others">and thanks to <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">James</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Cobb</span> (Graphic Design), <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Cheyenne</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Weaver</span> (Graphic Design), <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Vincent</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Ricard</span>, <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Sebastien</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Cesbron</span>, <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Michael</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Courcy</span>, <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Vincent</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Giguère</span>, <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Baptiste</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Mathus</span>, <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Emmanuel</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Bernard</span>, et <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Anthony</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Patricio</span></div></div></div><div><p class="releaseinfo">3.3.2.GA</p></div><div><p class="copyright">Copyright © 2004 Red Hat Middleware, LLC.</p></div><div><a href="legalnotice.html">Legal Notice</a></div><div><p class="pubdate">June 24, 2009</p></div></div><hr/></div><div class="toc"><dl><dt><span class="preface"><a href="#preface">Préface</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e231">1. Feedback</a></span></dt></dl></dd><dt><span class="chapter"><a href="#tutorial">1. Tutorial</a></span></dt><dd><dl><dt><span class="sect1"><a href="#tutorial-firstapp">1.1. Partie 1 - Première application Hibernate</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-firstapp-setup">1.1.1. Setup</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-firstclass">1.1.2. La première classe</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-mapping">1.1.3. Le fichier de mapping</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-configuration">1.1.4. Configuration d'Hibernate</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-mvn">1.1.5. Building with Maven</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-helpers">1.1.6. Démarrage et aides</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-workingpersistence">1.1.7. Charger et stocker des objets</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-associations">1.2. Partie 2 - Mapper des associations</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-associations-mappinguser">1.2.1. Mapper la classe Person</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-unidirset">1.2.2. Une association unidirectionnelle basée sur Set</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-working">1.2.3. Travailler avec l'association</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-valuecollections">1.2.4. Collection de valeurs</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-bidirectional">1.2.5. Associations bidirectionnelles</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-usingbidir">1.2.6. Travailler avec des liens bidirectionnels</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-webapp">1.3. Part 3 - L'application web EventManager</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-webapp-servlet">1.3.1. Ecrire la servlet de base</a></span></dt><dt><span class="sect2"><a href="#tutorial-webapp-processing">1.3.2. Procéder et rendre</a></span></dt><dt><span class="sect2"><a href="#tutorial-webapp-deploy">1.3.3. Déployer et tester</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-summary">1.4. Résumé</a></span></dt></dl></dd><dt><span class="chapter"><a href="#architecture">2. Architecture</a></span></dt><dd><dl><dt><span class="sect1"><a href="#architecture-overview">2.1. Généralités</a></span></dt><dt><span class="sect1"><a href="#architecture-states">2.2. Etats des instances</a></span></dt><dt><span class="sect1"><a href="#architecture-jmx">2.3. Intégration JMX</a></span></dt><dt><span class="sect1"><a href="#architecture-jca">2.4. Support JCA</a></span></dt><dt><span class="sect1"><a href="#architecture-current-session">2.5. Contextual sessions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#session-configuration">3. Configuration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#configuration-programmatic">3.1. Configuration par programmation</a></span></dt><dt><span class="sect1"><a href="#configuration-sessionfactory">3.2. Obtenir une SessionFactory</a></span></dt><dt><span class="sect1"><a href="#configuration-hibernatejdbc">3.3. Connexions JDBC</a></span></dt><dt><span class="sect1"><a href="#configuration-optional">3.4. Propriétés de configuration optionnelles</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuration-optional-dialects">3.4.1. Dialectes SQL</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-outerjoin">3.4.2. Chargement par Jointure Ouverte</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-binarystreams">3.4.3. Flux binaires</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-cacheprovider">3.4.4. Cache de second niveau et cache de requêtes</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-querysubstitution">3.4.5. Substitution dans le langage de requêtage</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-statistics">3.4.6. Statistiques Hibernate</a></span></dt></dl></dd><dt><span class="sect1"><a href="#configuration-logging">3.5. Tracer</a></span></dt><dt><span class="sect1"><a href="#configuration-namingstrategy">3.6. Implémenter une <code class="literal">NamingStrategy</code></a></span></dt><dt><span class="sect1"><a href="#configuration-xmlconfig">3.7. Fichier de configuration XML</a></span></dt><dt><span class="sect1"><a href="#configuration-j2ee">3.8. Intégration à un serveur d'application J2EE</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuration-optional-transactionstrategy">3.8.1. Configuration de la stratégie transactionnelle</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-jndi">3.8.2. <code class="literal">SessionFactory</code> associée au JNDI</a></span></dt><dt><span class="sect2"><a href="#configuration-j2ee-currentsession">3.8.3. Association automatique de la Session à JTA</a></span></dt><dt><span class="sect2"><a href="#configuration-j2ee-jmx">3.8.4. Déploiement JMX</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#persistent-classes">4. Classes persistantes</a></span></dt><dd><dl><dt><span class="sect1"><a href="#persistent-classes-pojo">4.1. Un exemple simple de POJO</a></span></dt><dd><dl><dt><span class="sect2"><a href="#persistent-classes-pojo-constructor">4.1.1. Implémenter un constructeur sans argument</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-identifier">4.1.2. Fournir une propriété d'indentifiant (optionnel)</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-final">4.1.3. Favoriser les classes non finales (optionnel)</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-accessors">4.1.4. Déclarer les accesseurs et mutateurs des attributs persistants (optionnel)</a></span></dt></dl></dd><dt><span class="sect1"><a href="#persistent-classes-inheritance">4.2. Implémenter l'héritage</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-equalshashcode">4.3. Implémenter <code class="literal">equals()</code> et <code class="literal">hashCode()</code></a></span></dt><dt><span class="sect1"><a href="#persistent-classes-dynamicmodels">4.4. Modèles dynamiques</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-tuplizers">4.5. Tuplizers</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-entity-name-resolver">4.6. EntityNameResolvers</a></span></dt></dl></dd><dt><span class="chapter"><a href="#mapping">5. Mapping O/R basique</a></span></dt><dd><dl><dt><span class="sect1"><a href="#mapping-declaration">5.1. Déclaration de Mapping</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-declaration-doctype">5.1.1. Doctype</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-mapping">5.1.2. Hibernate-mapping</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-class">5.1.3. Class</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id">5.1.4. id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id-enhanced">5.1.5. Enhanced identifier generators</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id-enhanced-optimizers">5.1.6. Identifier generator optimization</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-compositeid">5.1.7. composite-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-discriminator">5.1.8. Discriminator</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-version">5.1.9. Version (optional)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-timestamp">5.1.10. Timestamp (optional)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-property">5.1.11. Property</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-manytoone">5.1.12. Many-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-onetoone">5.1.13. One-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-naturalid">5.1.14. Natural-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-component">5.1.15. Component and dynamic-component</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-properties">5.1.16. Properties</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-subclass">5.1.17. Subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-joinedsubclass">5.1.18. Joined-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-unionsubclass">5.1.19. Union-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-join">5.1.20. Join</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-key">5.1.21. Key</a></span></dt><dt><span class="sect2"><a href="#mapping-column">5.1.22. Column and formula elements</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-import">5.1.23. Import</a></span></dt><dt><span class="sect2"><a href="#mapping-types-anymapping">5.1.24. Any</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-types">5.2. Hibernate types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-types-entitiesvalues">5.2.1. Entités et valeurs</a></span></dt><dt><span class="sect2"><a href="#mapping-types-basictypes">5.2.2. Basic value types</a></span></dt><dt><span class="sect2"><a href="#mapping-types-custom">5.2.3. Types de valeur définis par l'utilisateur</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-entityname">5.3. Mapper une classe plus d'une fois</a></span></dt><dt><span class="sect1"><a href="#mapping-quotedidentifiers">5.4. SQL quoted identifiers</a></span></dt><dt><span class="sect1"><a href="#mapping-alternatives">5.5. alternatives Metadata</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-xdoclet">5.5.1. utilisation de XDoclet</a></span></dt><dt><span class="sect2"><a href="#mapping-annotations">5.5.2. Utilisation des annotations JDK 5.0</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-generated">5.6. Generated properties</a></span></dt><dt><span class="sect1"><a href="#mapping-database-object">5.7. Auxiliary database objects</a></span></dt></dl></dd><dt><span class="chapter"><a href="#collections">6. Collection mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#collections-persistent">6.1. Collections persistantes</a></span></dt><dt><span class="sect1"><a href="#collections-mapping">6.2. Mapper une collection</a></span></dt><dd><dl><dt><span class="sect2"><a href="#collections-foreignkeys">6.2.1. Les clefs étrangères d'une collection</a></span></dt><dt><span class="sect2"><a href="#collections-elements">6.2.2. Les éléments d'une collection</a></span></dt><dt><span class="sect2"><a href="#collections-indexed">6.2.3. Collections indexées</a></span></dt><dt><span class="sect2"><a href="#collections-ofvalues">6.2.4. Collections de valeurs et associations plusieurs-vers-plusieurs</a></span></dt><dt><span class="sect2"><a href="#collections-onetomany">6.2.5. Association un-vers-plusieurs</a></span></dt></dl></dd><dt><span class="sect1"><a href="#collections-advancedmappings">6.3. Mappings de collection avancés</a></span></dt><dd><dl><dt><span class="sect2"><a href="#collections-sorted">6.3.1. Collections triées</a></span></dt><dt><span class="sect2"><a href="#collections-bidirectional">6.3.2. Associations bidirectionnelles</a></span></dt><dt><span class="sect2"><a href="#collections-indexedbidirectional">6.3.3. Associations bidirectionnelles avec des collections indexées</a></span></dt><dt><span class="sect2"><a href="#collections-ternary">6.3.4. Associations ternaires</a></span></dt><dt><span class="sect2"><a href="#collections-idbag">6.3.5. <code class="literal">Utiliser un <code class="literal">&lt;idbag&gt;</code></code></a></span></dt></dl></dd><dt><span class="sect1"><a href="#collections-example">6.4. Exemples de collections</a></span></dt></dl></dd><dt><span class="chapter"><a href="#associations">7. Mapper les associations</a></span></dt><dd><dl><dt><span class="sect1"><a href="#assoc-intro">7.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#assoc-unidirectional">7.2. Association unidirectionnelle</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-unidirectional-m21">7.2.1. Many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-121">7.2.2. One-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-12m">7.2.3. One-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-unidirectional-join">7.3. Associations unidirectionnelles avec tables de jointure</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-unidirectional-join-12m">7.3.1. One-to-many</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-m21">7.3.2. Many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-121">7.3.3. One-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-m2m">7.3.4. Many-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-bidirectional">7.4. Associations bidirectionnelles</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-bidirectional-m21">7.4.1. one-to-many / many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-121">7.4.2. One-to-one</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-bidirectional-join">7.5. Associations bidirectionnelles avec table de jointure</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-bidirectional-join-12m">7.5.1. one-to-many / many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-join-121">7.5.2. one to one</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-join-m2m">7.5.3. Many-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-complex">7.6. Des mappings plus complexes</a></span></dt></dl></dd><dt><span class="chapter"><a href="#components">8. Mapping de composants</a></span></dt><dd><dl><dt><span class="sect1"><a href="#components-dependentobjects">8.1. Objects dépendants</a></span></dt><dt><span class="sect1"><a href="#components-incollections">8.2. Collection d'objets dépendants</a></span></dt><dt><span class="sect1"><a href="#components-asmapindex">8.3. Utiliser les composants comme index de map</a></span></dt><dt><span class="sect1"><a href="#components-compositeid">8.4. Utiliser un composant comme identifiant</a></span></dt><dt><span class="sect1"><a href="#components-dynamic">8.5. Composant Dynamique</a></span></dt></dl></dd><dt><span class="chapter"><a href="#inheritance">9. Inheritance mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#inheritance-strategies">9.1. The three strategies</a></span></dt><dd><dl><dt><span class="sect2"><a href="#inheritance-tableperclass">9.1.1. Une table par hiérarchie de classe</a></span></dt><dt><span class="sect2"><a href="#inheritance-tablepersubclass">9.1.2. Une table par classe fille</a></span></dt><dt><span class="sect2"><a href="#inheritance-tablepersubclass-discriminator">9.1.3. Table per subclass: using a discriminator</a></span></dt><dt><span class="sect2"><a href="#inheritance-mixing-tableperclass-tablepersubclass">9.1.4. Mélange d'une table par hiérarchie de classe avec une table par classe fille</a></span></dt><dt><span class="sect2"><a href="#inheritance-tableperconcrete">9.1.5. Une table par classe concrète</a></span></dt><dt><span class="sect2"><a href="#inheritance-tableperconcreate-polymorphism">9.1.6. Table per concrete class using implicit polymorphism</a></span></dt><dt><span class="sect2"><a href="#inheritance-mixingpolymorphism">9.1.7. Mélange du polymorphisme implicite avec d'autres mappings d'héritage</a></span></dt></dl></dd><dt><span class="sect1"><a href="#inheritance-limitations">9.2. Limitations</a></span></dt></dl></dd><dt><span class="chapter"><a href="#objectstate">10. Travailler avec des objets</a></span></dt><dd><dl><dt><span class="sect1"><a href="#objectstate-overview">10.1. États des objets Hibernate</a></span></dt><dt><span class="sect1"><a href="#objectstate-makingpersistent">10.2. Rendre des objets persistants</a></span></dt><dt><span class="sect1"><a href="#objectstate-loading">10.3. Chargement d'un objet</a></span></dt><dt><span class="sect1"><a href="#objectstate-querying">10.4. Requêtage</a></span></dt><dd><dl><dt><span class="sect2"><a href="#objectstate-querying-executing">10.4.1. Exécution de requêtes</a></span></dt><dt><span class="sect2"><a href="#objectstate-filtering">10.4.2. Filtrer des collections</a></span></dt><dt><span class="sect2"><a href="#objecstate-querying-criteria">10.4.3. Requêtes Criteria</a></span></dt><dt><span class="sect2"><a href="#objectstate-querying-nativesql">10.4.4. Requêtes en SQL natif</a></span></dt></dl></dd><dt><span class="sect1"><a href="#objectstate-modifying">10.5. Modifier des objets persistants</a></span></dt><dt><span class="sect1"><a href="#objectstate-detached">10.6. Modifier des objets détachés</a></span></dt><dt><span class="sect1"><a href="#objectstate-saveorupdate">10.7. Détection automatique d'un état</a></span></dt><dt><span class="sect1"><a href="#objectstate-deleting">10.8. Suppression d'objets persistants</a></span></dt><dt><span class="sect1"><a href="#objectstate-replicating">10.9. Réplication d'objets entre deux entrepôts de données</a></span></dt><dt><span class="sect1"><a href="#objectstate-flushing">10.10. Flush de la session</a></span></dt><dt><span class="sect1"><a href="#objectstate-transitive">10.11. Persistance transitive</a></span></dt><dt><span class="sect1"><a href="#objectstate-metadata">10.12. Utilisation des méta-données</a></span></dt></dl></dd><dt><span class="chapter"><a href="#transactions">11. Transactions and Concurrency</a></span></dt><dd><dl><dt><span class="sect1"><a href="#transactions-basics">11.1. Gestion de session et délimitation de transactions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-basics-uow">11.1.1. Unité de travail</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-apptx">11.1.2. Longue conversation</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-identity">11.1.3. L'identité des objets</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-issues">11.1.4. Problèmes communs</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-demarcation">11.2. Démarcation des transactions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-demarcation-nonmanaged">11.2.1. Environnement non managé</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-jta">11.2.2. Utilisation de JTA</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-exceptions">11.2.3. Gestion des exceptions</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-timeout">11.2.4. Timeout de transaction</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-optimistic">11.3. Contrôle de consurrence optimiste</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-optimistic-manual">11.3.1. Gestion du versionnage au niveau applicatif</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-longsession">11.3.2. Les sessions longues et le versionnage automatique.</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-detached">11.3.3. Les objets détachés et le versionnage automatique</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-customizing">11.3.4. Personnaliser le versionnage automatique</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-locking">11.4. Pessimistic locking</a></span></dt><dt><span class="sect1"><a href="#transactions-connection-release">11.5. Connection release modes</a></span></dt></dl></dd><dt><span class="chapter"><a href="#events">12. Les intercepteurs et les événements</a></span></dt><dd><dl><dt><span class="sect1"><a href="#objectstate-interceptors">12.1. Intercepteurs</a></span></dt><dt><span class="sect1"><a href="#objectstate-events">12.2. Système d'événements</a></span></dt><dt><span class="sect1"><a href="#objectstate-decl-security">12.3. Sécurité déclarative d'Hibernate</a></span></dt></dl></dd><dt><span class="chapter"><a href="#batch">13. Traitement par paquet</a></span></dt><dd><dl><dt><span class="sect1"><a href="#batch-inserts">13.1. Paquet de mises Ã  jour</a></span></dt><dt><span class="sect1"><a href="#batch-update">13.2. L'interface StatelessSession</a></span></dt><dt><span class="sect1"><a href="#batch-statelesssession">13.3. Notez que dans le code de l'exemple, les intances de <code class="literal">Customer</code> retournÃ©es par la requÃªte sont immÃ©diatement dÃ©tachÃ©es. Elles ne sont jamais associÃ©es Ã  un contexte de persistance.</a></span></dt><dt><span class="sect1"><a href="#batch-direct">13.4. La pseudo-syntaxe pour les expressions <code class="literal">UPDATE</code> et <code class="literal">DELETE</code> est : <code class="literal">( UPDATE | DELETE ) FROM? EntityName (WHERE where_conditions)?</code>. Certains points sont Ã  noter :</a></span></dt></dl></dd><dt><span class="chapter"><a href="#queryhql">14. HQL: Langage de requêtage d'Hibernate</a></span></dt><dd><dl><dt><span class="sect1"><a href="#queryhql-casesensitivity">14.1. Sensibilité à la casse</a></span></dt><dt><span class="sect1"><a href="#queryhql-from">14.2. La clause from</a></span></dt><dt><span class="sect1"><a href="#queryhql-joins">14.3. Associations et jointures</a></span></dt><dt><span class="sect1"><a href="#queryhql-joins-forms">14.4. Formes de syntaxes pour les jointures</a></span></dt><dt><span class="sect1"><a href="#queryhql-identifier-property">14.5. Referring to identifier property</a></span></dt><dt><span class="sect1"><a href="#queryhql-select">14.6. La clause select</a></span></dt><dt><span class="sect1"><a href="#queryhql-aggregation">14.7. Fonctions d'aggrégation</a></span></dt><dt><span class="sect1"><a href="#queryhql-polymorphism">14.8. Requêtes polymorphiques</a></span></dt><dt><span class="sect1"><a href="#queryhql-where">14.9. La clause where</a></span></dt><dt><span class="sect1"><a href="#queryhql-expressions">14.10. Expressions</a></span></dt><dt><span class="sect1"><a href="#queryhql-ordering">14.11. La clause order by</a></span></dt><dt><span class="sect1"><a href="#queryhql-grouping">14.12. La clause group by</a></span></dt><dt><span class="sect1"><a href="#queryhql-subqueries">14.13. Sous-requêtes</a></span></dt><dt><span class="sect1"><a href="#queryhql-examples">14.14. Exemples HQL</a></span></dt><dt><span class="sect1"><a href="#queryhql-bulk">14.15. Mise à jour et suppression</a></span></dt><dt><span class="sect1"><a href="#queryhql-tipstricks">14.16. Trucs &amp; Astuces</a></span></dt><dt><span class="sect1"><a href="#queryhql-components">14.17. translator-credits</a></span></dt><dt><span class="sect1"><a href="#queryhql-tuple">14.18. Row value constructor syntax</a></span></dt></dl></dd><dt><span class="chapter"><a href="#querycriteria">15. Requêtes par critères</a></span></dt><dd><dl><dt><span class="sect1"><a href="#querycriteria-creating">15.1. Créer une instance de <code class="literal">Criteria</code></a></span></dt><dt><span class="sect1"><a href="#querycriteria-narrowing">15.2. Restriction du résultat</a></span></dt><dt><span class="sect1"><a href="#querycriteria-ordering">15.3. Trier les résultats</a></span></dt><dt><span class="sect1"><a href="#querycriteria-associations">15.4. Associations</a></span></dt><dt><span class="sect1"><a href="#querycriteria-dynamicfetching">15.5. Peuplement d'associations de manière dynamique</a></span></dt><dt><span class="sect1"><a href="#querycriteria-examples">15.6. Requêtes par l'exemple</a></span></dt><dt><span class="sect1"><a href="#querycriteria-projection">15.7. Projections, agrégation et regroupement</a></span></dt><dt><span class="sect1"><a href="#querycriteria-detachedqueries">15.8. Requêtes et sous-requêtes détachées</a></span></dt><dt><span class="sect1"><a href="#query-criteria-naturalid">15.9. Requêtes par identifiant naturel</a></span></dt></dl></dd><dt><span class="chapter"><a href="#querysql">16. SQL natif</a></span></dt><dd><dl><dt><span class="sect1"><a href="#querysql-creating">16.1. Utiliser une <code class="literal">SQLQuery</code></a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e13429">16.1.1. Scalar queries</a></span></dt><dt><span class="sect2"><a href="#d0e13479">16.1.2. Entity queries</a></span></dt><dt><span class="sect2"><a href="#d0e13515">16.1.3. Handling associations and collections</a></span></dt><dt><span class="sect2"><a href="#d0e13546">16.1.4. Returning multiple entities</a></span></dt><dt><span class="sect2"><a href="#d0e13687">16.1.5. Returning non-managed entities</a></span></dt><dt><span class="sect2"><a href="#d0e13708">16.1.6. Handling inheritance</a></span></dt><dt><span class="sect2"><a href="#d0e13713">16.1.7. Parameters</a></span></dt></dl></dd><dt><span class="sect1"><a href="#querysql-namedqueries">16.2. Requêtes SQL nommées</a></span></dt><dd><dl><dt><span class="sect2"><a href="#propertyresults">16.2.1. Utilisation de return-property pour spécifier explicitement les noms des colonnes/alias</a></span></dt><dt><span class="sect2"><a href="#sp_query">16.2.2. Utilisation de procédures stockées pour les requêtes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#querysql-cud">16.3. SQL personnalisé pour créer, mettre à jour et effacer</a></span></dt><dt><span class="sect1"><a href="#querysql-load">16.4. SQL personnalisé pour le chargement</a></span></dt></dl></dd><dt><span class="chapter"><a href="#filters">17. Filtrer les données</a></span></dt><dd><dl><dt><span class="sect1"><a href="#objectstate-filters">17.1. Filtres Hibernate</a></span></dt></dl></dd><dt><span class="chapter"><a href="#xml">18. Mapping XML</a></span></dt><dd><dl><dt><span class="sect1"><a href="#xml-intro">18.1. Travailler avec des données XML</a></span></dt><dd><dl><dt><span class="sect2"><a href="#xml-intro-mapping">18.1.1. Spécifier le mapping XML et le mapping d'une classe ensemble</a></span></dt><dt><span class="sect2"><a href="#xml-onlyxml">18.1.2. Spécifier seulement un mapping XML</a></span></dt></dl></dd><dt><span class="sect1"><a href="#xml-mapping">18.2. Métadonnées du mapping XML</a></span></dt><dt><span class="sect1"><a href="#xml-manipulation">18.3. Manipuler des données XML</a></span></dt></dl></dd><dt><span class="chapter"><a href="#performance">19. Améliorer les performances</a></span></dt><dd><dl><dt><span class="sect1"><a href="#performance-fetching">19.1. Stratégies de chargement</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-fetching-lazy">19.1.1. Travailler avec des associations chargées tardivement</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-custom">19.1.2. Personnalisation des stratégies de chargement</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-proxies">19.1.3. Proxys pour des associations vers un seul objet</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-initialization">19.1.4. Initialisation des collections et des proxys</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-batch">19.1.5. Utiliser le chargement par lot</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-subselect">19.1.6. Utilisation du chargement par sous select</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-lazyproperties">19.1.7. Utiliser le chargement tardif des propriétés</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-cache">19.2. Le cache de second niveau</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-cache-mapping">19.2.1. Mapping de Cache</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readonly">19.2.2. Strategie : lecture seule</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readwrite">19.2.3. Stratégie : lecture/écriture</a></span></dt><dt><span class="sect2"><a href="#performance-cache-nonstrict">19.2.4. Stratégie : lecture/écriture non stricte</a></span></dt><dt><span class="sect2"><a href="#performance-cache-transactional">19.2.5. Stratégie : transactionelle</a></span></dt><dt><span class="sect2"><a href="#performance-cache-compat-matrix">19.2.6. Cache-provider/concurrency-strategy compatibility</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-sessioncache">19.3. Gérer les caches</a></span></dt><dt><span class="sect1"><a href="#performance-querycache">19.4. Le cache de requêtes</a></span></dt><dt><span class="sect1"><a href="#performance-collections">19.5. Comprendre les performances des Collections</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-collections-taxonomy">19.5.1. Classification</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficientupdate">19.5.2. Les lists, les maps, les idbags et les sets sont les collections les plus efficaces pour la mise à jour</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficentinverse">19.5.3. Les Bags et les lists sont les plus efficaces pour les collections inverse</a></span></dt><dt><span class="sect2"><a href="#performance-collections-oneshotdelete">19.5.4. Suppression en un coup</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-monitoring">19.6. Moniteur de performance</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-monitoring-sf">19.6.1. Suivi d'une SessionFactory</a></span></dt><dt><span class="sect2"><a href="#performance-monitoring-metrics">19.6.2. Métriques</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#toolsetguide">20. Guide des outils</a></span></dt><dd><dl><dt><span class="sect1"><a href="#toolsetguide-s1">20.1. Génération automatique du schéma</a></span></dt><dd><dl><dt><span class="sect2"><a href="#toolsetguide-s1-2">20.1.1. Personnaliser le schéma</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-3">20.1.2. Exécuter l'outil</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-4">20.1.3. Propriétés</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-5">20.1.4. Utiliser Ant</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-6">20.1.5. Mises à jour incrémentales du schéma</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-7">20.1.6. Utiliser Ant pour des mises à jour de schéma par incrément</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-8">20.1.7. Validation du schéma</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-9">20.1.8. Utiliser Ant pour la validation du Schéma</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#example-parentchild">21. Exemple : Père/Fils</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-parentchild-collections">21.1. Une note à propos des collections</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-bidir">21.2. un-vers-plusieurs bidirectionnel</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-cascades">21.3. Cycle de vie en cascade</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-update">21.4. Cascades et <code class="literal">unsaved-value</code></a></span></dt><dt><span class="sect1"><a href="#example-parentchild-conclusion">21.5. Conclusion</a></span></dt></dl></dd><dt><span class="chapter"><a href="#example-weblog">22. Exemple : application Weblog</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-weblog-classes">22.1. Classes persistantes</a></span></dt><dt><span class="sect1"><a href="#example-weblog-mappings">22.2. Mappings Hibernate</a></span></dt><dt><span class="sect1"><a href="#example-weblog-code">22.3. Code Hibernate</a></span></dt></dl></dd><dt><span class="chapter"><a href="#example-mappings">23. Exemple : quelques mappings</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-mappings-emp">23.1. Employeur/Employé (Employer/Employee)</a></span></dt><dt><span class="sect1"><a href="#example-mappings-authorwork">23.2. Auteur/Travail (Author/Work)</a></span></dt><dt><span class="sect1"><a href="#example-mappings-customerorderproduct">23.3. Client/Commande/Produit (Customer/Order/Product)</a></span></dt><dt><span class="sect1"><a href="#misc">23.4. Divers mappings d'exemple</a></span></dt><dd><dl><dt><span class="sect2"><a href="#example-mappings-typed-onetone">23.4.1. "Typed" one-to-one association</a></span></dt><dt><span class="sect2"><a href="#example-mappings-composite-key">23.4.2. Exemple de clef composée</a></span></dt><dt><span class="sect2"><a href="#example-mappings-composite-key-manytomany">23.4.3. Many-to-many avec une clef composée partagée</a></span></dt><dt><span class="sect2"><a href="#example-mappings-content-discrimination">23.4.4. Contenu basé sur une discrimination</a></span></dt><dt><span class="sect2"><a href="#example-mappings-association-alternatekeys">23.4.5. Associations sur des clefs alternées</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#best-practices">24. Meilleures pratiques</a></span></dt><dt><span class="chapter"><a href="#portability">25. Database Portability Considerations</a></span></dt><dd><dl><dt><span class="sect1"><a href="#portability-basics">25.1. Portability Basics</a></span></dt><dt><span class="sect1"><a href="#portability-dialect">25.2. Dialect</a></span></dt><dt><span class="sect1"><a href="#portability-dialectresolver">25.3. Dialect resolution</a></span></dt><dt><span class="sect1"><a href="#portability-idgen">25.4. Identifier generation</a></span></dt><dt><span class="sect1"><a href="#portability-functions">25.5. Database functions</a></span></dt><dt><span class="sect1"><a href="#portability-types">25.6. Type mappings</a></span></dt></dl></dd><dt><span class="bibliography"><a href="#d0e17000">References</a></span></dt></dl></div><div class="preface" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="preface"/>Préface</h2></div></div></div><p>Working with object-oriented software and a relational database can be cumbersome and time consuming in today's enterprise environments. Hibernate is an Object/Relational Mapping tool for Java environments. The term Object/Relational Mapping (ORM) refers to the technique of mapping a data representation from an object model to a relational data model with a SQL-based schema. </p><p>Hibernate not only takes care of the mapping from Java classes to database tables (and from Java data types to SQL data types), but also provides data query and retrieval facilities. It can also significantly reduce development time otherwise spent with manual data handling in SQL and JDBC. </p><p>Hibernate's goal is to relieve the developer from 95 percent of common data persistence related programming tasks. Hibernate may not be the best solution for data-centric applications that only use stored-procedures to implement the business logic in the database, it is most useful with object-oriented domain models and business logic in the Java-based middle-tier. However, Hibernate can certainly help you to remove or encapsulate vendor-specific SQL code and will help with the common task of result set translation from a tabular representation to a graph of objects. </p><p>Si vous êtes nouveau dans Hibernate et le mapping Objet/Relationnel voire même en Java, suivez ces quelques étapes : </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>Lisez <a href="#tutorial" title="Chapitre 1. Tutorial">Chapitre 1, <i xmlns:xlink="http://www.w3.org/1999/xlink">Tutorial</i></a> pour un didacticiel plus long avec plus d'instructions étape par étape. </p></li><li><p>Lisez <a href="#architecture" title="Chapitre 2. Architecture">Chapitre 2, <i xmlns:xlink="http://www.w3.org/1999/xlink">Architecture</i></a> pour comprendre les environnements dans lesquels Hibernate peut être utilisé. </p></li><li><p>View the <code class="literal">eg/</code> directory in the Hibernate distribution. It contains a simple standalone application. Copy your JDBC driver to the <code class="literal">lib/</code> directory and edit <code class="literal">etc/hibernate.properties</code>, specifying correct values for your database. From a command prompt in the distribution directory, type <code class="literal">ant eg</code> (using Ant), or under Windows, type <code class="literal">build eg</code>. </p></li><li><p>Use this reference documentation as your primary source of information. Consider reading [<a xmlns:xlink="http://www.w3.org/1999/xlink" href="#biblio-JPwH" title="[JPwH]"><abbr class="abbrev">JPwH</abbr></a>] if you need more help with application design, or if you prefer a step-by-step tutorial. Also visit <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://caveatemptor.hibernate.org">http://caveatemptor.hibernate.org</a> and download the example application from [<a xmlns:xlink="http://www.w3.org/1999/xlink" href="#biblio-JPwH" title="[JPwH]"><abbr class="abbrev">JPwH</abbr></a>]. </p></li><li><p>Les questions les plus fréquemment posées (FAQs) trouvent leur réponse sur le site web Hibernate. </p></li><li><p>Links to third party demos, examples, and tutorials are maintained on the Hibernate website. </p></li><li><p>La zone communautaire (Community Area) du site web Hibernate est une bonne source d'information sur les design patterns et sur différentes solutions d'intégration d'Hibernate (Tomcat, JBoss, Spring Framework, Struts, EJB, etc). </p></li></ol></div><p>If you have questions, use the user forum linked on the Hibernate website. We also provide a JIRA issue tracking system for bug reports and feature requests. If you are interested in the development of Hibernate, join the developer mailing list. If you are interested in translating this documentation into your language, contact us on the developer mailing list. </p><p>Le développement commercial, le support de production et les formations à Hibernate sont proposés par JBoss Inc (voir http://www.hibernate.org/SupportTraining/). Hibernate est un projet Open Source professionnel et un composant critique de la suite de produits JBoss Enterprise Middleware System (JEMS). </p><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="d0e231"/>1. Feedback</h2></div></div></div><p>Use <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://opensource.atlassian.com/projects/hibernate">Hibernate JIRA</a> to report errors or request enhacements to this documentation. </p></div></div><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial"/>Chapitre 1. Tutorial</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#tutorial-firstapp">1.1. Partie 1 - Première application Hibernate</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-firstapp-setup">1.1.1. Setup</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-firstclass">1.1.2. La première classe</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-mapping">1.1.3. Le fichier de mapping</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-configuration">1.1.4. Configuration d'Hibernate</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-mvn">1.1.5. Building with Maven</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-helpers">1.1.6. Démarrage et aides</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-workingpersistence">1.1.7. Charger et stocker des objets</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-associations">1.2. Partie 2 - Mapper des associations</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-associations-mappinguser">1.2.1. Mapper la classe Person</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-unidirset">1.2.2. Une association unidirectionnelle basée sur Set</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-working">1.2.3. Travailler avec l'association</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-valuecollections">1.2.4. Collection de valeurs</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-bidirectional">1.2.5. Associations bidirectionnelles</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-usingbidir">1.2.6. Travailler avec des liens bidirectionnels</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-webapp">1.3. Part 3 - L'application web EventManager</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-webapp-servlet">1.3.1. Ecrire la servlet de base</a></span></dt><dt><span class="sect2"><a href="#tutorial-webapp-processing">1.3.2. Procéder et rendre</a></span></dt><dt><span class="sect2"><a href="#tutorial-webapp-deploy">1.3.3. Déployer et tester</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-summary">1.4. Résumé</a></span></dt></dl></div><p>Intended for new users, this chapter provides an step-by-step introduction to Hibernate, starting with a simple application using an in-memory database. The tutorial is based on an earlier tutorial developed by Michael Gloegl. All code is contained in the <code class="filename">tutorials/web</code> directory of the project source. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>This tutorial expects the user have knowledge of both Java and SQL. If you have a limited knowledge of JAVA or SQL, it is advised that you start with a good introduction to that technology prior to attempting to learn Hibernate. </p></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The distribution contains another example application under the <code class="filename">tutorial/eg</code> project source directory. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial-firstapp"/>1.1. Partie 1 - Première application Hibernate</h2></div></div></div><p>For this example, we will set up a small database application that can store events we want to attend and information about the host(s) of these events. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Although you can use whatever database you feel comfortable using, we will use <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://hsqldb.org/">HSQLDB</a> (an in-memory, Java database) to avoid describing installation/setup of any particular database servers. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-setup"/>1.1.1. Setup</h3></div></div></div><p>The first thing we need to do is to set up the development environment. We will be using the "standard layout" advocated by alot of build tools such as <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://maven.org">Maven</a>. Maven, in particular, has a good resource describing this <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html">layout</a>. As this tutorial is to be a web application, we will be creating and making use of <code class="filename">src/main/java</code>, <code class="filename">src/main/resources</code> and <code class="filename">src/main/webapp</code> directories. </p><p>We will be using Maven in this tutorial, taking advantage of its transitive dependency management capabilities as well as the ability of many IDEs to automatically set up a project for us based on the maven descriptor. </p><pre class="programlisting">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;

    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.hibernate.tutorials&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-tutorial&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;First Hibernate Tutorial&lt;/name&gt;

    &lt;build&gt;
         &lt;!-- we dont want the version to be part of the generated war file name --&gt;
         &lt;finalName&gt;${artifactId}&lt;/finalName&gt;
    &lt;/build&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- Because this is a web app, we also have a dependency on the servlet api. --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- Hibernate uses slf4j for logging, for our purposes here use the simple backend --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- Hibernate gives you a choice of bytecode providers between cglib and javassist --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javassist&lt;/groupId&gt;
            &lt;artifactId&gt;javassist&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Astuce</h2><p>It is not a requirement to use Maven. If you wish to use something else to build this tutoial (such as Ant), the layout will remain the same. The only change is that you will need to manually account for all the needed dependencies. If you use something like <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://ant.apache.org/ivy/">Ivy</a> providing transitive dependency management you would still use the dependencies mentioned below. Otherwise, you'd need to grab <span class="emphasis"><em>all</em></span> dependencies, both explicit and transitive, and add them to the project's classpath. If working from the Hibernate distribution bundle, this would mean <code class="filename">hibernate3.jar</code>, all artifacts in the <code class="filename">lib/required</code> directory and all files from either the <code class="filename">lib/bytecode/cglib</code> or <code class="filename">lib/bytecode/javassist</code> directory; additionally you will need both the servlet-api jar and one of the slf4j logging backends. </p></div><p>Save this file as <code class="filename">pom.xml</code> in the project root directory. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-firstclass"/>1.1.2. La première classe</h3></div></div></div><p>Next, we create a class that represents the event we want to store in the database; it is a simple JavaBean class with some properties: </p><pre class="programlisting">package org.hibernate.tutorial.domain;

import java.util.Date;

public class Event {
    private Long id;

    private String title;
    private Date date;

    public Event() {}

    public Long getId() {
        return id;
    }

    private void setId(Long id) {
        this.id = id;
    }

    public Date getDate() {
        return date;
    }

    public void setDate(Date date) {
        this.date = date;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }
}</pre><p>This class uses standard JavaBean naming conventions for property getter and setter methods, as well as private visibility for the fields. Although this is the recommended design, it is not required. Hibernate can also access fields directly, the benefit of accessor methods is robustness for refactoring. </p><p>The <code class="literal">id</code> property holds a unique identifier value for a particular event. All persistent entity classes (there are less important dependent classes as well) will need such an identifier property if we want to use the full feature set of Hibernate. In fact, most applications, especially web applications, need to distinguish objects by identifier, so you should consider this a feature rather than a limitation. However, we usually do not manipulate the identity of an object, hence the setter method should be private. Only Hibernate will assign identifiers when an object is saved. Hibernate can access public, private, and protected accessor methods, as well as public, private and protected fields directly. The choice is up to you and you can match it to fit your application design. </p><p>The no-argument constructor is a requirement for all persistent classes; Hibernate has to create objects for you, using Java Reflection. The constructor can be private, however package or public visibility is required for runtime proxy generation and efficient data retrieval without bytecode instrumentation. </p><p>Save this file to the <code class="filename">src/main/java/org/hibernate/tutorial/domain</code> directory. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-mapping"/>1.1.3. Le fichier de mapping</h3></div></div></div><p>Hibernate a besoin de savoir comment charger et stocker des objets d'une classe persistante. C'est là qu'intervient le fichier de mapping Hibernate. Le fichier de mapping indique à Hibernate à quelle table dans la base de données il doit accéder, et quelles colonnes de cette table il devra utiliser. </p><p>La structure basique de ce fichier de mapping ressemble à ça : </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;
[...]
&lt;/hibernate-mapping&gt;</pre><p>Hibernate DTD is sophisticated. You can use it for auto-completion of XML mapping elements and attributes in your editor or IDE. Opening up the DTD file in your text editor is the easiest way to get an overview of all elements and attributes, and to view the defaults, as well as some comments. Hibernate will not load the DTD file from the web, but first look it up from the classpath of the application. The DTD file is included in <code class="filename">hibernate-core.jar</code> (it is also included in the <code class="filename">hibernate3.jar</code>, if using the distribution bundle). </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>We will omit the DTD declaration in future examples to shorten the code. It is, of course, not optional. </p></div><p>Between the two <code class="literal">hibernate-mapping</code> tags, include a <code class="literal">class</code> element. All persistent entity classes (again, there might be dependent classes later on, which are not first-class entities) need a mapping to a table in the SQL database: </p><pre class="programlisting">&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;

    &lt;class name="Event" table="EVENTS"&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>So far we have told Hibernate how to persist and load object of class <code class="literal">Event</code> to the table <code class="literal">EVENTS</code>. Each instance is now represented by a row in that table. Now we can continue by mapping the unique identifier property to the tables primary key. As we do not want to care about handling this identifier, we configure Hibernate's identifier generation strategy for a surrogate primary key column: </p><pre class="programlisting">&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;

    &lt;class name="Event" table="EVENTS"&gt;
        &lt;id name="id" column="EVENT_ID"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>The <code class="literal">id</code> element is the declaration of the identifier property. The <code class="literal">name="id"</code> mapping attribute declares the name of the JavaBean property and tells Hibernate to use the <code class="literal">getId()</code> and <code class="literal">setId()</code> methods to access the property. The column attribute tells Hibernate which column of the <code class="literal">EVENTS</code> table holds the primary key value. </p><p>The nested <code class="literal">generator</code> element specifies the identifier generation strategy (aka how are identifier values generated?). In this case we choose <code class="literal">native</code>, which offers a level of portability depending on the configured database dialect. Hibernate supports database generated, globally unique, as well as application assigned, identifiers. Identifier value generation is also one of Hibernate's many extension points and you can plugin in your own strategy. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Astuce</h2><p><code class="literal">native</code> is no longer consider the best strategy in terms of portability. for further discussion, see <a href="#portability-idgen" title="25.4. Identifier generation">Section 25.4, « Identifier generation »</a> </p></div><p>Lastly, we need to tell Hibernate about the remaining entity class properties. By default, no properties of the class are considered persistent: </p><pre class="programlisting">
&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;

    &lt;class name="Event" table="EVENTS"&gt;
        &lt;id name="id" column="EVENT_ID"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="date" type="timestamp" column="EVENT_DATE"/&gt;
        &lt;property name="title"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>Similar to the <code class="literal">id</code> element, the <code class="literal">name</code> attribute of the <code class="literal">property</code> element tells Hibernate which getter and setter methods to use. In this case, Hibernate will search for <code class="literal">getDate()</code>, <code class="literal">setDate()</code>, <code class="literal">getTitle()</code> and <code class="literal">setTitle()</code> methods. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Why does the <code class="literal">date</code> property mapping include the <code class="literal">column</code> attribute, but the <code class="literal">title</code> does not? Without the <code class="literal">column</code> attribute, Hibernate by default uses the property name as the column name. This works for <code class="literal">title</code>, however, <code class="literal">date</code> is a reserved keyword in most databases so you will need to map it to a different name. </p></div><p>The <code class="literal">title</code> mapping also lacks a <code class="literal">type</code> attribute. The types declared and used in the mapping files are not Java data types; they are not SQL database types either. These types are called <span class="emphasis"><em>Hibernate mapping types</em></span>, converters which can translate from Java to SQL data types and vice versa. Again, Hibernate will try to determine the correct conversion and mapping type itself if the <code class="literal">type</code> attribute is not present in the mapping. In some cases this automatic detection using Reflection on the Java class might not have the default you expect or need. This is the case with the <code class="literal">date</code> property. Hibernate cannot know if the property, which is of <code class="literal">java.util.Date</code>, should map to a SQL <code class="literal">date</code>, <code class="literal">timestamp</code>, or <code class="literal">time</code> column. Full date and time information is preserved by mapping the property with a <code class="literal">timestamp</code> converter. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Astuce</h2><p>Hibernate makes this mapping type determination using reflection when the mapping files are processed. This can take time and resources, so if startup performance is important you should consider explicitly defining the type to use. </p></div><p>Save this mapping file as <code class="filename">src/main/resources/org/hibernate/tutorial/domain/Event.hbm.xml</code>. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-configuration"/>1.1.4. Configuration d'Hibernate</h3></div></div></div><p>At this point, you should have the persistent class and its mapping file in place. It is now time to configure Hibernate. First let's set up HSQLDB to run in "server mode" </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>We do this do that the data remains between runs. </p></div><p>We will utilize the Maven exec plugin to launch the HSQLDB server by running: <code class="command"> mvn exec:java -Dexec.mainClass="org.hsqldb.Server" -Dexec.args="-database.0 file:target/data/tutorial"</code> You will see it start up and bind to a TCP/IP socket; this is where our application will connect later. If you want to start with a fresh database during this tutorial, shutdown HSQLDB, delete all files in the <code class="filename">target/data</code> directory, and start HSQLDB again. </p><p>Hibernate will be connecting to the database on behalf of your application, so it needs to know how to obtain connections. For this tutorial we will be using a standalone connection pool (as opposed to a <code class="interfacename">javax.sql.DataSource</code>). Hibernate comes with support for two third-party open source JDBC connection pools: <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://sourceforge.net/projects/c3p0">c3p0</a> and <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://proxool.sourceforge.net/">proxool</a>. However, we will be using the Hibernate built-in connection pool for this tutorial. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="caution"><h2>Attention</h2><p>The built-in Hibernate connection pool is in no way intended for production use. It lacks several features found on any decent connection pool. </p></div><p>For Hibernate's configuration, we can use a simple <code class="literal">hibernate.properties</code> file, a more sophisticated <code class="literal">hibernate.cfg.xml</code> file, or even complete programmatic setup. Most users prefer the XML configuration file: </p><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;

&lt;hibernate-configuration&gt;

    &lt;session-factory&gt;

        &lt;!-- Database connection settings --&gt;
        &lt;property name="connection.driver_class"&gt;org.hsqldb.jdbcDriver&lt;/property&gt;
        &lt;property name="connection.url"&gt;jdbc:hsqldb:hsql://localhost&lt;/property&gt;
        &lt;property name="connection.username"&gt;sa&lt;/property&gt;
        &lt;property name="connection.password"&gt;&lt;/property&gt;

        &lt;!-- JDBC connection pool (use the built-in) --&gt;
        &lt;property name="connection.pool_size"&gt;1&lt;/property&gt;

        &lt;!-- SQL dialect --&gt;
        &lt;property name="dialect"&gt;org.hibernate.dialect.HSQLDialect&lt;/property&gt;

        &lt;!-- Enable Hibernate's automatic session context management --&gt;
        &lt;property name="current_session_context_class"&gt;thread&lt;/property&gt;

        &lt;!-- Disable the second-level cache  --&gt;
        &lt;property name="cache.provider_class"&gt;org.hibernate.cache.NoCacheProvider&lt;/property&gt;

        &lt;!-- Echo all executed SQL to stdout --&gt;
        &lt;property name="show_sql"&gt;true&lt;/property&gt;

        &lt;!-- Drop and re-create the database schema on startup --&gt;
        &lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt;

        &lt;mapping resource="org/hibernate/tutorial/domain/Event.hbm.xml"/&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Notice that this configuration file specifies a different DTD</p></div><p>You configure Hibernate's <code class="literal">SessionFactory</code>. SessionFactory is a global factory responsible for a particular database. If you have several databases, for easier startup you should use several <code class="literal">&lt;session-factory&gt;</code> configurations in several configuration files. </p><p>The first four <code class="literal">property</code> elements contain the necessary configuration for the JDBC connection. The dialect <code class="literal">property</code> element specifies the particular SQL variant Hibernate generates. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Astuce</h2><p>In most cases, Hibernate is able to properly determine which dialect to use. See <a href="#portability-dialectresolver" title="25.3. Dialect resolution">Section 25.3, « Dialect resolution »</a> for more information. </p></div><p>Hibernate's automatic session management for persistence contexts is particularly useful in this context. The <code class="literal">hbm2ddl.auto</code> option turns on automatic generation of database schemas directly into the database. This can also be turned off by removing the configuration option, or redirected to a file with the help of the <code class="literal">SchemaExport</code> Ant task. Finally, add the mapping file(s) for persistent classes to the configuration. </p><p>Save this file as <code class="filename">hibernate.cfg.xml</code> into the <code class="filename">src/main/resources</code> directory. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-mvn"/>1.1.5. Building with Maven</h3></div></div></div><p>We will now build the tutorial with Maven. You will need to have Maven installed; it is available from the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://maven.apache.org/download.html">Maven download page</a>. Maven will read the <code class="filename">/pom.xml</code> file we created earlier and know how to perform some basic project tasks. First, lets run the <code class="literal">compile</code> goal to make sure we can compile everything so far: </p><pre class="programlisting">[hibernateTutorial]$ mvn compile
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Building First Hibernate Tutorial
[INFO]    task-segment: [compile]
[INFO] ------------------------------------------------------------------------
[INFO] [resources:resources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:compile]
[INFO] Compiling 1 source file to /home/steve/projects/sandbox/hibernateTutorial/target/classes
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 2 seconds
[INFO] Finished at: Tue Jun 09 12:25:25 CDT 2009
[INFO] Final Memory: 5M/547M
[INFO] ------------------------------------------------------------------------</pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-helpers"/>1.1.6. Démarrage et aides</h3></div></div></div><p>It is time to load and store some <code class="literal">Event</code> objects, but first you have to complete the setup with some infrastructure code. You have to startup Hibernate by building a global <code class="interfacename">org.hibernate.SessionFactory</code> object and storing it somewhere for easy access in application code. A <code class="interfacename">org.hibernate.SessionFactory</code> is used to obtain <code class="interfacename">org.hibernate.Session</code> instances. A <code class="interfacename">org.hibernate.Session</code> represents a single-threaded unit of work. The <code class="interfacename">org.hibernate.SessionFactory</code> is a thread-safe global object that is instantiated once. </p><p>We will create a <code class="literal">HibernateUtil</code> helper class that takes care of startup and makes accessing the <code class="interfacename">org.hibernate.SessionFactory</code> more convenient. </p><pre class="programlisting">package org.hibernate.tutorial.util;

import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;

public class HibernateUtil {

    private static final SessionFactory sessionFactory = buildSessionFactory();

    private static SessionFactory buildSessionFactory() {
        try {
            // Create the SessionFactory from hibernate.cfg.xml
            return new Configuration().configure().buildSessionFactory();
        }
        catch (Throwable ex) {
            // Make sure you log the exception, as it might be swallowed
            System.err.println("Initial SessionFactory creation failed." + ex);
            throw new ExceptionInInitializerError(ex);
        }
    }

    public static SessionFactory getSessionFactory() {
        return sessionFactory;
    }

}</pre><p>Save this code as <code class="filename">src/main/java/org/hibernate/tutorial/util/HibernateUtil.java</code> </p><p>This class not only produces the global <code class="interfacename">org.hibernate.SessionFactory</code> reference in its static initializer; it also hides the fact that it uses a static singleton. We might just as well have looked up the <code class="interfacename">org.hibernate.SessionFactory</code> reference from JNDI in an application server or any other location for that matter. </p><p>If you give the <code class="interfacename">org.hibernate.SessionFactory</code> a name in your configuration, Hibernate will try to bind it to JNDI under that name after it has been built. Another, better option is to use a JMX deployment and let the JMX-capable container instantiate and bind a <code class="literal">HibernateService</code> to JNDI. Such advanced options are discussed later. </p><p>You now need to configure a logging system. Hibernate uses commons logging and provides two choices: Log4j and JDK 1.4 logging. Most developers prefer Log4j: copy <code class="literal">log4j.properties</code> from the Hibernate distribution in the <code class="literal">etc/</code> directory to your <code class="literal">src</code> directory, next to <code class="literal">hibernate.cfg.xml</code>. If you prefer to have more verbose output than that provided in the example configuration, you can change the settings. By default, only the Hibernate startup message is shown on stdout. </p><p>The tutorial infrastructure is complete and you are now ready to do some real work with Hibernate. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-workingpersistence"/>1.1.7. Charger et stocker des objets</h3></div></div></div><p>We are now ready to start doing some real worjk with Hibernate. Let's start by writing an <code class="literal">EventManager</code> class with a <code class="literal">main()</code> method: </p><pre class="programlisting">package org.hibernate.tutorial;

import org.hibernate.Session;

import java.util.*;

import org.hibernate.tutorial.domain.Event;
import org.hibernate.tutorial.util.HibernateUtil;

public class EventManager {

    public static void main(String[] args) {
        EventManager mgr = new EventManager();

        if (args[0].equals("store")) {
            mgr.createAndStoreEvent("My Event", new Date());
        }

        HibernateUtil.getSessionFactory().close();
    }

    private void createAndStoreEvent(String title, Date theDate) {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();

        Event theEvent = new Event();
        theEvent.setTitle(title);
        theEvent.setDate(theDate);
        session.save(theEvent);

        session.getTransaction().commit();
    }

}</pre><p>In <code class="literal">createAndStoreEvent()</code> we created a new <code class="literal">Event</code> object and handed it over to Hibernate. At that point, Hibernate takes care of the SQL and executes an <code class="literal">INSERT</code> on the database. </p><p>A <span class="interface">org.hibernate.Session</span> is designed to represent a single unit of work (a single atmoic piece of work to be performed). For now we will keep things simple and assume a one-to-one granularity between a Hibernate <span class="interface">org.hibernate.Session</span> and a database transaction. To shield our code from the actual underlying transaction system we use the Hibernate <code class="interfacename">org.hibernate.Transaction</code> API. In this particular case we are using JDBC-based transactional semantics, but it could also run with JTA. </p><p>What does <code class="literal">sessionFactory.getCurrentSession()</code> do? First, you can call it as many times and anywhere you like once you get hold of your <code class="interfacename">org.hibernate.SessionFactory</code>. The <code class="literal">getCurrentSession()</code> method always returns the "current" unit of work. Remember that we switched the configuration option for this mechanism to "thread" in our <code class="filename">src/main/resources/hibernate.cfg.xml</code>? Due to that setting, the context of a current unit of work is bound to the current Java thread that executes the application. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>Hibernate offers three methods of current session tracking. The "thread" based method is not intended for production use; it is merely useful for prototyping and tutorials such as this one. Current session tracking is discussed in more detail later on. </p></div><p>A <span class="interface">org.hibernate.Session</span> begins when the first call to <code class="literal">getCurrentSession()</code> is made for the current thread. It is then bound by Hibernate to the current thread. When the transaction ends, either through commit or rollback, Hibernate automatically unbinds the <span class="interface">org.hibernate.Session</span> from the thread and closes it for you. If you call <code class="literal">getCurrentSession()</code> again, you get a new <span class="interface">org.hibernate.Session</span> and can start a new unit of work. </p><p>Related to the unit of work scope, should the Hibernate <span class="interface">org.hibernate.Session</span> be used to execute one or several database operations? The above example uses one <span class="interface">org.hibernate.Session</span> for one operation. However this is pure coincidence; the example is just not complex enough to show any other approach. The scope of a Hibernate <span class="interface">org.hibernate.Session</span> is flexible but you should never design your application to use a new Hibernate <span class="interface">org.hibernate.Session</span> for <span class="emphasis"><em>every</em></span> database operation. Even though it is used in the following examples, consider <span class="emphasis"><em>session-per-operation</em></span> an anti-pattern. A real web application is shown later in the tutorial which will help illustrate this. </p><p>See <a href="#transactions" title="Chapitre 11. Transactions and Concurrency">Chapitre 11, <i xmlns:xlink="http://www.w3.org/1999/xlink">Transactions and Concurrency</i></a> for more information about transaction handling and demarcation. The previous example also skipped any error handling and rollback. </p><p>To run this, we will make use of the Maven exec plugin to call our class with the necessary classpath setup: <code class="command">mvn exec:java -Dexec.mainClass="org.hibernate.tutorial.EventManager" -Dexec.args="store"</code> </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>You may need to perform <code class="command">mvn compile</code> first. </p></div><p>You should see Hibernate starting up and, depending on your configuration, lots of log output. Towards the end, the following line will be displayed: </p><pre class="programlisting">[java] Hibernate: insert into EVENTS (EVENT_DATE, title, EVENT_ID) values (?, ?, ?)</pre><p>This is the <code class="literal">INSERT</code> executed by Hibernate. </p><p>To list stored events an option is added to the main method: </p><pre class="programlisting">        if (args[0].equals("store")) {
            mgr.createAndStoreEvent("My Event", new Date());
        }
        else if (args[0].equals("list")) {
            List events = mgr.listEvents();
            for (int i = 0; i &lt; events.size(); i++) {
                Event theEvent = (Event) events.get(i);
                System.out.println(
                        "Event: " + theEvent.getTitle() + " Time: " + theEvent.getDate()
                );
            }
        }</pre><p>A new <code class="literal">listEvents() method is also added</code>: </p><pre class="programlisting">    private List listEvents() {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();
        List result = session.createQuery("from Event").list();
        session.getTransaction().commit();
        return result;
    }</pre><p>Here, we are using a Hibernate Query Language (HQL) query to load all existing <code class="literal">Event</code> objects from the database. Hibernate will generate the appropriate SQL, send it to the database and populate <code class="literal">Event</code> objects with the data. You can create more complex queries with HQL. See <a href="#queryhql" title="Chapitre 14. HQL: Langage de requêtage d'Hibernate">Chapitre 14, <i xmlns:xlink="http://www.w3.org/1999/xlink">HQL: Langage de requêtage d'Hibernate</i></a> for more information. </p><p>Now we can call our new functionality, again using the Maven exec plugin: <code class="command">mvn exec:java -Dexec.mainClass="org.hibernate.tutorial.EventManager" -Dexec.args="list"</code> </p></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial-associations"/>1.2. Partie 2 - Mapper des associations</h2></div></div></div><p>So far we have mapped a single persistent entity class to a table in isolation. Let's expand on that a bit and add some class associations. We will add people to the application and store a list of events in which they participate. </p><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-mappinguser"/>1.2.1. Mapper la classe Person</h3></div></div></div><p>The first cut of the <code class="literal">Person</code> class looks like this: </p><pre class="programlisting">package org.hibernate.tutorial.domain;

public class Person {

    private Long id;
    private int age;
    private String firstname;
    private String lastname;

    public Person() {}

    // Accessor methods for all properties, private setter for 'id'

}</pre><p>Save this to a file named <code class="filename">src/main/java/org/hibernate/tutorial/domain/Person.java</code> </p><p>Next, create the new mapping file as <code class="filename">src/main/resources/org/hibernate/tutorial/domain/Person.hbm.xml</code> </p><pre class="programlisting">&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;

    &lt;class name="Person" table="PERSON"&gt;
        &lt;id name="id" column="PERSON_ID"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="age"/&gt;
        &lt;property name="firstname"/&gt;
        &lt;property name="lastname"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>Finalement, ajoutez la nouveau mapping à la configuration d'Hibernate : </p><pre class="programlisting">&lt;mapping resource="events/Event.hbm.xml"/&gt;
&lt;mapping resource="events/Person.hbm.xml"/&gt;</pre><p>Create an association between these two entities. Persons can participate in events, and events have participants. The design questions you have to deal with are: directionality, multiplicity, and collection behavior. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-unidirset"/>1.2.2. Une association unidirectionnelle basée sur Set</h3></div></div></div><p>By adding a collection of events to the <code class="literal">Person</code> class, you can easily navigate to the events for a particular person, without executing an explicit query - by calling <code class="literal">Person#getEvents</code>. Multi-valued associations are represented in Hibernate by one of the Java Collection Framework contracts; here we choose a <code class="interfacename">java.util.Set</code> because the collection will not contain duplicate elements and the ordering is not relevant to our examples: </p><pre class="programlisting">public class Person {

    private Set events = new HashSet();

    public Set getEvents() {
        return events;
    }

    public void setEvents(Set events) {
        this.events = events;
    }
}</pre><p>Before mapping this association, let's consider the other side. We could just keep this unidirectional or create another collection on the <code class="literal">Event</code>, if we wanted to be able to navigate it from both directions. This is not necessary, from a functional perspective. You can always execute an explicit query to retrieve the participants for a particular event. This is a design choice left to you, but what is clear from this discussion is the multiplicity of the association: "many" valued on both sides is called a <span class="emphasis"><em>many-to-many</em></span> association. Hence, we use Hibernate's many-to-many mapping: </p><pre class="programlisting">&lt;class name="Person" table="PERSON"&gt;
    &lt;id name="id" column="PERSON_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="age"/&gt;
    &lt;property name="firstname"/&gt;
    &lt;property name="lastname"/&gt;

    &lt;set name="events" table="PERSON_EVENT"&gt;
        &lt;key column="PERSON_ID"/&gt;
        &lt;many-to-many column="EVENT_ID" class="Event"/&gt;
    &lt;/set&gt;

&lt;/class&gt;</pre><p>Hibernate supports a broad range of collection mappings, a <code class="literal">set</code> being most common. For a many-to-many association, or <span class="emphasis"><em>n:m</em></span> entity relationship, an association table is required. Each row in this table represents a link between a person and an event. The table name is decalred using the <code class="literal">table</code> attribute of the <code class="literal">set</code> element. The identifier column name in the association, for the person side, is defined with the <code class="literal">key</code> element, the column name for the event's side with the <code class="literal">column</code> attribute of the <code class="literal">many-to-many</code>. You also have to tell Hibernate the class of the objects in your collection (the class on the other side of the collection of references). </p><p>Le schéma de base de données pour ce mapping est donc : </p><pre class="programlisting">
    _____________        __________________
   |             |      |                  |       _____________
   |   EVENTS    |      |   PERSON_EVENT   |      |             |
   |_____________|      |__________________|      |    PERSON   |
   |             |      |                  |      |_____________|
   | *EVENT_ID   | &lt;--&gt; | *EVENT_ID        |      |             |
   |  EVENT_DATE |      | *PERSON_ID       | &lt;--&gt; | *PERSON_ID  |
   |  TITLE      |      |__________________|      |  AGE        |
   |_____________|                                |  FIRSTNAME  |
                                                  |  LASTNAME   |
                                                  |_____________|
 </pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-working"/>1.2.3. Travailler avec l'association</h3></div></div></div><p>Now we will bring some people and events together in a new method in <code class="literal">EventManager</code>: </p><pre class="programlisting">    private void addPersonToEvent(Long personId, Long eventId) {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();

        Person aPerson = (Person) session.load(Person.class, personId);
        Event anEvent = (Event) session.load(Event.class, eventId);
        aPerson.getEvents().add(anEvent);

        session.getTransaction().commit();
    }</pre><p>After loading a <code class="literal">Person</code> and an <code class="literal">Event</code>, simply modify the collection using the normal collection methods. There is no explicit call to <code class="literal">update()</code> or <code class="literal">save()</code>; Hibernate automatically detects that the collection has been modified and needs to be updated. This is called <span class="emphasis"><em>automatic dirty checking</em></span>. You can also try it by modifying the name or the date property of any of your objects. As long as they are in <span class="emphasis"><em>persistent</em></span> state, that is, bound to a particular Hibernate <code class="interfacename">org.hibernate.Session</code>, Hibernate monitors any changes and executes SQL in a write-behind fashion. The process of synchronizing the memory state with the database, usually only at the end of a unit of work, is called <span class="emphasis"><em>flushing</em></span>. In our code, the unit of work ends with a commit, or rollback, of the database transaction. </p><p>You can load person and event in different units of work. Or you can modify an object outside of a <code class="interfacename">org.hibernate.Session</code>, when it is not in persistent state (if it was persistent before, this state is called <span class="emphasis"><em>detached</em></span>). You can even modify a collection when it is detached: </p><pre class="programlisting">    private void addPersonToEvent(Long personId, Long eventId) {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();

        Person aPerson = (Person) session
                .createQuery("select p from Person p left join fetch p.events where p.id = :pid")
                .setParameter("pid", personId)
                .uniqueResult(); // Eager fetch the collection so we can use it detached
        Event anEvent = (Event) session.load(Event.class, eventId);

        session.getTransaction().commit();

        // End of first unit of work

        aPerson.getEvents().add(anEvent); // aPerson (and its collection) is detached

        // Begin second unit of work

        Session session2 = HibernateUtil.getSessionFactory().getCurrentSession();
        session2.beginTransaction();
        session2.update(aPerson); // Reattachment of aPerson

        session2.getTransaction().commit();
    }</pre><p>The call to <code class="literal">update</code> makes a detached object persistent again by binding it to a new unit of work, so any modifications you made to it while detached can be saved to the database. This includes any modifications (additions/deletions) you made to a collection of that entity object. </p><p>This is not much use in our example, but it is an important concept you can incorporate into your own application. Complete this exercise by adding a new action to the main method of the <code class="literal">EventManager</code> and call it from the command line. If you need the identifiers of a person and an event - the <code class="literal">save()</code> method returns it (you might have to modify some of the previous methods to return that identifier): </p><pre class="programlisting">        else if (args[0].equals("addpersontoevent")) {
            Long eventId = mgr.createAndStoreEvent("My Event", new Date());
            Long personId = mgr.createAndStorePerson("Foo", "Bar");
            mgr.addPersonToEvent(personId, eventId);
            System.out.println("Added person " + personId + " to event " + eventId);
        }</pre><p>This is an example of an association between two equally important classes : two entities. As mentioned earlier, there are other classes and types in a typical model, usually "less important". Some you have already seen, like an <code class="literal">int</code> or a <code class="classname">java.lang.String</code>. We call these classes <span class="emphasis"><em>value types</em></span>, and their instances <span class="emphasis"><em>depend</em></span> on a particular entity. Instances of these types do not have their own identity, nor are they shared between entities. Two persons do not reference the same <code class="literal">firstname</code> object, even if they have the same first name. Value types cannot only be found in the JDK , but you can also write dependent classes yourself such as an <code class="literal">Address</code> or <code class="literal">MonetaryAmount</code> class. In fact, in a Hibernate application all JDK classes are considered value types. </p><p>You can also design a collection of value types. This is conceptually different from a collection of references to other entities, but looks almost the same in Java. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-valuecollections"/>1.2.4. Collection de valeurs</h3></div></div></div><p>Let's add a collection of email addresses to the <code class="literal">Person</code> entity. This will be represented as a <code class="interfacename">java.util.Set</code> of <code class="classname">java.lang.String</code> instances: </p><pre class="programlisting">    private Set emailAddresses = new HashSet();

    public Set getEmailAddresses() {
        return emailAddresses;
    }

    public void setEmailAddresses(Set emailAddresses) {
        this.emailAddresses = emailAddresses;
    }</pre><p>The mapping of this <code class="literal">Set</code> is as follows: </p><pre class="programlisting">        &lt;set name="emailAddresses" table="PERSON_EMAIL_ADDR"&gt;
            &lt;key column="PERSON_ID"/&gt;
            &lt;element type="string" column="EMAIL_ADDR"/&gt;
        &lt;/set&gt;</pre><p>The difference compared with the earlier mapping is the use of the <code class="literal">element</code> part which tells Hibernate that the collection does not contain references to another entity, but is rather a collection whose elements are values types, here specifically of type <code class="literal">string</code>. The lowercase name tells you it is a Hibernate mapping type/converter. Again the <code class="literal">table</code> attribute of the <code class="literal">set</code> element determines the table name for the collection. The <code class="literal">key</code> element defines the foreign-key column name in the collection table. The <code class="literal">column</code> attribute in the <code class="literal">element</code> element defines the column name where the email address values will actually be stored. </p><p>Here is the updated schema: </p><pre class="programlisting">
  _____________        __________________
 |             |      |                  |       _____________
 |   EVENTS    |      |   PERSON_EVENT   |      |             |       ___________________
 |_____________|      |__________________|      |    PERSON   |      |                   |
 |             |      |                  |      |_____________|      | PERSON_EMAIL_ADDR |
 | *EVENT_ID   | &lt;--&gt; | *EVENT_ID        |      |             |      |___________________|
 |  EVENT_DATE |      | *PERSON_ID       | &lt;--&gt; | *PERSON_ID  | &lt;--&gt; |  *PERSON_ID       |
 |  TITLE      |      |__________________|      |  AGE        |      |  *EMAIL_ADDR      |
 |_____________|                                |  FIRSTNAME  |      |___________________|
                                                |  LASTNAME   |
                                                |_____________|
 </pre><p>You can see that the primary key of the collection table is in fact a composite key that uses both columns. This also implies that there cannot be duplicate email addresses per person, which is exactly the semantics we need for a set in Java. </p><p>You can now try to add elements to this collection, just like we did before by linking persons and events. It is the same code in Java: </p><pre class="programlisting">    private void addEmailToPerson(Long personId, String emailAddress) {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();

        Person aPerson = (Person) session.load(Person.class, personId);
        // adding to the emailAddress collection might trigger a lazy load of the collection
        aPerson.getEmailAddresses().add(emailAddress);

        session.getTransaction().commit();
    }</pre><p>This time we did not use a <span class="emphasis"><em>fetch</em></span> query to initialize the collection. Monitor the SQL log and try to optimize this with an eager fetch. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-bidirectional"/>1.2.5. Associations bidirectionnelles</h3></div></div></div><p>Next you will map a bi-directional association. You will make the association between person and event work from both sides in Java. The database schema does not change, so you will still have many-to-many multiplicity. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>A relational database is more flexible than a network programming language, in that it does not need a navigation direction; data can be viewed and retrieved in any possible way. </p></div><p>First, add a collection of participants to the <code class="literal">Event</code> class: </p><pre class="programlisting">    private Set participants = new HashSet();

    public Set getParticipants() {
        return participants;
    }

    public void setParticipants(Set participants) {
        this.participants = participants;
    }</pre><p>Now map this side of the association in <code class="literal">Event.hbm.xml</code>. </p><pre class="programlisting">        &lt;set name="participants" table="PERSON_EVENT" inverse="true"&gt;
            &lt;key column="EVENT_ID"/&gt;
            &lt;many-to-many column="PERSON_ID" class="events.Person"/&gt;
        &lt;/set&gt;</pre><p>These are normal <code class="literal">set</code> mappings in both mapping documents. Notice that the column names in <code class="literal">key</code> and <code class="literal">many-to-many</code> swap in both mapping documents. The most important addition here is the <code class="literal">inverse="true"</code> attribute in the <code class="literal">set</code> element of the <code class="literal">Event</code>'s collection mapping. </p><p>What this means is that Hibernate should take the other side, the <code class="literal">Person</code> class, when it needs to find out information about the link between the two. This will be a lot easier to understand once you see how the bi-directional link between our two entities is created. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-usingbidir"/>1.2.6. Travailler avec des liens bidirectionnels</h3></div></div></div><p>First, keep in mind that Hibernate does not affect normal Java semantics. How did we create a link between a <code class="literal">Person</code> and an <code class="literal">Event</code> in the unidirectional example? You add an instance of <code class="literal">Event</code> to the collection of event references, of an instance of <code class="literal">Person</code>. If you want to make this link bi-directional, you have to do the same on the other side by adding a <code class="literal">Person</code> reference to the collection in an <code class="literal">Event</code>. This process of "setting the link on both sides" is absolutely necessary with bi-directional links. </p><p>Many developers program defensively and create link management methods to correctly set both sides (for example, in <code class="literal">Person</code>): </p><pre class="programlisting">    protected Set getEvents() {
        return events;
    }

    protected void setEvents(Set events) {
        this.events = events;
    }

    public void addToEvent(Event event) {
        this.getEvents().add(event);
        event.getParticipants().add(this);
    }

    public void removeFromEvent(Event event) {
        this.getEvents().remove(event);
        event.getParticipants().remove(this);
    }</pre><p>The get and set methods for the collection are now protected. This allows classes in the same package and subclasses to still access the methods, but prevents everybody else from altering the collections directly. Repeat the steps for the collection on the other side. </p><p>What about the <code class="literal">inverse</code> mapping attribute? For you, and for Java, a bi-directional link is simply a matter of setting the references on both sides correctly. Hibernate, however, does not have enough information to correctly arrange SQL <code class="literal">INSERT</code> and <code class="literal">UPDATE</code> statements (to avoid constraint violations). Making one side of the association <code class="literal">inverse</code> tells Hibernate to consider it a <span class="emphasis"><em>mirror</em></span> of the other side. That is all that is necessary for Hibernate to resolve any issues that arise when transforming a directional navigation model to a SQL database schema. The rules are straightforward: all bi-directional associations need one side as <code class="literal">inverse</code>. In a one-to-many association it has to be the many-side, and in many-to-many association you can select either side. </p></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial-webapp"/>1.3. Part 3 - L'application web EventManager</h2></div></div></div><p>A Hibernate web application uses <code class="literal">Session</code> and <code class="literal">Transaction</code> almost like a standalone application. However, some common patterns are useful. You can now write an <code class="literal">EventManagerServlet</code>. This servlet can list all events stored in the database, and it provides an HTML form to enter new events. </p><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-webapp-servlet"/>1.3.1. Ecrire la servlet de base</h3></div></div></div><p>First we need create our basic processing servlet. Since our servlet only handles HTTP <code class="literal">GET</code> requests, we will only implement the <code class="literal">doGet()</code> method: </p><pre class="programlisting">package org.hibernate.tutorial.web;

// Imports

public class EventManagerServlet extends HttpServlet {

    protected void doGet(
            HttpServletRequest request,
            HttpServletResponse response) throws ServletException, IOException {

        SimpleDateFormat dateFormatter = new SimpleDateFormat( "dd.MM.yyyy" );

        try {
            // Begin unit of work
            HibernateUtil.getSessionFactory().getCurrentSession().beginTransaction();

            // Process request and render page...

            // End unit of work
            HibernateUtil.getSessionFactory().getCurrentSession().getTransaction().commit();
        }
        catch (Exception ex) {
            HibernateUtil.getSessionFactory().getCurrentSession().getTransaction().rollback();
            if ( ServletException.class.isInstance( ex ) ) {
                throw ( ServletException ) ex;
            }
            else {
                throw new ServletException( ex );
            }
        }
    }

}</pre><p>Save this servlet as <code class="filename">src/main/java/org/hibernate/tutorial/web/EventManagerServlet.java</code> </p><p>The pattern applied here is called <span class="emphasis"><em>session-per-request</em></span>. When a request hits the servlet, a new Hibernate <code class="literal">Session</code> is opened through the first call to <code class="literal">getCurrentSession()</code> on the <code class="literal">SessionFactory</code>. A database transaction is then started. All data access occurs inside a transaction irrespective of whether the data is read or written. Do not use the auto-commit mode in applications. </p><p>UNTRANSLATED Do <span class="emphasis"><em>not</em></span> use a new Hibernate <code class="literal">Session</code> for every database operation. Use one Hibernate <code class="literal">Session</code> that is scoped to the whole request. Use <code class="literal">getCurrentSession()</code>, so that it is automatically bound to the current Java thread. </p><p>Next, the possible actions of the request are processed and the response HTML is rendered. We will get to that part soon. </p><p>Finally, the unit of work ends when processing and rendering are complete. If any problems occurred during processing or rendering, an exception will be thrown and the database transaction rolled back. This completes the <code class="literal">session-per-request</code> pattern. Instead of the transaction demarcation code in every servlet, you could also write a servlet filter. See the Hibernate website and Wiki for more information about this pattern called <span class="emphasis"><em>Open Session in View</em></span>. You will need it as soon as you consider rendering your view in JSP, not in a servlet. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-webapp-processing"/>1.3.2. Procéder et rendre</h3></div></div></div><p>Now you can implement the processing of the request and the rendering of the page. </p><pre class="programlisting">        // Write HTML header
        PrintWriter out = response.getWriter();
        out.println("&lt;html&gt;&lt;head&gt;&lt;title&gt;Event Manager&lt;/title&gt;&lt;/head&gt;&lt;body&gt;");

        // Handle actions
        if ( "store".equals(request.getParameter("action")) ) {

            String eventTitle = request.getParameter("eventTitle");
            String eventDate = request.getParameter("eventDate");

            if ( "".equals(eventTitle) || "".equals(eventDate) ) {
                out.println("&lt;b&gt;&lt;i&gt;Please enter event title and date.&lt;/i&gt;&lt;/b&gt;");
            }
            else {
                createAndStoreEvent(eventTitle, dateFormatter.parse(eventDate));
                out.println("&lt;b&gt;&lt;i&gt;Added event.&lt;/i&gt;&lt;/b&gt;");
            }
        }

        // Print page
       printEventForm(out);
       listEvents(out, dateFormatter);

       // Write HTML footer
       out.println("&lt;/body&gt;&lt;/html&gt;");
       out.flush();
       out.close();</pre><p>This coding style, with a mix of Java and HTML, would not scale in a more complex application-keep in mind that we are only illustrating basic Hibernate concepts in this tutorial. The code prints an HTML header and a footer. Inside this page, an HTML form for event entry and a list of all events in the database are printed. The first method is trivial and only outputs HTML: </p><pre class="programlisting">    private void printEventForm(PrintWriter out) {
        out.println("&lt;h2&gt;Add new event:&lt;/h2&gt;");
        out.println("&lt;form&gt;");
        out.println("Title: &lt;input name='eventTitle' length='50'/&gt;&lt;br/&gt;");
        out.println("Date (e.g. 24.12.2009): &lt;input name='eventDate' length='10'/&gt;&lt;br/&gt;");
        out.println("&lt;input type='submit' name='action' value='store'/&gt;");
        out.println("&lt;/form&gt;");
    }</pre><p>La méthode <code class="literal">listEvents()</code> utilise la <code class="literal">Session</code> Hibernate liée au thread courant pour exécuter la requête: </p><pre class="programlisting">    private void listEvents(PrintWriter out, SimpleDateFormat dateFormatter) {

        List result = HibernateUtil.getSessionFactory()
                .getCurrentSession().createCriteria(Event.class).list();
        if (result.size() &gt; 0) {
            out.println("&lt;h2&gt;Events in database:&lt;/h2&gt;");
            out.println("&lt;table border='1'&gt;");
            out.println("&lt;tr&gt;");
            out.println("&lt;th&gt;Event title&lt;/th&gt;");
            out.println("&lt;th&gt;Event date&lt;/th&gt;");
            out.println("&lt;/tr&gt;");
            Iterator it = result.iterator();
            while (it.hasNext()) {
                Event event = (Event) it.next();
                out.println("&lt;tr&gt;");
                out.println("&lt;td&gt;" + event.getTitle() + "&lt;/td&gt;");
                out.println("&lt;td&gt;" + dateFormatter.format(event.getDate()) + "&lt;/td&gt;");
                out.println("&lt;/tr&gt;");
            }
            out.println("&lt;/table&gt;");
        }
    }</pre><p>FEnfin, l'action <code class="literal">store</code> renvoie à la méthode <code class="literal">createAndStoreEvent()</code>, qui utilise aussi la <code class="literal">Session</code> du thread courant: </p><pre class="programlisting">    protected void createAndStoreEvent(String title, Date theDate) {
        Event theEvent = new Event();
        theEvent.setTitle(title);
        theEvent.setDate(theDate);

        HibernateUtil.getSessionFactory()
                .getCurrentSession().save(theEvent);
    }</pre><p>The servlet is now complete. A request to the servlet will be processed in a single <code class="literal">Session</code> and <code class="literal">Transaction</code>. As earlier in the standalone application, Hibernate can automatically bind these objects to the current thread of execution. This gives you the freedom to layer your code and access the <code class="literal">SessionFactory</code> in any way you like. Usually you would use a more sophisticated design and move the data access code into data access objects (the DAO pattern). See the Hibernate Wiki for more examples. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-webapp-deploy"/>1.3.3. Déployer et tester</h3></div></div></div><p>To deploy this application for testing we must create a Web ARchive (WAR). First we must define the WAR descriptor as <code class="filename">src/main/webapp/WEB-INF/web.xml</code> </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="2.4"
    xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;Event Manager&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.hibernate.tutorial.web.EventManagerServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Event Manager&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/eventmanager&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre><p>To build and deploy call <code class="literal">mvn package</code> in your project directory and copy the <code class="filename">hibernate-tutorial.war</code> file into your Tomcat <code class="filename">webapps</code> directory. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>If you do not have Tomcat installed, download it from <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://tomcat.apache.org/">http://tomcat.apache.org/</a> and follow the installation instructions. Our application requires no changes to the standard Tomcat configuration. </p></div><p>Une fois l'application déployée et Tomcat lancé, accédez à l'application via <code class="literal">http://localhost:8080/hibernate-tutorial/eventmanager</code>. Assurez vous de consulter les traces tomcat pour observer l'initialisation d'Hibernate à la première requête touchant votre servlet (l'initialisation statique dans <code class="literal">HibernateUtil</code> est invoquée) et pour vérifier qu'aucune exception ne survienne. </p></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial-summary"/>1.4. Résumé</h2></div></div></div><p>This tutorial covered the basics of writing a simple standalone Hibernate application and a small web application. More tutorials are available from the Hibernate <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://hibernate.org">website</a>. </p></div></div><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture"/>Chapitre 2. Architecture</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#architecture-overview">2.1. Généralités</a></span></dt><dt><span class="sect1"><a href="#architecture-states">2.2. Etats des instances</a></span></dt><dt><span class="sect1"><a href="#architecture-jmx">2.3. Intégration JMX</a></span></dt><dt><span class="sect1"><a href="#architecture-jca">2.4. Support JCA</a></span></dt><dt><span class="sect1"><a href="#architecture-current-session">2.5. Contextual sessions</a></span></dt></dl></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-overview"/>2.1. Généralités</h2></div></div></div><p>The diagram below provides a high-level view of the Hibernate architecture: </p><div class="mediaobject" align="center"><img src="../images/overview.png" align="middle"/></div><p>We do not have the scope in this document to provide a more detailed view of all the runtime architectures available; Hibernate is flexible and supports several different approaches. We will, however, show the two extremes: "minimal" architecture and "comprehensive" architecture. </p><p>This next diagram illustrates how Hibernate utilizes database and configuration data to provide persistence services, and persistent objects, to the application. </p><p>The "minimal" architecture has the application provide its own JDBC connections and manage its own transactions. This approach uses a minimal subset of Hibernate's APIs: </p><div class="mediaobject" align="center"><img src="../images/lite.png" align="middle"/></div><p>The "comprehensive" architecture abstracts the application away from the underlying JDBC/JTA APIs and allows Hibernate to manage the details. </p><div class="mediaobject" align="center"><img src="../images/full_cream.png" align="middle"/></div><p>Here are some definitions of the objects depicted in the diagrams: </p><div class="variablelist"><dl><dt><span class="term">SessionFactory (<code class="literal">org.hibernate.SessionFactory</code>)</span></dt><dd><p>A threadsafe, immutable cache of compiled mappings for a single database. A factory for <code class="literal">Session</code> and a client of <code class="literal">ConnectionProvider</code>, <code class="literal">SessionFactory</code> can hold an optional (second-level) cache of data that is reusable between transactions at a process, or cluster, level. </p></dd><dt><span class="term">Session (<code class="literal">org.hibernate.Session</code>)</span></dt><dd><p>A single-threaded, short-lived object representing a conversation between the application and the persistent store. It wraps a JDBC connection and is a factory for <code class="literal">Transaction</code>. <code class="literal">Session</code> holds a mandatory first-level cache of persistent objects that are used when navigating the object graph or looking up objects by identifier. </p></dd><dt><span class="term">Objets et Collections persistants</span></dt><dd><p>Short-lived, single threaded objects containing persistent state and business function. These can be ordinary JavaBeans/POJOs. They are associated with exactly one <code class="literal">Session</code>. Once the <code class="literal">Session</code> is closed, they will be detached and free to use in any application layer (for example, directly as data transfer objects to and from presentation). </p></dd><dt><span class="term">Objets et collections transients</span></dt><dd><p>Instances of persistent classes that are not currently associated with a <code class="literal">Session</code>. They may have been instantiated by the application and not yet persisted, or they may have been instantiated by a closed <code class="literal">Session</code>. </p></dd><dt><span class="term">Transaction (<code class="literal">org.hibernate.Transaction</code>)</span></dt><dd><p>(Optional) A single-threaded, short-lived object used by the application to specify atomic units of work. It abstracts the application from the underlying JDBC, JTA or CORBA transaction. A <code class="literal">Session</code> might span several <code class="literal">Transaction</code>s in some cases. However, transaction demarcation, either using the underlying API or <code class="literal">Transaction</code>, is never optional. </p></dd><dt><span class="term">ConnectionProvider (<code class="literal">org.hibernate.connection.ConnectionProvider</code>)</span></dt><dd><p>(Optional) A factory for, and pool of, JDBC connections. It abstracts the application from underlying <code class="literal">Datasource</code> or <code class="literal">DriverManager</code>. It is not exposed to application, but it can be extended and/or implemented by the developer. </p></dd><dt><span class="term">TransactionFactory (<code class="literal">org.hibernate.TransactionFactory</code>)</span></dt><dd><p>(Optional) A factory for <code class="literal">Transaction</code> instances. It is not exposed to the application, but it can be extended and/or implemented by the developer. </p></dd><dt><span class="term"><span class="emphasis"><em>Interfaces d'extension</em></span></span></dt><dd><p>Hibernate offers a range of optional extension interfaces you can implement to customize the behavior of your persistence layer. See the API documentation for details. </p></dd></dl></div><p>
        </p><p>Given a "minimal" architecture, the application bypasses the <code class="literal">Transaction</code>/<code class="literal">TransactionFactory</code> and/or <code class="literal">ConnectionProvider</code> APIs to communicate with JTA or JDBC directly. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-states"/>2.2. Etats des instances</h2></div></div></div><p>An instance of a persistent class can be in one of three different states. These states are defined in relation to a <span class="emphasis"><em>persistence context</em></span>. The Hibernate <code class="literal">Session</code> object is the persistence context. The three different states are as follows: </p><div class="variablelist"><dl><dt><span class="term">passager (transient)</span></dt><dd><p>The instance is not associated with any persistence context. It has no persistent identity or primary key value. </p></dd><dt><span class="term">persistant</span></dt><dd><p>The instance is currently associated with a persistence context. It has a persistent identity (primary key value) and can have a corresponding row in the database. For a particular persistence context, Hibernate <span class="emphasis"><em>guarantees</em></span> that persistent identity is equivalent to Java identity in relation to the in-memory location of the object. </p></dd><dt><span class="term">détaché</span></dt><dd><p>The instance was once associated with a persistence context, but that context was closed, or the instance was serialized to another process. It has a persistent identity and can have a corresponding row in the database. For detached instances, Hibernate does not guarantee the relationship between persistent identity and Java identity. </p></dd></dl></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-jmx"/>2.3. Intégration JMX</h2></div></div></div><p>JMX is the J2EE standard for the management of Java components. Hibernate can be managed via a JMX standard service. AN MBean implementation is provided in the distribution: <code class="literal">org.hibernate.jmx.HibernateService</code>. </p><p>For an example of how to deploy Hibernate as a JMX service on the JBoss Application Server, please see the JBoss User Guide. JBoss AS also provides these benefits if you deploy using JMX: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Session Management</em></span>: the Hibernate <code class="literal">Session</code>'s life cycle can be automatically bound to the scope of a JTA transaction. This means that you no longer have to manually open and close the <code class="literal">Session</code>; this becomes the job of a JBoss EJB interceptor. You also do not have to worry about transaction demarcation in your code (if you would like to write a portable persistence layer use the optional Hibernate <code class="literal">Transaction</code> API for this). You call the <code class="literal">HibernateContext</code> to access a <code class="literal">Session</code>. </p></li><li><p><span class="emphasis"><em>HAR deployment</em></span>: the Hibernate JMX service is deployed using a JBoss service deployment descriptor in an EAR and/or SAR file, as it supports all the usual configuration options of a Hibernate <code class="literal">SessionFactory</code>. However, you still need to name all your mapping files in the deployment descriptor. If you use the optional HAR deployment, JBoss will automatically detect all mapping files in your HAR file. </p></li></ul></div><p>Consultez le guide d'utilisation de JBoss AS pour plus d'informations sur ces options. </p><p>Another feature available as a JMX service is runtime Hibernate statistics. See <a href="#configuration-optional-statistics" title="3.4.6. Statistiques Hibernate">Section 3.4.6, « Statistiques Hibernate »</a> for more information. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-jca"/>2.4. Support JCA</h2></div></div></div><p>Hibernate can also be configured as a JCA connector. Please see the website for more information. Please note, however, that at this stage Hibernate JCA support is under development. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-current-session"/>2.5. Contextual sessions</h2></div></div></div><p>Most applications using Hibernate need some form of "contextual" session, where a given session is in effect throughout the scope of a given context. However, across applications the definition of what constitutes a context is typically different; different contexts define different scopes to the notion of current. Applications using Hibernate prior to version 3.0 tended to utilize either home-grown <code class="literal">ThreadLocal</code>-based contextual sessions, helper classes such as <code class="literal">HibernateUtil</code>, or utilized third-party frameworks, such as Spring or Pico, which provided proxy/interception-based contextual sessions. </p><p>Starting with version 3.0.1, Hibernate added the <code class="literal">SessionFactory.getCurrentSession()</code> method. Initially, this assumed usage of <code class="literal">JTA</code> transactions, where the <code class="literal">JTA</code> transaction defined both the scope and context of a current session. Given the maturity of the numerous stand-alone <code class="literal">JTA TransactionManager</code> implementations, most, if not all, applications should be using <code class="literal">JTA</code> transaction management, whether or not they are deployed into a <code class="literal">J2EE</code> container. Based on that, the <code class="literal">JTA</code>-based contextual sessions are all you need to use. </p><p>However, as of version 3.1, the processing behind <code class="literal">SessionFactory.getCurrentSession()</code> is now pluggable. To that end, a new extension interface, <code class="literal">org.hibernate.context.CurrentSessionContext</code>, and a new configuration parameter, <code class="literal">hibernate.current_session_context_class</code>, have been added to allow pluggability of the scope and context of defining current sessions. </p><p>See the Javadocs for the <code class="literal">org.hibernate.context.CurrentSessionContext</code> interface for a detailed discussion of its contract. It defines a single method, <code class="literal">currentSession()</code>, by which the implementation is responsible for tracking the current contextual session. Out-of-the-box, Hibernate comes with three implementations of this interface: </p><div class="itemizedlist"><ul><li><p><code class="literal">org.hibernate.context.JTASessionContext</code>: current sessions are tracked and scoped by a <code class="literal">JTA</code> transaction. The processing here is exactly the same as in the older JTA-only approach. See the Javadocs for details. </p></li><li><p><code class="literal">org.hibernate.context.ThreadLocalSessionContext</code>:current sessions are tracked by thread of execution. See the Javadocs for details. </p></li><li><p><code class="literal">org.hibernate.context.ManagedSessionContext</code>: current sessions are tracked by thread of execution. However, you are responsible to bind and unbind a <code class="literal">Session</code> instance with static methods on this class: it does not open, flush, or close a <code class="literal">Session</code>. </p></li></ul></div><p>The first two implementations provide a "one session - one database transaction" programming model. This is also also known and used as <span class="emphasis"><em>session-per-request</em></span>. The beginning and end of a Hibernate session is defined by the duration of a database transaction. If you use programmatic transaction demarcation in plain JSE without JTA, you are advised to use the Hibernate <code class="literal">Transaction</code> API to hide the underlying transaction system from your code. If you use JTA, you can utilize the JTA interfaces to demarcate transactions. If you execute in an EJB container that supports CMT, transaction boundaries are defined declaratively and you do not need any transaction or session demarcation operations in your code. Refer to <a href="#transactions" title="Chapitre 11. Transactions and Concurrency">Chapitre 11, <i xmlns:xlink="http://www.w3.org/1999/xlink">Transactions and Concurrency</i></a> for more information and code examples. </p><p>The <code class="literal">hibernate.current_session_context_class</code> configuration parameter defines which <code class="literal">org.hibernate.context.CurrentSessionContext</code> implementation should be used. For backwards compatibility, if this configuration parameter is not set but a <code class="literal">org.hibernate.transaction.TransactionManagerLookup</code> is configured, Hibernate will use the <code class="literal">org.hibernate.context.JTASessionContext</code>. Typically, the value of this parameter would just name the implementation class to use. For the three out-of-the-box implementations, however, there are three corresponding short names: "jta", "thread", and "managed". </p></div></div><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="session-configuration"/>Chapitre 3. Configuration</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#configuration-programmatic">3.1. Configuration par programmation</a></span></dt><dt><span class="sect1"><a href="#configuration-sessionfactory">3.2. Obtenir une SessionFactory</a></span></dt><dt><span class="sect1"><a href="#configuration-hibernatejdbc">3.3. Connexions JDBC</a></span></dt><dt><span class="sect1"><a href="#configuration-optional">3.4. Propriétés de configuration optionnelles</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuration-optional-dialects">3.4.1. Dialectes SQL</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-outerjoin">3.4.2. Chargement par Jointure Ouverte</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-binarystreams">3.4.3. Flux binaires</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-cacheprovider">3.4.4. Cache de second niveau et cache de requêtes</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-querysubstitution">3.4.5. Substitution dans le langage de requêtage</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-statistics">3.4.6. Statistiques Hibernate</a></span></dt></dl></dd><dt><span class="sect1"><a href="#configuration-logging">3.5. Tracer</a></span></dt><dt><span class="sect1"><a href="#configuration-namingstrategy">3.6. Implémenter une <code class="literal">NamingStrategy</code></a></span></dt><dt><span class="sect1"><a href="#configuration-xmlconfig">3.7. Fichier de configuration XML</a></span></dt><dt><span class="sect1"><a href="#configuration-j2ee">3.8. Intégration à un serveur d'application J2EE</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuration-optional-transactionstrategy">3.8.1. Configuration de la stratégie transactionnelle</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-jndi">3.8.2. <code class="literal">SessionFactory</code> associée au JNDI</a></span></dt><dt><span class="sect2"><a href="#configuration-j2ee-currentsession">3.8.3. Association automatique de la Session à JTA</a></span></dt><dt><span class="sect2"><a href="#configuration-j2ee-jmx">3.8.4. Déploiement JMX</a></span></dt></dl></dd></dl></div><p>Hibernate is designed to operate in many different environments and, as such, there is a broad range of configuration parameters. Fortunately, most have sensible default values and Hibernate is distributed with an example <code class="literal">hibernate.properties</code> file in <code class="literal">etc/</code> that displays the various options. Simply put the example file in your classpath and customize it to suit your needs. </p><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-programmatic"/>3.1. Configuration par programmation</h2></div></div></div><p>An instance of <code class="classname">org.hibernate.cfg.Configuration</code> represents an entire set of mappings of an application's Java types to an SQL database. The <code class="classname">org.hibernate.cfg.Configuration</code> is used to build an immutable <code class="interfacename">org.hibernate.SessionFactory</code>. The mappings are compiled from various XML mapping files. </p><p>You can obtain a <code class="classname">org.hibernate.cfg.Configuration</code> instance by instantiating it directly and specifying XML mapping documents. If the mapping files are in the classpath, use <code class="literal">addResource()</code>. For example: </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addResource("Item.hbm.xml")
    .addResource("Bid.hbm.xml");</pre><p>An alternative way is to specify the mapped class and allow Hibernate to find the mapping document for you: </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class);</pre><p>Hibernate will then search for mapping files named <code class="filename">/org/hibernate/auction/Item.hbm.xml</code> and <code class="filename">/org/hibernate/auction/Bid.hbm.xml</code> in the classpath. This approach eliminates any hardcoded filenames. </p><p>A <code class="classname">org.hibernate.cfg.Configuration</code> also allows you to specify configuration properties. For example: </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class)
    .setProperty("hibernate.dialect", "org.hibernate.dialect.MySQLInnoDBDialect")
    .setProperty("hibernate.connection.datasource", "java:comp/env/jdbc/test")
    .setProperty("hibernate.order_updates", "true");</pre><p>This is not the only way to pass configuration properties to Hibernate. Some alternative options include: </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>Pass an instance of <code class="classname">java.util.Properties</code> to <code class="literal">Configuration.setProperties()</code>. </p></li><li><p>Place a file named <code class="filename">hibernate.properties</code> in a root directory of the classpath. </p></li><li><p>Positionner les propriétés <code class="literal">System</code> en utilisant <code class="literal">java -Dproperty=value</code>. </p></li><li><p>Include <code class="literal">&lt;property&gt;</code> elements in <code class="literal">hibernate.cfg.xml</code> (this is discussed later). </p></li></ol></div><p>If you want to get started quickly<code class="filename">hibernate.properties</code> is the easiest approach. </p><p>The <code class="classname">org.hibernate.cfg.Configuration</code> is intended as a startup-time object that will be discarded once a <code class="literal">SessionFactory</code> is created. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-sessionfactory"/>3.2. Obtenir une SessionFactory</h2></div></div></div><p>When all mappings have been parsed by the <code class="classname">org.hibernate.cfg.Configuration</code>, the application must obtain a factory for <code class="interfacename">org.hibernate.Session</code> instances. This factory is intended to be shared by all application threads: </p><pre class="programlisting">SessionFactory sessions = cfg.buildSessionFactory();</pre><p>Hibernate does allow your application to instantiate more than one <code class="interfacename">org.hibernate.SessionFactory</code>. This is useful if you are using more than one database. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-hibernatejdbc"/>3.3. Connexions JDBC</h2></div></div></div><p>It is advisable to have the <code class="interfacename">org.hibernate.SessionFactory</code> create and pool JDBC connections for you. If you take this approach, opening a <code class="interfacename">org.hibernate.Session</code> is as simple as: </p><pre class="programlisting">Session session = sessions.openSession(); // open a new Session</pre><p>Once you start a task that requires access to the database, a JDBC connection will be obtained from the pool. </p><p>Before you can do this, you first need to pass some JDBC connection properties to Hibernate. All Hibernate property names and semantics are defined on the class <code class="classname">org.hibernate.cfg.Environment</code>. The most important settings for JDBC connection configuration are outlined below. </p><p>Hibernate will obtain and pool connections using <code class="classname">java.sql.DriverManager</code> if you set the following properties: </p><div class="table"><a id="d0e1781"/><p class="title"><b>Tableau 3.1. Propriétés JDBC d'Hibernate</b></p><div class="table-contents"><table summary="Propriétés JDBC d'Hibernate" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td>
                    <span class="property">hibernate.connection.driver_class</span>
                </td><td>
                    <span class="emphasis"><em>Classe du driver jdbc</em></span>
                </td></tr><tr><td>
                    <span class="property">hibernate.connection.url</span>
                </td><td>
                    <span class="emphasis"><em>URL jdbc</em></span>
                </td></tr><tr><td>
                    <span class="property">hibernate.connection.username</span>
                </td><td>
                    <span class="emphasis"><em>utilisateur de la base de données</em></span>
                </td></tr><tr><td>
                    <span class="property">hibernate.connection.password</span>
                </td><td>
                    <span class="emphasis"><em>mot de passe de la base de données</em></span>
                </td></tr><tr><td>
                    <span class="property">hibernate.connection.pool_size</span>
                </td><td>
                    <span class="emphasis"><em>nombre maximum de connexions dans le pool</em></span>
                </td></tr></tbody></table></div></div><br class="table-break"/><p>Hibernate's own connection pooling algorithm is, however, quite rudimentary. It is intended to help you get started and is <span class="emphasis"><em>not intended for use in a production system</em></span>, or even for performance testing. You should use a third party pool for best performance and stability. Just replace the <span class="property">hibernate.connection.pool_size</span> property with connection pool specific settings. This will turn off Hibernate's internal pool. For example, you might like to use c3p0. </p><p>C3P0 is an open source JDBC connection pool distributed along with Hibernate in the <code class="filename">lib</code> directory. Hibernate will use its <code class="classname">org.hibernate.connection.C3P0ConnectionProvider</code> for connection pooling if you set <span class="property">hibernate.c3p0.*</span> properties. If you would like to use Proxool, refer to the packaged <code class="filename">hibernate.properties</code> and the Hibernate web site for more information. </p><p>The following is an example <code class="filename">hibernate.properties</code> file for c3p0: </p><a id="c3p0-configuration"/><pre class="programlisting">hibernate.connection.driver_class = org.postgresql.Driver
hibernate.connection.url = jdbc:postgresql://localhost/mydatabase
hibernate.connection.username = myuser
hibernate.connection.password = secret
hibernate.c3p0.min_size=5
hibernate.c3p0.max_size=20
hibernate.c3p0.timeout=1800
hibernate.c3p0.max_statements=50
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect</pre><p>For use inside an application server, you should almost always configure Hibernate to obtain connections from an application server <code class="interfacename">javax.sql.Datasource</code> registered in JNDI. You will need to set at least one of the following properties: </p><div class="table"><a id="d0e1883"/><p class="title"><b>Tableau 3.2. Propriété d'une Datasource Hibernate</b></p><div class="table-contents"><table summary="Propriété d'une Datasource Hibernate" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td>
                    <span class="property">hibernate.connection.datasource</span>
                </td><td>
                    <span class="emphasis"><em>Nom JNDI de la datasource</em></span>
                </td></tr><tr><td>
                    <span class="property">hibernate.jndi.url</span>
                </td><td><span class="emphasis"><em>URL of the JNDI provider</em></span> (optional) </td></tr><tr><td>
                    <span class="property">hibernate.jndi.class</span>
                </td><td><span class="emphasis"><em>class of the JNDI <code class="literal">InitialContextFactory</code></em></span> (optional) </td></tr><tr><td>
                    <span class="property">hibernate.connection.username</span>
                </td><td><span class="emphasis"><em>database user</em></span> (optional) </td></tr><tr><td>
                    <span class="property">hibernate.connection.password</span>
                </td><td><span class="emphasis"><em>database user password</em></span> (optional) </td></tr></tbody></table></div></div><br class="table-break"/><p>Here is an example <code class="filename">hibernate.properties</code> file for an application server provided JNDI datasource: </p><pre class="programlisting">hibernate.connection.datasource = java:/comp/env/jdbc/test
hibernate.transaction.factory_class = \
    org.hibernate.transaction.JTATransactionFactory
hibernate.transaction.manager_lookup_class = \
    org.hibernate.transaction.JBossTransactionManagerLookup
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect</pre><p>Les connexions JDBC obtenues à partir d'une datasource JNDI participeront automatiquement aux transactions gérées par le conteneur du serveur d'applications. </p><p>Arbitrary connection properties can be given by prepending "<code class="literal">hibernate.connection</code>" to the connection property name. For example, you can specify a <span class="property">charSet</span> connection property using <span class="property">hibernate.connection.charSet</span>. </p><p>You can define your own plugin strategy for obtaining JDBC connections by implementing the interface <code class="interfacename">org.hibernate.connection.ConnectionProvider</code>, and specifying your custom implementation via the <span class="property">hibernate.connection.provider_class</span> property. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-optional"/>3.4. Propriétés de configuration optionnelles</h2></div></div></div><p>There are a number of other properties that control the behavior of Hibernate at runtime. All are optional and have reasonable default values. </p><p>
        	</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Avertissement</h2><span class="emphasis"><em>Some of these properties are "system-level" only.</em></span> System-level properties can be set only via <code class="literal">java -Dproperty=value</code> or <code class="filename">hibernate.properties</code>. They <span class="emphasis"><em>cannot</em></span> be set by the other techniques described above.</div><p>
        </p><div class="table"><a id="configuration-optional-properties"/><p class="title"><b>Tableau 3.3. Propriétés de configuration d'Hibernate</b></p><div class="table-contents"><table summary="Propriétés de configuration d'Hibernate" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td>
                            <span class="property">hibernate.dialect</span>
                        </td><td>The classname of a Hibernate <code class="classname">org.hibernate.dialect.Dialect</code> which allows Hibernate to generate SQL optimized for a particular relational database. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">full.classname.of.Dialect</code> </p>
                            <p>In most cases Hibernate will actually be able to choose the correct <code class="classname">org.hibernate.dialect.Dialect</code> implementation based on the <code class="literal">JDBC metadata</code> returned by the JDBC driver. </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.show_sql</span>
                        </td><td>Write all SQL statements to console. This is an alternative to setting the log category <code class="literal">org.hibernate.SQL</code> to <code class="literal">debug</code>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.format_sql</span>
                        </td><td>Pretty print the SQL in the log and console. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.default_schema</span>
                        </td><td>Qualify unqualified table names with the given schema/tablespace in generated SQL. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">SCHEMA_NAME</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.default_catalog</span>
                        </td><td>Qualifies unqualified table names with the given catalog in generated SQL. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">CATALOG_NAME</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.session_factory_name</span>
                        </td><td>The <code class="interfacename">org.hibernate.SessionFactory</code> will be automatically bound to this name in JNDI after it has been created. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">jndi/composite/name</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.max_fetch_depth</span>
                        </td><td>Sets a maximum "depth" for the outer join fetch tree for single-ended associations (one-to-one, many-to-one). A <code class="literal">0</code> disables default outer join fetching. <p><span class="strong"><strong>e.g.</strong></span> recommended values between <code class="literal">0</code> and <code class="literal">3</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.default_batch_fetch_size</span>
                        </td><td>Sets a default size for Hibernate batch fetching of associations. <p><span class="strong"><strong>e.g.</strong></span> recommended values <code class="literal">4</code>, <code class="literal">8</code>, <code class="literal">16</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.default_entity_mode</span>
                        </td><td>Sets a default mode for entity representation for all sessions opened from this <code class="literal">SessionFactory</code> <p><code class="literal">dynamic-map</code>, <code class="literal">dom4j</code>, <code class="literal">pojo</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.order_updates</span>
                        </td><td>Forces Hibernate to order SQL updates by the primary key value of the items being updated. This will result in fewer transaction deadlocks in highly concurrent systems. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.generate_statistics</span>
                        </td><td>If enabled, Hibernate will collect statistics useful for performance tuning. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.use_identifer_rollback</span>
                        </td><td>If enabled, generated identifier properties will be reset to default values when objects are deleted. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.use_sql_comments</span>
                        </td><td>If turned on, Hibernate will generate comments inside the SQL, for easier debugging, defaults to <code class="literal">false</code>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="configuration-jdbc-properties"/><p class="title"><b>Tableau 3.4. Propriétés Hibernate liées à JDBC et aux connexions</b></p><div class="table-contents"><table summary="Propriétés Hibernate liées à JDBC et aux connexions" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td>
                            <span class="property">hibernate.jdbc.fetch_size</span>
                        </td><td>A non-zero value determines the JDBC fetch size (calls <code class="literal">Statement.setFetchSize()</code>). </td></tr><tr><td>
                            <span class="property">hibernate.jdbc.batch_size</span>
                        </td><td>A non-zero value enables use of JDBC2 batch updates by Hibernate. <p><span class="strong"><strong>e.g.</strong></span> recommended values between <code class="literal">5</code> and <code class="literal">30</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.jdbc.batch_versioned_data</span>
                        </td><td>Set this property to <code class="literal">true</code> if your JDBC driver returns correct row counts from <code class="literal">executeBatch()</code>. Iit is usually safe to turn this option on. Hibernate will then use batched DML for automatically versioned data. Defaults to <code class="literal">false</code>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.jdbc.factory_class</span>
                        </td><td>Select a custom <code class="interfacename">org.hibernate.jdbc.Batcher</code>. Most applications will not need this configuration property. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">classname.of.BatcherFactory</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.jdbc.use_scrollable_resultset</span>
                        </td><td>Enables use of JDBC2 scrollable resultsets by Hibernate. This property is only necessary when using user-supplied JDBC connections. Hibernate uses connection metadata otherwise. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.jdbc.use_streams_for_binary</span>
                        </td><td>Use streams when writing/reading <code class="literal">binary</code> or <code class="literal">serializable</code> types to/from JDBC. <span class="emphasis"><em>*system-level property*</em></span> <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.jdbc.use_get_generated_keys</span>
                        </td><td>Enables use of JDBC3 <code class="literal">PreparedStatement.getGeneratedKeys()</code> to retrieve natively generated keys after insert. Requires JDBC3+ driver and JRE1.4+, set to false if your driver has problems with the Hibernate identifier generators. By default, it tries to determine the driver capabilities using connection metadata. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true|false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.connection.provider_class</span>
                        </td><td>The classname of a custom <code class="interfacename">org.hibernate.connection.ConnectionProvider</code> which provides JDBC connections to Hibernate. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">classname.of.ConnectionProvider</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.connection.isolation</span>
                        </td><td>Sets the JDBC transaction isolation level. Check <code class="interfacename">java.sql.Connection</code> for meaningful values, but note that most databases do not support all isolation levels and some define additional, non-standard isolations. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">1, 2, 4, 8</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.connection.autocommit</span>
                        </td><td>Enables autocommit for JDBC pooled connections (it is not recommended). <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.connection.release_mode</span>
                        </td><td>Specifies when Hibernate should release JDBC connections. By default, a JDBC connection is held until the session is explicitly closed or disconnected. For an application server JTA datasource, use <code class="literal">after_statement</code> to aggressively release connections after every JDBC call. For a non-JTA connection, it often makes sense to release the connection at the end of each transaction, by using <code class="literal">after_transaction</code>. <code class="literal">auto</code> will choose <code class="literal">after_statement</code> for the JTA and CMT transaction strategies and <code class="literal">after_transaction</code> for the JDBC transaction strategy. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">auto</code> (default) | <code class="literal">on_close</code> | <code class="literal">after_transaction</code> | <code class="literal">after_statement</code> </p>
                            <p>This setting only affects <code class="literal">Session</code>s returned from <code class="literal">SessionFactory.openSession</code>. For <code class="literal">Session</code>s obtained through <code class="literal">SessionFactory.getCurrentSession</code>, the <code class="literal">CurrentSessionContext</code> implementation configured for use controls the connection release mode for those <code class="literal">Session</code>s. See <a href="#architecture-current-session" title="2.5. Contextual sessions">Section 2.5, « Contextual sessions »</a> </p>
                        </td></tr><tr><td><span class="property">hibernate.connection.</span><span class="emphasis"><em>&lt;propertyName&gt;</em></span> </td><td>Pass the JDBC property <span class="emphasis"><em>&lt;propertyName&gt;</em></span> to <code class="literal">DriverManager.getConnection()</code>. </td></tr><tr><td><span class="property">hibernate.jndi.</span><span class="emphasis"><em>&lt;propertyName&gt;</em></span> </td><td>Pass the property <span class="emphasis"><em>&lt;propertyName&gt;</em></span> to the JNDI <code class="literal">InitialContextFactory</code>. </td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="configuration-cache-properties"/><p class="title"><b>Tableau 3.5. Propriétés du Cache d'Hibernate</b></p><div class="table-contents"><table summary="Propriétés du Cache d'Hibernate" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td>
                            <code class="literal">hibernate.cache.provider_class</code>
                        </td><td>The classname of a custom <code class="literal">CacheProvider</code>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">classname.of.CacheProvider</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cache.use_minimal_puts</code>
                        </td><td>Optimizes second-level cache operation to minimize writes, at the cost of more frequent reads. This setting is most useful for clustered caches and, in Hibernate3, is enabled by default for clustered cache implementations. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true|false</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cache.use_query_cache</code>
                        </td><td>Enables the query cache. Individual queries still have to be set cachable. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true|false</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cache.use_second_level_cache</code>
                        </td><td>Can be used to completely disable the second level cache, which is enabled by default for classes which specify a <code class="literal">&lt;cache&gt;</code> mapping. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true|false</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cache.query_cache_factory</code>
                        </td><td>The classname of a custom <code class="literal">QueryCache</code> interface, defaults to the built-in <code class="literal">StandardQueryCache</code>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">classname.of.QueryCache</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cache.region_prefix</code>
                        </td><td>A prefix to use for second-level cache region names. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">prefix</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cache.use_structured_entries</code>
                        </td><td>Forces Hibernate to store data in the second-level cache in a more human-friendly format. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true|false</code> </p>
                        </td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="configuration-transaction-properties"/><p class="title"><b>Tableau 3.6. Propriétés des transactions Hibernate</b></p><div class="table-contents"><table summary="Propriétés des transactions Hibernate" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td>
                            <code class="literal">hibernate.transaction.factory_class</code>
                        </td><td>The classname of a <code class="literal">TransactionFactory</code> to use with Hibernate <code class="literal">Transaction</code> API (defaults to <code class="literal">JDBCTransactionFactory</code>). <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">classname.of.TransactionFactory</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">jta.UserTransaction</code>
                        </td><td>A JNDI name used by <code class="literal">JTATransactionFactory</code> to obtain the JTA <code class="literal">UserTransaction</code> from the application server. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">jndi/composite/name</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.transaction.manager_lookup_class</code>
                        </td><td>The classname of a <code class="literal">TransactionManagerLookup</code>. It is required when JVM-level caching is enabled or when using hilo generator in a JTA environment. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">classname.of.TransactionManagerLookup</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.transaction.flush_before_completion</code>
                        </td><td>If enabled, the session will be automatically flushed during the before completion phase of the transaction. Built-in and automatic session context management is preferred, see <a href="#architecture-current-session" title="2.5. Contextual sessions">Section 2.5, « Contextual sessions »</a>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.transaction.auto_close_session</code>
                        </td><td>If enabled, the session will be automatically closed during the after completion phase of the transaction. Built-in and automatic session context management is preferred, see <a href="#architecture-current-session" title="2.5. Contextual sessions">Section 2.5, « Contextual sessions »</a>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="configuration-misc-properties"/><p class="title"><b>Tableau 3.7. Propriétés diverses</b></p><div class="table-contents"><table summary="Propriétés diverses" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Property name</th><th>Purpose</th></tr></thead><tbody><tr><td>
                            <code class="literal">hibernate.current_session_context_class</code>
                        </td><td>Supply a custom strategy for the scoping of the "current" <code class="literal">Session</code>. See <a href="#architecture-current-session" title="2.5. Contextual sessions">Section 2.5, « Contextual sessions »</a> for more information about the built-in strategies. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">jta</code> | <code class="literal">thread</code> | <code class="literal">managed</code> | <code class="literal">custom.Class</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.query.factory_class</code>
                        </td><td>Chooses the HQL parser implementation. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">org.hibernate.hql.ast.ASTQueryTranslatorFactory</code> or <code class="literal">org.hibernate.hql.classic.ClassicQueryTranslatorFactory</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.query.substitutions</code>
                        </td><td>Is used to map from tokens in Hibernate queries to SQL tokens (tokens might be function or literal names, for example). <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.hbm2ddl.auto</code>
                        </td><td>Automatically validates or exports schema DDL to the database when the <code class="literal">SessionFactory</code> is created. With <code class="literal">create-drop</code>, the database schema will be dropped when the <code class="literal">SessionFactory</code> is closed explicitly. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">validate</code> | <code class="literal">update</code> | <code class="literal">create</code> | <code class="literal">create-drop</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cglib.use_reflection_optimizer</code>
                        </td><td>Enables the use of CGLIB instead of runtime reflection (System-level property). Reflection can sometimes be useful when troubleshooting. Hibernate always requires CGLIB even if you turn off the optimizer. You cannot set this property in <code class="literal">hibernate.cfg.xml</code>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr></tbody></table></div></div><br class="table-break"/><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-dialects"/>3.4.1. Dialectes SQL</h3></div></div></div><p>Always set the <code class="literal">hibernate.dialect</code> property to the correct <code class="literal">org.hibernate.dialect.Dialect</code> subclass for your database. If you specify a dialect, Hibernate will use sensible defaults for some of the other properties listed above. This means that you will not have to specify them manually. </p><div class="table"><a id="sql-dialects"/><p class="title"><b>Tableau 3.8. Dialectes SQL d'Hibernate (<code class="literal">hibernate.dialect</code>)</b></p><div class="table-contents"><table summary="Dialectes SQL d'Hibernate (hibernate.dialect)" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>SGBD</th><th>Dialect</th></tr></thead><tbody><tr><td>DB2</td><td><code class="literal">org.hibernate.dialect.DB2Dialect</code></td></tr><tr><td>DB2 AS/400</td><td><code class="literal">org.hibernate.dialect.DB2400Dialect</code></td></tr><tr><td>DB2 OS390</td><td><code class="literal">org.hibernate.dialect.DB2390Dialect</code></td></tr><tr><td>PostgreSQL</td><td><code class="literal">org.hibernate.dialect.PostgreSQLDialect</code></td></tr><tr><td>MySQL</td><td><code class="literal">org.hibernate.dialect.MySQLDialect</code></td></tr><tr><td>MySQL with InnoDB</td><td><code class="literal">org.hibernate.dialect.MySQLInnoDBDialect</code></td></tr><tr><td>MySQL with MyISAM</td><td><code class="literal">org.hibernate.dialect.MySQLMyISAMDialect</code></td></tr><tr><td>Oracle (any version)</td><td><code class="literal">org.hibernate.dialect.OracleDialect</code></td></tr><tr><td>Oracle 9i</td><td><code class="literal">org.hibernate.dialect.Oracle9iDialect</code></td></tr><tr><td>Oracle 10g</td><td><code class="literal">org.hibernate.dialect.Oracle10gDialect</code></td></tr><tr><td>Sybase</td><td><code class="literal">org.hibernate.dialect.SybaseDialect</code></td></tr><tr><td>Sybase Anywhere</td><td><code class="literal">org.hibernate.dialect.SybaseAnywhereDialect</code></td></tr><tr><td>Microsoft SQL Server</td><td><code class="literal">org.hibernate.dialect.SQLServerDialect</code></td></tr><tr><td>SAP DB</td><td><code class="literal">org.hibernate.dialect.SAPDBDialect</code></td></tr><tr><td>Informix</td><td><code class="literal">org.hibernate.dialect.InformixDialect</code></td></tr><tr><td>HypersonicSQL</td><td><code class="literal">org.hibernate.dialect.HSQLDialect</code></td></tr><tr><td>Ingres</td><td><code class="literal">org.hibernate.dialect.IngresDialect</code></td></tr><tr><td>Progress</td><td><code class="literal">org.hibernate.dialect.ProgressDialect</code></td></tr><tr><td>Mckoi SQL</td><td><code class="literal">org.hibernate.dialect.MckoiDialect</code></td></tr><tr><td>Interbase</td><td><code class="literal">org.hibernate.dialect.InterbaseDialect</code></td></tr><tr><td>Pointbase</td><td><code class="literal">org.hibernate.dialect.PointbaseDialect</code></td></tr><tr><td>FrontBase</td><td><code class="literal">org.hibernate.dialect.FrontbaseDialect</code></td></tr><tr><td>Firebird</td><td><code class="literal">org.hibernate.dialect.FirebirdDialect</code></td></tr></tbody></table></div></div><br class="table-break"/></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-outerjoin"/>3.4.2. Chargement par Jointure Ouverte</h3></div></div></div><p>If your database supports ANSI, Oracle or Sybase style outer joins, <span class="emphasis"><em>outer join fetching</em></span> will often increase performance by limiting the number of round trips to and from the database. This is, however, at the cost of possibly more work performed by the database itself. Outer join fetching allows a whole graph of objects connected by many-to-one, one-to-many, many-to-many and one-to-one associations to be retrieved in a single SQL <code class="literal">SELECT</code>. </p><p>Outer join fetching can be disabled <span class="emphasis"><em>globally</em></span> by setting the property <code class="literal">hibernate.max_fetch_depth</code> to <code class="literal">0</code>. A setting of <code class="literal">1</code> or higher enables outer join fetching for one-to-one and many-to-one associations that have been mapped with <code class="literal">fetch="join"</code>. </p><p>Reportez vous à <a href="#performance-fetching" title="19.1. Stratégies de chargement">Section 19.1, « Stratégies de chargement »</a> pour plus d'information. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-binarystreams"/>3.4.3. Flux binaires</h3></div></div></div><p>Oracle limits the size of <code class="literal">byte</code> arrays that can be passed to and/or from its JDBC driver. If you wish to use large instances of <code class="literal">binary</code> or <code class="literal">serializable</code> type, you should enable <code class="literal">hibernate.jdbc.use_streams_for_binary</code>. <span class="emphasis"><em>This is a system-level setting only.</em></span> </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-cacheprovider"/>3.4.4. Cache de second niveau et cache de requêtes</h3></div></div></div><p>The properties prefixed by <code class="literal">hibernate.cache</code> allow you to use a process or cluster scoped second-level cache system with Hibernate. See the <a href="#performance-cache" title="19.2. Le cache de second niveau">Section 19.2, « Le cache de second niveau »</a> for more information. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-querysubstitution"/>3.4.5. Substitution dans le langage de requêtage</h3></div></div></div><p>You can define new Hibernate query tokens using <code class="literal">hibernate.query.substitutions</code>. For example: </p><pre class="programlisting">hibernate.query.substitutions vrai=1, faux=0</pre><p>This would cause the tokens <code class="literal">true</code> and <code class="literal">false</code> to be translated to integer literals in the generated SQL. </p><pre class="programlisting">hibernate.query.substitutions toLowercase=LOWER</pre><p>This would allow you to rename the SQL <code class="literal">LOWER</code> function. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-statistics"/>3.4.6. Statistiques Hibernate</h3></div></div></div><p>If you enable <code class="literal">hibernate.generate_statistics</code>, Hibernate exposes a number of metrics that are useful when tuning a running system via <code class="literal">SessionFactory.getStatistics()</code>. Hibernate can even be configured to expose these statistics via JMX. Read the Javadoc of the interfaces in <code class="literal">org.hibernate.stats</code> for more information. </p></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-logging"/>3.5. Tracer</h2></div></div></div><p>Hibernate utilizes <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.slf4j.org/">Simple Logging Facade for Java</a> (SLF4J) in order to log various system events. SLF4J can direct your logging output to several logging frameworks (NOP, Simple, log4j version 1.2, JDK 1.4 logging, JCL or logback) depending on your chosen binding. In order to setup logging you will need <code class="filename">slf4j-api.jar</code> in your classpath together with the jar file for your preferred binding - <code class="filename">slf4j-log4j12.jar</code> in the case of Log4J. See the SLF4J <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.slf4j.org/manual.html">documentation</a> for more detail. To use Log4j you will also need to place a <code class="filename">log4j.properties</code> file in your classpath. An example properties file is distributed with Hibernate in the <code class="literal">src/</code> directory. </p><p>It is recommended that you familiarize yourself with Hibernate's log messages. A lot of work has been put into making the Hibernate log as detailed as possible, without making it unreadable. It is an essential troubleshooting device. The most interesting log categories are the following: </p><div class="table"><a id="log-categories"/><p class="title"><b>Tableau 3.9. Catégories de trace d'Hibernate</b></p><div class="table-contents"><table summary="Catégories de trace d'Hibernate" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Catégorie</th><th>Fonction</th></tr></thead><tbody><tr><td><code class="literal">org.hibernate.SQL</code></td><td>Trace toutes les requêts SQL de type DML (gestion des données) qui sont exécutées</td></tr><tr><td><code class="literal">org.hibernate.type</code></td><td>Trace tous les paramètres JDBC</td></tr><tr><td><code class="literal">org.hibernate.tool.hbm2ddl</code></td><td>Trace toutes les requêts SQL de type DDL (gestion de la structure de la base) qui sont exécutées</td></tr><tr><td><code class="literal">org.hibernate.pretty</code></td><td>Trace l'état de toutes les entités (20 entités maximum) qui sont associées avec la session hibernate au moment du flush </td></tr><tr><td><code class="literal">org.hibernate.cache</code></td><td>Trace toute l'activité du cache de second niveau</td></tr><tr><td><code class="literal">org.hibernate.transaction</code></td><td>Trace toute l'activité relative aux transactions</td></tr><tr><td><code class="literal">org.hibernate.jdbc</code></td><td>Trace toute acquisition de ressource JDBC</td></tr><tr><td><code class="literal">org.hibernate.hql.ast.AST</code></td><td>Trace l'arbre syntaxique des requêtes HQL et SQL durant l'analyse syntaxique des requêtes </td></tr><tr><td><code class="literal">org.hibernate.secure</code></td><td>Trace toutes les demandes d'autorisation JAAS</td></tr><tr><td><code class="literal">org.hibernate</code></td><td>Log everything. This is a lot of information but it is useful for troubleshooting </td></tr></tbody></table></div></div><br class="table-break"/><p>Lorsque vous développez des applications avec Hibernate, vous devriez quasiment toujours travailler avec le niveau <code class="literal">debug</code> activé pour la catégorie <code class="literal">org.hibernate.SQL</code>, ou sinon avec la propriété <code class="literal">hibernate.show_sql</code> activée. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-namingstrategy"/>3.6. Implémenter une <code class="literal">NamingStrategy</code></h2></div></div></div><p>L'interface <code class="literal">org.hibernate.cfg.NamingStrategy</code> vous permet de spécifier une "stratégie de nommage" des objets et éléments de la base de données. </p><p>You can provide rules for automatically generating database identifiers from Java identifiers or for processing "logical" column and table names given in the mapping file into "physical" table and column names. This feature helps reduce the verbosity of the mapping document, eliminating repetitive noise (<code class="literal">TBL_</code> prefixes, for example). The default strategy used by Hibernate is quite minimal. </p><p>You can specify a different strategy by calling <code class="literal">Configuration.setNamingStrategy()</code> before adding mappings: </p><pre class="programlisting">SessionFactory sf = new Configuration()
    .setNamingStrategy(ImprovedNamingStrategy.INSTANCE)
    .addFile("Item.hbm.xml")
    .addFile("Bid.hbm.xml")
    .buildSessionFactory();</pre><p><code class="literal">net.sf.hibernate.cfg.ImprovedNamingStrategy</code> est une stratégie fournie qui peut être utile comme point de départ de quelques applications. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-xmlconfig"/>3.7. Fichier de configuration XML</h2></div></div></div><p>Une approche alternative est de spécifier toute la configuration dans un fichier nommé <code class="literal">hibernate.cfg.xml</code>. Ce fichier peut être utilisé à la place du fichier <code class="literal">hibernate.properties</code>, voire même peut servir à surcharger les propriétés si les deux fichiers sont présents. </p><p>The XML configuration file is by default expected to be in the root of your <code class="literal">CLASSPATH</code>. Here is an example: </p><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
    "-//Hibernate/Hibernate Configuration DTD//EN"
    "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;

&lt;hibernate-configuration&gt;

    &lt;!-- a SessionFactory instance listed as /jndi/name --&gt;
    &lt;session-factory
        name="java:hibernate/SessionFactory"&gt;

        &lt;!-- properties --&gt;
        &lt;property name="connection.datasource"&gt;java:/comp/env/jdbc/MyDB&lt;/property&gt;
        &lt;property name="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;
        &lt;property name="show_sql"&gt;false&lt;/property&gt;
        &lt;property name="transaction.factory_class"&gt;
            org.hibernate.transaction.JTATransactionFactory
        &lt;/property&gt;
        &lt;property name="jta.UserTransaction"&gt;java:comp/UserTransaction&lt;/property&gt;

        &lt;!-- mapping files --&gt;
        &lt;mapping resource="org/hibernate/auction/Item.hbm.xml"/&gt;
        &lt;mapping resource="org/hibernate/auction/Bid.hbm.xml"/&gt;

        &lt;!-- cache settings --&gt;
        &lt;class-cache class="org.hibernate.auction.Item" usage="read-write"/&gt;
        &lt;class-cache class="org.hibernate.auction.Bid" usage="read-only"/&gt;
        &lt;collection-cache collection="org.hibernate.auction.Item.bids" usage="read-write"/&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre><p>The advantage of this approach is the externalization of the mapping file names to configuration. The <code class="literal">hibernate.cfg.xml</code> is also more convenient once you have to tune the Hibernate cache. It is your choice to use either <code class="literal">hibernate.properties</code> or <code class="literal">hibernate.cfg.xml</code>. Both are equivalent, except for the above mentioned benefits of using the XML syntax. </p><p>With the XML configuration, starting Hibernate is then as simple as: </p><pre class="programlisting">SessionFactory sf = new Configuration().configure().buildSessionFactory();</pre><p>You can select a different XML configuration file using: </p><pre class="programlisting">SessionFactory sf = new Configuration()
    .configure("catdb.cfg.xml")
    .buildSessionFactory();</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-j2ee"/>3.8. Intégration à un serveur d'application J2EE</h2></div></div></div><p>Hibernate possède les points suivants d'intégration à l'infrastructure J2EE : </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Container-managed datasources</em></span>: Hibernate can use JDBC connections managed by the container and provided through JNDI. Usually, a JTA compatible <code class="literal">TransactionManager</code> and a <code class="literal">ResourceManager</code> take care of transaction management (CMT), especially distributed transaction handling across several datasources. You can also demarcate transaction boundaries programmatically (BMT), or you might want to use the optional Hibernate <code class="literal">Transaction</code> API for this to keep your code portable. </p></li></ul></div><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Association JNDI automatique</em></span>: Hibernate peut associer sa <code class="literal">SessionFactory</code> à JNDI après le démarrage. </p></li></ul></div><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>JTA Session binding:</em></span> the Hibernate <code class="literal">Session</code> can be automatically bound to the scope of JTA transactions. Simply lookup the <code class="literal">SessionFactory</code> from JNDI and get the current <code class="literal">Session</code>. Let Hibernate manage flushing and closing the <code class="literal">Session</code> when your JTA transaction completes. Transaction demarcation is either declarative (CMT) or programmatic (BMT/UserTransaction). </p></li></ul></div><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>JMX deployment:</em></span> if you have a JMX capable application server (e.g. JBoss AS), you can choose to deploy Hibernate as a managed MBean. This saves you the one line startup code to build your <code class="literal">SessionFactory</code> from a <code class="literal">Configuration</code>. The container will startup your <code class="literal">HibernateService</code> and also take care of service dependencies (datasource has to be available before Hibernate starts, etc). </p></li></ul></div><p>En fonction de votre environnement, vous devrez peut être mettre l'option de configuration <code class="literal">hibernate.connection.aggressive_release</code> à vrai si le serveur d'application affiche des exceptions de type "connection containment". </p><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-transactionstrategy"/>3.8.1. Configuration de la stratégie transactionnelle</h3></div></div></div><p>The Hibernate <code class="literal">Session</code> API is independent of any transaction demarcation system in your architecture. If you let Hibernate use JDBC directly through a connection pool, you can begin and end your transactions by calling the JDBC API. If you run in a J2EE application server, you might want to use bean-managed transactions and call the JTA API and <code class="literal">UserTransaction</code> when needed. </p><p>Pour conserver votre code portable entre ces deux environnements (et d'autres éventuels) nous vous recommandons d'utiliser l'API optionnelle <code class="literal">Transaction</code> d'Hibernate, qui va encapsuler et masquer le système de transaction sous-jacent. Pour cela, vous devez préciser une classe de fabrique d'instances de <code class="literal">Transaction</code> en positionnant la propriété <code class="literal">hibernate.transaction.factory_class</code>. </p><p>There are three standard, or built-in, choices: </p><div class="variablelist"><dl><dt><span class="term"><code class="literal">net.sf.hibernate.transaction.JDBCTransactionFactory</code></span></dt><dd><p>délègue aux transactions de la base de données (JDBC). Valeur par défaut.</p></dd><dt><span class="term"><code class="literal">org.hibernate.transaction.JTATransactionFactory</code></span></dt><dd><p>delegates to container-managed transactions if an existing transaction is underway in this context (for example, EJB session bean method). Otherwise, a new transaction is started and bean-managed transactions are used. </p></dd><dt><span class="term"><code class="literal">org.hibernate.transaction.CMTTransactionFactory</code></span></dt><dd><p>délègue à aux transactions JTA gérées par le conteneur</p></dd></dl></div><p>You can also define your own transaction strategies (for a CORBA transaction service, for example). </p><p>Some features in Hibernate (i.e., the second level cache, Contextual Sessions with JTA, etc.) require access to the JTA <code class="literal">TransactionManager</code> in a managed environment. In an application server, since J2EE does not standardize a single mechanism, you have to specify how Hibernate should obtain a reference to the <code class="literal">TransactionManager</code>: </p><div class="table"><a id="jtamanagerlookup"/><p class="title"><b>Tableau 3.10. TransactionManagers JTA</b></p><div class="table-contents"><table summary="TransactionManagers JTA" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Fabrique de Transaction</th><th align="center">Serveur d'application</th></tr></thead><tbody><tr><td><code class="literal">org.hibernate.transaction.JBossTransactionManagerLookup</code></td><td align="center">JBoss</td></tr><tr><td><code class="literal">org.hibernate.transaction.WeblogicTransactionManagerLookup</code></td><td align="center">Weblogic</td></tr><tr><td><code class="literal">org.hibernate.transaction.WebSphereTransactionManagerLookup</code></td><td align="center">WebSphere</td></tr><tr><td><code class="literal">org.hibernate.transaction.WebSphereExtendedJTATransactionLookup</code></td><td align="center">WebSphere 6</td></tr><tr><td><code class="literal">org.hibernate.transaction.OrionTransactionManagerLookup</code></td><td align="center">Orion</td></tr><tr><td><code class="literal">org.hibernate.transaction.ResinTransactionManagerLookup</code></td><td align="center">Resin</td></tr><tr><td><code class="literal">org.hibernate.transaction.JOTMTransactionManagerLookup</code></td><td align="center">JOTM</td></tr><tr><td><code class="literal">org.hibernate.transaction.JOnASTransactionManagerLookup</code></td><td align="center">JOnAS</td></tr><tr><td><code class="literal">org.hibernate.transaction.JRun4TransactionManagerLookup</code></td><td align="center">JRun4</td></tr><tr><td><code class="literal">org.hibernate.transaction.BESTransactionManagerLookup</code></td><td align="center">Borland ES</td></tr></tbody></table></div></div><br class="table-break"/></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-jndi"/>3.8.2. <code class="literal">SessionFactory</code> associée au JNDI</h3></div></div></div><p>A JNDI-bound Hibernate <code class="literal">SessionFactory</code> can simplify the lookup function of the factory and create new <code class="literal">Session</code>s. This is not, however, related to a JNDI bound <code class="literal">Datasource</code>; both simply use the same registry. </p><p>If you wish to have the <code class="literal">SessionFactory</code> bound to a JNDI namespace, specify a name (e.g. <code class="literal">java:hibernate/SessionFactory</code>) using the property <code class="literal">hibernate.session_factory_name</code>. If this property is omitted, the <code class="literal">SessionFactory</code> will not be bound to JNDI. This is especially useful in environments with a read-only JNDI default implementation (in Tomcat, for example). </p><p>Lorsqu'il associe la <code class="literal">SessionFactory</code> au JNDI, Hibernate utilisera les valeurs de <code class="literal">hibernate.jndi.url</code>, <code class="literal">hibernate.jndi.class</code> pour instancier un contexte d'initialisation. S'ils ne sont pas spécifiés, l'<code class="literal">InitialContext</code> par défaut sera utilisé. </p><p>Hibernate will automatically place the <code class="literal">SessionFactory</code> in JNDI after you call <code class="literal">cfg.buildSessionFactory()</code>. This means you will have this call in some startup code, or utility class in your application, unless you use JMX deployment with the <code class="literal">HibernateService</code> (this is discussed later in greater detail). </p><p>If you use a JNDI <code class="literal">SessionFactory</code>, an EJB or any other class, you can obtain the <code class="literal">SessionFactory</code> using a JNDI lookup. </p><p>It is recommended that you bind the <code class="literal">SessionFactory</code> to JNDI in a managed environment and use a <code class="literal">static</code> singleton otherwise. To shield your application code from these details, we also recommend to hide the actual lookup code for a <code class="literal">SessionFactory</code> in a helper class, such as <code class="literal">HibernateUtil.getSessionFactory()</code>. Note that such a class is also a convenient way to startup Hibernatesee chapter 1. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-j2ee-currentsession"/>3.8.3. Association automatique de la Session à JTA</h3></div></div></div><p>The easiest way to handle <code class="literal">Sessions</code> and transactions is Hibernate's automatic "current" <code class="literal">Session</code> management. For a discussion of contextual sessions see <a href="#architecture-current-session" title="2.5. Contextual sessions">Section 2.5, « Contextual sessions »</a>. Using the <code class="literal">"jta"</code> session context, if there is no Hibernate <code class="literal">Session</code> associated with the current JTA transaction, one will be started and associated with that JTA transaction the first time you call <code class="literal">sessionFactory.getCurrentSession()</code>. The <code class="literal">Session</code>s retrieved via <code class="literal">getCurrentSession()</code> in the<code class="literal">"jta"</code> context are set to automatically flush before the transaction completes, close after the transaction completes, and aggressively release JDBC connections after each statement. This allows the <code class="literal">Session</code>s to be managed by the life cycle of the JTA transaction to which it is associated, keeping user code clean of such management concerns. Your code can either use JTA programmatically through <code class="literal">UserTransaction</code>, or (recommended for portable code) use the Hibernate <code class="literal">Transaction</code> API to set transaction boundaries. If you run in an EJB container, declarative transaction demarcation with CMT is preferred. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-j2ee-jmx"/>3.8.4. Déploiement JMX</h3></div></div></div><p>The line <code class="literal">cfg.buildSessionFactory()</code> still has to be executed somewhere to get a <code class="literal">SessionFactory</code> into JNDI. You can do this either in a <code class="literal">static</code> initializer block, like the one in <code class="literal">HibernateUtil</code>, or you can deploy Hibernate as a <span class="emphasis"><em>managed service</em></span>. </p><p>Hibernate is distributed with <code class="literal">org.hibernate.jmx.HibernateService</code> for deployment on an application server with JMX capabilities, such as JBoss AS. The actual deployment and configuration is vendor-specific. Here is an example <code class="literal">jboss-service.xml</code> for JBoss 4.0.x: </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;server&gt;

&lt;mbean code="org.hibernate.jmx.HibernateService"
    name="jboss.jca:service=HibernateFactory,name=HibernateFactory"&gt;

    &lt;!-- Required services --&gt;
    &lt;depends&gt;jboss.jca:service=RARDeployer&lt;/depends&gt;
    &lt;depends&gt;jboss.jca:service=LocalTxCM,name=HsqlDS&lt;/depends&gt;

    &lt;!-- Bind the Hibernate service to JNDI --&gt;
    &lt;attribute name="JndiName"&gt;java:/hibernate/SessionFactory&lt;/attribute&gt;

    &lt;!-- Datasource settings --&gt;
    &lt;attribute name="Datasource"&gt;java:HsqlDS&lt;/attribute&gt;
    &lt;attribute name="Dialect"&gt;org.hibernate.dialect.HSQLDialect&lt;/attribute&gt;

    &lt;!-- Transaction integration --&gt;
    &lt;attribute name="TransactionStrategy"&gt;
        org.hibernate.transaction.JTATransactionFactory&lt;/attribute&gt;
    &lt;attribute name="TransactionManagerLookupStrategy"&gt;
        org.hibernate.transaction.JBossTransactionManagerLookup&lt;/attribute&gt;
    &lt;attribute name="FlushBeforeCompletionEnabled"&gt;true&lt;/attribute&gt;
    &lt;attribute name="AutoCloseSessionEnabled"&gt;true&lt;/attribute&gt;

    &lt;!-- Fetching options --&gt;
    &lt;attribute name="MaximumFetchDepth"&gt;5&lt;/attribute&gt;

    &lt;!-- Second-level caching --&gt;
    &lt;attribute name="SecondLevelCacheEnabled"&gt;true&lt;/attribute&gt;
    &lt;attribute name="CacheProviderClass"&gt;org.hibernate.cache.EhCacheProvider&lt;/attribute&gt;
    &lt;attribute name="QueryCacheEnabled"&gt;true&lt;/attribute&gt;

    &lt;!-- Logging --&gt;
    &lt;attribute name="ShowSqlEnabled"&gt;true&lt;/attribute&gt;

    &lt;!-- Mapping files --&gt;
    &lt;attribute name="MapResources"&gt;auction/Item.hbm.xml,auction/Category.hbm.xml&lt;/attribute&gt;

&lt;/mbean&gt;

&lt;/server&gt;</pre><p>This file is deployed in a directory called <code class="literal">META-INF</code> and packaged in a JAR file with the extension <code class="literal">.sar</code> (service archive). You also need to package Hibernate, its required third-party libraries, your compiled persistent classes, as well as your mapping files in the same archive. Your enterprise beans (usually session beans) can be kept in their own JAR file, but you can include this EJB JAR file in the main service archive to get a single (hot-)deployable unit. Consult the JBoss AS documentation for more information about JMX service and EJB deployment. </p></div></div></div><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes"/>Chapitre 4. Classes persistantes</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#persistent-classes-pojo">4.1. Un exemple simple de POJO</a></span></dt><dd><dl><dt><span class="sect2"><a href="#persistent-classes-pojo-constructor">4.1.1. Implémenter un constructeur sans argument</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-identifier">4.1.2. Fournir une propriété d'indentifiant (optionnel)</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-final">4.1.3. Favoriser les classes non finales (optionnel)</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-accessors">4.1.4. Déclarer les accesseurs et mutateurs des attributs persistants (optionnel)</a></span></dt></dl></dd><dt><span class="sect1"><a href="#persistent-classes-inheritance">4.2. Implémenter l'héritage</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-equalshashcode">4.3. Implémenter <code class="literal">equals()</code> et <code class="literal">hashCode()</code></a></span></dt><dt><span class="sect1"><a href="#persistent-classes-dynamicmodels">4.4. Modèles dynamiques</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-tuplizers">4.5. Tuplizers</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-entity-name-resolver">4.6. EntityNameResolvers</a></span></dt></dl></div><p>Persistent classes are classes in an application that implement the entities of the business problem (e.g. Customer and Order in an E-commerce application). Not all instances of a persistent class are considered to be in the persistent state. For example, an instance can instead be transient or detached. </p><p>Hibernate works best if these classes follow some simple rules, also known as the Plain Old Java Object (POJO) programming model. However, none of these rules are hard requirements. Indeed, Hibernate3 assumes very little about the nature of your persistent objects. You can express a domain model in other ways (using trees of <code class="literal">Map</code> instances, for example). </p><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes-pojo"/>4.1. Un exemple simple de POJO</h2></div></div></div><p>Most Java applications require a persistent class representing felines. For example: </p><pre class="programlisting">package eg;
import java.util.Set;
import java.util.Date;

public class Cat {
    private Long id; // identifier

    private Date birthdate;
    private Color color;
    private char sex;
    private float weight;
    private int litterId;

    private Cat mother;
    private Set kittens = new HashSet();

    private void setId(Long id) {
        this.id=id;
    }
    public Long getId() {
        return id;
    }

    void setBirthdate(Date date) {
        birthdate = date;
    }
    public Date getBirthdate() {
        return birthdate;
    }

    void setWeight(float weight) {
        this.weight = weight;
    }
    public float getWeight() {
        return weight;
    }

    public Color getColor() {
        return color;
    }
    void setColor(Color color) {
        this.color = color;
    }

    void setSex(char sex) {
        this.sex=sex;
    }
    public char getSex() {
        return sex;
    }

    void setLitterId(int id) {
        this.litterId = id;
    }
    public int getLitterId() {
        return litterId;
    }

    void setMother(Cat mother) {
        this.mother = mother;
    }
    public Cat getMother() {
        return mother;
    }
    void setKittens(Set kittens) {
        this.kittens = kittens;
    }
    public Set getKittens() {
        return kittens;
    }
    
    // addKitten not needed by Hibernate
    public void addKitten(Cat kitten) {
            kitten.setMother(this);
        kitten.setLitterId( kittens.size() ); 
        kittens.add(kitten);
    }
}</pre><p>The four main rules of persistent classes are explored in more detail in the following sections. </p><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="persistent-classes-pojo-constructor"/>4.1.1. Implémenter un constructeur sans argument</h3></div></div></div><p><code class="literal">Cat</code> has a no-argument constructor. All persistent classes must have a default constructor (which can be non-public) so that Hibernate can instantiate them using <code class="literal">Constructor.newInstance()</code>. It is recommended that you have a default constructor with at least <span class="emphasis"><em>package</em></span> visibility for runtime proxy generation in Hibernate. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="persistent-classes-pojo-identifier"/>4.1.2. Fournir une propriété d'indentifiant (optionnel)</h3></div></div></div><p><code class="literal">Cat</code> has a property called <code class="literal">id</code>. This property maps to the primary key column of a database table. The property might have been called anything, and its type might have been any primitive type, any primitive "wrapper" type, <code class="literal">java.lang.String</code> or <code class="literal">java.util.Date</code>. If your legacy database table has composite keys, you can use a user-defined class with properties of these types (see the section on composite identifiers later in the chapter.) </p><p>La propriété d'identifiant est strictement optionnelle. Vous pouver l'oublier et laisser Hibernate s'occuper des identifiants de l'objet en interne. Toutefois, nous ne le recommandons pas. </p><p>In fact, some functionality is available only to classes that declare an identifier property: </p><div class="itemizedlist"><ul compact="compact"><li><p>Transitive reattachment for detached objects (cascade update or cascade merge) - see <a href="#objectstate-transitive" title="10.11. Persistance transitive">Section 10.11, « Persistance transitive »</a> </p></li><li><p>
                        <code class="literal">Session.saveOrUpdate()</code>
                    </p></li><li><p>
                        <code class="literal">Session.merge()</code>
                    </p></li></ul></div><p>We recommend that you declare consistently-named identifier properties on persistent classes and that you use a nullable (i.e., non-primitive) type. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="persistent-classes-pojo-final"/>4.1.3. Favoriser les classes non finales (optionnel)</h3></div></div></div><p>Une fonctionnalité clef d'Hibernate, les <span class="emphasis"><em>proxies</em></span>, nécessitent que la classe persistente soit non finale ou qu'elle soit l'implémentation d'une interface qui déclare toutes les méthodes publiques. </p><p>You can persist <code class="literal">final</code> classes that do not implement an interface with Hibernate. You will not, however, be able to use proxies for lazy association fetching which will ultimately limit your options for performance tuning. </p><p>Vous devriez aussi éviter de déclarer des méthodes <code class="literal">public final</code> sur des classes non-finales. Si vous voulez utiliser une classe avec une méthode <code class="literal">public final</code>, vous devez explicitement désactiver les proxies en paramétrant <code class="literal">lazy="false"</code>. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="persistent-classes-pojo-accessors"/>4.1.4. Déclarer les accesseurs et mutateurs des attributs persistants (optionnel)</h3></div></div></div><p><code class="literal">Cat</code> declares accessor methods for all its persistent fields. Many other ORM tools directly persist instance variables. It is better to provide an indirection between the relational schema and internal data structures of the class. By default, Hibernate persists JavaBeans style properties and recognizes method names of the form <code class="literal">getFoo</code>, <code class="literal">isFoo</code> and <code class="literal">setFoo</code>. If required, you can switch to direct field access for particular properties. </p><p>Les propriétés <span class="emphasis"><em>n'ont pas</em></span> à être déclarées publiques - Hibernate peut persister une propriété avec un paire de getter/setter de visibilité par défault, <code class="literal">protected</code> ou <code class="literal"> private</code>. </p></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes-inheritance"/>4.2. Implémenter l'héritage</h2></div></div></div><p>A subclass must also observe the first and second rules. It inherits its identifier property from the superclass, <code class="literal">Cat</code>. For example: </p><pre class="programlisting">package eg;

public class DomesticCat extends Cat {
        private String name;

        public String getName() {
                return name;
        }
        protected void setName(String name) {
                this.name=name;
        }
}</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes-equalshashcode"/>4.3. Implémenter <code class="literal">equals()</code> et <code class="literal">hashCode()</code></h2></div></div></div><p>You have to override the <code class="literal">equals()</code> and <code class="literal">hashCode()</code> methods if you: </p><div class="itemizedlist"><ul compact="compact"><li><p>intend to put instances of persistent classes in a <code class="literal">Set</code> (the recommended way to represent many-valued associations); <span class="emphasis"><em>and</em></span> </p></li><li><p>avez l'intention d'utiliser le réattachement d'instances détachées </p></li></ul></div><p>Hibernate guarantees equivalence of persistent identity (database row) and Java identity only inside a particular session scope. When you mix instances retrieved in different sessions, you must implement <code class="literal">equals()</code> and <code class="literal">hashCode()</code> if you wish to have meaningful semantics for <code class="literal">Set</code>s. </p><p>The most obvious way is to implement <code class="literal">equals()</code>/<code class="literal">hashCode()</code> by comparing the identifier value of both objects. If the value is the same, both must be the same database row, because they are equal. If both are added to a <code class="literal">Set</code>, you will only have one element in the <code class="literal">Set</code>). Unfortunately, you cannot use that approach with generated identifiers. Hibernate will only assign identifier values to objects that are persistent; a newly created instance will not have any identifier value. Furthermore, if an instance is unsaved and currently in a <code class="literal">Set</code>, saving it will assign an identifier value to the object. If <code class="literal">equals()</code> and <code class="literal">hashCode()</code> are based on the identifier value, the hash code would change, breaking the contract of the <code class="literal">Set</code>. See the Hibernate website for a full discussion of this problem. This is not a Hibernate issue, but normal Java semantics of object identity and equality. </p><p>It is recommended that you implement <code class="literal">equals()</code> and <code class="literal">hashCode()</code> using <span class="emphasis"><em>Business key equality</em></span>. Business key equality means that the <code class="literal">equals()</code> method compares only the properties that form the business key. It is a key that would identify our instance in the real world (a <span class="emphasis"><em>natural</em></span> candidate key): </p><pre class="programlisting">public class Cat {

    ...
    public boolean equals(Object other) {
        if (this == other) return true;
        if ( !(other instanceof Cat) ) return false;

        final Cat cat = (Cat) other;

        if ( !cat.getLitterId().equals( getLitterId() ) ) return false;
        if ( !cat.getMother().equals( getMother() ) ) return false;

        return true;
    }

    public int hashCode() {
        int result;
        result = getMother().hashCode();
        result = 29 * result + getLitterId();
        return result;
    }

}</pre><p>A business key does not have to be as solid as a database primary key candidate (see <a href="#transactions-basics-identity" title="11.1.3. L'identité des objets">Section 11.1.3, « L'identité des objets »</a>). Immutable or unique properties are usually good candidates for a business key. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes-dynamicmodels"/>4.4. Modèles dynamiques</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
	 <span class="emphasis"><em>The following features are currently considered experimental and may change in the near future.</em></span>
	      
	</p></div><p>Persistent entities do not necessarily have to be represented as POJO classes or as JavaBean objects at runtime. Hibernate also supports dynamic models (using <code class="literal">Map</code>s of <code class="literal">Map</code>s at runtime) and the representation of entities as DOM4J trees. With this approach, you do not write persistent classes, only mapping files. </p><p>By default, Hibernate works in normal POJO mode. You can set a default entity representation mode for a particular <code class="literal">SessionFactory</code> using the <code class="literal">default_entity_mode</code> configuration option (see <a href="#configuration-optional-properties" title="Tableau 3.3. Propriétés de configuration d'Hibernate">Tableau 3.3, « Propriétés de configuration d'Hibernate »</a>). </p><p>The following examples demonstrate the representation using <code class="literal">Map</code>s. First, in the mapping file an <code class="literal">entity-name</code> has to be declared instead of, or in addition to, a class name: </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class entity-name="Customer"&gt;

        &lt;id name="id"
            type="long"
            column="ID"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;

        &lt;property name="name"
            column="NAME"
            type="string"/&gt;

        &lt;property name="address"
            column="ADDRESS"
            type="string"/&gt;

        &lt;many-to-one name="organization"
            column="ORGANIZATION_ID"
            class="Organization"/&gt;

        &lt;bag name="orders"
            inverse="true"
            lazy="false"
            cascade="all"&gt;
            &lt;key column="CUSTOMER_ID"/&gt;
            &lt;one-to-many class="Order"/&gt;
        &lt;/bag&gt;

    &lt;/class&gt;
    
&lt;/hibernate-mapping&gt;</pre><p>Even though associations are declared using target class names, the target type of associations can also be a dynamic entity instead of a POJO. </p><p>After setting the default entity mode to <code class="literal">dynamic-map</code> for the <code class="literal">SessionFactory</code>, you can, at runtime, work with <code class="literal">Map</code>s of <code class="literal">Map</code>s: </p><pre class="programlisting">Session s = openSession();
Transaction tx = s.beginTransaction();
Session s = openSession();

// Create a customer
Map david = new HashMap();
david.put("name", "David");

// Create an organization
Map foobar = new HashMap();
foobar.put("name", "Foobar Inc.");

// Link both
david.put("organization", foobar);

// Save both
s.save("Customer", david);
s.save("Organization", foobar);

tx.commit();
s.close();</pre><p>One of the main advantages of dynamic mapping is quick turnaround time for prototyping, without the need for entity class implementation. However, you lose compile-time type checking and will likely deal with many exceptions at runtime. As a result of the Hibernate mapping, the database schema can easily be normalized and sound, allowing to add a proper domain model implementation on top later on. </p><p>Les modes de représentation d'une entité peut aussi être configuré par <code class="literal">Session</code> : </p><pre class="programlisting">Session dynamicSession = pojoSession.getSession(EntityMode.MAP);

// Create a customer
Map david = new HashMap();
david.put("name", "David");
dynamicSession.save("Customer", david);
...
dynamicSession.flush();
dynamicSession.close()
...
// Continue on pojoSession
</pre><p>Please note that the call to <code class="literal">getSession()</code> using an <code class="literal">EntityMode</code> is on the <code class="literal">Session</code> API, not the <code class="literal">SessionFactory</code>. That way, the new <code class="literal">Session</code> shares the underlying JDBC connection, transaction, and other context information. This means you do not have to call <code class="literal">flush()</code> and <code class="literal">close()</code> on the secondary <code class="literal">Session</code>, and also leave the transaction and connection handling to the primary unit of work. </p><p>Plus d'informations à propos de la représentation XML peuvent être trouvées dans <a href="#xml" title="Chapitre 18. Mapping XML">Chapitre 18, <i xmlns:xlink="http://www.w3.org/1999/xlink">Mapping XML</i></a>. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes-tuplizers"/>4.5. Tuplizers</h2></div></div></div><p><code class="literal">org.hibernate.tuple.Tuplizer</code>, and its sub-interfaces, are responsible for managing a particular representation of a piece of data given that representation's <code class="literal">org.hibernate.EntityMode</code>. If a given piece of data is thought of as a data structure, then a tuplizer is the thing that knows how to create such a data structure and how to extract values from and inject values into such a data structure. For example, for the POJO entity mode, the corresponding tuplizer knows how create the POJO through its constructor. It also knows how to access the POJO properties using the defined property accessors. </p><p>There are two high-level types of Tuplizers, represented by the <code class="literal">org.hibernate.tuple.entity.EntityTuplizer</code> and <code class="literal">org.hibernate.tuple.component.ComponentTuplizer</code> interfaces. <code class="literal">EntityTuplizer</code>s are responsible for managing the above mentioned contracts in regards to entities, while <code class="literal">ComponentTuplizer</code>s do the same for components. </p><p>Users can also plug in their own tuplizers. Perhaps you require that a <code class="literal">java.util.Map</code> implementation other than <code class="literal">java.util.HashMap</code> be used while in the dynamic-map entity-mode. Or perhaps you need to define a different proxy generation strategy than the one used by default. Both would be achieved by defining a custom tuplizer implementation. Tuplizer definitions are attached to the entity or component mapping they are meant to manage. Going back to the example of our customer entity: </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    &lt;class entity-name="Customer"&gt;
        &lt;!--
            Override the dynamic-map entity-mode
            tuplizer for the customer entity
        --&gt;
        &lt;tuplizer entity-mode="dynamic-map"
                class="CustomMapTuplizerImpl"/&gt;

        &lt;id name="id" type="long" column="ID"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;

        &lt;!-- other properties --&gt;
        ...
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;


public class CustomMapTuplizerImpl
        extends org.hibernate.tuple.entity.DynamicMapEntityTuplizer {
    // override the buildInstantiator() method to plug in our custom map...
    protected final Instantiator buildInstantiator(
            org.hibernate.mapping.PersistentClass mappingInfo) {
        return new CustomMapInstantiator( mappingInfo );
    }

    private static final class CustomMapInstantiator
            extends org.hibernate.tuple.DynamicMapInstantitor {
        // override the generateMap() method to return our custom map...
            protected final Map generateMap() {
                    return new CustomMap();
            }
    }
}</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes-entity-name-resolver"/>4.6. EntityNameResolvers</h2></div></div></div><p>The <code class="interfacename">org.hibernate.EntityNameResolver</code> interface is a contract for resolving the entity name of a given entity instance. The interface defines a single method <code class="methodname">resolveEntityName</code> which is passed the entity instance and is expected to return the appropriate entity name (null is allowed and would indicate that the resolver does not know how to resolve the entity name of the given entity instance). Generally speaking, an <code class="interfacename">org.hibernate.EntityNameResolver</code> is going to be most useful in the case of dynamic models. One example might be using proxied interfaces as your domain model. The hibernate test suite has an example of this exact style of usage under the <span class="package">org.hibernate.test.dynamicentity.tuplizer2</span>. Here is some of the code from that package for illustration. </p><pre class="programlisting">/**
 * A very trivial JDK Proxy InvocationHandler implementation where we proxy an interface as
 * the domain model and simply store persistent state in an internal Map.  This is an extremely
 * trivial example meant only for illustration.
 */
public final class DataProxyHandler implements InvocationHandler {
        private String entityName;
        private HashMap data = new HashMap();

        public DataProxyHandler(String entityName, Serializable id) {
                this.entityName = entityName;
                data.put( "Id", id );
        }

        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                String methodName = method.getName();
                if ( methodName.startsWith( "set" ) ) {
                        String propertyName = methodName.substring( 3 );
                        data.put( propertyName, args[0] );
                }
                else if ( methodName.startsWith( "get" ) ) {
                        String propertyName = methodName.substring( 3 );
                        return data.get( propertyName );
                }
                else if ( "toString".equals( methodName ) ) {
                        return entityName + "#" + data.get( "Id" );
                }
                else if ( "hashCode".equals( methodName ) ) {
                        return new Integer( this.hashCode() );
                }
                return null;
        }

        public String getEntityName() {
                return entityName;
        }

        public HashMap getData() {
                return data;
        }
}

/**
 *
 */
public class ProxyHelper {
    public static String extractEntityName(Object object) {
        // Our custom java.lang.reflect.Proxy instances actually bundle
        // their appropriate entity name, so we simply extract it from there
        // if this represents one of our proxies; otherwise, we return null
        if ( Proxy.isProxyClass( object.getClass() ) ) {
            InvocationHandler handler = Proxy.getInvocationHandler( object );
            if ( DataProxyHandler.class.isAssignableFrom( handler.getClass() ) ) {
                DataProxyHandler myHandler = ( DataProxyHandler ) handler;
                return myHandler.getEntityName();
            }
        }
        return null;
    }

    // various other utility methods ....

}

/**
 * The EntityNameResolver implementation.
 * IMPL NOTE : An EntityNameResolver really defines a strategy for how entity names should be
 * resolved.  Since this particular impl can handle resolution for all of our entities we want to
 * take advantage of the fact that SessionFactoryImpl keeps these in a Set so that we only ever
 * have one instance registered.  Why?  Well, when it comes time to resolve an entity name,
 * Hibernate must iterate over all the registered resolvers.  So keeping that number down
 * helps that process be as speedy as possible.  Hence the equals and hashCode impls
 */
public class MyEntityNameResolver implements EntityNameResolver {
    public static final MyEntityNameResolver INSTANCE = new MyEntityNameResolver();

    public String resolveEntityName(Object entity) {
        return ProxyHelper.extractEntityName( entity );
    }

    public boolean equals(Object obj) {
        return getClass().equals( obj.getClass() );
    }

    public int hashCode() {
        return getClass().hashCode();
    }
}

public class MyEntityTuplizer extends PojoEntityTuplizer {
        public MyEntityTuplizer(EntityMetamodel entityMetamodel, PersistentClass mappedEntity) {
                super( entityMetamodel, mappedEntity );
        }

        public EntityNameResolver[] getEntityNameResolvers() {
                return new EntityNameResolver[] { MyEntityNameResolver.INSTANCE };
        }

    public String determineConcreteSubclassEntityName(Object entityInstance, SessionFactoryImplementor factory) {
        String entityName = ProxyHelper.extractEntityName( entityInstance );
        if ( entityName == null ) {
            entityName = super.determineConcreteSubclassEntityName( entityInstance, factory );
        }
        return entityName;
    }

    ...
}
        </pre><p>In order to register an <code class="interfacename">org.hibernate.EntityNameResolver</code> users must either: </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>Implement a custom <a href="#persistent-classes-tuplizers" title="4.5. Tuplizers">Tuplizer</a>, implementing the <code class="methodname">getEntityNameResolvers</code> method. </p></li><li><p>Register it with the <code class="classname">org.hibernate.impl.SessionFactoryImpl</code> (which is the implementation class for <code class="interfacename">org.hibernate.SessionFactory</code>) using the <code class="methodname">registerEntityNameResolver</code> method. </p></li></ol></div><p>
        </p></div></div><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="mapping"/>Chapitre 5. Mapping O/R basique</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#mapping-declaration">5.1. Déclaration de Mapping</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-declaration-doctype">5.1.1. Doctype</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-mapping">5.1.2. Hibernate-mapping</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-class">5.1.3. Class</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id">5.1.4. id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id-enhanced">5.1.5. Enhanced identifier generators</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id-enhanced-optimizers">5.1.6. Identifier generator optimization</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-compositeid">5.1.7. composite-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-discriminator">5.1.8. Discriminator</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-version">5.1.9. Version (optional)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-timestamp">5.1.10. Timestamp (optional)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-property">5.1.11. Property</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-manytoone">5.1.12. Many-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-onetoone">5.1.13. One-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-naturalid">5.1.14. Natural-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-component">5.1.15. Component and dynamic-component</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-properties">5.1.16. Properties</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-subclass">5.1.17. Subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-joinedsubclass">5.1.18. Joined-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-unionsubclass">5.1.19. Union-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-join">5.1.20. Join</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-key">5.1.21. Key</a></span></dt><dt><span class="sect2"><a href="#mapping-column">5.1.22. Column and formula elements</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-import">5.1.23. Import</a></span></dt><dt><span class="sect2"><a href="#mapping-types-anymapping">5.1.24. Any</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-types">5.2. Hibernate types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-types-entitiesvalues">5.2.1. Entités et valeurs</a></span></dt><dt><span class="sect2"><a href="#mapping-types-basictypes">5.2.2. Basic value types</a></span></dt><dt><span class="sect2"><a href="#mapping-types-custom">5.2.3. Types de valeur définis par l'utilisateur</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-entityname">5.3. Mapper une classe plus d'une fois</a></span></dt><dt><span class="sect1"><a href="#mapping-quotedidentifiers">5.4. SQL quoted identifiers</a></span></dt><dt><span class="sect1"><a href="#mapping-alternatives">5.5. alternatives Metadata</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-xdoclet">5.5.1. utilisation de XDoclet</a></span></dt><dt><span class="sect2"><a href="#mapping-annotations">5.5.2. Utilisation des annotations JDK 5.0</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-generated">5.6. Generated properties</a></span></dt><dt><span class="sect1"><a href="#mapping-database-object">5.7. Auxiliary database objects</a></span></dt></dl></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-declaration"/>5.1. Déclaration de Mapping</h2></div></div></div><p>Object/relational mappings are usually defined in an XML document. The mapping document is designed to be readable and hand-editable. The mapping language is Java-centric, meaning that mappings are constructed around persistent class declarations and not table declarations. </p><p>Please note that even though many Hibernate users choose to write the XML by hand, a number of tools exist to generate the mapping document. These include XDoclet, Middlegen and AndroMDA. </p><p>Here is an example mapping: </p><a id="mapping-declaration-ex1"/><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
      "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
          "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

        &lt;class name="Cat"
            table="cats"
            discriminator-value="C"&gt;

                &lt;id name="id"&gt;
                        &lt;generator class="native"/&gt;
                &lt;/id&gt;

                &lt;discriminator column="subclass"
                     type="character"/&gt;

                &lt;property name="weight"/&gt;

                &lt;property name="birthdate"
                    type="date"
                    not-null="true"
                    update="false"/&gt;

                &lt;property name="color"
                    type="eg.types.ColorUserType"
                    not-null="true"
                    update="false"/&gt;

                &lt;property name="sex"
                    not-null="true"
                    update="false"/&gt;

                &lt;property name="litterId"
                    column="litterId"
                    update="false"/&gt;

                &lt;many-to-one name="mother"
                    column="mother_id"
                    update="false"/&gt;

                &lt;set name="kittens"
                    inverse="true"
                    order-by="litter_id"&gt;
                        &lt;key column="mother_id"/&gt;
                        &lt;one-to-many class="Cat"/&gt;
                &lt;/set&gt;

                &lt;subclass name="DomesticCat"
                    discriminator-value="D"&gt;

                        &lt;property name="name"
                            type="string"/&gt;

                &lt;/subclass&gt;

        &lt;/class&gt;

        &lt;class name="Dog"&gt;
                &lt;!-- mapping for Dog could go here --&gt;
        &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>We will now discuss the content of the mapping document. We will only describe, however, the document elements and attributes that are used by Hibernate at runtime. The mapping document also contains some extra optional attributes and elements that affect the database schemas exported by the schema export tool (for example, the <code class="literal"> not-null</code> attribute). </p><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-doctype"/>5.1.1. Doctype</h3></div></div></div><p>All XML mappings should declare the doctype shown. The actual DTD can be found at the URL above, in the directory <code class="literal">hibernate-x.x.x/src/org/hibernate </code>, or in <code class="literal">hibernate3.jar</code>. Hibernate will always look for the DTD in its classpath first. If you experience lookups of the DTD using an Internet connection, check the DTD declaration against the contents of your classpath. </p><div class="sect3" lang="fr-FR"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-entity-resolution"/>5.1.1.1. EntityResolver</h4></div></div></div><p>Hibernate will first attempt to resolve DTDs in its classpath. It does this is by registering a custom <code class="literal">org.xml.sax.EntityResolver</code> implementation with the SAXReader it uses to read in the xml files. This custom <code class="literal">EntityResolver</code> recognizes two different systemId namespaces: </p><div class="itemizedlist"><ul><li><p>a <code class="literal">hibernate namespace</code> is recognized whenever the resolver encounters a systemId starting with <code class="literal">http://hibernate.sourceforge.net/</code>. The resolver attempts to resolve these entities via the classloader which loaded the Hibernate classes. </p></li><li><p>a <code class="literal">user namespace</code> is recognized whenever the resolver encounters a systemId using a <code class="literal">classpath://</code> URL protocol. The resolver will attempt to resolve these entities via (1) the current thread context classloader and (2) the classloader which loaded the Hibernate classes. </p></li></ul></div><p>The following is an example of utilizing user namespacing: </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd" [
    &lt;!ENTITY types SYSTEM "classpath://your/domain/types.xml"&gt;
]&gt;

&lt;hibernate-mapping package="your.domain"&gt;
    &lt;class name="MyEntity"&gt;
        &lt;id name="id" type="my-custom-id-type"&gt;
            ...
        &lt;/id&gt;
    &lt;class&gt;
    &amp;types;
&lt;/hibernate-mapping&gt;</pre><p>Where <code class="literal">types.xml</code> is a resource in the <code class="literal">your.domain</code> package and contains a custom <a href="#mapping-types-custom" title="5.2.3. Types de valeur définis par l'utilisateur">typedef</a>. </p></div></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-mapping"/>5.1.2. Hibernate-mapping</h3></div></div></div><p>This element has several optional attributes. The <code class="literal">schema</code> and <code class="literal">catalog</code> attributes specify that tables referred to in this mapping belong to the named schema and/or catalog. If they are specified, tablenames will be qualified by the given schema and catalog names. If they are missing, tablenames will be unqualified. The <code class="literal">default-cascade</code> attribute specifies what cascade style should be assumed for properties and collections that do not specify a <code class="literal">cascade</code> attribute. By default, the <code class="literal">auto-import</code> attribute allows you to use unqualified class names in the query language. </p><div class="programlistingco"><pre class="programlisting">&lt;hibernate-mapping
         schema="schemaName"                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
         catalog="catalogName"                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
         default-cascade="cascade_style"              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
         default-access="field|property|ClassName"    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
         default-lazy="true|false"                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
         auto-import="true|false"                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
         package="package.name"                       <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
 /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">schema</code> (optional): the name of a database schema. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">catalog</code> (optional): the name of a database catalog. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">default-cascade</code> (optional - defaults to <code class="literal">none</code>): a default cascade style. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">default-access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate should use for accessing all properties. It can be a custom implementation of <code class="literal">PropertyAccessor</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">default-lazy</code> (optional - defaults to <code class="literal">true</code>): the default value for unspecified <code class="literal">lazy</code> attributes of class and collection mappings. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">auto-import</code> (optional - defaults to <code class="literal">true</code>): specifies whether we can use unqualified class names of classes in this mapping in the query language. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">package</code> (optional): specifies a package prefix to use for unqualified class names in the mapping document. </p></td></tr></table></div></div><p>If you have two persistent classes with the same unqualified name, you should set <code class="literal">auto-import="false"</code>. An exception will result if you attempt to assign two classes to the same "imported" name. </p><p>The <code class="literal">hibernate-mapping</code> element allows you to nest several persistent <code class="literal">&lt;class&gt;</code> mappings, as shown above. It is, however, good practice (and expected by some tools) to map only a single persistent class, or a single class hierarchy, in one mapping file and name it after the persistent superclass. For example, <code class="literal">Cat.hbm.xml</code>, <code class="literal">Dog.hbm.xml</code>, or if using inheritance, <code class="literal">Animal.hbm.xml</code>. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-class"/>5.1.3. Class</h3></div></div></div><p>You can declare a persistent class using the <code class="literal">class</code> element. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;class
        name="ClassName"                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        table="tableName"                             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        discriminator-value="discriminator_value"     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        mutable="true|false"                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        schema="owner"                                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        catalog="catalog"                             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        proxy="ProxyInterface"                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        dynamic-update="true|false"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
        dynamic-insert="true|false"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/9.png" alt="(9)"/></span>
        select-before-update="true|false"             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/10.png" alt="(10)"/></span>
        polymorphism="implicit|explicit"              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/11.png" alt="(11)"/></span>
        where="arbitrary sql where condition"         <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/12.png" alt="(12)"/></span>
        persister="PersisterClass"                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/13.png" alt="(13)"/></span>
        batch-size="N"                                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/14.png" alt="(14)"/></span>
        optimistic-lock="none|version|dirty|all"      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/15.png" alt="(15)"/></span>
        lazy="true|false"                             <span xmlns="" class="co">(16)</span>
        entity-name="EntityName"                      <span xmlns="" class="co">(17)</span>
        check="arbitrary sql check condition"         <span xmlns="" class="co">(18)</span>
        rowid="rowid"                                 <span xmlns="" class="co">(19)</span>
        subselect="SQL expression"                    <span xmlns="" class="co">(20)</span>
        abstract="true|false"                         <span xmlns="" class="co">(21)</span>
        node="element-name"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code> (optional): the fully qualified Java class name of the persistent class or interface. If this attribute is missing, it is assumed that the mapping is for a non-POJO entity. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">table</code> (optional - defaults to the unqualified class name): the name of its database table. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">discriminator-value</code> (optional - defaults to the class name): a value that distinguishes individual subclasses that is used for polymorphic behavior. Acceptable values include <code class="literal">null</code> and <code class="literal">not null</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">mutable</code> (optional - defaults to <code class="literal">true</code>): specifies that instances of the class are (not) mutable. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">schema</code> (optional): overrides the schema name specified by the root <code class="literal">&lt;hibernate-mapping&gt;</code> element. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">catalog</code> (optional): overrides the catalog name specified by the root <code class="literal">&lt;hibernate-mapping&gt;</code> element. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">proxy</code> (optional): specifies an interface to use for lazy initializing proxies. You can specify the name of the class itself. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">dynamic-update</code> (optional - defaults to <code class="literal">false</code>): specifies that <code class="literal">UPDATE</code> SQL should be generated at runtime and can contain only those columns whose values have changed. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/9.png" alt="9" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">dynamic-insert</code> (optional - defaults to <code class="literal">false</code>): specifies that <code class="literal">INSERT</code> SQL should be generated at runtime and contain only the columns whose values are not null. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/10.png" alt="10" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">select-before-update</code> (optional - defaults to <code class="literal">false</code>): specifies that Hibernate should <span class="emphasis"><em>never</em></span> perform an SQL <code class="literal">UPDATE</code> unless it is certain that an object is actually modified. Only when a transient object has been associated with a new session using <code class="literal">update()</code>, will Hibernate perform an extra SQL <code class="literal">SELECT</code> to determine if an <code class="literal">UPDATE</code> is actually required. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/11.png" alt="11" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">polymorphism</code> (optional - defaults to <code class="literal">implicit</code>): determines whether implicit or explicit query polymorphism is used. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/12.png" alt="12" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">where</code> (optional): specifies an arbitrary SQL <code class="literal">WHERE</code> condition to be used when retrieving objects of this class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/13.png" alt="13" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">persister</code> (optional): specifies a custom <code class="literal">ClassPersister</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/14.png" alt="14" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">batch-size</code> (optional - defaults to <code class="literal">1</code>): specifies a "batch size" for fetching instances of this class by identifier. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/15.png" alt="15" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">version</code>): determines the optimistic locking strategy. </p></td></tr><tr><td width="5%" valign="top" align="left">(16)</td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional): lazy fetching can be disabled by setting <code class="literal">lazy="false"</code>. </p></td></tr><tr><td width="5%" valign="top" align="left">(17)</td><td valign="top" align="left"><p><code class="literal">entity-name</code> (optional - defaults to the class name): Hibernate3 allows a class to be mapped multiple times, potentially to different tables. It also allows entity mappings that are represented by Maps or XML at the Java level. In these cases, you should provide an explicit arbitrary name for the entity. See <a href="#persistent-classes-dynamicmodels" title="4.4. Modèles dynamiques">Section 4.4, « Modèles dynamiques »</a> and <a href="#xml" title="Chapitre 18. Mapping XML">Chapitre 18, <i xmlns:xlink="http://www.w3.org/1999/xlink">Mapping XML</i></a> for more information. </p></td></tr><tr><td width="5%" valign="top" align="left">(18)</td><td valign="top" align="left"><p><code class="literal">check</code> (optional): an SQL expression used to generate a multi-row <span class="emphasis"><em>check</em></span> constraint for automatic schema generation. </p></td></tr><tr><td width="5%" valign="top" align="left">(19)</td><td valign="top" align="left"><p><code class="literal">rowid</code> (optional): Hibernate can use ROWIDs on databases. On Oracle, for example, Hibernate can use the <code class="literal">rowid</code> extra column for fast updates once this option has been set to <code class="literal">rowid</code>. A ROWID is an implementation detail and represents the physical location of a stored tuple. </p></td></tr><tr><td width="5%" valign="top" align="left">(20)</td><td valign="top" align="left"><p><code class="literal">subselect</code> (optional): maps an immutable and read-only entity to a database subselect. This is useful if you want to have a view instead of a base table. See below for more information. </p></td></tr><tr><td width="5%" valign="top" align="left">(21)</td><td valign="top" align="left"><p><code class="literal">abstract</code> (optional): is used to mark abstract superclasses in <code class="literal">&lt;union-subclass&gt;</code> hierarchies. </p></td></tr></table></div></div><p>It is acceptable for the named persistent class to be an interface. You can declare implementing classes of that interface using the <code class="literal">&lt;subclass&gt;</code> element. You can persist any <span class="emphasis"><em>static</em></span> inner class. Specify the class name using the standard form i.e. <code class="literal">e.g.Foo$Bar</code>. </p><p>Immutable classes, <code class="literal">mutable="false"</code>, cannot be updated or deleted by the application. This allows Hibernate to make some minor performance optimizations. </p><p>The optional <code class="literal">proxy</code> attribute enables lazy initialization of persistent instances of the class. Hibernate will initially return CGLIB proxies that implement the named interface. The persistent object will load when a method of the proxy is invoked. See "Initializing collections and proxies" below. </p><p><span class="emphasis"><em>Implicit</em></span> polymorphism means that instances of the class will be returned by a query that names any superclass or implemented interface or class, and that instances of any subclass of the class will be returned by a query that names the class itself. <span class="emphasis"><em>Explicit</em></span> polymorphism means that class instances will be returned only by queries that explicitly name that class. Queries that name the class will return only instances of subclasses mapped inside this <code class="literal">&lt;class&gt;</code> declaration as a <code class="literal">&lt;subclass&gt;</code> or <code class="literal">&lt;joined-subclass&gt;</code>. For most purposes, the default <code class="literal">polymorphism="implicit"</code> is appropriate. Explicit polymorphism is useful when two different classes are mapped to the same table This allows a "lightweight" class that contains a subset of the table columns. </p><p>The <code class="literal">persister</code> attribute lets you customize the persistence strategy used for the class. You can, for example, specify your own subclass of <code class="literal">org.hibernate.persister.EntityPersister</code>, or you can even provide a completely new implementation of the interface <code class="literal">org.hibernate.persister.ClassPersister</code> that implements, for example, persistence via stored procedure calls, serialization to flat files or LDAP. See <code class="literal">org.hibernate.test.CustomPersister</code> for a simple example of "persistence" to a <code class="literal">Hashtable</code>. </p><p>The <code class="literal">dynamic-update</code> and <code class="literal">dynamic-insert</code> settings are not inherited by subclasses, so they can also be specified on the <code class="literal">&lt;subclass&gt;</code> or <code class="literal">&lt;joined-subclass&gt;</code> elements. Although these settings can increase performance in some cases, they can actually decrease performance in others. </p><p>Use of <code class="literal">select-before-update</code> will usually decrease performance. It is useful to prevent a database update trigger being called unnecessarily if you reattach a graph of detached instances to a <code class="literal">Session</code>. </p><p>Si vous utilisez le <code class="literal">dynamic-update</code>, les différentes stratégies de verrouillage optimiste (optimistic locking) sont les suivantes: </p><div class="itemizedlist"><ul><li><p><code class="literal">version</code>: check the version/timestamp columns </p></li><li><p><code class="literal">all</code>: check all columns </p></li><li><p><code class="literal">dirty</code>: check the changed columns, allowing some concurrent updates </p></li><li><p><code class="literal">none</code>: do not use optimistic locking </p></li></ul></div><p>It is <span class="emphasis"><em>strongly</em></span> recommended that you use version/timestamp columns for optimistic locking with Hibernate. This strategy optimizes performance and correctly handles modifications made to detached instances (i.e. when <code class="literal">Session.merge()</code> is used). </p><p>There is no difference between a view and a base table for a Hibernate mapping. This is transparent at the database level, although some DBMS do not support views properly, especially with updates. Sometimes you want to use a view, but you cannot create one in the database (i.e. with a legacy schema). In this case, you can map an immutable and read-only entity to a given SQL subselect expression: </p><pre class="programlisting">&lt;class name="Summary"&gt;
    &lt;subselect&gt;
        select item.name, max(bid.amount), count(*)
        from item
        join bid on bid.item_id = item.id
        group by item.name
    &lt;/subselect&gt;
    &lt;synchronize table="item"/&gt;
    &lt;synchronize table="bid"/&gt;
    &lt;id name="name"/&gt;
    ...
&lt;/class&gt;</pre><p>Declare the tables to synchronize this entity with, ensuring that auto-flush happens correctly and that queries against the derived entity do not return stale data. The <code class="literal">&lt;subselect&gt;</code> is available both as an attribute and a nested mapping element. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-id"/>5.1.4. id</h3></div></div></div><p>Les classes mappées <span class="emphasis"><em>doivent</em></span> déclarer la clef primaire de la table en base de données. La plupart des classes auront aussi une propriété de type javabean présentant l'identifiant unique d'une instance. L'élément <code class="literal">&lt;id&gt;</code> sert à définir le mapping entre cette propriété et la clef primaire en base. </p><div class="programlistingco"><pre class="programlisting">&lt;id
        name="propertyName"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        type="typename"                                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        column="column_name"                                         <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        unsaved-value="null|any|none|undefined|id_value"             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        access="field|property|ClassName"&gt;                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        node="element-name|@attribute-name|element/@attribute|."

        &lt;generator class="generatorClass"/&gt;
&lt;/id&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code> (optional): the name of the identifier property. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">type</code> (optionnel) : nom indiquant le type Hibernate. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional - defaults to the property name): the name of the primary key column. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unsaved-value</code> (optional - defaults to a "sensible" value): an identifier property value that indicates an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate should use for accessing the property value. </p></td></tr></table></div></div><p>Si l'attribut <code class="literal">name</code> est absent, Hibernate considère que la classe ne possède pas de propriété identifiant. </p><p>L'attribut <code class="literal">unsaved-value</code> est important ! Si l'identifiant de votre classe n'a pas une valeur par défaut compatible avec le comportement standard de Java (zéro ou null), vous devez alors préciser la valeur par défaut. </p><p>There is an alternative <code class="literal">&lt;composite-id&gt;</code> declaration that allows access to legacy data with composite keys. Its use is strongly discouraged for anything else. </p><div class="sect3" lang="fr-FR"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-generator"/>5.1.4.1. Generator</h4></div></div></div><p>L'élément fils <code class="literal">&lt;generator&gt;</code> nomme une classe Java utilisée pour générer les identifiants uniques pour les instances des classes persistantes. Si des paramètres sont requis pour configurer ou initialiser l'instance du générateur, ils sont passés en utilisant l'élément <code class="literal">&lt;param&gt;</code>. </p><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="org.hibernate.id.TableHiLoGenerator"&gt;
                &lt;param name="table"&gt;uid_table&lt;/param&gt;
                &lt;param name="column"&gt;next_hi_value_column&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>All generators implement the interface <code class="literal">org.hibernate.id.IdentifierGenerator</code>. This is a very simple interface. Some applications can choose to provide their own specialized implementations, however, Hibernate provides a range of built-in implementations. The shortcut names for the built-in generators are as follows: </p><div class="variablelist"><dl><dt><span class="term"><code class="literal">increment</code></span></dt><dd><p>Génère des identifiants de type <code class="literal">long</code>, <code class="literal">short</code> ou <code class="literal">int</code> qui ne sont uniques que si aucun autre processus n'insère de données dans la même table. <span class="emphasis"><em>Ne pas utiliser en environnement clusterisé.</em></span> </p></dd><dt><span class="term"><code class="literal">identity</code></span></dt><dd><p>Utilisation de la colonne identity de DB2, MySQL, MS SQL Server, Sybase et HypersonicSQL. L'identifiant renvoyé est de type <code class="literal">long</code>, <code class="literal">short</code> ou <code class="literal">int</code>. </p></dd><dt><span class="term"><code class="literal">sequence</code></span></dt><dd><p>Utilisation des séquences dans DB2, PostgreSQL, Oracle, SAP DB, McKoi ou d'un générateur dans Interbase. L'identifiant renvoyé est de type <code class="literal">long</code>, <code class="literal">short</code> ou <code class="literal">int</code> </p></dd><dt><span class="term"><code class="literal">hilo</code></span></dt><dd><p><a id="mapping-declaration-id-hilodescription"/>Utilise un algorithme hi/lo pour générer de façon efficace des identifiants de type <code class="literal">long</code>, <code class="literal">short</code> ou <code class="literal">int</code>, en prenant comme source de valeur "hi" une table et une colonne (par défaut <code class="literal">hibernate_unique_key</code> et <code class="literal">next_hi</code> respectivement). L'algorithme hi/lo génère des identifiants uniques pour une base de données particulière seulement. </p></dd><dt><span class="term"><code class="literal">seqhilo</code></span></dt><dd><p>Utilise un algorithme hi/lo pour générer efficacement des identifiants de type <code class="literal">long</code>, <code class="literal">short</code> ou <code class="literal">int</code>, étant donné un nom de séquence en base. </p></dd><dt><span class="term"><code class="literal">uuid</code></span></dt><dd><p>uses a 128-bit UUID algorithm to generate identifiers of type string that are unique within a network (the IP address is used). The UUID is encoded as a string of 32 hexadecimal digits in length. </p></dd><dt><span class="term"><code class="literal">guid</code></span></dt><dd><p>Utilise une chaîne GUID générée par la base pour MS SQL Server et MySQL. </p></dd><dt><span class="term"><code class="literal">native</code></span></dt><dd><p>selects <code class="literal">identity</code>, <code class="literal">sequence</code> or <code class="literal">hilo</code> depending upon the capabilities of the underlying database. </p></dd><dt><span class="term"><code class="literal">assigned</code></span></dt><dd><p>lets the application assign an identifier to the object before <code class="literal">save()</code> is called. This is the default strategy if no <code class="literal">&lt;generator&gt;</code> element is specified. </p></dd><dt><span class="term"><code class="literal">select</code></span></dt><dd><p>retrieves a primary key, assigned by a database trigger, by selecting the row by some unique key and retrieving the primary key value. </p></dd><dt><span class="term"><code class="literal">foreign</code></span></dt><dd><p>uses the identifier of another associated object. It is usually used in conjunction with a <code class="literal">&lt;one-to-one&gt;</code> primary key association. </p></dd><dt><span class="term"><code class="literal">sequence-identity</code></span></dt><dd><p>a specialized sequence generation strategy that utilizes a database sequence for the actual value generation, but combines this with JDBC3 getGeneratedKeys to return the generated identifier value as part of the insert statement execution. This strategy is only supported on Oracle 10g drivers targeted for JDK 1.4. Comments on these insert statements are disabled due to a bug in the Oracle drivers. </p></dd></dl></div><p>

                </p></div><div class="sect3" lang="fr-FR"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-hilo"/>5.1.4.2. algorithme Hi/lo</h4></div></div></div><p>The <code class="literal">hilo</code> and <code class="literal">seqhilo</code> generators provide two alternate implementations of the hi/lo algorithm. The first implementation requires a "special" database table to hold the next available "hi" value. Where supported, the second uses an Oracle-style sequence. </p><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="hilo"&gt;
                &lt;param name="table"&gt;hi_value&lt;/param&gt;
                &lt;param name="column"&gt;next_value&lt;/param&gt;
                &lt;param name="max_lo"&gt;100&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="seqhilo"&gt;
                &lt;param name="sequence"&gt;hi_value&lt;/param&gt;
                &lt;param name="max_lo"&gt;100&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>Unfortunately, you cannot use <code class="literal">hilo</code> when supplying your own <code class="literal">Connection</code> to Hibernate. When Hibernate uses an application server datasource to obtain connections enlisted with JTA, you must configure the <code class="literal">hibernate.transaction.manager_lookup_class</code>. </p></div><div class="sect3" lang="fr-FR"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-uuid"/>5.1.4.3. UUID algorithm</h4></div></div></div><p>The UUID contains: IP address, startup time of the JVM that is accurate to a quarter second, system time and a counter value that is unique within the JVM. It is not possible to obtain a MAC address or memory address from Java code, so this is the best option without using JNI. </p></div><div class="sect3" lang="fr-FR"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-sequences"/>5.1.4.4. Colonnes identifiantes et séquences</h4></div></div></div><p>For databases that support identity columns (DB2, MySQL, Sybase, MS SQL), you can use <code class="literal">identity</code> key generation. For databases that support sequences (DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB) you can use <code class="literal">sequence</code> style key generation. Both of these strategies require two SQL queries to insert a new object. For example: </p><pre class="programlisting">&lt;id name="id" type="long" column="person_id"&gt;
        &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;person_id_sequence&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><pre class="programlisting">&lt;id name="id" type="long" column="person_id" unsaved-value="0"&gt;
        &lt;generator class="identity"/&gt;
&lt;/id&gt;</pre><p>For cross-platform development, the <code class="literal">native</code> strategy will, depending on the capabilities of the underlying database, choose from the <code class="literal">identity</code>, <code class="literal">sequence</code> and <code class="literal">hilo</code> strategies. </p></div><div class="sect3" lang="fr-FR"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-assigned"/>5.1.4.5. Identifiants assignés</h4></div></div></div><p>If you want the application to assign identifiers, as opposed to having Hibernate generate them, you can use the <code class="literal">assigned</code> generator. This special generator uses the identifier value already assigned to the object's identifier property. The generator is used when the primary key is a natural key instead of a surrogate key. This is the default behavior if you do not specify a <code class="literal">&lt;generator&gt;</code> element. </p><p>The <code class="literal">assigned</code> generator makes Hibernate use <code class="literal">unsaved-value="undefined"</code>. This forces Hibernate to go to the database to determine if an instance is transient or detached, unless there is a version or timestamp property, or you define <code class="literal">Interceptor.isUnsaved()</code>. </p></div><div class="sect3" lang="fr-FR"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-select"/>5.1.4.6. Clefs primaires assignées par trigger</h4></div></div></div><p>Hibernate does not generate DDL with triggers. It is for legacy schemas only. </p><pre class="programlisting">&lt;id name="id" type="long" column="person_id"&gt;
        &lt;generator class="select"&gt;
                &lt;param name="key"&gt;socialSecurityNumber&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>In the above example, there is a unique valued property named <code class="literal">socialSecurityNumber</code>. It is defined by the class, as a natural key and a surrogate key named <code class="literal">person_id</code>, whose value is generated by a trigger. </p></div></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-id-enhanced"/>5.1.5. Enhanced identifier generators</h3></div></div></div><p>Starting with release 3.2.3, there are 2 new generators which represent a re-thinking of 2 different aspects of identifier generation. The first aspect is database portability; the second is optimization Optimization means that you do not have to query the database for every request for a new identifier value. These two new generators are intended to take the place of some of the named generators described above, starting in 3.3.x. However, they are included in the current releases and can be referenced by FQN. </p><p>The first of these new generators is <code class="literal">org.hibernate.id.enhanced.SequenceStyleGenerator</code> which is intended, firstly, as a replacement for the <code class="literal">sequence</code> generator and, secondly, as a better portability generator than <code class="literal">native</code>. This is because <code class="literal">native</code> generally chooses between <code class="literal">identity</code> and <code class="literal">sequence</code> which have largely different semantics that can cause subtle issues in applications eyeing portability. <code class="literal">org.hibernate.id.enhanced.SequenceStyleGenerator</code>, however, achieves portability in a different manner. It chooses between a table or a sequence in the database to store its incrementing values, depending on the capabilities of the dialect being used. The difference between this and <code class="literal">native</code> is that table-based and sequence-based storage have the same exact semantic. In fact, sequences are exactly what Hibernate tries to emulate with its table-based generators. This generator has a number of configuration parameters: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">sequence_name</code> (optional, defaults to <code class="literal">hibernate_sequence</code>): the name of the sequence or table to be used. </p></li><li><p><code class="literal">initial_value</code> (optional, defaults to <code class="literal">1</code>): the initial value to be retrieved from the sequence/table. In sequence creation terms, this is analogous to the clause typically named "STARTS WITH". </p></li><li><p><code class="literal">increment_size</code> (optional - defaults to <code class="literal">1</code>): the value by which subsequent calls to the sequence/table should differ. In sequence creation terms, this is analogous to the clause typically named "INCREMENT BY". </p></li><li><p><code class="literal">force_table_use</code> (optional - defaults to <code class="literal">false</code>): should we force the use of a table as the backing structure even though the dialect might support sequence? </p></li><li><p><code class="literal">value_column</code> (optional - defaults to <code class="literal">next_val</code>): only relevant for table structures, it is the name of the column on the table which is used to hold the value. </p></li><li><p><code class="literal">optimizer</code> (optional - defaults to <code class="literal">none</code>): See <a href="#mapping-declaration-id-enhanced-optimizers" title="5.1.6. Identifier generator optimization">Section 5.1.6, « Identifier generator optimization »</a> </p></li></ul></div><p>
            </p><p>The second of these new generators is <code class="literal">org.hibernate.id.enhanced.TableGenerator</code>, which is intended, firstly, as a replacement for the <code class="literal">table</code> generator, even though it actually functions much more like <code class="literal">org.hibernate.id.MultipleHiLoPerTableGenerator</code>, and secondly, as a re-implementation of <code class="literal">org.hibernate.id.MultipleHiLoPerTableGenerator</code> that utilizes the notion of pluggable optimizers. Essentially this generator defines a table capable of holding a number of different increment values simultaneously by using multiple distinctly keyed rows. This generator has a number of configuration parameters: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">table_name</code> (optional - defaults to <code class="literal">hibernate_sequences</code>): the name of the table to be used. </p></li><li><p><code class="literal">value_column_name</code> (optional - defaults to <code class="literal">next_val</code>): the name of the column on the table that is used to hold the value. </p></li><li><p><code class="literal">segment_column_name</code> (optional - defaults to <code class="literal">sequence_name</code>): the name of the column on the table that is used to hold the "segment key". This is the value which identifies which increment value to use. </p></li><li><p><code class="literal">segment_value</code> (optional - defaults to <code class="literal">default</code>): The "segment key" value for the segment from which we want to pull increment values for this generator. </p></li><li><p><code class="literal">segment_value_length</code> (optional - defaults to <code class="literal">255</code>): Used for schema generation; the column size to create this segment key column. </p></li><li><p><code class="literal">initial_value</code> (optional - defaults to <code class="literal">1</code>): The initial value to be retrieved from the table. </p></li><li><p><code class="literal">increment_size</code> (optional - defaults to <code class="literal">1</code>): The value by which subsequent calls to the table should differ. </p></li><li><p><code class="literal">optimizer</code> (optional - defaults to <code class="literal"/>): See <a href="#mapping-declaration-id-enhanced-optimizers" title="5.1.6. Identifier generator optimization">Section 5.1.6, « Identifier generator optimization »</a> </p></li></ul></div><p>
            </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-id-enhanced-optimizers"/>5.1.6. Identifier generator optimization</h3></div></div></div><p>For identifier generators that store values in the database, it is inefficient for them to hit the database on each and every call to generate a new identifier value. Instead, you can group a bunch of them in memory and only hit the database when you have exhausted your in-memory value group. This is the role of the pluggable optimizers. Currently only the two enhanced generators (<a href="#mapping-declaration-id-enhanced" title="5.1.5. Enhanced identifier generators">Section 5.1.5, « Enhanced identifier generators »</a> support this operation. </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">none</code> (generally this is the default if no optimizer was specified): this will not perform any optimizations and hit the database for each and every request. </p></li><li><p><code class="literal">hilo</code>: applies a hi/lo algorithm around the database retrieved values. The values from the database for this optimizer are expected to be sequential. The values retrieved from the database structure for this optimizer indicates the "group number". The <code class="literal">increment_size</code> is multiplied by that value in memory to define a group "hi value". </p></li><li><p><code class="literal">pooled</code>: as with the case of <code class="literal">hilo</code>, this optimizer attempts to minimize the number of hits to the database. Here, however, we simply store the starting value for the "next group" into the database structure rather than a sequential value in combination with an in-memory grouping algorithm. Here, <code class="literal">increment_size</code> refers to the values coming from the database. </p></li></ul></div><p>
            </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-compositeid"/>5.1.7. composite-id</h3></div></div></div><pre class="programlisting">&lt;composite-id
        name="propertyName"
        class="ClassName"
        mapped="true|false"
        access="field|property|ClassName"&gt;
        node="element-name|."

        &lt;key-property name="propertyName" type="typename" column="column_name"/&gt;
        &lt;key-many-to-one name="propertyName class="ClassName" column="column_name"/&gt;
        ......
&lt;/composite-id&gt;</pre><p>A table with a composite key can be mapped with multiple properties of the class as identifier properties. The <code class="literal">&lt;composite-id&gt;</code> element accepts <code class="literal">&lt;key-property&gt;</code> property mappings and <code class="literal">&lt;key-many-to-one&gt;</code> mappings as child elements. </p><pre class="programlisting">&lt;composite-id&gt;
        &lt;key-property name="medicareNumber"/&gt;
        &lt;key-property name="dependent"/&gt;
&lt;/composite-id&gt;</pre><p>The persistent class <span class="emphasis"><em>must</em></span> override <code class="literal">equals()</code> and <code class="literal">hashCode()</code> to implement composite identifier equality. It must also implement <code class="literal">Serializable</code>. </p><p>Unfortunately, this approach means that a persistent object is its own identifier. There is no convenient "handle" other than the object itself. You must instantiate an instance of the persistent class itself and populate its identifier properties before you can <code class="literal">load()</code> the persistent state associated with a composite key. We call this approach an <span class="emphasis"><em>embedded</em></span> composite identifier, and discourage it for serious applications. </p><p>Une seconde approche, appelée identifiant composé <span class="emphasis"><em>mappé</em></span>, consiste à encapsuler les propriétés identifiantes (celles contenues dans <code class="literal">&lt;composite-id&gt;</code>) dans une classe particulière. </p><pre class="programlisting">&lt;composite-id class="MedicareId" mapped="true"&gt;
        &lt;key-property name="medicareNumber"/&gt;
        &lt;key-property name="dependent"/&gt;
&lt;/composite-id&gt;</pre><p>In this example, both the composite identifier class, <code class="literal">MedicareId</code>, and the entity class itself have properties named <code class="literal">medicareNumber</code> and <code class="literal">dependent</code>. The identifier class must override <code class="literal">equals()</code> and <code class="literal">hashCode()</code> and implement <code class="literal">Serializable</code>. The main disadvantage of this approach is code duplication. </p><p>Les attributs suivants servent à configurer un identifiant composé mappé : </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">mapped</code> (optional - defaults to <code class="literal">false</code>): indicates that a mapped composite identifier is used, and that the contained property mappings refer to both the entity class and the composite identifier class. </p></li><li><p><code class="literal">class</code> (optional - but required for a mapped composite identifier): the class used as a composite identifier. </p></li></ul></div><p>We will describe a third, even more convenient approach, where the composite identifier is implemented as a component class in <a href="#components-compositeid" title="8.4. Utiliser un composant comme identifiant">Section 8.4, « Utiliser un composant comme identifiant »</a>. The attributes described below apply only to this alternative approach: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">name</code> (optional - required for this approach): a property of component type that holds the composite identifier. Please see chapter 9 for more information. </p></li><li><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></li><li><p><code class="literal">class</code> (optional - defaults to the property type determined by reflection): the component class used as a composite identifier. Please see the next section for more information. </p></li></ul></div><p>The third approach, an <span class="emphasis"><em>identifier component</em></span>, is recommended for almost all applications. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-discriminator"/>5.1.8. Discriminator</h3></div></div></div><p>The <code class="literal">&lt;discriminator&gt;</code> element is required for polymorphic persistence using the table-per-class-hierarchy mapping strategy. It declares a discriminator column of the table. The discriminator column contains marker values that tell the persistence layer what subclass to instantiate for a particular row. A restricted set of types can be used: <code class="literal">string</code>, <code class="literal">character</code>, <code class="literal">integer</code>, <code class="literal">byte</code>, <code class="literal">short</code>, <code class="literal">boolean</code>, <code class="literal">yes_no</code>, <code class="literal">true_false</code>. </p><div class="programlistingco"><pre class="programlisting">&lt;discriminator
        column="discriminator_column"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        type="discriminator_type"                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        force="true|false"                                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        insert="true|false"                                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        formula="arbitrary sql expression"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional - defaults to <code class="literal">class</code>): the name of the discriminator column. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">type</code> (optional - defaults to <code class="literal">string</code>): a name that indicates the Hibernate type </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">force</code> (optional - defaults to <code class="literal">false</code>): "forces" Hibernate to specify the allowed discriminator values, even when retrieving all instances of the root class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">insert</code> (optional - defaults to <code class="literal">true</code>): set this to <code class="literal">false</code> if your discriminator column is also part of a mapped composite identifier. It tells Hibernate not to include the column in SQL <code class="literal">INSERTs</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">formula</code> (optional): an arbitrary SQL expression that is executed when a type has to be evaluated. It allows content-based discrimination. </p></td></tr></table></div></div><p>Les véritables valeurs de la colonne discriminante sont spécifiées par l'attribut <code class="literal">discriminator-value</code> des éléments <code class="literal">&lt;class&gt;</code> et <code class="literal">&lt;subclass&gt;</code>. </p><p>The <code class="literal">force</code> attribute is only useful if the table contains rows with "extra" discriminator values that are not mapped to a persistent class. This will not usually be the case. </p><p>The <code class="literal">formula</code> attribute allows you to declare an arbitrary SQL expression that will be used to evaluate the type of a row. For example: </p><pre class="programlisting">&lt;discriminator
    formula="case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end"
    type="integer"/&gt;</pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-version"/>5.1.9. Version (optional)</h3></div></div></div><p>The <code class="literal">&lt;version&gt;</code> element is optional and indicates that the table contains versioned data. This is particularly useful if you plan to use <span class="emphasis"><em>long transactions</em></span>. See below for more information: </p><div class="programlistingco"><pre class="programlisting">&lt;version
        column="version_column"                                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        name="propertyName"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        type="typename"                                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        access="field|property|ClassName"                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        unsaved-value="null|negative|undefined"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        generated="never|always"                                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        insert="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        node="element-name|@attribute-name|element/@attribute|."
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional - defaults to the property name): the name of the column holding the version number. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the name of a property of the persistent class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">type</code> (optional - defaults to <code class="literal">integer</code>): the type of the version number. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses to access the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unsaved-value</code> (optional - defaults to <code class="literal">undefined</code>): a version property value that indicates that an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session. <code class="literal">Undefined</code> specifies that the identifier property value should be used. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">generated</code> (optional - defaults to <code class="literal">never</code>): specifies that this version property value is generated by the database. See the discussion of <a href="#mapping-generated" title="5.6. Generated properties">generated properties</a> for more information. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">insert</code> (optional - defaults to <code class="literal">true</code>): specifies whether the version column should be included in SQL insert statements. It can be set to <code class="literal">false</code> if the database column is defined with a default value of <code class="literal">0</code>. </p></td></tr></table></div></div><p>Version numbers can be of Hibernate type <code class="literal">long</code>, <code class="literal">integer</code>, <code class="literal">short</code>, <code class="literal">timestamp</code> or <code class="literal">calendar</code>. </p><p>A version or timestamp property should never be null for a detached instance. Hibernate will detect any instance with a null version or timestamp as transient, irrespective of what other <code class="literal">unsaved-value</code> strategies are specified. <span class="emphasis"><em>Declaring a nullable version or timestamp property is an easy way to avoid problems with transitive reattachment in Hibernate. It is especially useful for people using assigned identifiers or composite keys</em></span>. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-timestamp"/>5.1.10. Timestamp (optional)</h3></div></div></div><p>The optional <code class="literal">&lt;timestamp&gt;</code> element indicates that the table contains timestamped data. This provides an alternative to versioning. Timestamps are a less safe implementation of optimistic locking. However, sometimes the application might use the timestamps in other ways. </p><div class="programlistingco"><pre class="programlisting">&lt;timestamp
        column="timestamp_column"                                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        name="propertyName"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        access="field|property|ClassName"                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        unsaved-value="null|undefined"                               <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        source="vm|db"                                               <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        generated="never|always"                                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        node="element-name|@attribute-name|element/@attribute|."
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional - defaults to the property name): the name of a column holding the timestamp. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the name of a JavaBeans style property of Java type <code class="literal">Date</code> or <code class="literal">Timestamp</code> of the persistent class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unsaved-value</code> (optional - defaults to <code class="literal">null</code>): a version property value that indicates that an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session. <code class="literal">Undefined</code> specifies that the identifier property value should be used. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">source</code> (optional - defaults to <code class="literal">vm</code>): Where should Hibernate retrieve the timestamp value from? From the database, or from the current JVM? Database-based timestamps incur an overhead because Hibernate must hit the database in order to determine the "next value". It is safer to use in clustered environments. Not all <code class="literal">Dialects</code> are known to support the retrieval of the database's current timestamp. Others may also be unsafe for usage in locking due to lack of precision (Oracle 8, for example). </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">generated</code> (optional - defaults to <code class="literal">never</code>): specifies that this timestamp property value is actually generated by the database. See the discussion of <a href="#mapping-generated" title="5.6. Generated properties">generated properties</a> for more information. </p></td></tr></table></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p><code class="literal">&lt;Timestamp&gt;</code> is equivalent to <code class="literal">&lt;version type="timestamp"&gt;</code>. And <code class="literal">&lt;timestamp source="db"&gt;</code> is equivalent to <code class="literal">&lt;version type="dbtimestamp"&gt;</code> </p></div></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-property"/>5.1.11. Property</h3></div></div></div><p>The <code class="literal">&lt;property&gt;</code> element declares a persistent JavaBean style property of the class. </p><div class="programlistingco"><pre class="programlisting">&lt;property
        name="propertyName"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        column="column_name"                                         <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        type="typename"                                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        update="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        insert="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        formula="arbitrary SQL expression"                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        access="field|property|ClassName"                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        lazy="true|false"                                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        unique="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
        not-null="true|false"                                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/9.png" alt="(9)"/></span>
        optimistic-lock="true|false"                                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/10.png" alt="(10)"/></span>
        generated="never|insert|always"                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/11.png" alt="(11)"/></span>
        node="element-name|@attribute-name|element/@attribute|."
        index="index_name"
        unique_key="unique_key_id"
        length="L"
        precision="P"
        scale="S"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code> : nom de la propriété, avec une lettre initiale en minuscule. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional - defaults to the property name): the name of the mapped database table column. This can also be specified by nested <code class="literal">&lt;column&gt;</code> element(s). </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">type</code> (optionnel) : nom indiquant le type Hibernate. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">update, insert</code> (optional - defaults to <code class="literal">true</code>): specifies that the mapped columns should be included in SQL <code class="literal">UPDATE</code> and/or <code class="literal">INSERT</code> statements. Setting both to <code class="literal">false</code> allows a pure "derived" property whose value is initialized from some other property that maps to the same column(s), or by a trigger or other application. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">formula</code> (optionnel) : une expression SQL qui définit la valeur pour une propriété <span class="emphasis"><em>calculée</em></span>. Les propriétés calculées ne possède pas leur propre mapping. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional - defaults to <code class="literal">false</code>): specifies that this property should be fetched lazily when the instance variable is first accessed. It requires build-time bytecode instrumentation. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unique</code> (optional): enables the DDL generation of a unique constraint for the columns. Also, allow this to be the target of a <code class="literal">property-ref</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/9.png" alt="9" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">not-null</code> (optional): enables the DDL generation of a nullability constraint for the columns. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/10.png" alt="10" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">true</code>): specifies that updates to this property do or do not require acquisition of the optimistic lock. In other words, it determines if a version increment should occur when this property is dirty. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/11.png" alt="11" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">generated</code> (optional - defaults to <code class="literal">never</code>): specifies that this property value is actually generated by the database. See the discussion of <a href="#mapping-generated" title="5.6. Generated properties">generated properties</a> for more information. </p></td></tr></table></div></div><p><span class="emphasis"><em>typename</em></span> peut être: </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>The name of a Hibernate basic type: <code class="literal">integer, string, character, date, timestamp, float, binary, serializable, object, blob</code> etc. </p></li><li><p>The name of a Java class with a default basic type: <code class="literal">int, float, char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</code> etc. </p></li><li><p>Nom d'une classe Java sérialisable. </p></li><li><p>The class name of a custom type: <code class="literal">com.illflow.type.MyCustomType</code> etc. </p></li></ol></div><p>If you do not specify a type, Hibernate will use reflection upon the named property and guess the correct Hibernate type. Hibernate will attempt to interpret the name of the return class of the property getter using, in order, rules 2, 3, and 4. In certain cases you will need the <code class="literal">type</code> attribute. For example, to distinguish between <code class="literal">Hibernate.DATE</code> and <code class="literal">Hibernate.TIMESTAMP</code>, or to specify a custom type. </p><p>The <code class="literal">access</code> attribute allows you to control how Hibernate accesses the property at runtime. By default, Hibernate will call the property get/set pair. If you specify <code class="literal">access="field"</code>, Hibernate will bypass the get/set pair and access the field directly using reflection. You can specify your own strategy for property access by naming a class that implements the interface <code class="literal">org.hibernate.property.PropertyAccessor</code>. </p><p>A powerful feature is derived properties. These properties are by definition read-only. The property value is computed at load time. You declare the computation as an SQL expression. This then translates to a <code class="literal">SELECT</code> clause subquery in the SQL query that loads an instance: </p><pre class="programlisting">
&lt;property name="totalPrice"
    formula="( SELECT SUM (li.quantity*p.price) FROM LineItem li, Product p
                WHERE li.productId = p.productId
                AND li.customerId = customerId
                AND li.orderNumber = orderNumber )"/&gt;</pre><p>You can reference the entity table by not declaring an alias on a particular column. This would be <code class="literal">customerId</code> in the given example. You can also use the nested <code class="literal">&lt;formula&gt;</code> mapping element if you do not want to use the attribute. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-manytoone"/>5.1.12. Many-to-one</h3></div></div></div><p>An ordinary association to another persistent class is declared using a <code class="literal">many-to-one</code> element. The relational model is a many-to-one association; a foreign key in one table is referencing the primary key column(s) of the target table. </p><div class="programlistingco"><pre class="programlisting">&lt;many-to-one
        name="propertyName"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        column="column_name"                                         <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        class="ClassName"                                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        cascade="cascade_style"                                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        fetch="join|select"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        update="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        insert="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        property-ref="propertyNameFromAssociatedClass"               <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        access="field|property|ClassName"                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
        unique="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/9.png" alt="(9)"/></span>
        not-null="true|false"                                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/10.png" alt="(10)"/></span>
        optimistic-lock="true|false"                                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/11.png" alt="(11)"/></span>
        lazy="proxy|no-proxy|false"                                  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/12.png" alt="(12)"/></span>
        not-found="ignore|exception"                                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/13.png" alt="(13)"/></span>
        entity-name="EntityName"                                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/14.png" alt="(14)"/></span>
        formula="arbitrary SQL expression"                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/15.png" alt="(15)"/></span>
        node="element-name|@attribute-name|element/@attribute|."
        embed-xml="true|false"
        index="index_name"
        unique_key="unique_key_id"
        foreign-key="foreign_key_name"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the name of the property. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional): the name of the foreign key column. This can also be specified by nested <code class="literal">&lt;column&gt;</code> element(s). </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">class</code> (optional - defaults to the property type determined by reflection): the name of the associated class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">cascade</code> (optional): specifies which operations should be cascaded from the parent object to the associated object. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">fetch</code> (optional - defaults to <code class="literal">select</code>): chooses between outer-join fetching or sequential select fetching. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">update, insert</code> (optional - defaults to <code class="literal">true</code>): specifies that the mapped columns should be included in SQL <code class="literal">UPDATE</code> and/or <code class="literal">INSERT</code> statements. Setting both to <code class="literal">false</code> allows a pure "derived" association whose value is initialized from another property that maps to the same column(s), or by a trigger or other application. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">property-ref</code> (optional): the name of a property of the associated class that is joined to this foreign key. If not specified, the primary key of the associated class is used. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/9.png" alt="9" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unique</code> (optional): enables the DDL generation of a unique constraint for the foreign-key column. By allowing this to be the target of a <code class="literal">property-ref</code>, you can make the association multiplicity one-to-one. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/10.png" alt="10" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">not-null</code> (optional): enables the DDL generation of a nullability constraint for the foreign key columns. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/11.png" alt="11" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">true</code>): specifies that updates to this property do or do not require acquisition of the optimistic lock. In other words, it determines if a version increment should occur when this property is dirty. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/12.png" alt="12" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional - defaults to <code class="literal">proxy</code>): by default, single point associations are proxied. <code class="literal">lazy="no-proxy"</code> specifies that the property should be fetched lazily when the instance variable is first accessed. This requires build-time bytecode instrumentation. <code class="literal">lazy="false"</code> specifies that the association will always be eagerly fetched. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/13.png" alt="13" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">not-found</code> (optional - defaults to <code class="literal">exception</code>): specifies how foreign keys that reference missing rows will be handled. <code class="literal">ignore</code> will treat a missing row as a null association. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/14.png" alt="14" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">entity-name</code> (optional): the entity name of the associated class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/15.png" alt="15" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">formula</code> (optionnel) : une expression SQL qui définit la valeur pour une clé étrangère calculée. </p></td></tr></table></div></div><p>Setting a value of the <code class="literal">cascade</code> attribute to any meaningful value other than <code class="literal">none</code> will propagate certain operations to the associated object. The meaningful values are divided into three categories. First, basic operations, which include: <code class="literal">persist, merge, delete, save-update, evict, replicate, lock and refresh</code>; second, special values: <code class="literal">delete-orphan</code>; and third,<code class="literal">all</code> comma-separated combinations of operation names: <code class="literal">cascade="persist,merge,evict"</code> or <code class="literal">cascade="all,delete-orphan"</code>. See <a href="#objectstate-transitive" title="10.11. Persistance transitive">Section 10.11, « Persistance transitive »</a> for a full explanation. Note that single valued, many-to-one and one-to-one, associations do not support orphan delete. </p><p>Here is an example of a typical <code class="literal">many-to-one</code> declaration: </p><pre class="programlisting">&lt;many-to-one name="product" class="Product" column="PRODUCT_ID"/&gt;</pre><p>The <code class="literal">property-ref</code> attribute should only be used for mapping legacy data where a foreign key refers to a unique key of the associated table other than the primary key. This is a complicated and confusing relational model. For example, if the <code class="literal">Product</code> class had a unique serial number that is not the primary key. The <code class="literal">unique</code> attribute controls Hibernate's DDL generation with the SchemaExport tool. </p><pre class="programlisting">&lt;property name="serialNumber" unique="true" type="string" column="SERIAL_NUMBER"/&gt;</pre><p>Ainsi le mapping pour <code class="literal">OrderItem</code> peut utiliser : </p><pre class="programlisting">&lt;many-to-one name="product" property-ref="serialNumber" column="PRODUCT_SERIAL_NUMBER"/&gt;</pre><p>This is not encouraged, however. </p><p>Si la clef unique référencée comprend des propriétés multiples de l'entité associée, vous devez mapper ces propriétés à l'intérieur d'un élément <code class="literal">&lt;properties&gt;</code>. </p><p>If the referenced unique key is the property of a component, you can specify a property path: </p><pre class="programlisting">&lt;many-to-one name="owner" property-ref="identity.ssn" column="OWNER_SSN"/&gt;</pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-onetoone"/>5.1.13. One-to-one</h3></div></div></div><p><code class="literal">name</code> : Le nom de la propriété. </p><div class="programlistingco"><pre class="programlisting">&lt;one-to-one
        name="propertyName"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        class="ClassName"                                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        cascade="cascade_style"                                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        constrained="true|false"                                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        fetch="join|select"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        property-ref="propertyNameFromAssociatedClass"               <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        access="field|property|ClassName"                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        formula="any SQL expression"                                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
        lazy="proxy|no-proxy|false"                                  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/9.png" alt="(9)"/></span>
        entity-name="EntityName"                                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/10.png" alt="(10)"/></span>
        node="element-name|@attribute-name|element/@attribute|."
        embed-xml="true|false"
        foreign-key="foreign_key_name"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the name of the property. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">class</code> (optional - defaults to the property type determined by reflection): the name of the associated class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">cascade</code> (optional): specifies which operations should be cascaded from the parent object to the associated object. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">constrained</code> (optional): specifies that a foreign key constraint on the primary key of the mapped table and references the table of the associated class. This option affects the order in which <code class="literal">save()</code> and <code class="literal">delete()</code> are cascaded, and determines whether the association can be proxied. It is also used by the schema export tool. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">fetch</code> (optional - defaults to <code class="literal">select</code>): chooses between outer-join fetching or sequential select fetching. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">property-ref</code> (optional): the name of a property of the associated class that is joined to the primary key of this class. If not specified, the primary key of the associated class is used. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">formula</code> (optional): almost all one-to-one associations map to the primary key of the owning entity. If this is not the case, you can specify another column, columns or expression to join on using an SQL formula. See <code class="literal">org.hibernate.test.onetooneformula</code> for an example. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/9.png" alt="9" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional - defaults to <code class="literal">proxy</code>): by default, single point associations are proxied. <code class="literal">lazy="no-proxy"</code> specifies that the property should be fetched lazily when the instance variable is first accessed. It requires build-time bytecode instrumentation. <code class="literal">lazy="false"</code> specifies that the association will always be eagerly fetched. <span class="emphasis"><em>Note that if <code class="literal">constrained="false"</code>, proxying is impossible and Hibernate will eagerly fetch the association</em></span>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/10.png" alt="10" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">entity-name</code> (optional): the entity name of the associated class. </p></td></tr></table></div></div><p>There are two varieties of one-to-one associations: </p><div class="itemizedlist"><ul><li><p>association par clef étrangère unique </p></li><li><p>Les associations par clef primaire ne nécessitent pas une colonne supplémentaire en table ; si deux lignes sont liés par l'association alors les deux lignes de la table partagent la même valeur de clef primaire. Donc si vous voulez que deux objets soient liés par une association par clef primaire, vous devez faire en sorte qu'on leur assigne la même valeur d'identifiant ! </p></li></ul></div><p>Primary key associations do not need an extra table column. If two rows are related by the association, then the two table rows share the same primary key value. To relate two objects by a primary key association, ensure that they are assigned the same identifier value. </p><p>For a primary key association, add the following mappings to <code class="literal">Employee</code> and <code class="literal">Person</code> respectively: </p><pre class="programlisting">&lt;one-to-one name="person" class="Person"/&gt;</pre><pre class="programlisting">&lt;one-to-one name="employee" class="Employee" constrained="true"/&gt;</pre><p>Ensure that the primary keys of the related rows in the PERSON and EMPLOYEE tables are equal. You use a special Hibernate identifier generation strategy called <code class="literal">foreign</code>: </p><pre class="programlisting">&lt;class name="person" table="PERSON"&gt;
    &lt;id name="id" column="PERSON_ID"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"&gt;employee&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    ...
    &lt;one-to-one name="employee"
        class="Employee"
        constrained="true"/&gt;
&lt;/class&gt;</pre><p>A newly saved instance of <code class="literal">Person</code> is assigned the same primary key value as the <code class="literal">Employee</code> instance referred with the <code class="literal">employee</code> property of that <code class="literal">Person</code>. </p><p>Alternatively, a foreign key with a unique constraint, from <code class="literal">Employee</code> to <code class="literal">Person</code>, can be expressed as: </p><pre class="programlisting">&lt;many-to-one name="person" class="Person" column="PERSON_ID" unique="true"/&gt;</pre><p>This association can be made bidirectional by adding the following to the <code class="literal">Person</code> mapping: </p><pre class="programlisting">&lt;one-to-one name="employee" class="Employee" property-ref="person"/&gt;</pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-naturalid"/>5.1.14. Natural-id</h3></div></div></div><pre class="programlisting">&lt;natural-id mutable="true|false"/&gt;
        &lt;property ... /&gt;
        &lt;many-to-one ... /&gt;
        ......
&lt;/natural-id&gt;</pre><p>Although we recommend the use of surrogate keys as primary keys, you should try to identify natural keys for all entities. A natural key is a property or combination of properties that is unique and non-null. It is also immutable. Map the properties of the natural key inside the <code class="literal">&lt;natural-id&gt;</code> element. Hibernate will generate the necessary unique key and nullability constraints and, as a result, your mapping will be more self-documenting. </p><p>It is recommended that you implement <code class="literal">equals()</code> and <code class="literal">hashCode()</code> to compare the natural key properties of the entity. </p><p>This mapping is not intended for use with entities that have natural primary keys. </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">mutable</code> (optional - defaults to <code class="literal">false</code>): by default, natural identifier properties are assumed to be immutable (constant). </p></li></ul></div></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-component"/>5.1.15. Component and dynamic-component</h3></div></div></div><p>The <code class="literal">&lt;component&gt;</code> element maps properties of a child object to columns of the table of a parent class. Components can, in turn, declare their own properties, components or collections. See the "Component" examples below: </p><div class="programlistingco"><pre class="programlisting">&lt;component
        name="propertyName"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        class="className"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        insert="true|false"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        update="true|false"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        access="field|property|ClassName"   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        lazy="true|false"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        optimistic-lock="true|false"        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        unique="true|false"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
        node="element-name|."
&gt;

        &lt;property ...../&gt;
        &lt;many-to-one .... /&gt;
        ........
&lt;/component&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the name of the property. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">class</code> (optional - defaults to the property type determined by reflection): the name of the component (child) class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">insert</code>: do the mapped columns appear in SQL <code class="literal">INSERTs</code>? </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">update</code>: do the mapped columns appear in SQL <code class="literal">UPDATEs</code>? </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional - defaults to <code class="literal">false</code>): specifies that this component should be fetched lazily when the instance variable is first accessed. It requires build-time bytecode instrumentation. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">true</code>): specifies that updates to this component either do or do not require acquisition of the optimistic lock. It determines if a version increment should occur when this property is dirty. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unique</code> (optional - defaults to <code class="literal">false</code>): specifies that a unique constraint exists upon all mapped columns of the component. </p></td></tr></table></div></div><p>L'élément <code class="literal">&lt;component&gt;</code> permet de déclarer sous-élément <code class="literal">&lt;parent&gt;</code> qui associe une propriété de la classe composant comme une référence arrière vers l'entité contenante. </p><p>L'élément <code class="literal">&lt;dynamic-component&gt;</code> permet à une <code class="literal">Map</code> d'être mappée comme un composant, quand les noms de la propriété font référence aux clefs de cette Map, voir <a href="#components-dynamic" title="8.5. Composant Dynamique">Section 8.5, « Composant Dynamique »</a>. </p><p>The <code class="literal">&lt;dynamic-component&gt;</code> element allows a <code class="literal">Map</code> to be mapped as a component, where the property names refer to keys of the map. See <a href="#components-dynamic" title="8.5. Composant Dynamique">Section 8.5, « Composant Dynamique »</a> for more information. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-properties"/>5.1.16. Properties</h3></div></div></div><p>The <code class="literal">&lt;properties&gt;</code> element allows the definition of a named, logical grouping of the properties of a class. The most important use of the construct is that it allows a combination of properties to be the target of a <code class="literal">property-ref</code>. It is also a convenient way to define a multi-column unique constraint. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;properties
        name="logicalName"                  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        insert="true|false"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        update="true|false"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        optimistic-lock="true|false"        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        unique="true|false"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
&gt;

        &lt;property ...../&gt;
        &lt;many-to-one .... /&gt;
        ........
&lt;/properties&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the logical name of the grouping. It is <span class="emphasis"><em>not</em></span> an actual property name. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">insert</code>: do the mapped columns appear in SQL <code class="literal">INSERTs</code>? </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">update</code>: do the mapped columns appear in SQL <code class="literal">UPDATEs</code>? </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">true</code>): specifies that updates to these properties either do or do not require acquisition of the optimistic lock. It determines if a version increment should occur when these properties are dirty. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unique</code> (optional - defaults to <code class="literal">false</code>): specifies that a unique constraint exists upon all mapped columns of the component. </p></td></tr></table></div></div><p>Alors nous pourrions avoir une association sur des données d'un ancien système (legacy) qui font référence à cette clef unique de la table <code class="literal">Person</code> au lieu de la clef primaire : </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="personNumber"/&gt;

    ...
    &lt;properties name="name"
            unique="true" update="false"&gt;
        &lt;property name="firstName"/&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="lastName"/&gt;
    &lt;/properties&gt;
&lt;/class&gt;</pre><p>You might have some legacy data association that refers to this unique key of the <code class="literal">Person</code> table, instead of to the primary key: </p><pre class="programlisting">&lt;many-to-one name="person"
         class="Person" property-ref="name"&gt;
    &lt;column name="firstName"/&gt;
    &lt;column name="initial"/&gt;
    &lt;column name="lastName"/&gt;
&lt;/many-to-one&gt;</pre><p>The use of this outside the context of mapping legacy data is not recommended. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-subclass"/>5.1.17. Subclass</h3></div></div></div><p>Polymorphic persistence requires the declaration of each subclass of the root persistent class. For the table-per-class-hierarchy mapping strategy, the <code class="literal">&lt;subclass&gt;</code> declaration is used. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;subclass
        name="ClassName"                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        discriminator-value="discriminator_value"     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        proxy="ProxyInterface"                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        lazy="true|false"                             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        dynamic-update="true|false"
        dynamic-insert="true|false"
        entity-name="EntityName"
        node="element-name"
        extends="SuperclassName"&gt;

        &lt;property .... /&gt;
        .....
&lt;/subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the fully qualified class name of the subclass. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">discriminator-value</code> (optional - defaults to the class name): a value that distinguishes individual subclasses. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">proxy</code> (optional): specifies a class or interface used for lazy initializing proxies. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional - defaults to <code class="literal">true</code>): setting <code class="literal">lazy="false"</code> disables the use of lazy fetching. </p></td></tr></table></div></div><p>Each subclass declares its own persistent properties and subclasses. <code class="literal">&lt;version&gt;</code> and <code class="literal">&lt;id&gt;</code> properties are assumed to be inherited from the root class. Each subclass in a hierarchy must define a unique <code class="literal">discriminator-value</code>. If this is not specified, the fully qualified Java class name is used. </p><p>For information about inheritance mappings see <a href="#inheritance" title="Chapitre 9. Inheritance mapping">Chapitre 9, <i xmlns:xlink="http://www.w3.org/1999/xlink">Inheritance mapping</i></a>. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-joinedsubclass"/>5.1.18. Joined-subclass</h3></div></div></div><p>Each subclass can also be mapped to its own table. This is called the table-per-subclass mapping strategy. An inherited state is retrieved by joining with the table of the superclass. To do this you use the <code class="literal">&lt;joined-subclass&gt;</code> element. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;joined-subclass
        name="ClassName"                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        table="tablename"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        proxy="ProxyInterface"              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        lazy="true|false"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        dynamic-update="true|false"
        dynamic-insert="true|false"
        schema="schema"
        catalog="catalog"
        extends="SuperclassName"
        persister="ClassName"
        subselect="SQL expression"
        entity-name="EntityName"
        node="element-name"&gt;

        &lt;key .... &gt;

        &lt;property .... /&gt;
        .....
&lt;/joined-subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the fully qualified class name of the subclass. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">table</code>: the name of the subclass table. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">proxy</code> (optional): specifies a class or interface to use for lazy initializing proxies. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional, defaults to <code class="literal">true</code>): setting <code class="literal">lazy="false"</code> disables the use of lazy fetching. </p></td></tr></table></div></div><p>A discriminator column is not required for this mapping strategy. Each subclass must, however, declare a table column holding the object identifier using the <code class="literal">&lt;key&gt;</code> element. The mapping at the start of the chapter would then be re-written as: </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

        &lt;class name="Cat" table="CATS"&gt;
                &lt;id name="id" column="uid" type="long"&gt;
                        &lt;generator class="hilo"/&gt;
                &lt;/id&gt;
                &lt;property name="birthdate" type="date"/&gt;
                &lt;property name="color" not-null="true"/&gt;
                &lt;property name="sex" not-null="true"/&gt;
                &lt;property name="weight"/&gt;
                &lt;many-to-one name="mate"/&gt;
                &lt;set name="kittens"&gt;
                        &lt;key column="MOTHER"/&gt;
                        &lt;one-to-many class="Cat"/&gt;
                &lt;/set&gt;
                &lt;joined-subclass name="DomesticCat" table="DOMESTIC_CATS"&gt;
                    &lt;key column="CAT"/&gt;
                    &lt;property name="name" type="string"/&gt;
                &lt;/joined-subclass&gt;
        &lt;/class&gt;

        &lt;class name="eg.Dog"&gt;
                &lt;!-- mapping for Dog could go here --&gt;
        &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>For information about inheritance mappings see <a href="#inheritance" title="Chapitre 9. Inheritance mapping">Chapitre 9, <i xmlns:xlink="http://www.w3.org/1999/xlink">Inheritance mapping</i></a>. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-unionsubclass"/>5.1.19. Union-subclass</h3></div></div></div><p>A third option is to map only the concrete classes of an inheritance hierarchy to tables. This is called the table-per-concrete-class strategy. Each table defines all persistent states of the class, including the inherited state. In Hibernate, it is not necessary to explicitly map such inheritance hierarchies. You can map each class with a separate <code class="literal">&lt;class&gt;</code> declaration. However, if you wish use polymorphic associations (e.g. an association to the superclass of your hierarchy), you need to use the <code class="literal">&lt;union-subclass&gt;</code> mapping. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;union-subclass
        name="ClassName"                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        table="tablename"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        proxy="ProxyInterface"              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        lazy="true|false"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        dynamic-update="true|false"
        dynamic-insert="true|false"
        schema="schema"
        catalog="catalog"
        extends="SuperclassName"
        abstract="true|false"
        persister="ClassName"
        subselect="SQL expression"
        entity-name="EntityName"
        node="element-name"&gt;

        &lt;property .... /&gt;
        .....
&lt;/union-subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the fully qualified class name of the subclass. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">table</code>: the name of the subclass table. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">proxy</code> (optional): specifies a class or interface to use for lazy initializing proxies. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional, defaults to <code class="literal">true</code>): setting <code class="literal">lazy="false"</code> disables the use of lazy fetching. </p></td></tr></table></div></div><p>Aucune colonne discriminante ou colonne clef n'est requise pour cette stratégie de mapping. </p><p>For information about inheritance mappings see <a href="#inheritance" title="Chapitre 9. Inheritance mapping">Chapitre 9, <i xmlns:xlink="http://www.w3.org/1999/xlink">Inheritance mapping</i></a>. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-join"/>5.1.20. Join</h3></div></div></div><p>Using the <code class="literal">&lt;join&gt;</code> element, it is possible to map properties of one class to several tables that have a one-to-one relationship. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;join
        table="tablename"                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        schema="owner"                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        catalog="catalog"                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        fetch="join|select"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        inverse="true|false"                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        optional="true|false"&gt;                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>

        &lt;key ... /&gt;

        &lt;property ... /&gt;
        ...
&lt;/join&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">table</code>: the name of the joined table. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">schema</code> (optional): overrides the schema name specified by the root <code class="literal">&lt;hibernate-mapping&gt;</code> element. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">catalog</code> (optional): overrides the catalog name specified by the root <code class="literal">&lt;hibernate-mapping&gt;</code> element. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">fetch</code> (optional - defaults to <code class="literal">join</code>): if set to <code class="literal">join</code>, the default, Hibernate will use an inner join to retrieve a <code class="literal">&lt;join&gt;</code> defined by a class or its superclasses. It will use an outer join for a <code class="literal">&lt;join&gt;</code> defined by a subclass. If set to <code class="literal">select</code> then Hibernate will use a sequential select for a <code class="literal">&lt;join&gt;</code> defined on a subclass. This will be issued only if a row represents an instance of the subclass. Inner joins will still be used to retrieve a <code class="literal">&lt;join&gt;</code> defined by the class and its superclasses. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">inverse</code> (optional - defaults to <code class="literal">false</code>): if enabled, Hibernate will not insert or update the properties defined by this join. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optional</code> (optional - defaults to <code class="literal">false</code>): if enabled, Hibernate will insert a row only if the properties defined by this join are non-null. It will always use an outer join to retrieve the properties. </p></td></tr></table></div></div><p>For example, address information for a person can be mapped to a separate table while preserving value type semantics for all properties: </p><pre class="programlisting">&lt;class name="Person"
    table="PERSON"&gt;

    &lt;id name="id" column="PERSON_ID"&gt;...&lt;/id&gt;

    &lt;join table="ADDRESS"&gt;
        &lt;key column="ADDRESS_ID"/&gt;
        &lt;property name="address"/&gt;
        &lt;property name="zip"/&gt;
        &lt;property name="country"/&gt;
    &lt;/join&gt;
    ...</pre><p>This feature is often only useful for legacy data models. We recommend fewer tables than classes and a fine-grained domain model. However, it is useful for switching between inheritance mapping strategies in a single hierarchy, as explained later. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-key"/>5.1.21. Key</h3></div></div></div><p>The <code class="literal">&lt;key&gt;</code> element has featured a few times within this guide. It appears anywhere the parent mapping element defines a join to a new table that references the primary key of the original table. It also defines the foreign key in the joined table: </p><div class="programlistingco"><pre class="programlisting">&lt;key
        column="columnname"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        on-delete="noaction|cascade"             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        property-ref="propertyName"              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        not-null="true|false"                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        update="true|false"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        unique="true|false"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional): the name of the foreign key column. This can also be specified by nested <code class="literal">&lt;column&gt;</code> element(s). </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">on-delete</code> (optional - defaults to <code class="literal">noaction</code>): specifies whether the foreign key constraint has database-level cascade delete enabled. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">property-ref</code> (optional): specifies that the foreign key refers to columns that are not the primary key of the original table. It is provided for legacy data. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">not-null</code> (optional): specifies that the foreign key columns are not nullable. This is implied whenever the foreign key is also part of the primary key. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">update</code> (optional): specifies that the foreign key should never be updated. This is implied whenever the foreign key is also part of the primary key. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unique</code> (optional): specifies that the foreign key should have a unique constraint. This is implied whenever the foreign key is also the primary key. </p></td></tr></table></div></div><p>For systems where delete performance is important, we recommend that all keys should be defined <code class="literal">on-delete="cascade"</code>. Hibernate uses a database-level <code class="literal">ON CASCADE DELETE</code> constraint, instead of many individual <code class="literal">DELETE</code> statements. Be aware that this feature bypasses Hibernate's usual optimistic locking strategy for versioned data. </p><p>The <code class="literal">not-null</code> and <code class="literal">update</code> attributes are useful when mapping a unidirectional one-to-many association. If you map a unidirectional one-to-many association to a non-nullable foreign key, you <span class="emphasis"><em>must</em></span> declare the key column using <code class="literal">&lt;key not-null="true"&gt;</code>. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-column"/>5.1.22. Column and formula elements</h3></div></div></div><p>Mapping elements which accept a <code class="literal">column</code> attribute will alternatively accept a <code class="literal">&lt;column&gt;</code> subelement. Likewise, <code class="literal">&lt;formula&gt;</code> is an alternative to the <code class="literal">formula</code> attribute. For example: </p><pre class="programlisting">&lt;column
        name="column_name"
        length="N"
        precision="N"
        scale="N"
        not-null="true|false"
        unique="true|false"
        unique-key="multicolumn_unique_key_name"
        index="index_name"
        sql-type="sql_type_name"
        check="SQL expression"
        default="SQL expression"/&gt;</pre><pre class="programlisting">&lt;formula&gt;SQL expression&lt;/formula&gt;</pre><p><code class="literal">column</code> and <code class="literal">formula</code> attributes can even be combined within the same property or association mapping to express, for example, exotic join conditions. </p><pre class="programlisting">&lt;many-to-one name="homeAddress" class="Address"
        insert="false" update="false"&gt;
    &lt;column name="person_id" not-null="true" length="10"/&gt;
    &lt;formula&gt;'MAILING'&lt;/formula&gt;
&lt;/many-to-one&gt;</pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-import"/>5.1.23. Import</h3></div></div></div><p>If your application has two persistent classes with the same name, and you do not want to specify the fully qualified package name in Hibernate queries, classes can be "imported" explicitly, rather than relying upon <code class="literal">auto-import="true"</code>. You can also import classes and interfaces that are not explicitly mapped: </p><pre class="programlisting">&lt;import class="java.lang.Object" rename="Universe"/&gt;</pre><div class="programlistingco"><pre class="programlisting">&lt;import
        class="ClassName"              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        rename="ShortName"             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">class</code>: the fully qualified class name of any Java class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">rename</code> (optional - defaults to the unqualified class name): a name that can be used in the query language. </p></td></tr></table></div></div></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-types-anymapping"/>5.1.24. Any</h3></div></div></div><p>There is one more type of property mapping. The <code class="literal">&lt;any&gt;</code> mapping element defines a polymorphic association to classes from multiple tables. This type of mapping requires more than one column. The first column contains the type of the associated entity. The remaining columns contain the identifier. It is impossible to specify a foreign key constraint for this kind of association. This is not the usual way of mapping polymorphic associations and you should use this only in special cases. For example, for audit logs, user session data, etc. </p><p>The <code class="literal">meta-type</code> attribute allows the application to specify a custom type that maps database column values to persistent classes that have identifier properties of the type specified by <code class="literal">id-type</code>. You must specify the mapping from values of the meta-type to class names. </p><pre class="programlisting">&lt;any name="being" id-type="long" meta-type="string"&gt;
    &lt;meta-value value="TBL_ANIMAL" class="Animal"/&gt;
    &lt;meta-value value="TBL_HUMAN" class="Human"/&gt;
    &lt;meta-value value="TBL_ALIEN" class="Alien"/&gt;
    &lt;column name="table_name"/&gt;
    &lt;column name="id"/&gt;
&lt;/any&gt;</pre><div class="programlistingco"><pre class="programlisting">&lt;any
        name="propertyName"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        id-type="idtypename"                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        meta-type="metatypename"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        cascade="cascade_style"                  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        access="field|property|ClassName"        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        optimistic-lock="true|false"             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
&gt;
        &lt;meta-value ... /&gt;
        &lt;meta-value ... /&gt;
        .....
        &lt;column .... /&gt;
        &lt;column .... /&gt;
        .....
&lt;/any&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code> : le nom de la propriété. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">id-type</code> : le type identifiant. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">meta-type</code> (optional - defaults to <code class="literal">string</code>): any type that is allowed for a discriminator mapping. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">cascade</code> (optionnel - par défaut à <code class="literal">none</code>) : le style de cascade. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">true</code>): specifies that updates to this property either do or do not require acquisition of the optimistic lock. It defines whether a version increment should occur if this property is dirty. </p></td></tr></table></div></div></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-types"/>5.2. Hibernate types</h2></div></div></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-types-entitiesvalues"/>5.2.1. Entités et valeurs</h3></div></div></div><p>In relation to the persistence service, Java language-level objects are classified into two groups: </p><p>An <span class="emphasis"><em>entity</em></span> exists independently of any other objects holding references to the entity. Contrast this with the usual Java model, where an unreferenced object is garbage collected. Entities must be explicitly saved and deleted. Saves and deletions, however, can be <span class="emphasis"><em>cascaded</em></span> from a parent entity to its children. This is different from the ODMG model of object persistence by reachability and corresponds more closely to how application objects are usually used in large systems. Entities support circular and shared references. They can also be versioned. </p><p>An entity's persistent state consists of references to other entities and instances of <span class="emphasis"><em>value</em></span> types. Values are primitives: collections (not what is inside a collection), components and certain immutable objects. Unlike entities, values in particular collections and components, <span class="emphasis"><em>are</em></span> persisted and deleted by reachability. Since value objects and primitives are persisted and deleted along with their containing entity, they cannot be independently versioned. Values have no independent identity, so they cannot be shared by two entities or collections. </p><p>Until now, we have been using the term "persistent class" to refer to entities. We will continue to do that. Not all user-defined classes with a persistent state, however, are entities. A <span class="emphasis"><em>component</em></span> is a user-defined class with value semantics. A Java property of type <code class="literal">java.lang.String</code> also has value semantics. Given this definition, all types (classes) provided by the JDK have value type semantics in Java, while user-defined types can be mapped with entity or value type semantics. This decision is up to the application developer. An entity class in a domain model will normally have shared references to a single instance of that class, while composition or aggregation usually translates to a value type. </p><p>We will revisit both concepts throughout this reference guide. </p><p>The challenge is to map the Java type system, and the developers' definition of entities and value types, to the SQL/database type system. The bridge between both systems is provided by Hibernate. For entities, <code class="literal">&lt;class&gt;</code>, <code class="literal">&lt;subclass&gt;</code> and so on are used. For value types we use <code class="literal">&lt;property&gt;</code>, <code class="literal">&lt;component&gt;</code>etc., that usually have a <code class="literal">type</code> attribute. The value of this attribute is the name of a Hibernate <span class="emphasis"><em>mapping type</em></span>. Hibernate provides a range of mappings for standard JDK value types out of the box. You can write your own mapping types and implement your own custom conversion strategies. </p><p>With the exception of collections, all built-in Hibernate types support null semantics. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-types-basictypes"/>5.2.2. Basic value types</h3></div></div></div><p>The built-in <span class="emphasis"><em>basic mapping types</em></span> can be roughly categorized into the following: </p><div class="variablelist"><dl><dt><span class="term"><code class="literal">integer, long, short, float, double, character, byte, boolean, yes_no, true_false</code></span></dt><dd><p>Les mappings de type des primitives Java ou leurs classes wrappers (ex: Integer pour int) vers les types SQL (propriétaires) appropriés. <code class="literal">boolean, yes_no</code>et <code class="literal">true_false</code> sont tous des alternatives pour les types Java <code class="literal">boolean</code> ou <code class="literal">java.lang.Boolean</code>. </p></dd><dt><span class="term"><code class="literal">string</code></span></dt><dd><p>Mapping de type de <code class="literal">java.lang.String</code> vers <code class="literal">VARCHAR</code> (ou le <code class="literal">VARCHAR2</code> Oracle). </p></dd><dt><span class="term"><code class="literal">date, time, timestamp</code></span></dt><dd><p>Mappings de type pour <code class="literal">java.util.Date</code> et ses sous-classes vers les types SQL <code class="literal">DATE</code>, <code class="literal">TIME</code> et <code class="literal">TIMESTAMP</code> (ou équivalent). </p></dd><dt><span class="term"><code class="literal">calendar, calendar_date</code></span></dt><dd><p>Mappings de type pour <code class="literal">java.util.Calendar</code> vers les types SQL <code class="literal">TIMESTAMP</code> et <code class="literal">DATE</code> (ou équivalent). </p></dd><dt><span class="term"><code class="literal">big_decimal, big_integer</code></span></dt><dd><p>Mappings de type pour <code class="literal">java.math.BigDecimal</code> et <code class="literal">java.math.BigInteger</code> vers <code class="literal">NUMERIC</code> (ou le <code class="literal">NUMBER</code> Oracle). </p></dd><dt><span class="term"><code class="literal">locale, timezone, currency</code></span></dt><dd><p>Mappings de type pour <code class="literal">java.util.Locale</code>, <code class="literal">java.util.TimeZone</code> et <code class="literal">java.util.Currency</code> vers <code class="literal">VARCHAR</code> (ou le <code class="literal">VARCHAR2</code> Oracle). Les instances de <code class="literal">Locale</code> et <code class="literal">Currency</code> sont mappées sur leurs codes ISO. Les instances de <code class="literal">TimeZone</code> sont mappées sur leur <code class="literal">ID</code>. </p></dd><dt><span class="term"><code class="literal">class</code></span></dt><dd><p>Un type de mapping pour <code class="literal">java.lang.Class</code> vers <code class="literal">VARCHAR</code> (ou le <code class="literal">VARCHAR2</code> Oracle). Un objet <code class="literal">Class</code> est mappé sur son nom Java complet. </p></dd><dt><span class="term"><code class="literal">binary</code></span></dt><dd><p>Mappe les tableaux de bytes vers le type binaire SQL approprié. </p></dd><dt><span class="term"><code class="literal">text</code></span></dt><dd><p>Mappe les longues chaînes de caractères Java vers les types SQL <code class="literal">CLOB</code> ou <code class="literal">TEXT</code>. </p></dd><dt><span class="term"><code class="literal">serializable</code></span></dt><dd><p>Maps serializable Java types to an appropriate SQL binary type. You can also indicate the Hibernate type <code class="literal">serializable</code> with the name of a serializable Java class or interface that does not default to a basic type. </p></dd><dt><span class="term"><code class="literal">clob, blob</code></span></dt><dd><p>Type mappings for the JDBC classes <code class="literal">java.sql.Clob</code> and <code class="literal">java.sql.Blob</code>. These types can be inconvenient for some applications, since the blob or clob object cannot be reused outside of a transaction. Driver support is patchy and inconsistent. </p></dd><dt><span class="term">
                            <code class="literal">imm_date, imm_time, imm_timestamp, imm_calendar, imm_calendar_date, imm_serializable, imm_binary</code>
                        </span></dt><dd><p>Type mappings for what are considered mutable Java types. This is where Hibernate makes certain optimizations appropriate only for immutable Java types, and the application treats the object as immutable. For example, you should not call <code class="literal">Date.setTime()</code> for an instance mapped as <code class="literal">imm_timestamp</code>. To change the value of the property, and have that change made persistent, the application must assign a new, nonidentical, object to the property. </p></dd></dl></div><p>

            </p><p>Unique identifiers of entities and collections can be of any basic type except <code class="literal">binary</code>, <code class="literal">blob</code> and <code class="literal">clob</code>. Composite identifiers are also allowed. See below for more information. </p><p>Les types de base des valeurs ont des <code class="literal">Type</code> constants correspondants définis dans <code class="literal">org.hibernate.Hibernate</code>. Par exemple, <code class="literal">Hibernate.STRING</code> représenté le type <code class="literal">string</code>. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-types-custom"/>5.2.3. Types de valeur définis par l'utilisateur</h3></div></div></div><p>It is relatively easy for developers to create their own value types. For example, you might want to persist properties of type <code class="literal">java.lang.BigInteger</code> to <code class="literal">VARCHAR</code> columns. Hibernate does not provide a built-in type for this. Custom types are not limited to mapping a property, or collection element, to a single table column. So, for example, you might have a Java property <code class="literal">getName()</code>/<code class="literal">setName()</code> of type <code class="literal">java.lang.String</code> that is persisted to the columns <code class="literal">FIRST_NAME</code>, <code class="literal">INITIAL</code>, <code class="literal">SURNAME</code>. </p><p>To implement a custom type, implement either <code class="literal">org.hibernate.UserType</code> or <code class="literal">org.hibernate.CompositeUserType</code> and declare properties using the fully qualified classname of the type. View <code class="literal">org.hibernate.test.DoubleStringType</code> to see the kind of things that are possible. </p><pre class="programlisting">&lt;property name="twoStrings" type="org.hibernate.test.DoubleStringType"&gt;
    &lt;column name="first_string"/&gt;
    &lt;column name="second_string"/&gt;
&lt;/property&gt;</pre><p>Remarquez l'utilisation des tags <code class="literal">&lt;column&gt;</code> pour mapper une propriété sur des colonnes multiples. </p><p>Les interfaces <code class="literal">CompositeUserType</code>, <code class="literal">EnhancedUserType</code>, <code class="literal">UserCollectionType</code>, et <code class="literal">UserVersionType</code> permettent des utilisations plus spécialisées. </p><p>You can even supply parameters to a <code class="literal">UserType</code> in the mapping file. To do this, your <code class="literal">UserType</code> must implement the <code class="literal">org.hibernate.usertype.ParameterizedType</code> interface. To supply parameters to your custom type, you can use the <code class="literal">&lt;type&gt;</code> element in your mapping files. </p><pre class="programlisting">&lt;property name="priority"&gt;
    &lt;type name="com.mycompany.usertypes.DefaultValueIntegerType"&gt;
        &lt;param name="default"&gt;0&lt;/param&gt;
    &lt;/type&gt;
&lt;/property&gt;</pre><p>Le <code class="literal">UserType</code> permet maintenant de récupérer la valeur pour le paramètre nommé <code class="literal">default</code> à partir de l'objet <code class="literal">Properties</code> qui lui est passé. </p><p>If you regularly use a certain <code class="literal">UserType</code>, it is useful to define a shorter name for it. You can do this using the <code class="literal">&lt;typedef&gt;</code> element. Typedefs assign a name to a custom type, and can also contain a list of default parameter values if the type is parameterized. </p><pre class="programlisting">&lt;typedef class="com.mycompany.usertypes.DefaultValueIntegerType" name="default_zero"&gt;
    &lt;param name="default"&gt;0&lt;/param&gt;
&lt;/typedef&gt;</pre><pre class="programlisting">&lt;property name="priority" type="default_zero"/&gt;</pre><p>Il est aussi possible de redéfinir les paramètres par défaut du typedef au cas par cas en utilisant des paramètres type sur le mapping de la propriété. </p><p>Even though Hibernate's rich range of built-in types and support for components means you will rarely need to use a custom type, it is considered good practice to use custom types for non-entity classes that occur frequently in your application. For example, a <code class="literal">MonetaryAmount</code> class is a good candidate for a <code class="literal">CompositeUserType</code>, even though it could be mapped as a component. One reason for this is abstraction. With a custom type, your mapping documents would be protected against changes to the way monetary values are represented. </p></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-entityname"/>5.3. Mapper une classe plus d'une fois</h2></div></div></div><p>It is possible to provide more than one mapping for a particular persistent class. In this case, you must specify an <span class="emphasis"><em>entity name</em></span> to disambiguate between instances of the two mapped entities. By default, the entity name is the same as the class name. Hibernate lets you specify the entity name when working with persistent objects, when writing queries, or when mapping associations to the named entity. </p><pre class="programlisting">&lt;class name="Contract" table="Contracts"
        entity-name="CurrentContract"&gt;
    ...
    &lt;set name="history" inverse="true"
            order-by="effectiveEndDate desc"&gt;
        &lt;key column="currentContractId"/&gt;
        &lt;one-to-many entity-name="HistoricalContract"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Contract" table="ContractHistory"
        entity-name="HistoricalContract"&gt;
    ...
    &lt;many-to-one name="currentContract"
            column="currentContractId"
            entity-name="CurrentContract"/&gt;
&lt;/class&gt;</pre><p>Associations are now specified using <code class="literal">entity-name</code> instead of <code class="literal">class</code>. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-quotedidentifiers"/>5.4. SQL quoted identifiers</h2></div></div></div><p>You can force Hibernate to quote an identifier in the generated SQL by enclosing the table or column name in backticks in the mapping document. Hibernate will use the correct quotation style for the SQL <code class="literal">Dialect</code>. This is usually double quotes, but the SQL Server uses brackets and MySQL uses backticks. </p><pre class="programlisting">&lt;class name="LineItem" table="`Line Item`"&gt;
    &lt;id name="id" column="`Item Id`"/&gt;&lt;generator class="assigned"/&gt;&lt;/id&gt;
    &lt;property name="itemNumber" column="`Item #`"/&gt;
    ...
&lt;/class&gt;</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-alternatives"/>5.5. alternatives Metadata</h2></div></div></div><p>XML does not suit all users so there are some alternative ways to define O/R mapping metadata in Hibernate. </p><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-xdoclet"/>5.5.1. utilisation de XDoclet</h3></div></div></div><p>Many Hibernate users prefer to embed mapping information directly in sourcecode using XDoclet <code class="literal">@hibernate.tags</code>. We do not cover this approach in this reference guide since it is considered part of XDoclet. However, we include the following example of the <code class="literal">Cat</code> class with XDoclet mappings: </p><pre class="programlisting">package eg;
import java.util.Set;
import java.util.Date;

/**
 * @hibernate.class
 *  table="CATS"
 */
public class Cat {
    private Long id; // identifier
    private Date birthdate;
    private Cat mother;
    private Set kittens
    private Color color;
    private char sex;
    private float weight;

    /*
     * @hibernate.id
     *  generator-class="native"
     *  column="CAT_ID"
     */
    public Long getId() {
        return id;
    }
    private void setId(Long id) {
        this.id=id;
    }

    /**
     * @hibernate.many-to-one
     *  column="PARENT_ID"
     */
    public Cat getMother() {
        return mother;
    }
    void setMother(Cat mother) {
        this.mother = mother;
    }

    /**
     * @hibernate.property
     *  column="BIRTH_DATE"
     */
    public Date getBirthdate() {
        return birthdate;
    }
    void setBirthdate(Date date) {
        birthdate = date;
    }
    /**
     * @hibernate.property
     *  column="WEIGHT"
     */
    public float getWeight() {
        return weight;
    }
    void setWeight(float weight) {
        this.weight = weight;
    }

    /**
     * @hibernate.property
     *  column="COLOR"
     *  not-null="true"
     */
    public Color getColor() {
        return color;
    }
    void setColor(Color color) {
        this.color = color;
    }
    /**
     * @hibernate.set
     *  inverse="true"
     *  order-by="BIRTH_DATE"
     * @hibernate.collection-key
     *  column="PARENT_ID"
     * @hibernate.collection-one-to-many
     */
    public Set getKittens() {
        return kittens;
    }
    void setKittens(Set kittens) {
        this.kittens = kittens;
    }
    // addKitten not needed by Hibernate
    public void addKitten(Cat kitten) {
        kittens.add(kitten);
    }

    /**
     * @hibernate.property
     *  column="SEX"
     *  not-null="true"
     *  update="false"
     */
    public char getSex() {
        return sex;
    }
    void setSex(char sex) {
        this.sex=sex;
    }
}</pre><p>See the Hibernate website for more examples of XDoclet and Hibernate. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-annotations"/>5.5.2. Utilisation des annotations JDK 5.0</h3></div></div></div><p>JDK 5.0 introduced XDoclet-style annotations at the language level that are type-safe and checked at compile time. This mechanism is more powerful than XDoclet annotations and better supported by tools and IDEs. IntelliJ IDEA, for example, supports auto-completion and syntax highlighting of JDK 5.0 annotations. The new revision of the EJB specification (JSR-220) uses JDK 5.0 annotations as the primary metadata mechanism for entity beans. Hibernate3 implements the <code class="literal">EntityManager</code> of JSR-220 (the persistence API). Support for mapping metadata is available via the <span class="emphasis"><em>Hibernate Annotations</em></span> package as a separate download. Both EJB3 (JSR-220) and Hibernate3 metadata is supported. </p><p>Ceci est un exemple d'une classe POJO annotée comme un EJB entité : </p><pre class="programlisting">@Entity(access = AccessType.FIELD)
public class Customer implements Serializable {

    @Id;
    Long id;

    String firstName;
    String lastName;
    Date birthday;

    @Transient
    Integer age;

    @Embedded
    private Address homeAddress;

    @OneToMany(cascade=CascadeType.ALL)
    @JoinColumn(name="CUSTOMER_ID")
    Set&lt;Order&gt; orders;

    // Getter/setter and business methods
}</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Support for JDK 5.0 Annotations (and JSR-220) is currently under development. Please refer to the Hibernate Annotations module for more details. </p></div></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-generated"/>5.6. Generated properties</h2></div></div></div><p>Generated properties are properties that have their values generated by the database. Typically, Hibernate applications needed to <code class="literal">refresh</code> objects that contain any properties for which the database was generating values. Marking properties as generated, however, lets the application delegate this responsibility to Hibernate. When Hibernate issues an SQL INSERT or UPDATE for an entity that has defined generated properties, it immediately issues a select afterwards to retrieve the generated values. </p><p>Properties marked as generated must additionally be non-insertable and non-updateable. Only <a href="#mapping-declaration-version" title="5.1.9. Version (optional)">versions</a>, <a href="#mapping-declaration-timestamp" title="5.1.10. Timestamp (optional)">timestamps</a>, and <a href="#mapping-declaration-property" title="5.1.11. Property">simple properties</a>, can be marked as generated. </p><p><code class="literal">never</code> (the default): the given property value is not generated within the database. </p><p><code class="literal">insert</code>: the given property value is generated on insert, but is not regenerated on subsequent updates. Properties like created-date fall into this category. Even though <a href="#mapping-declaration-version" title="5.1.9. Version (optional)">version</a> and <a href="#mapping-declaration-timestamp" title="5.1.10. Timestamp (optional)">timestamp</a> properties can be marked as generated, this option is not available. </p><p><code class="literal">always</code>: the property value is generated both on insert and on update. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-database-object"/>5.7. Auxiliary database objects</h2></div></div></div><p>Auxiliary database objects allow for the CREATE and DROP of arbitrary database objects. In conjunction with Hibernate's schema evolution tools, they have the ability to fully define a user schema within the Hibernate mapping files. Although designed specifically for creating and dropping things like triggers or stored procedures, any SQL command that can be run via a <code class="literal">java.sql.Statement.execute()</code> method is valid (for example, ALTERs, INSERTS, etc.). There are essentially two modes for defining auxiliary database objects: </p><p>The first mode is to explicitly list the CREATE and DROP commands in the mapping file: </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    ...
    &lt;database-object&gt;
        &lt;create&gt;CREATE TRIGGER my_trigger ...&lt;/create&gt;
        &lt;drop&gt;DROP TRIGGER my_trigger&lt;/drop&gt;
    &lt;/database-object&gt;
&lt;/hibernate-mapping&gt;</pre><p>The second mode is to supply a custom class that constructs the CREATE and DROP commands. This custom class must implement the <code class="literal">org.hibernate.mapping.AuxiliaryDatabaseObject</code> interface. </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    ...
    &lt;database-object&gt;
        &lt;definition class="MyTriggerDefinition"/&gt;
    &lt;/database-object&gt;
&lt;/hibernate-mapping&gt;</pre><p>Additionally, these database objects can be optionally scoped so that they only apply when certain dialects are used. </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    ...
    &lt;database-object&gt;
        &lt;definition class="MyTriggerDefinition"/&gt;
        &lt;dialect-scope name="org.hibernate.dialect.Oracle9iDialect"/&gt;
        &lt;dialect-scope name="org.hibernate.dialect.Oracle10gDialect"/&gt;
    &lt;/database-object&gt;
&lt;/hibernate-mapping&gt;</pre></div></div><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="collections"/>Chapitre 6. Collection mapping</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#collections-persistent">6.1. Collections persistantes</a></span></dt><dt><span class="sect1"><a href="#collections-mapping">6.2. Mapper une collection</a></span></dt><dd><dl><dt><span class="sect2"><a href="#collections-foreignkeys">6.2.1. Les clefs étrangères d'une collection</a></span></dt><dt><span class="sect2"><a href="#collections-elements">6.2.2. Les éléments d'une collection</a></span></dt><dt><span class="sect2"><a href="#collections-indexed">6.2.3. Collections indexées</a></span></dt><dt><span class="sect2"><a href="#collections-ofvalues">6.2.4. Collections de valeurs et associations plusieurs-vers-plusieurs</a></span></dt><dt><span class="sect2"><a href="#collections-onetomany">6.2.5. Association un-vers-plusieurs</a></span></dt></dl></dd><dt><span class="sect1"><a href="#collections-advancedmappings">6.3. Mappings de collection avancés</a></span></dt><dd><dl><dt><span class="sect2"><a href="#collections-sorted">6.3.1. Collections triées</a></span></dt><dt><span class="sect2"><a href="#collections-bidirectional">6.3.2. Associations bidirectionnelles</a></span></dt><dt><span class="sect2"><a href="#collections-indexedbidirectional">6.3.3. Associations bidirectionnelles avec des collections indexées</a></span></dt><dt><span class="sect2"><a href="#collections-ternary">6.3.4. Associations ternaires</a></span></dt><dt><span class="sect2"><a href="#collections-idbag">6.3.5. <code class="literal">Utiliser un <code class="literal">&lt;idbag&gt;</code></code></a></span></dt></dl></dd><dt><span class="sect1"><a href="#collections-example">6.4. Exemples de collections</a></span></dt></dl></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="collections-persistent"/>6.1. Collections persistantes</h2></div></div></div><p>Hibernate requires that persistent collection-valued fields be declared as an interface type. For example: </p><pre class="programlisting">public class Product {
    private String serialNumber;
    private Set parts = new HashSet();
    
    public Set getParts() { return parts; }
    void setParts(Set parts) { this.parts = parts; }
    public String getSerialNumber() { return serialNumber; }
    void setSerialNumber(String sn) { serialNumber = sn; }
}</pre><p>The actual interface might be <code class="literal">java.util.Set</code>, <code class="literal">java.util.Collection</code>, <code class="literal">java.util.List</code>, <code class="literal">java.util.Map</code>, <code class="literal">java.util.SortedSet</code>, <code class="literal">java.util.SortedMap</code> or anything you like ("anything you like" means you will have to write an implementation of <code class="literal">org.hibernate.usertype.UserCollectionType</code>.) </p><p>Notice how the instance variable was initialized with an instance of <code class="literal">HashSet</code>. This is the best way to initialize collection valued properties of newly instantiated (non-persistent) instances. When you make the instance persistent, by calling <code class="literal">persist()</code> for example, Hibernate will actually replace the <code class="literal">HashSet</code> with an instance of Hibernate's own implementation of <code class="literal">Set</code>. Be aware of the following errors: </p><pre class="programlisting">Cat cat = new DomesticCat();
Cat kitten = new DomesticCat();
....
Set kittens = new HashSet();
kittens.add(kitten);
cat.setKittens(kittens);
session.persist(cat);
kittens = cat.getKittens(); // Okay, kittens collection is a Set
(HashSet) cat.getKittens(); // Error!</pre><p>The persistent collections injected by Hibernate behave like <code class="literal">HashMap</code>, <code class="literal">HashSet</code>, <code class="literal">TreeMap</code>, <code class="literal">TreeSet</code> or <code class="literal">ArrayList</code>, depending on the interface type. </p><p>Collections instances have the usual behavior of value types. They are automatically persisted when referenced by a persistent object and are automatically deleted when unreferenced. If a collection is passed from one persistent object to another, its elements might be moved from one table to another. Two entities cannot share a reference to the same collection instance. Due to the underlying relational model, collection-valued properties do not support null value semantics. Hibernate does not distinguish between a null collection reference and an empty collection. </p><p>Use persistent collections the same way you use ordinary Java collections. However, please ensure you understand the semantics of bidirectional associations (these are discussed later). </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="collections-mapping"/>6.2. Mapper une collection</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Astuce</h2><p>There are quite a range of mappings that can be generated for collections that cover many common relational models. We suggest you experiment with the schema generation tool so that you understand how various mapping declarations translate to database tables. </p></div><p>The Hibernate mapping element used for mapping a collection depends upon the type of interface. For example, a <code class="literal">&lt;set&gt;</code> element is used for mapping properties of type <code class="literal">Set</code>. </p><pre class="programlisting">&lt;class name="Product"&gt;
    &lt;id name="serialNumber" column="productSerialNumber"/&gt;
    &lt;set name="parts"&gt;
        &lt;key column="productSerialNumber" not-null="true"/&gt;
        &lt;one-to-many class="Part"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>À part <code class="literal">&lt;set&gt;</code>, il y aussi les éléments de mapping <code class="literal">&lt;list&gt;</code>, <code class="literal">&lt;map&gt;</code>, <code class="literal">&lt;bag&gt;</code>, <code class="literal">&lt;array&gt;</code> et <code class="literal">&lt;primitive-array&gt;</code>. L'élément <code class="literal">&lt;map&gt;</code> est représentatif : </p><div class="programlistingco"><pre class="programlisting">&lt;map
    name="propertyName"                                         <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
    table="table_name"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
    schema="schema_name"                                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
    lazy="true|extra|false"                                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
    inverse="true|false"                                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
    cascade="all|none|save-update|delete|all-delete-orphan|delet<span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>e-orphan"
    sort="unsorted|natural|comparatorClass"                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
    order-by="column_name asc|desc"                             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
    where="arbitrary sql where condition"                       <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/9.png" alt="(9)"/></span>
    fetch="join|select|subselect"                               <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/10.png" alt="(10)"/></span>
    batch-size="N"                                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/11.png" alt="(11)"/></span>
    access="field|property|ClassName"                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/12.png" alt="(12)"/></span>
    optimistic-lock="true|false"                                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/13.png" alt="(13)"/></span>
    mutable="true|false"                                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/14.png" alt="(14)"/></span>
    node="element-name|."
    embed-xml="true|false"
&gt;

    &lt;key .... /&gt;
    &lt;map-key .... /&gt;
    &lt;element .... /&gt;
&lt;/map&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the collection property name </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">table</code> (optional - defaults to property name): the name of the collection table. It is not used for one-to-many associations. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">schema</code> (optional): the name of a table schema to override the schema declared on the root element </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional - defaults to <code class="literal">true</code>): disables lazy fetching and specifies that the association is always eagerly fetched. It can also be used to enable "extra-lazy" fetching where most operations do not initialize the collection. This is suitable for large collections. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">inverse</code> (optional - defaults to <code class="literal">false</code>): marks this collection as the "inverse" end of a bidirectional association. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">cascade</code> (optional - defaults to <code class="literal">none</code>): enables operations to cascade to child entities. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">sort</code> (optional): specifies a sorted collection with <code class="literal">natural</code> sort order or a given comparator class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">order-by</code> (optional, JDK1.4 only): specifies a table column or columns that define the iteration order of the <code class="literal">Map</code>, <code class="literal">Set</code> or bag, together with an optional <code class="literal">asc</code> or <code class="literal">desc</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/9.png" alt="9" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">where</code> (optional): specifies an arbitrary SQL <code class="literal">WHERE</code> condition that is used when retrieving or removing the collection. This is useful if the collection needs to contain only a subset of the available data. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/10.png" alt="10" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">fetch</code> (optional, defaults to <code class="literal">select</code>): chooses between outer-join fetching, fetching by sequential select, and fetching by sequential subselect. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/11.png" alt="11" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">batch-size</code> (optional, defaults to <code class="literal">1</code>): specifies a "batch size" for lazily fetching instances of this collection. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/12.png" alt="12" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the collection property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/13.png" alt="13" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">true</code>): specifies that changes to the state of the collection results in increments of the owning entity's version. For one-to-many associations you may want to disable this setting. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/14.png" alt="14" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">mutable</code> (optional - defaults to <code class="literal">true</code>): a value of <code class="literal">false</code> specifies that the elements of the collection never change. This allows for minor performance optimization in some cases. </p></td></tr></table></div></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="collections-foreignkeys"/>6.2.1. Les clefs étrangères d'une collection</h3></div></div></div><p>Collection instances are distinguished in the database by the foreign key of the entity that owns the collection. This foreign key is referred to as the <span class="emphasis"><em>collection key column</em></span>, or columns, of the collection table. The collection key column is mapped by the <code class="literal">&lt;key&gt;</code> element. </p><p>There can be a nullability constraint on the foreign key column. For most collections, this is implied. For unidirectional one-to-many associations, the foreign key column is nullable by default, so you may need to specify <code class="literal">not-null="true"</code>. </p><pre class="programlisting">&lt;key column="productSerialNumber" not-null="true"/&gt;</pre><p>The foreign key constraint can use <code class="literal">ON DELETE CASCADE</code>. </p><pre class="programlisting">&lt;key column="productSerialNumber" on-delete="cascade"/&gt;</pre><p>Voir le chapitre précédent pour une définition complète de l'élément <code class="literal">&lt;key&gt;</code>. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="collections-elements"/>6.2.2. Les éléments d'une collection</h3></div></div></div><p>Collections can contain almost any other Hibernate type, including: basic types, custom types, components and references to other entities. This is an important distinction. An object in a collection might be handled with "value" semantics (its life cycle fully depends on the collection owner), or it might be a reference to another entity with its own life cycle. In the latter case, only the "link" between the two objects is considered to be a state held by the collection. </p><p>Le type contenu est référencé comme le <span class="emphasis"><em>type de l'élément de la collection</em></span>. Les éléments de la collections sont mappés par <code class="literal">&lt;element&gt;</code> ou <code class="literal">&lt;composite-element&gt;</code>, ou dans le cas des références d'entité, avec <code class="literal">&lt;one-to-many&gt;</code> ou <code class="literal">&lt;many-to-many&gt;</code>. Les deux premiers mappent des éléments avec un sémantique de valeur, les deux suivants sont utilisés pour mapper des associations d'entité. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="collections-indexed"/>6.2.3. Collections indexées</h3></div></div></div><p>All collection mappings, except those with set and bag semantics, need an <span class="emphasis"><em>index column</em></span> in the collection table. An index column is a column that maps to an array index, or <code class="literal">List</code> index, or <code class="literal">Map</code> key. The index of a <code class="literal">Map</code> may be of any basic type, mapped with <code class="literal">&lt;map-key&gt;</code>. It can be an entity reference mapped with <code class="literal">&lt;map-key-many-to-many&gt;</code>, or it can be a composite type mapped with <code class="literal">&lt;composite-map-key&gt;</code>. The index of an array or list is always of type <code class="literal">integer</code> and is mapped using the <code class="literal">&lt;list-index&gt;</code> element. The mapped column contains sequential integers that are numbered from zero by default. </p><div class="programlistingco"><pre class="programlisting">&lt;list-index 
        column="column_name"                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        base="0|1|..."/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">column_name</code> (required): the name of the column holding the collection index values. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">base</code> (optional - defaults to <code class="literal">0</code>): the value of the index column that corresponds to the first element of the list or array. </p></td></tr></table></div></div><div class="programlistingco"><pre class="programlisting">&lt;map-key 
        column="column_name"                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        formula="any SQL expression"        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        type="type_name"                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        node="@attribute-name"
        length="N"/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">column</code> (optional): the name of the column holding the collection index values. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">formula</code> (optional): a SQL formula used to evaluate the key of the map. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">type</code> (required): the type of the map keys. </p></td></tr></table></div></div><div class="programlistingco"><pre class="programlisting">&lt;map-key-many-to-many
        column="column_name"                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        formula="any SQL expression"        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span><span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        class="ClassName"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">column</code> (optional): the name of the foreign key column for the collection index values. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">formula</code> (optional): a SQ formula used to evaluate the foreign key of the map key. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">class</code> (required): the entity class used as the map key. </p></td></tr></table></div></div><p>If your table does not have an index column, and you still wish to use <code class="literal">List</code> as the property type, you can map the property as a Hibernate <span class="emphasis"><em>&lt;bag&gt;</em></span>. A bag does not retain its order when it is retrieved from the database, but it can be optionally sorted or ordered. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="collections-ofvalues"/>6.2.4. Collections de valeurs et associations plusieurs-vers-plusieurs</h3></div></div></div><p>Any collection of values or many-to-many associations requires a dedicated <span class="emphasis"><em>collection table</em></span> with a foreign key column or columns, <span class="emphasis"><em>collection element column</em></span> or columns, and possibly an index column or columns. </p><p>For a collection of values use the <code class="literal">&lt;element&gt;</code> tag. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;element
        column="column_name"                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        formula="any SQL expression"             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        type="typename"                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        length="L"
        precision="P"
        scale="S"
        not-null="true|false"
        unique="true|false"
        node="element-name"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">column</code> (optional): the name of the column holding the collection element values. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">formula</code> (optional): an SQL formula used to evaluate the element. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">type</code> (required): the type of the collection element. </p></td></tr></table></div></div><p> A <span class="emphasis"><em>many-to-many association</em></span> is specified using the <code class="literal">&lt;many-to-many&gt;</code> element. </p><div class="programlistingco"><pre class="programlisting">&lt;many-to-many
        column="column_name"                               <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        formula="any SQL expression"                       <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        class="ClassName"                                  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        fetch="select|join"                                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        unique="true|false"                                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        not-found="ignore|exception"                       <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        entity-name="EntityName"                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        property-ref="propertyNameFromAssociatedClass"     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
        node="element-name"
        embed-xml="true|false"
    /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">column</code> (optional): the name of the element foreign key column. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">formula</code> (optional): an SQL formula used to evaluate the element foreign key value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">class</code> (required): the name of the associated class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">fetch</code> (optional - defaults to <code class="literal">join</code>): enables outer-join or sequential select fetching for this association. This is a special case; for full eager fetching in a single <code class="literal">SELECT</code> of an entity and its many-to-many relationships to other entities, you would enable <code class="literal">join</code> fetching,not only of the collection itself, but also with this attribute on the <code class="literal">&lt;many-to-many&gt;</code> nested element. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">unique</code> (optional): enables the DDL generation of a unique constraint for the foreign-key column. This makes the association multiplicity effectively one-to-many. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">not-found</code> (optional - defaults to <code class="literal">exception</code>): specifies how foreign keys that reference missing rows will be handled: <code class="literal">ignore</code> will treat a missing row as a null association. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">entity-name</code> (optional): the entity name of the associated class, as an alternative to <code class="literal">class</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">property-ref</code> (optional): the name of a property of the associated class that is joined to this foreign key. If not specified, the primary key of the associated class is used. </p></td></tr></table></div></div><p>Here are some examples. </p><p>A set of strings: </p><pre class="programlisting">&lt;set name="names" table="person_names"&gt;
    &lt;key column="person_id"/&gt;
    &lt;element column="person_name" type="string"/&gt;
&lt;/set&gt;</pre><p>A bag containing integers with an iteration order determined by the <code class="literal">order-by</code> attribute: </p><pre class="programlisting">&lt;bag name="sizes" 
        table="item_sizes" 
        order-by="size asc"&gt;
    &lt;key column="item_id"/&gt;
    &lt;element column="size" type="integer"/&gt;
&lt;/bag&gt;</pre><p>An array of entities, in this case, a many-to-many association: </p><pre class="programlisting">&lt;array name="addresses" 
        table="PersonAddress" 
        cascade="persist"&gt;
    &lt;key column="personId"/&gt;
    &lt;list-index column="sortOrder"/&gt;
    &lt;many-to-many column="addressId" class="Address"/&gt;
&lt;/array&gt;</pre><p>Une map de chaînes de caractères vers des dates : </p><pre class="programlisting">&lt;map name="holidays" 
        table="holidays" 
        schema="dbo" 
        order-by="hol_name asc"&gt;
    &lt;key column="id"/&gt;
    &lt;map-key column="hol_name" type="string"/&gt;
    &lt;element column="hol_date" type="date"/&gt;
&lt;/map&gt;</pre><p>A list of components (this is discussed in the next chapter): </p><pre class="programlisting">&lt;list name="carComponents" 
        table="CarComponents"&gt;
    &lt;key column="carId"/&gt;
    &lt;list-index column="sortOrder"/&gt;
    &lt;composite-element class="CarComponent"&gt;
        &lt;property name="price"/&gt;
        &lt;property name="type"/&gt;
        &lt;property name="serialNumber" column="serialNum"/&gt;
    &lt;/composite-element&gt;
&lt;/list&gt;</pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="collections-onetomany"/>6.2.5. Association un-vers-plusieurs</h3></div></div></div><p>A <span class="emphasis"><em>one-to-many association</em></span> links the tables of two classes via a foreign key with no intervening collection table. This mapping loses certain semantics of normal Java collections: </p><div class="itemizedlist"><ul compact="compact"><li><p>An instance of the contained entity class cannot belong to more than one instance of the collection. </p></li><li><p>An instance of the contained entity class cannot appear at more than one value of the collection index. </p></li></ul></div><p>An association from <code class="literal">Product</code> to <code class="literal">Part</code> requires the existence of a foreign key column and possibly an index column to the <code class="literal">Part</code> table. A <code class="literal">&lt;one-to-many&gt;</code> tag indicates that this is a one-to-many association. </p><div class="programlistingco"><pre class="programlisting">&lt;one-to-many 
        class="ClassName"                                  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        not-found="ignore|exception"                       <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        entity-name="EntityName"                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        node="element-name"
        embed-xml="true|false"
    /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">class</code> (required): the name of the associated class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">not-found</code> (optional - defaults to <code class="literal">exception</code>): specifies how cached identifiers that reference missing rows will be handled. <code class="literal">ignore</code> will treat a missing row as a null association. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">entity-name</code> (optional): the entity name of the associated class, as an alternative to <code class="literal">class</code>. </p></td></tr></table></div></div><p>The <code class="literal">&lt;one-to-many&gt;</code> element does not need to declare any columns. Nor is it necessary to specify the <code class="literal">table</code> name anywhere. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Avertissement</h2><p>If the foreign key column of a <code class="literal">&lt;one-to-many&gt;</code> association is declared <code class="literal">NOT NULL</code>, you must declare the <code class="literal">&lt;key&gt;</code> mapping <code class="literal">not-null="true"</code> or <span class="emphasis"><em>use a bidirectional association</em></span> with the collection mapping marked <code class="literal">inverse="true"</code>. See the discussion of bidirectional associations later in this chapter for more information. </p></div><p>The following example shows a map of <code class="literal">Part</code> entities by name, where <code class="literal">partName</code> is a persistent property of <code class="literal">Part</code>. Notice the use of a formula-based index: </p><pre class="programlisting">&lt;map name="parts"
        cascade="all"&gt;
    &lt;key column="productId" not-null="true"/&gt;
    &lt;map-key formula="partName"/&gt;
    &lt;one-to-many class="Part"/&gt;
&lt;/map&gt;</pre></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="collections-advancedmappings"/>6.3. Mappings de collection avancés</h2></div></div></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="collections-sorted"/>6.3.1. Collections triées</h3></div></div></div><p>Hibernate supporte des collections implémentant <code class="literal">java.util.SortedMap</code> et <code class="literal">java.util.SortedSet</code>. Vous devez spécifier un comparateur dans le fichier de mapping : </p><pre class="programlisting">&lt;set name="aliases" 
            table="person_aliases" 
            sort="natural"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="string"/&gt;
&lt;/set&gt;

&lt;map name="holidays" sort="my.custom.HolidayComparator"&gt;
    &lt;key column="year_id"/&gt;
    &lt;map-key column="hol_name" type="string"/&gt;
    &lt;element column="hol_date" type="date"/&gt;
&lt;/map&gt;</pre><p>Les valeurs permises pour l'attribut <code class="literal">sort</code> sont <code class="literal">unsorted</code>, <code class="literal">natural</code> et le nom d'une classe implémentant <code class="literal">java.util.Comparator</code>. </p><p>Les collections triées se comportent réellement comme <code class="literal">java.util.TreeSet</code> ou <code class="literal">java.util.TreeMap</code>. </p><p>If you want the database itself to order the collection elements, use the <code class="literal">order-by</code> attribute of <code class="literal">set</code>, <code class="literal">bag</code> or <code class="literal">map</code> mappings. This solution is only available under JDK 1.4 or higher and is implemented using <code class="literal">LinkedHashSet</code> or <code class="literal">LinkedHashMap</code>. This performs the ordering in the SQL query and not in the memory. </p><pre class="programlisting">&lt;set name="aliases" table="person_aliases" order-by="lower(name) asc"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="string"/&gt;
&lt;/set&gt;

&lt;map name="holidays" order-by="hol_date, hol_name"&gt;
    &lt;key column="year_id"/&gt;
    &lt;map-key column="hol_name" type="string"/&gt;
    &lt;element column="hol_date type="date"/&gt;
&lt;/map&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The value of the <code class="literal">order-by</code> attribute is an SQL ordering, not an HQL ordering. </p></div><p>Associations can even be sorted by arbitrary criteria at runtime using a collection <code class="literal">filter()</code>: </p><pre class="programlisting">sortedUsers = s.createFilter( group.getUsers(), "order by this.name" ).list();</pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="collections-bidirectional"/>6.3.2. Associations bidirectionnelles</h3></div></div></div><p>A <span class="emphasis"><em>bidirectional association</em></span> allows navigation from both "ends" of the association. Two kinds of bidirectional association are supported: </p><div class="variablelist"><dl><dt><span class="term">un-vers-plusieurs (NdT : one-to-many)</span></dt><dd><p>set or bag valued at one end and single-valued at the other </p></dd><dt><span class="term">plusieurs-vers-plusieurs (NdT : many-to-many)</span></dt><dd><p>ensemble ou sac aux deux extrémités </p></dd></dl></div><p>

        </p><p>You can specify a bidirectional many-to-many association by mapping two many-to-many associations to the same database table and declaring one end as <span class="emphasis"><em>inverse</em></span>. You cannot select an indexed collection. </p><p>Here is an example of a bidirectional many-to-many association that illustrates how each category can have many items and each item can be in many categories: </p><pre class="programlisting">&lt;class name="Category"&gt;
    &lt;id name="id" column="CATEGORY_ID"/&gt;
    ...
    &lt;bag name="items" table="CATEGORY_ITEM"&gt;
        &lt;key column="CATEGORY_ID"/&gt;
        &lt;many-to-many class="Item" column="ITEM_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;

&lt;class name="Item"&gt;
    &lt;id name="id" column="ITEM_ID"/&gt;
    ...

    &lt;!-- inverse end --&gt;
    &lt;bag name="categories" table="CATEGORY_ITEM" inverse="true"&gt;
        &lt;key column="ITEM_ID"/&gt;
        &lt;many-to-many class="Category" column="CATEGORY_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;</pre><p>Changes made only to the inverse end of the association are <span class="emphasis"><em>not</em></span> persisted. This means that Hibernate has two representations in memory for every bidirectional association: one link from A to B and another link from B to A. This is easier to understand if you think about the Java object model and how a many-to-many relationship in Javais created: </p><pre class="programlisting">
category.getItems().add(item);          // The category now "knows" about the relationship
item.getCategories().add(category);     // The item now "knows" about the relationship

session.persist(item);                   // The relationship won't be saved!
session.persist(category);               // The relationship will be saved</pre><p>La partie non-inverse est utilisée pour sauvegarder la représentation en mémoire dans la base de données. </p><p>You can define a bidirectional one-to-many association by mapping a one-to-many association to the same table column(s) as a many-to-one association and declaring the many-valued end <code class="literal">inverse="true"</code>. </p><pre class="programlisting">&lt;class name="Parent"&gt;
    &lt;id name="id" column="parent_id"/&gt;
    ....
    &lt;set name="children" inverse="true"&gt;
        &lt;key column="parent_id"/&gt;
        &lt;one-to-many class="Child"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Child"&gt;
    &lt;id name="id" column="child_id"/&gt;
    ....
    &lt;many-to-one name="parent" 
        class="Parent" 
        column="parent_id"
        not-null="true"/&gt;
&lt;/class&gt;</pre><p>Mapping one end of an association with <code class="literal">inverse="true"</code> does not affect the operation of cascades as these are orthogonal concepts. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="collections-indexedbidirectional"/>6.3.3. Associations bidirectionnelles avec des collections indexées</h3></div></div></div><p>A bidirectional association where one end is represented as a <code class="literal">&lt;list&gt;</code> or <code class="literal">&lt;map&gt;</code>, requires special consideration. If there is a property of the child class that maps to the index column you can use <code class="literal">inverse="true"</code> on the collection mapping: </p><pre class="programlisting">&lt;class name="Parent"&gt;
    &lt;id name="id" column="parent_id"/&gt;
    ....
    &lt;map name="children" inverse="true"&gt;
        &lt;key column="parent_id"/&gt;
        &lt;map-key column="name" 
            type="string"/&gt;
        &lt;one-to-many class="Child"/&gt;
    &lt;/map&gt;
&lt;/class&gt;

&lt;class name="Child"&gt;
    &lt;id name="id" column="child_id"/&gt;
    ....
    &lt;property name="name" 
        not-null="true"/&gt;
    &lt;many-to-one name="parent" 
        class="Parent" 
        column="parent_id"
        not-null="true"/&gt;
&lt;/class&gt;</pre><p>If there is no such property on the child class, the association cannot be considered truly bidirectional. That is, there is information available at one end of the association that is not available at the other end. In this case, you cannot map the collection <code class="literal">inverse="true"</code>. Instead, you could use the following mapping: </p><pre class="programlisting">&lt;class name="Parent"&gt;
    &lt;id name="id" column="parent_id"/&gt;
    ....
    &lt;map name="children"&gt;
        &lt;key column="parent_id"
            not-null="true"/&gt;
        &lt;map-key column="name" 
            type="string"/&gt;
        &lt;one-to-many class="Child"/&gt;
    &lt;/map&gt;
&lt;/class&gt;

&lt;class name="Child"&gt;
    &lt;id name="id" column="child_id"/&gt;
    ....
    &lt;many-to-one name="parent" 
        class="Parent" 
        column="parent_id"
        insert="false"
        update="false"
        not-null="true"/&gt;
&lt;/class&gt;</pre><p>Note that in this mapping, the collection-valued end of the association is responsible for updates to the foreign key. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="collections-ternary"/>6.3.4. Associations ternaires</h3></div></div></div><p>There are three possible approaches to mapping a ternary association. One approach is to use a <code class="literal">Map</code> with an association as its index: </p><pre class="programlisting">&lt;map name="contracts"&gt;
    &lt;key column="employer_id" not-null="true"/&gt;
    &lt;map-key-many-to-many column="employee_id" class="Employee"/&gt;
    &lt;one-to-many class="Contract"/&gt;
&lt;/map&gt;</pre><pre class="programlisting">&lt;map name="connections"&gt;
    &lt;key column="incoming_node_id"/&gt;
    &lt;map-key-many-to-many column="outgoing_node_id" class="Node"/&gt;
    &lt;many-to-many column="connection_id" class="Connection"/&gt;
&lt;/map&gt;</pre><p>A second approach is to remodel the association as an entity class. This is the most common approach. </p><p>A final alternative is to use composite elements, which will be discussed later. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="collections-idbag"/>6.3.5. <code class="literal">Utiliser un <code class="literal">&lt;idbag&gt;</code></code></h3></div></div></div><p>The majority of the many-to-many associations and collections of values shown previously all map to tables with composite keys, even though it has been have suggested that entities should have synthetic identifiers (surrogate keys). A pure association table does not seem to benefit much from a surrogate key, although a collection of composite values <span class="emphasis"><em>might</em></span>. It is for this reason that Hibernate provides a feature that allows you to map many-to-many associations and collections of values to a table with a surrogate key. </p><p>The <code class="literal">&lt;idbag&gt;</code> element lets you map a <code class="literal">List</code> (or <code class="literal">Collection</code>) with bag semantics. For example: </p><pre class="programlisting">&lt;idbag name="lovers" table="LOVERS"&gt;
    &lt;collection-id column="ID" type="long"&gt;
        &lt;generator class="sequence"/&gt;
    &lt;/collection-id&gt;
    &lt;key column="PERSON1"/&gt;
    &lt;many-to-many column="PERSON2" class="Person" fetch="join"/&gt;
&lt;/idbag&gt;</pre><p>An <code class="literal">&lt;idbag&gt;</code> has a synthetic id generator, just like an entity class. A different surrogate key is assigned to each collection row. Hibernate does not, however, provide any mechanism for discovering the surrogate key value of a particular row. </p><p>The update performance of an <code class="literal">&lt;idbag&gt;</code> supersedes a regular <code class="literal">&lt;bag&gt;</code>. Hibernate can locate individual rows efficiently and update or delete them individually, similar to a list, map or set. </p><p>Dans l'implémentation actuelle, la stratégie de la génération de l'identifiant <code class="literal">native</code> n'est pas supportée pour les identifiants de collection <code class="literal">&lt;idbag&gt;</code>. </p></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="collections-example"/>6.4. Exemples de collections</h2></div></div></div><p>This section covers collection examples. </p><p>The following class has a collection of <code class="literal">Child</code> instances: </p><pre class="programlisting">package eg;
import java.util.Set;

public class Parent {
    private long id;
    private Set children;

    public long getId() { return id; }
    private void setId(long id) { this.id=id; }

    private Set getChildren() { return children; }
    private void setChildren(Set children) { this.children=children; }

    ....
    ....
}</pre><p>If each child has, at most, one parent, the most natural mapping is a one-to-many association: </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>Ceci mappe les définitions de tables suivantes : </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null primary key, name varchar(255), parent_id bigint )
alter table child add constraint childfk0 (parent_id) references parent</pre><p>Si le parent est <span class="emphasis"><em>requis</em></span>, utilisez une association un-vers-plusieurs unidirectionnelle : </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" inverse="true"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
        &lt;many-to-one name="parent" class="Parent" column="parent_id" not-null="true"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>Notez la contrainte <code class="literal">NOT NULL</code> : </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null
                     primary key,
                     name varchar(255),
                     parent_id bigint not null )
alter table child add constraint childfk0 (parent_id) references parent</pre><p>Alternatively, if this association must be unidirectional you can declare the <code class="literal">NOT NULL</code> constraint on the <code class="literal">&lt;key&gt;</code> mapping: </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children"&gt;
            &lt;key column="parent_id" not-null="true"/&gt;
            &lt;one-to-many class="Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>On the other hand, if a child has multiple parents, a many-to-many association is appropriate: </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" table="childset"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;many-to-many class="Child" column="child_id"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>Définitions des tables : </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null primary key, name varchar(255) )
create table childset ( parent_id bigint not null,
                        child_id bigint not null,
                        primary key ( parent_id, child_id ) )
alter table childset add constraint childsetfk0 (parent_id) references parent
alter table childset add constraint childsetfk1 (child_id) references child</pre><p>For more examples and a complete explanation of a parent/child relationship mapping, see <a href="#example-parentchild" title="Chapitre 21. Exemple : Père/Fils">Chapitre 21, <i xmlns:xlink="http://www.w3.org/1999/xlink">Exemple : Père/Fils</i></a> for more information. </p><p>Even more complex association mappings are covered in the next chapter. </p></div></div><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="associations"/>Chapitre 7. Mapper les associations</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#assoc-intro">7.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#assoc-unidirectional">7.2. Association unidirectionnelle</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-unidirectional-m21">7.2.1. Many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-121">7.2.2. One-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-12m">7.2.3. One-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-unidirectional-join">7.3. Associations unidirectionnelles avec tables de jointure</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-unidirectional-join-12m">7.3.1. One-to-many</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-m21">7.3.2. Many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-121">7.3.3. One-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-m2m">7.3.4. Many-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-bidirectional">7.4. Associations bidirectionnelles</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-bidirectional-m21">7.4.1. one-to-many / many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-121">7.4.2. One-to-one</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-bidirectional-join">7.5. Associations bidirectionnelles avec table de jointure</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-bidirectional-join-12m">7.5.1. one-to-many / many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-join-121">7.5.2. one to one</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-join-m2m">7.5.3. Many-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-complex">7.6. Des mappings plus complexes</a></span></dt></dl></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="assoc-intro"/>7.1. Introduction</h2></div></div></div><p>Association mappings are often the most difficult thing to implement correctly. In this section we examine some canonical cases one by one, starting with unidirectional mappings and then bidirectional cases. We will use <code class="literal">Person</code> and <code class="literal">Address</code> in all the examples. </p><p>Associations will be classified by multiplicity and whether or not they map to an intervening join table. </p><p>Nullable foreign keys are not considered to be good practice in traditional data modelling, so our examples do not use nullable foreign keys. This is not a requirement of Hibernate, and the mappings will work if you drop the nullability constraints. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="assoc-unidirectional"/>7.2. Association unidirectionnelle</h2></div></div></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-m21"/>7.2.1. Many-to-one</h3></div></div></div><p>Une <span class="emphasis"><em>association plusieurs-à-un (many-to-one) unidirectionnelle </em></span> est le type que l'on rencontre le plus souvent dans les associations unidirectionnelles. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-121"/>7.2.2. One-to-one</h3></div></div></div><p>une <span class="emphasis"><em>association un-à-un (one-to-one) sur une clé étrangère</em></span> est presque identique. La seule différence est sur la contrainte d'unicité que l'on impose à cette colonne. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId" 
        unique="true"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre><p>A <span class="emphasis"><em>unidirectional one-to-one association on a primary key</em></span> usually uses a special id generator In this example, however, we have reversed the direction of the association: </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"&gt;person&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    &lt;one-to-one name="person" constrained="true"/&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table Address ( personId bigint not null primary key )
        </pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-12m"/>7.2.3. One-to-many</h3></div></div></div><p>A <span class="emphasis"><em>unidirectional one-to-many association on a foreign key</em></span> is an unusual case, and is not recommended. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses"&gt;
        &lt;key column="personId" 
            not-null="true"/&gt;
        &lt;one-to-many class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table Address ( addressId bigint not null primary key, personId bigint not null )
        </pre><p>You should instead use a join table for this kind of association. </p></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="assoc-unidirectional-join"/>7.3. Associations unidirectionnelles avec tables de jointure</h2></div></div></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-join-12m"/>7.3.1. One-to-many</h3></div></div></div><p>A <span class="emphasis"><em>unidirectional one-to-many association on a join table</em></span> is the preferred option. Specifying <code class="literal">unique="true"</code>, changes the multiplicity from many-to-many to one-to-many. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses" table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            unique="true"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId not null, addressId bigint not null primary key )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-join-m21"/>7.3.2. Many-to-one</h3></div></div></div><p>A <span class="emphasis"><em>unidirectional many-to-one association on a join table</em></span> is common when the association is optional. For example: </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"&gt;
        &lt;key column="personId" unique="true"/&gt;
        &lt;many-to-one name="address"
            column="addressId" 
            not-null="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null primary key, addressId bigint not null )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-join-121"/>7.3.3. One-to-one</h3></div></div></div><p>A <span class="emphasis"><em>unidirectional one-to-one association on a join table</em></span> is possible, but extremely unusual. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"&gt;
        &lt;key column="personId" 
            unique="true"/&gt;
        &lt;many-to-one name="address"
            column="addressId" 
            not-null="true"
            unique="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-join-m2m"/>7.3.4. Many-to-many</h3></div></div></div><p>Finally, here is an example of a <span class="emphasis"><em>unidirectional many-to-many association</em></span>. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses" table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null, addressId bigint not null, primary key (personId, addressId) )
create table Address ( addressId bigint not null primary key )
        </pre></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="assoc-bidirectional"/>7.4. Associations bidirectionnelles</h2></div></div></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-bidirectional-m21"/>7.4.1. one-to-many / many-to-one</h3></div></div></div><p>A <span class="emphasis"><em>bidirectional many-to-one association</em></span> is the most common kind of association. The following example illustrates the standard parent/child relationship. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="people" inverse="true"&gt;
        &lt;key column="addressId"/&gt;
        &lt;one-to-many class="Person"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null )
create table Address ( addressId bigint not null primary key )
        </pre><p>If you use a <code class="literal">List</code>, or other indexed collection, set the <code class="literal">key</code> column of the foreign key to <code class="literal">not null</code>. Hibernate will manage the association from the collections side to maintain the index of each element, making the other side virtually inverse by setting <code class="literal">update="false"</code> and <code class="literal">insert="false"</code>: </p><pre class="programlisting">&lt;class name="Person"&gt;
   &lt;id name="id"/&gt;
   ...
   &lt;many-to-one name="address"
      column="addressId"
      not-null="true"
      insert="false"
      update="false"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
   &lt;id name="id"/&gt;
   ...
   &lt;list name="people"&gt;
      &lt;key column="addressId" not-null="true"/&gt;
      &lt;list-index column="peopleIdx"/&gt;
      &lt;one-to-many class="Person"/&gt;
   &lt;/list&gt;
&lt;/class&gt;</pre><p>If the underlying foreign key column is <code class="literal">NOT NULL</code>, it is important that you define <code class="literal">not-null="true"</code> on the <code class="literal">&lt;key&gt;</code> element of the collection mapping. Do not only declare <code class="literal">not-null="true"</code> on a possible nested <code class="literal">&lt;column&gt;</code> element, but on the <code class="literal">&lt;key&gt;</code> element. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-bidirectional-121"/>7.4.2. One-to-one</h3></div></div></div><p>A <span class="emphasis"><em>bidirectional one-to-one association on a foreign key</em></span> is common: </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId" 
        unique="true"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
   &lt;one-to-one name="person" 
        property-ref="address"/&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre><p>A <span class="emphasis"><em>bidirectional one-to-one association on a primary key</em></span> uses the special id generator: </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;one-to-one name="address"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"&gt;person&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    &lt;one-to-one name="person" 
        constrained="true"/&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table Address ( personId bigint not null primary key )
        </pre></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="assoc-bidirectional-join"/>7.5. Associations bidirectionnelles avec table de jointure</h2></div></div></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-bidirectional-join-12m"/>7.5.1. one-to-many / many-to-one</h3></div></div></div><p>The following is an example of a <span class="emphasis"><em>bidirectional one-to-many association on a join table</em></span>. The <code class="literal">inverse="true"</code> can go on either end of the association, on the collection, or on the join. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses" 
        table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            unique="true"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        inverse="true" 
        optional="true"&gt;
        &lt;key column="addressId"/&gt;
        &lt;many-to-one name="person"
            column="personId"
            not-null="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null, addressId bigint not null primary key )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-bidirectional-join-121"/>7.5.2. one to one</h3></div></div></div><p>A <span class="emphasis"><em>bidirectional one-to-one association on a join table</em></span> is possible, but extremely unusual. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"&gt;
        &lt;key column="personId" 
            unique="true"/&gt;
        &lt;many-to-one name="address"
            column="addressId" 
            not-null="true"
            unique="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"
        inverse="true"&gt;
        &lt;key column="addressId" 
            unique="true"/&gt;
        &lt;many-to-one name="person"
            column="personId" 
            not-null="true"
            unique="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-bidirectional-join-m2m"/>7.5.3. Many-to-many</h3></div></div></div><p>Here is an example of a <span class="emphasis"><em>bidirectional many-to-many association</em></span>. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses" table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="people" inverse="true" table="PersonAddress"&gt;
        &lt;key column="addressId"/&gt;
        &lt;many-to-many column="personId"
            class="Person"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null, addressId bigint not null, primary key (personId, addressId) )
create table Address ( addressId bigint not null primary key )
        </pre></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="assoc-complex"/>7.6. Des mappings plus complexes</h2></div></div></div><p>More complex association joins are <span class="emphasis"><em>extremely</em></span> rare. Hibernate handles more complex situations by using SQL fragments embedded in the mapping document. For example, if a table with historical account information data defines <code class="literal">accountNumber</code>, <code class="literal">effectiveEndDate</code> and <code class="literal">effectiveStartDate</code>columns, it would be mapped as follows: </p><pre class="programlisting">&lt;properties name="currentAccountKey"&gt;
    &lt;property name="accountNumber" type="string" not-null="true"/&gt;
    &lt;property name="currentAccount" type="boolean"&gt;
        &lt;formula&gt;case when effectiveEndDate is null then 1 else 0 end&lt;/formula&gt;
    &lt;/property&gt;
&lt;/properties&gt;
&lt;property name="effectiveEndDate" type="date"/&gt;
&lt;property name="effectiveStateDate" type="date" not-null="true"/&gt;</pre><p>You can then map an association to the <span class="emphasis"><em>current</em></span> instance, the one with null <code class="literal">effectiveEndDate</code>, by using: </p><pre class="programlisting">&lt;many-to-one name="currentAccountInfo" 
        property-ref="currentAccountKey"
        class="AccountInfo"&gt;
    &lt;column name="accountNumber"/&gt;
    &lt;formula&gt;'1'&lt;/formula&gt;
&lt;/many-to-one&gt;</pre><p>In a more complex example, imagine that the association between <code class="literal">Employee</code> and <code class="literal">Organization</code> is maintained in an <code class="literal">Employment</code> table full of historical employment data. An association to the employee's <span class="emphasis"><em>most recent</em></span> employer, the one with the most recent <code class="literal">startDate</code>, could be mapped in the following way: </p><pre class="programlisting">&lt;join&gt;
    &lt;key column="employeeId"/&gt;
    &lt;subselect&gt;
        select employeeId, orgId 
        from Employments 
        group by orgId 
        having startDate = max(startDate)
    &lt;/subselect&gt;
    &lt;many-to-one name="mostRecentEmployer" 
            class="Organization" 
            column="orgId"/&gt;
&lt;/join&gt;</pre><p>This functionality allows a degree of creativity and flexibility, but it is more practical to handle these kinds of cases using HQL or a criteria query. </p></div></div><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="components"/>Chapitre 8. Mapping de composants</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#components-dependentobjects">8.1. Objects dépendants</a></span></dt><dt><span class="sect1"><a href="#components-incollections">8.2. Collection d'objets dépendants</a></span></dt><dt><span class="sect1"><a href="#components-asmapindex">8.3. Utiliser les composants comme index de map</a></span></dt><dt><span class="sect1"><a href="#components-compositeid">8.4. Utiliser un composant comme identifiant</a></span></dt><dt><span class="sect1"><a href="#components-dynamic">8.5. Composant Dynamique</a></span></dt></dl></div><p>The notion of a <span class="emphasis"><em>component</em></span> is re-used in several different contexts and purposes throughout Hibernate. </p><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="components-dependentobjects"/>8.1. Objects dépendants</h2></div></div></div><p>A component is a contained object that is persisted as a value type and not an entity reference. The term "component" refers to the object-oriented notion of composition and not to architecture-level components. For example, you can model a person like this: </p><pre class="programlisting">public class Person {
    private java.util.Date birthday;
    private Name name;
    private String key;
    public String getKey() {
        return key;
    }
    private void setKey(String key) {
        this.key=key;
    }
    public java.util.Date getBirthday() {
        return birthday;
    }
    public void setBirthday(java.util.Date birthday) {
        this.birthday = birthday;
    }
    public Name getName() {
        return name;
    }
    public void setName(Name name) {
        this.name = name;
    }
    ......
    ......
}</pre><pre class="programlisting">public class Name {
    char initial;
    String first;
    String last;
    public String getFirst() {
        return first;
    }
    void setFirst(String first) {
        this.first = first;
    }
    public String getLast() {
        return last;
    }
    void setLast(String last) {
        this.last = last;
    }
    public char getInitial() {
        return initial;
    }
    void setInitial(char initial) {
        this.initial = initial;
    }
}</pre><p>Now <code class="literal">Name</code> can be persisted as a component of <code class="literal">Person</code>. <code class="literal">Name</code> defines getter and setter methods for its persistent properties, but it does not need to declare any interfaces or identifier properties. </p><p>Our Hibernate mapping would look like this: </p><pre class="programlisting">&lt;class name="eg.Person" table="person"&gt;
    &lt;id name="Key" column="pid" type="string"&gt;
        &lt;generator class="uuid"/&gt;
    &lt;/id&gt;
    &lt;property name="birthday" type="date"/&gt;
    &lt;component name="Name" class="eg.Name"&gt; &lt;!-- class attribute optional --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/component&gt;
&lt;/class&gt;</pre><p>La table person aurai les colonnes <code class="literal">pid</code>, <code class="literal">birthday</code>, <code class="literal">initial</code>, <code class="literal">first</code> and <code class="literal">last</code>. </p><p>Like value types, components do not support shared references. In other words, two persons could have the same name, but the two person objects would contain two independent name objects that were only "the same" by value. The null value semantics of a component are <span class="emphasis"><em>ad hoc</em></span>. When reloading the containing object, Hibernate will assume that if all component columns are null, then the entire component is null. This is suitable for most purposes. </p><p>The properties of a component can be of any Hibernate type (collections, many-to-one associations, other components, etc). Nested components should <span class="emphasis"><em>not</em></span> be considered an exotic usage. Hibernate is intended to support a fine-grained object model. </p><p>Le <code class="literal">&lt;component&gt;</code> peut inclure dans la liste de ses propriétés une référence au <code class="literal">&lt;parent&gt;</code> conteneur. </p><pre class="programlisting">&lt;class name="eg.Person" table="person"&gt;
    &lt;id name="Key" column="pid" type="string"&gt;
        &lt;generator class="uuid"/&gt;
    &lt;/id&gt;
    &lt;property name="birthday" type="date"/&gt;
    &lt;component name="Name" class="eg.Name" unique="true"&gt;
        &lt;parent name="namedPerson"/&gt; &lt;!-- reference back to the Person --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/component&gt;
&lt;/class&gt;</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="components-incollections"/>8.2. Collection d'objets dépendants</h2></div></div></div><p>Collections of components are supported (e.g. an array of type <code class="literal">Name</code>). Declare your component collection by replacing the <code class="literal">&lt;element&gt;</code> tag with a <code class="literal">&lt;composite-element&gt;</code> tag: </p><pre class="programlisting">&lt;set name="someNames" table="some_names" lazy="true"&gt;
    &lt;key column="id"/&gt;
    &lt;composite-element class="eg.Name"&gt; &lt;!-- class attribute required --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/composite-element&gt;
&lt;/set&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>If you define a <code class="literal">Set</code> of composite elements, it is important to implement <code class="literal">equals()</code> and <code class="literal">hashCode()</code> correctly. </p></div><p>Composite elements can contain components but not collections. If your composite element contains components, use the <code class="literal">&lt;nested-composite-element&gt;</code> tag. This case is a collection of components which themselves have components. You may want to consider if a one-to-many association is more appropriate. Remodel the composite element as an entity, but be aware that even though the Java model is the same, the relational model and persistence semantics are still slightly different. </p><p>A composite element mapping does not support null-able properties if you are using a <code class="literal">&lt;set&gt;</code>. There is no separate primary key column in the composite element table. Hibernate uses each column's value to identify a record when deleting objects, which is not possible with null values. You have to either use only not-null properties in a composite-element or choose a <code class="literal">&lt;list&gt;</code>, <code class="literal">&lt;map&gt;</code>, <code class="literal">&lt;bag&gt;</code> or <code class="literal">&lt;idbag&gt;</code>. </p><p>A special case of a composite element is a composite element with a nested <code class="literal">&lt;many-to-one&gt;</code> element. This mapping allows you to map extra columns of a many-to-many association table to the composite element class. The following is a many-to-many association from <code class="literal">Order</code> to <code class="literal">Item</code>, where <code class="literal">purchaseDate</code>, <code class="literal">price</code> and <code class="literal">quantity</code> are properties of the association: </p><pre class="programlisting">&lt;class name="eg.Order" .... &gt;
    ....
    &lt;set name="purchasedItems" table="purchase_items" lazy="true"&gt;
        &lt;key column="order_id"&gt;
        &lt;composite-element class="eg.Purchase"&gt;
            &lt;property name="purchaseDate"/&gt;
            &lt;property name="price"/&gt;
            &lt;property name="quantity"/&gt;
            &lt;many-to-one name="item" class="eg.Item"/&gt; &lt;!-- class attribute is optional --&gt;
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>There cannot be a reference to the purchase on the other side for bidirectional association navigation. Components are value types and do not allow shared references. A single <code class="literal">Purchase</code> can be in the set of an <code class="literal">Order</code>, but it cannot be referenced by the <code class="literal">Item</code> at the same time. </p><p>Même les associations ternaires ou quaternaires sont possibles:</p><pre class="programlisting">&lt;class name="eg.Order" .... &gt;
    ....
    &lt;set name="purchasedItems" table="purchase_items" lazy="true"&gt;
        &lt;key column="order_id"&gt;
        &lt;composite-element class="eg.OrderLine"&gt;
            &lt;many-to-one name="purchaseDetails class="eg.Purchase"/&gt;
            &lt;many-to-one name="item" class="eg.Item"/&gt;
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>Composite elements can appear in queries using the same syntax as associations to other entities. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="components-asmapindex"/>8.3. Utiliser les composants comme index de map</h2></div></div></div><p>The <code class="literal">&lt;composite-map-key&gt;</code> element allows you to map a component class as the key of a <code class="literal">Map</code>. Ensure that you override <code class="literal">hashCode()</code> and <code class="literal">equals()</code> correctly on the component class. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="components-compositeid"/>8.4. Utiliser un composant comme identifiant</h2></div></div></div><p>You can use a component as an identifier of an entity class. Your component class must satisfy certain requirements: </p><div class="itemizedlist"><ul compact="compact"><li><p>Elle doit implémenter <code class="literal">java.io.Serializable</code>. </p></li><li><p>It must re-implement <code class="literal">equals()</code> and <code class="literal">hashCode()</code> consistently with the database's notion of composite key equality. </p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>In Hibernate3, although the second requirement is not an absolutely hard requirement of Hibernate, it is recommended. </p></div><p>You cannot use an <code class="literal">IdentifierGenerator</code> to generate composite keys. Instead the application must assign its own identifiers. </p><p>Use the <code class="literal">&lt;composite-id&gt;</code> tag, with nested <code class="literal">&lt;key-property&gt;</code> elements, in place of the usual <code class="literal">&lt;id&gt;</code> declaration. For example, the <code class="literal">OrderLine</code> class has a primary key that depends upon the (composite) primary key of <code class="literal">Order</code>. </p><pre class="programlisting">&lt;class name="OrderLine"&gt;
    
    &lt;composite-id name="id" class="OrderLineId"&gt;
        &lt;key-property name="lineId"/&gt;
        &lt;key-property name="orderId"/&gt;
        &lt;key-property name="customerId"/&gt;
    &lt;/composite-id&gt;
    
    &lt;property name="name"/&gt;
    
    &lt;many-to-one name="order" class="Order"
            insert="false" update="false"&gt;
        &lt;column name="orderId"/&gt;
        &lt;column name="customerId"/&gt;
    &lt;/many-to-one&gt;
    ....
    
&lt;/class&gt;</pre><p>Any foreign keys referencing the <code class="literal">OrderLine</code> table are now composite. Declare this in your mappings for other classes. An association to <code class="literal">OrderLine</code> is mapped like this: </p><pre class="programlisting">&lt;many-to-one name="orderLine" class="OrderLine"&gt;
&lt;!-- the "class" attribute is optional, as usual --&gt;
    &lt;column name="lineId"/&gt;
    &lt;column name="orderId"/&gt;
    &lt;column name="customerId"/&gt;
&lt;/many-to-one&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Astuce</h2><p>The <code class="literal">column</code> element is an alternative to the <code class="literal">column</code> attribute everywhere. Using the <code class="literal">column</code> element just gives more declaration options, which are mostly useful when utilizing <code class="literal">hbm2ddl</code> </p></div><p>Une association <code class="literal">plusieurs-à-plusieurs</code> (many-to-many) à <code class="literal">OrderLine</code> utilisera aussi une clé étrangère composite: </p><pre class="programlisting">&lt;set name="undeliveredOrderLines"&gt;
    &lt;key column name="warehouseId"/&gt;
    &lt;many-to-many class="OrderLine"&gt;
        &lt;column name="lineId"/&gt;
        &lt;column name="orderId"/&gt;
        &lt;column name="customerId"/&gt;
    &lt;/many-to-many&gt;
&lt;/set&gt;</pre><p>La collection des <code class="literal">OrderLine</code>s dans <code class="literal">Order</code> utilisera: </p><pre class="programlisting">&lt;set name="orderLines" inverse="true"&gt;
    &lt;key&gt;
        &lt;column name="orderId"/&gt;
        &lt;column name="customerId"/&gt;
    &lt;/key&gt;
    &lt;one-to-many class="OrderLine"/&gt;
&lt;/set&gt;</pre><p>The <code class="literal">&lt;one-to-many&gt;</code> element declares no columns. </p><p>Si <code class="literal">OrderLine</code> lui-même possède une collection, celle-ci aura aussi une clé composite étrangère. </p><pre class="programlisting">&lt;class name="OrderLine"&gt;
    ....
    ....
    &lt;list name="deliveryAttempts"&gt;
        &lt;key&gt;   &lt;!-- a collection inherits the composite key type --&gt;
            &lt;column name="lineId"/&gt;
            &lt;column name="orderId"/&gt;
            &lt;column name="customerId"/&gt;
        &lt;/key&gt;
        &lt;list-index column="attemptId" base="1"/&gt;
        &lt;composite-element class="DeliveryAttempt"&gt;
            ...
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="components-dynamic"/>8.5. Composant Dynamique</h2></div></div></div><p>You can also map a property of type <code class="literal">Map</code>: </p><pre class="programlisting">&lt;dynamic-component name="userAttributes"&gt;
    &lt;property name="foo" column="FOO" type="string"/&gt;
    &lt;property name="bar" column="BAR" type="integer"/&gt;
    &lt;many-to-one name="baz" class="Baz" column="BAZ_ID"/&gt;
&lt;/dynamic-component&gt;</pre><p>The semantics of a <code class="literal">&lt;dynamic-component&gt;</code> mapping are identical to <code class="literal">&lt;component&gt;</code>. The advantage of this kind of mapping is the ability to determine the actual properties of the bean at deployment time just by editing the mapping document. Runtime manipulation of the mapping document is also possible, using a DOM parser. You can also access, and change, Hibernate's configuration-time metamodel via the <code class="literal">Configuration</code> object. </p></div></div><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="inheritance"/>Chapitre 9. Inheritance mapping</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#inheritance-strategies">9.1. The three strategies</a></span></dt><dd><dl><dt><span class="sect2"><a href="#inheritance-tableperclass">9.1.1. Une table par hiérarchie de classe</a></span></dt><dt><span class="sect2"><a href="#inheritance-tablepersubclass">9.1.2. Une table par classe fille</a></span></dt><dt><span class="sect2"><a href="#inheritance-tablepersubclass-discriminator">9.1.3. Table per subclass: using a discriminator</a></span></dt><dt><span class="sect2"><a href="#inheritance-mixing-tableperclass-tablepersubclass">9.1.4. Mélange d'une table par hiérarchie de classe avec une table par classe fille</a></span></dt><dt><span class="sect2"><a href="#inheritance-tableperconcrete">9.1.5. Une table par classe concrète</a></span></dt><dt><span class="sect2"><a href="#inheritance-tableperconcreate-polymorphism">9.1.6. Table per concrete class using implicit polymorphism</a></span></dt><dt><span class="sect2"><a href="#inheritance-mixingpolymorphism">9.1.7. Mélange du polymorphisme implicite avec d'autres mappings d'héritage</a></span></dt></dl></dd><dt><span class="sect1"><a href="#inheritance-limitations">9.2. Limitations</a></span></dt></dl></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="inheritance-strategies"/>9.1. The three strategies</h2></div></div></div><p>Hibernate supporte les trois stratégies d'héritage de base : </p><div class="itemizedlist"><ul><li><p>une table par hiérarchie de classe (table per class hierarchy) </p></li><li><p>table per subclass </p></li><li><p>une table par classe concrète (table per concrete class) </p></li></ul></div><p>Hibernate supporte en plus une quatrièmestratégie, légèrement différente, qui supporte le polymorphisme : </p><div class="itemizedlist"><ul><li><p>le polymorphisme implicite </p></li></ul></div><p>It is possible to use different mapping strategies for different branches of the same inheritance hierarchy. You can then make use of implicit polymorphism to achieve polymorphism across the whole hierarchy. However, Hibernate does not support mixing <code class="literal">&lt;subclass&gt;</code>, <code class="literal">&lt;joined-subclass&gt;</code> and <code class="literal">&lt;union-subclass&gt;</code> mappings under the same root <code class="literal">&lt;class&gt;</code> element. It is possible to mix together the table per hierarchy and table per subclass strategies under the the same <code class="literal">&lt;class&gt;</code> element, by combining the <code class="literal">&lt;subclass&gt;</code> and <code class="literal">&lt;join&gt;</code> elements (see below for an example). </p><p>It is possible to define <code class="literal">subclass</code>, <code class="literal">union-subclass</code>, and <code class="literal">joined-subclass</code> mappings in separate mapping documents directly beneath <code class="literal">hibernate-mapping</code>. This allows you to extend a class hierarchy by adding a new mapping file. You must specify an <code class="literal">extends</code> attribute in the subclass mapping, naming a previously mapped superclass. Previously this feature made the ordering of the mapping documents important. Since Hibernate3, the ordering of mapping files is irrelevant when using the extends keyword. The ordering inside a single mapping file still needs to be defined as superclasses before subclasses. </p><pre class="programlisting">
 &lt;hibernate-mapping&gt;
     &lt;subclass name="DomesticCat" extends="Cat" discriminator-value="D"&gt;
          &lt;property name="name" type="string"/&gt;
     &lt;/subclass&gt;
 &lt;/hibernate-mapping&gt;</pre><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-tableperclass"/>9.1.1. Une table par hiérarchie de classe</h3></div></div></div><p>Suppose we have an interface <code class="literal">Payment</code> with the implementors <code class="literal">CreditCardPayment</code>, <code class="literal">CashPayment</code>, and <code class="literal">ChequePayment</code>. The table per hierarchy mapping would display in the following way: </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        &lt;property name="creditCardType" column="CCTYPE"/&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        ...
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>Exactly one table is required. There is a limitation of this mapping strategy: columns declared by the subclasses, such as <code class="literal">CCTYPE</code>, cannot have <code class="literal">NOT NULL</code> constraints. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-tablepersubclass"/>9.1.2. Une table par classe fille</h3></div></div></div><p>A table per subclass mapping looks like this: </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;joined-subclass name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="creditCardType" column="CCTYPE"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
&lt;/class&gt;</pre><p>Four tables are required. The three subclass tables have primary key associations to the superclass table so the relational model is actually a one-to-one association. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-tablepersubclass-discriminator"/>9.1.3. Table per subclass: using a discriminator</h3></div></div></div><p>Hibernate's implementation of table per subclass does not require a discriminator column. Other object/relational mappers use a different implementation of table per subclass that requires a type discriminator column in the superclass table. The approach taken by Hibernate is much more difficult to implement, but arguably more correct from a relational point of view. If you want to use a discriminator column with the table per subclass strategy, you can combine the use of <code class="literal">&lt;subclass&gt;</code> and <code class="literal">&lt;join&gt;</code>, as follows: </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        &lt;join table="CREDIT_PAYMENT"&gt;
            &lt;key column="PAYMENT_ID"/&gt;
            &lt;property name="creditCardType" column="CCTYPE"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        &lt;join table="CASH_PAYMENT"&gt;
            &lt;key column="PAYMENT_ID"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        &lt;join table="CHEQUE_PAYMENT" fetch="select"&gt;
            &lt;key column="PAYMENT_ID"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>La déclaration optionnelle <code class="literal">fetch="select"</code> indique à Hibernate de ne pas récupérer les données de la classe fille <code class="literal">ChequePayment</code> par une jointure externe lors des requêtes sur la classe mère. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-mixing-tableperclass-tablepersubclass"/>9.1.4. Mélange d'une table par hiérarchie de classe avec une table par classe fille</h3></div></div></div><p>You can even mix the table per hierarchy and table per subclass strategies using the following approach: </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        &lt;join table="CREDIT_PAYMENT"&gt;
            &lt;property name="creditCardType" column="CCTYPE"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        ...
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>Pour importe laquelle de ces stratégies, une association polymorphique vers la classe racine <code class="literal">Payment</code> est mappée en utilisant <code class="literal">&lt;many-to-one&gt;</code>. </p><pre class="programlisting">&lt;many-to-one name="payment" column="PAYMENT_ID" class="Payment"/&gt;</pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-tableperconcrete"/>9.1.5. Une table par classe concrète</h3></div></div></div><p>There are two ways we can map the table per concrete class strategy. First, you can use <code class="literal">&lt;union-subclass&gt;</code>. </p><pre class="programlisting">&lt;class name="Payment"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="sequence"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;union-subclass name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
        &lt;property name="creditCardType" column="CCTYPE"/&gt;
        ...
    &lt;/union-subclass&gt;
    &lt;union-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        ...
    &lt;/union-subclass&gt;
    &lt;union-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        ...
    &lt;/union-subclass&gt;
&lt;/class&gt;</pre><p>Trois tables sont nécessaires pour les classes filles. Chaque table définit des colonnes pour toutes les propriétés de la classe, incluant les propriétés héritéés. </p><p>The limitation of this approach is that if a property is mapped on the superclass, the column name must be the same on all subclass tables. The identity generator strategy is not allowed in union subclass inheritance. The primary key seed has to be shared across all unioned subclasses of a hierarchy. </p><p>If your superclass is abstract, map it with <code class="literal">abstract="true"</code>. If it is not abstract, an additional table (it defaults to <code class="literal">PAYMENT</code> in the example above), is needed to hold instances of the superclass. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-tableperconcreate-polymorphism"/>9.1.6. Table per concrete class using implicit polymorphism</h3></div></div></div><p>Une approche alternative est l'emploi du polymorphisme implicite : </p><pre class="programlisting">&lt;class name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CREDIT_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CREDIT_AMOUNT"/&gt;
    ...
&lt;/class&gt;

&lt;class name="CashPayment" table="CASH_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CASH_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CASH_AMOUNT"/&gt;
    ...
&lt;/class&gt;

&lt;class name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CHEQUE_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CHEQUE_AMOUNT"/&gt;
    ...
&lt;/class&gt;</pre><p>Notice that the <code class="literal">Payment</code> interface is not mentioned explicitly. Also notice that properties of <code class="literal">Payment</code> are mapped in each of the subclasses. If you want to avoid duplication, consider using XML entities (for example, <code class="literal">[ &lt;!ENTITY allproperties SYSTEM "allproperties.xml"&gt; ]</code> in the <code class="literal">DOCTYPE</code> declaration and <code class="literal">&amp;allproperties;</code> in the mapping). </p><p>L'inconvénient de cette approche est qu'Hibernate ne génère pas d'<code class="literal">UNION</code>s SQL lors de l'exécution des requêtes polymorphiques. </p><p>Pour cette stratégie de mapping, une association polymorphique pour <code class="literal">Payment</code> est habituellement mappée en utilisant <code class="literal">&lt;any&gt;</code>. </p><pre class="programlisting">&lt;any name="payment" meta-type="string" id-type="long"&gt;
    &lt;meta-value value="CREDIT" class="CreditCardPayment"/&gt;
    &lt;meta-value value="CASH" class="CashPayment"/&gt;
    &lt;meta-value value="CHEQUE" class="ChequePayment"/&gt;
    &lt;column name="PAYMENT_CLASS"/&gt;
    &lt;column name="PAYMENT_ID"/&gt;
&lt;/any&gt;</pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-mixingpolymorphism"/>9.1.7. Mélange du polymorphisme implicite avec d'autres mappings d'héritage</h3></div></div></div><p>Since the subclasses are each mapped in their own <code class="literal">&lt;class&gt;</code> element, and since <code class="literal">Payment</code> is just an interface), each of the subclasses could easily be part of another inheritance hierarchy. You can still use polymorphic queries against the <code class="literal">Payment</code> interface. </p><pre class="programlisting">&lt;class name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CREDIT_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="CREDIT_CARD" type="string"/&gt;
    &lt;property name="amount" column="CREDIT_AMOUNT"/&gt;
    ...
    &lt;subclass name="MasterCardPayment" discriminator-value="MDC"/&gt;
    &lt;subclass name="VisaPayment" discriminator-value="VISA"/&gt;
&lt;/class&gt;

&lt;class name="NonelectronicTransaction" table="NONELECTRONIC_TXN"&gt;
    &lt;id name="id" type="long" column="TXN_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    ...
    &lt;joined-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="amount" column="CASH_AMOUNT"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="amount" column="CHEQUE_AMOUNT"/&gt;
        ...
    &lt;/joined-subclass&gt;
&lt;/class&gt;</pre><p>Once again, <code class="literal">Payment</code> is not mentioned explicitly. If we execute a query against the <code class="literal">Payment</code> interface, for example <code class="literal">from Payment</code>, Hibernate automatically returns instances of <code class="literal">CreditCardPayment</code> (and its subclasses, since they also implement <code class="literal">Payment</code>), <code class="literal">CashPayment</code> and <code class="literal">ChequePayment</code>, but not instances of <code class="literal">NonelectronicTransaction</code>. </p></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="inheritance-limitations"/>9.2. Limitations</h2></div></div></div><p>There are limitations to the "implicit polymorphism" approach to the table per concrete-class mapping strategy. There are somewhat less restrictive limitations to <code class="literal">&lt;union-subclass&gt;</code> mappings. </p><p>La table suivante montre les limitations des mappings d'une table par classe concrète, et du polymorphisme implicite, dans Hibernate. </p><div class="table"><a id="d0e9194"/><p class="title"><b>Tableau 9.1. Caractéristiques du mapping d'héritage</b></p><div class="table-contents"><table summary="Caractéristiques du mapping d'héritage" border="1"><colgroup><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/></colgroup><thead><tr><th align="left">Stratégie d'héritage</th><th align="left">many-to-one polymorphique</th><th align="left">one-to-one polymorphique</th><th align="left">one-to-many polymorphique</th><th align="left">many-to-many polymorphique</th><th align="left">Polymorphic <code class="literal">load()/get()</code></th><th align="left">Requêtes polymorphiques</th><th align="left">Jointures polymorphiques</th><th align="left">Récupération par jointure externe</th></tr></thead><tbody><tr><td align="left">une table par hiérarchie de classe</td><td align="left"><code class="literal">&lt;many-to-one&gt;</code></td><td align="left"><code class="literal">&lt;one-to-one&gt;</code></td><td align="left"><code class="literal">&lt;one-to-many&gt;</code></td><td align="left"><code class="literal">&lt;many-to-many&gt;</code></td><td align="left"><code class="literal">s.get(Payment.class, id)</code></td><td align="left"><code class="literal">from Payment p</code></td><td align="left"><code class="literal">from Order o join o.payment p</code></td><td align="left"><span class="emphasis"><em>supportée</em></span></td></tr><tr><td align="left">table per subclass</td><td align="left"><code class="literal">&lt;many-to-one&gt;</code></td><td align="left"><code class="literal">&lt;one-to-one&gt;</code></td><td align="left"><code class="literal">&lt;one-to-many&gt;</code></td><td align="left"><code class="literal">&lt;many-to-many&gt;</code></td><td align="left"><code class="literal">s.get(Payment.class, id)</code></td><td align="left"><code class="literal">from Payment p</code></td><td align="left"><code class="literal">from Order o join o.payment p</code></td><td align="left"><span class="emphasis"><em>supportée</em></span></td></tr><tr><td align="left">une table par classe concrète (union-subclass)</td><td align="left"><code class="literal">&lt;many-to-one&gt;</code></td><td align="left"><code class="literal">&lt;one-to-one&gt;</code></td><td align="left"><code class="literal">&lt;one-to-many&gt;</code> (for <code class="literal">inverse="true"</code> only)</td><td align="left"><code class="literal">&lt;many-to-many&gt;</code></td><td align="left"><code class="literal">s.get(Payment.class, id)</code></td><td align="left"><code class="literal">from Payment p</code></td><td align="left"><code class="literal">from Order o join o.payment p</code></td><td align="left"><span class="emphasis"><em>supportée</em></span></td></tr><tr><td align="left">une table par classe concrète (polymorphisme implicite)</td><td align="left"><code class="literal">&lt;any&gt;</code></td><td align="left"><span class="emphasis"><em>not supported</em></span></td><td align="left"><span class="emphasis"><em>not supported</em></span></td><td align="left"><code class="literal">&lt;many-to-any&gt;</code></td><td align="left"><code class="literal">s.createCriteria(Payment.class).add( Restrictions.idEq(id) ).uniqueResult()</code></td><td align="left"><code class="literal">from Payment p</code></td><td align="left"><span class="emphasis"><em>not supported</em></span></td><td align="left"><span class="emphasis"><em>not supported</em></span></td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate"/>Chapitre 10. Travailler avec des objets</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#objectstate-overview">10.1. États des objets Hibernate</a></span></dt><dt><span class="sect1"><a href="#objectstate-makingpersistent">10.2. Rendre des objets persistants</a></span></dt><dt><span class="sect1"><a href="#objectstate-loading">10.3. Chargement d'un objet</a></span></dt><dt><span class="sect1"><a href="#objectstate-querying">10.4. Requêtage</a></span></dt><dd><dl><dt><span class="sect2"><a href="#objectstate-querying-executing">10.4.1. Exécution de requêtes</a></span></dt><dt><span class="sect2"><a href="#objectstate-filtering">10.4.2. Filtrer des collections</a></span></dt><dt><span class="sect2"><a href="#objecstate-querying-criteria">10.4.3. Requêtes Criteria</a></span></dt><dt><span class="sect2"><a href="#objectstate-querying-nativesql">10.4.4. Requêtes en SQL natif</a></span></dt></dl></dd><dt><span class="sect1"><a href="#objectstate-modifying">10.5. Modifier des objets persistants</a></span></dt><dt><span class="sect1"><a href="#objectstate-detached">10.6. Modifier des objets détachés</a></span></dt><dt><span class="sect1"><a href="#objectstate-saveorupdate">10.7. Détection automatique d'un état</a></span></dt><dt><span class="sect1"><a href="#objectstate-deleting">10.8. Suppression d'objets persistants</a></span></dt><dt><span class="sect1"><a href="#objectstate-replicating">10.9. Réplication d'objets entre deux entrepôts de données</a></span></dt><dt><span class="sect1"><a href="#objectstate-flushing">10.10. Flush de la session</a></span></dt><dt><span class="sect1"><a href="#objectstate-transitive">10.11. Persistance transitive</a></span></dt><dt><span class="sect1"><a href="#objectstate-metadata">10.12. Utilisation des méta-données</a></span></dt></dl></div><p>Hibernate is a full object/relational mapping solution that not only shields the developer from the details of the underlying database management system, but also offers <span class="emphasis"><em>state management</em></span> of objects. This is, contrary to the management of SQL <code class="literal">statements</code> in common JDBC/SQL persistence layers, a natural object-oriented view of persistence in Java applications. </p><p>En d'autres mots, les développeurs d'applications Hibernate devrait toujours réfléchir à <span class="emphasis"><em>l'état</em></span> de leurs objets, et pas nécessairement à l'exécution des expressions SQL. Cette part est prise en charge pas Hibernate et seulement importante pour les développeurs d'applications lors du réglage de la performance de leur système. </p><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-overview"/>10.1. États des objets Hibernate</h2></div></div></div><p>Hibernate définit et comprend les états suivants : </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Transient</em></span> - an object is transient if it has just been instantiated using the <code class="literal">new</code> operator, and it is not associated with a Hibernate <code class="literal">Session</code>. It has no persistent representation in the database and no identifier value has been assigned. Transient instances will be destroyed by the garbage collector if the application does not hold a reference anymore. Use the Hibernate <code class="literal">Session</code> to make an object persistent (and let Hibernate take care of the SQL statements that need to be executed for this transition). </p></li><li><p><span class="emphasis"><em>Persistent</em></span> - a persistent instance has a representation in the database and an identifier value. It might just have been saved or loaded, however, it is by definition in the scope of a <code class="literal">Session</code>. Hibernate will detect any changes made to an object in persistent state and synchronize the state with the database when the unit of work completes. Developers do not execute manual <code class="literal">UPDATE</code> statements, or <code class="literal">DELETE</code> statements when an object should be made transient. </p></li><li><p><span class="emphasis"><em>Detached</em></span> - a detached instance is an object that has been persistent, but its <code class="literal">Session</code> has been closed. The reference to the object is still valid, of course, and the detached instance might even be modified in this state. A detached instance can be reattached to a new <code class="literal">Session</code> at a later point in time, making it (and all the modifications) persistent again. This feature enables a programming model for long running units of work that require user think-time. We call them <span class="emphasis"><em>application transactions</em></span>, i.e., a unit of work from the point of view of the user. </p></li></ul></div><p>We will now discuss the states and state transitions (and the Hibernate methods that trigger a transition) in more detail. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-makingpersistent"/>10.2. Rendre des objets persistants</h2></div></div></div><p>Les instances nouvellement instanciées d'une classe persistante sont considérées <span class="emphasis"><em>éphémères</em></span> par Hibernate. Nous pouvons rendre une instance éphémère <span class="emphasis"><em>persistante</em></span> en l'associant avec une session : </p><pre class="programlisting">DomesticCat fritz = new DomesticCat();
fritz.setColor(Color.GINGER);
fritz.setSex('M');
fritz.setName("Fritz");
Long generatedId = (Long) sess.save(fritz);</pre><p>If <code class="literal">Cat</code> has a generated identifier, the identifier is generated and assigned to the <code class="literal">cat</code> when <code class="literal">save()</code> is called. If <code class="literal">Cat</code> has an <code class="literal">assigned</code> identifier, or a composite key, the identifier should be assigned to the <code class="literal">cat</code> instance before calling <code class="literal">save()</code>. You can also use <code class="literal">persist()</code> instead of <code class="literal">save()</code>, with the semantics defined in the EJB3 early draft. </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">persist()</code> makes a transient instance persistent. However, it does not guarantee that the identifier value will be assigned to the persistent instance immediately, the assignment might happen at flush time. <code class="literal">persist()</code> also guarantees that it will not execute an <code class="literal">INSERT</code> statement if it is called outside of transaction boundaries. This is useful in long-running conversations with an extended Session/persistence context. </p></li><li><p><code class="literal">save()</code> does guarantee to return an identifier. If an INSERT has to be executed to get the identifier ( e.g. "identity" generator, not "sequence"), this INSERT happens immediately, no matter if you are inside or outside of a transaction. This is problematic in a long-running conversation with an extended Session/persistence context. </p></li></ul></div><p>Alternatively, you can assign the identifier using an overloaded version of <code class="literal">save()</code>. </p><pre class="programlisting">DomesticCat pk = new DomesticCat();
pk.setColor(Color.TABBY);
pk.setSex('F');
pk.setName("PK");
pk.setKittens( new HashSet() );
pk.addKitten(fritz);
sess.save( pk, new Long(1234) );</pre><p>If the object you make persistent has associated objects (e.g. the <code class="literal">kittens</code> collection in the previous example), these objects can be made persistent in any order you like unless you have a <code class="literal">NOT NULL</code> constraint upon a foreign key column. There is never a risk of violating foreign key constraints. However, you might violate a <code class="literal">NOT NULL</code> constraint if you <code class="literal">save()</code> the objects in the wrong order. </p><p>Usually you do not bother with this detail, as you will normally use Hibernate's <span class="emphasis"><em>transitive persistence</em></span> feature to save the associated objects automatically. Then, even <code class="literal">NOT NULL</code> constraint violations do not occur - Hibernate will take care of everything. Transitive persistence is discussed later in this chapter. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-loading"/>10.3. Chargement d'un objet</h2></div></div></div><p>The <code class="literal">load()</code> methods of <code class="literal">Session</code> provide a way of retrieving a persistent instance if you know its identifier. <code class="literal">load()</code> takes a class object and loads the state into a newly instantiated instance of that class in a persistent state. </p><pre class="programlisting">Cat fritz = (Cat) sess.load(Cat.class, generatedId);</pre><pre class="programlisting">// you need to wrap primitive identifiers
long id = 1234;
DomesticCat pk = (DomesticCat) sess.load( DomesticCat.class, new Long(id) );</pre><p>Alternativement, vous pouvez charger un état dans une instance donnée : </p><pre class="programlisting">Cat cat = new DomesticCat();
// load pk's state into cat
sess.load( cat, new Long(pkId) );
Set kittens = cat.getKittens();</pre><p>Be aware that <code class="literal">load()</code> will throw an unrecoverable exception if there is no matching database row. If the class is mapped with a proxy, <code class="literal">load()</code> just returns an uninitialized proxy and does not actually hit the database until you invoke a method of the proxy. This is useful if you wish to create an association to an object without actually loading it from the database. It also allows multiple instances to be loaded as a batch if <code class="literal">batch-size</code> is defined for the class mapping. </p><p>If you are not certain that a matching row exists, you should use the <code class="literal">get()</code> method which hits the database immediately and returns null if there is no matching row. </p><pre class="programlisting">Cat cat = (Cat) sess.get(Cat.class, id);
if (cat==null) {
    cat = new Cat();
    sess.save(cat, id);
}
return cat;</pre><p>You can even load an object using an SQL <code class="literal">SELECT ... FOR UPDATE</code>, using a <code class="literal">LockMode</code>. See the API documentation for more information. </p><pre class="programlisting">Cat cat = (Cat) sess.get(Cat.class, id, LockMode.UPGRADE);</pre><p>Any associated instances or contained collections will <span class="emphasis"><em>not</em></span> be selected <code class="literal">FOR UPDATE</code>, unless you decide to specify <code class="literal">lock</code> or <code class="literal">all</code> as a cascade style for the association. </p><p>Il est possible de re-charger un objet et toutes ses collections à n'importe quel moment, en utilisant la méthode <code class="literal">refresh()</code>. C'est utile lorsque des "triggers" de base de données sont utilisés pour initiliser certains propriétés de l'objet. </p><pre class="programlisting">sess.save(cat);
sess.flush(); //force the SQL INSERT
sess.refresh(cat); //re-read the state (after the trigger executes)</pre><p>How much does Hibernate load from the database and how many SQL <code class="literal">SELECT</code>s will it use? This depends on the <span class="emphasis"><em>fetching strategy</em></span>. This is explained in <a href="#performance-fetching" title="19.1. Stratégies de chargement">Section 19.1, « Stratégies de chargement »</a>. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-querying"/>10.4. Requêtage</h2></div></div></div><p>If you do not know the identifiers of the objects you are looking for, you need a query. Hibernate supports an easy-to-use but powerful object oriented query language (HQL). For programmatic query creation, Hibernate supports a sophisticated Criteria and Example query feature (QBC and QBE). You can also express your query in the native SQL of your database, with optional support from Hibernate for result set conversion into objects. </p><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="objectstate-querying-executing"/>10.4.1. Exécution de requêtes</h3></div></div></div><p>Les requêtes HQL et SQL natives sont représentées avec une instance de <code class="literal">org.hibernate.Query</code>. L'interface offre des méthodes pour la liaison des paramètres, la gestion des ensembles de resultats, et pour l'exécution de la requête réelle. Vous obtenez toujours une <code class="literal">Query</code> en utilisant la <code class="literal">Session</code> courante : </p><pre class="programlisting">List cats = session.createQuery(
    "from Cat as cat where cat.birthdate &lt; ?")
    .setDate(0, date)
    .list();

List mothers = session.createQuery(
    "select mother from Cat as cat join cat.mother as mother where cat.name = ?")
    .setString(0, name)
    .list();

List kittens = session.createQuery(
    "from Cat as cat where cat.mother = ?")
    .setEntity(0, pk)
    .list();

Cat mother = (Cat) session.createQuery(
    "select cat.mother from Cat as cat where cat = ?")
    .setEntity(0, izi)
    .uniqueResult();]]

Query mothersWithKittens = (Cat) session.createQuery(
    "select mother from Cat as mother left join fetch mother.kittens");
Set uniqueMothers = new HashSet(mothersWithKittens.list());</pre><p>A query is usually executed by invoking <code class="literal">list()</code>. The result of the query will be loaded completely into a collection in memory. Entity instances retrieved by a query are in a persistent state. The <code class="literal">uniqueResult()</code> method offers a shortcut if you know your query will only return a single object. Queries that make use of eager fetching of collections usually return duplicates of the root objects, but with their collections initialized. You can filter these duplicates through a <code class="literal">Set</code>. </p><div class="sect3" lang="fr-FR"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-iterate"/>10.4.1.1. Itération de résultats</h4></div></div></div><p>Occasionally, you might be able to achieve better performance by executing the query using the <code class="literal">iterate()</code> method. This will usually be the case if you expect that the actual entity instances returned by the query will already be in the session or second-level cache. If they are not already cached, <code class="literal">iterate()</code> will be slower than <code class="literal">list()</code> and might require many database hits for a simple query, usually <span class="emphasis"><em>1</em></span> for the initial select which only returns identifiers, and <span class="emphasis"><em>n</em></span> additional selects to initialize the actual instances. </p><pre class="programlisting">// fetch ids
Iterator iter = sess.createQuery("from eg.Qux q order by q.likeliness").iterate();
while ( iter.hasNext() ) {
    Qux qux = (Qux) iter.next();  // fetch the object
    // something we couldnt express in the query
    if ( qux.calculateComplicatedAlgorithm() ) {
        // delete the current instance
        iter.remove();
        // dont need to process the rest
        break;
    }
}</pre></div><div class="sect3" lang="fr-FR"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-tuples"/>10.4.1.2. Requêtes qui retournent des tuples</h4></div></div></div><p>Hibernate queries sometimes return tuples of objects. Each tuple is returned as an array: </p><pre class="programlisting">Iterator kittensAndMothers = sess.createQuery(
            "select kitten, mother from Cat kitten join kitten.mother mother")
            .list()
            .iterator();

while ( kittensAndMothers.hasNext() ) {
    Object[] tuple = (Object[]) kittensAndMothers.next();
    Cat kitten = (Cat) tuple[0];
    Cat mother = (Cat) tuple[1];
    ....
}</pre></div><div class="sect3" lang="fr-FR"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-scalar"/>10.4.1.3. Résultats scalaires</h4></div></div></div><p>Queries can specify a property of a class in the <code class="literal">select</code> clause. They can even call SQL aggregate functions. Properties or aggregates are considered "scalar" results and not entities in persistent state. </p><pre class="programlisting">Iterator results = sess.createQuery(
        "select cat.color, min(cat.birthdate), count(cat) from Cat cat " +
        "group by cat.color")
        .list()
        .iterator();

while ( results.hasNext() ) {
    Object[] row = (Object[]) results.next();
    Color type = (Color) row[0];
    Date oldest = (Date) row[1];
    Integer count = (Integer) row[2];
    .....
}</pre></div><div class="sect3" lang="fr-FR"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-parameters"/>10.4.1.4. Lier des paramètres</h4></div></div></div><p>Methods on <code class="literal">Query</code> are provided for binding values to named parameters or JDBC-style <code class="literal">?</code> parameters. <span class="emphasis"><em>Contrary to JDBC, Hibernate numbers parameters from zero.</em></span> Named parameters are identifiers of the form <code class="literal">:name</code> in the query string. The advantages of named parameters are as follows: </p><div class="itemizedlist"><ul compact="compact"><li><p>les paramètres nommés sont insensibles à l'ordre de leur place dans la chaîne de la requête </p></li><li><p>they can occur multiple times in the same query </p></li><li><p>ils sont auto-documentés </p></li></ul></div><pre class="programlisting">//named parameter (preferred)
Query q = sess.createQuery("from DomesticCat cat where cat.name = :name");
q.setString("name", "Fritz");
Iterator cats = q.iterate();</pre><pre class="programlisting">//positional parameter
Query q = sess.createQuery("from DomesticCat cat where cat.name = ?");
q.setString(0, "Izi");
Iterator cats = q.iterate();</pre><pre class="programlisting">//named parameter list
List names = new ArrayList();
names.add("Izi");
names.add("Fritz");
Query q = sess.createQuery("from DomesticCat cat where cat.name in (:namesList)");
q.setParameterList("namesList", names);
List cats = q.list();</pre></div><div class="sect3" lang="fr-FR"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-pagination"/>10.4.1.5. Pagination</h4></div></div></div><p>If you need to specify bounds upon your result set, that is, the maximum number of rows you want to retrieve and/or the first row you want to retrieve, you can use methods of the <code class="literal">Query</code> interface: </p><pre class="programlisting">Query q = sess.createQuery("from DomesticCat cat");
q.setFirstResult(20);
q.setMaxResults(10);
List cats = q.list();</pre><p>Hibernate sait comment traduite cette requête de limite en SQL natif pour votre SGBD. </p></div><div class="sect3" lang="fr-FR"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-scrolling"/>10.4.1.6. Itération "scrollable"</h4></div></div></div><p>If your JDBC driver supports scrollable <code class="literal">ResultSet</code>s, the <code class="literal">Query</code> interface can be used to obtain a <code class="literal">ScrollableResults</code> object that allows flexible navigation of the query results. </p><pre class="programlisting">Query q = sess.createQuery("select cat.name, cat from DomesticCat cat " +
                            "order by cat.name");
ScrollableResults cats = q.scroll();
if ( cats.first() ) {

    // find the first name on each page of an alphabetical list of cats by name
    firstNamesOfPages = new ArrayList();
    do {
        String name = cats.getString(0);
        firstNamesOfPages.add(name);
    }
    while ( cats.scroll(PAGE_SIZE) );

    // Now get the first page of cats
    pageOfCats = new ArrayList();
    cats.beforeFirst();
    int i=0;
    while( ( PAGE_SIZE &gt; i++ ) &amp;&amp; cats.next() ) pageOfCats.add( cats.get(1) );

}
cats.close()</pre><p>Note that an open database connection and cursor is required for this functionality. Use <code class="literal">setMaxResult()</code>/<code class="literal">setFirstResult()</code> if you need offline pagination functionality. </p></div><div class="sect3" lang="fr-FR"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-named"/>10.4.1.7. Externaliser des requêtes nommées</h4></div></div></div><p>You can also define named queries in the mapping document. Remember to use a <code class="literal">CDATA</code> section if your query contains characters that could be interpreted as markup. </p><pre class="programlisting">&lt;query name="ByNameAndMaximumWeight"&gt;&lt;![CDATA[
    from eg.DomesticCat as cat
        where cat.name = ?
        and cat.weight &gt; ?
] ]&gt;&lt;/query&gt;</pre><p>La liaison de paramètres et l'exécution sont fait par programmation : </p><pre class="programlisting">Query q = sess.getNamedQuery("ByNameAndMaximumWeight");
q.setString(0, name);
q.setInt(1, minWeight);
List cats = q.list();</pre><p>The actual program code is independent of the query language that is used. You can also define native SQL queries in metadata, or migrate existing queries to Hibernate by placing them in mapping files. </p><p>Also note that a query declaration inside a <code class="literal">&lt;hibernate-mapping&gt;</code> element requires a global unique name for the query, while a query declaration inside a <code class="literal">&lt;class&gt;</code> element is made unique automatically by prepending the fully qualified name of the class. For example <code class="literal">eg.Cat.ByNameAndMaximumWeight</code>. </p></div></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="objectstate-filtering"/>10.4.2. Filtrer des collections</h3></div></div></div><p>A collection <span class="emphasis"><em>filter</em></span> is a special type of query that can be applied to a persistent collection or array. The query string can refer to <code class="literal">this</code>, meaning the current collection element. </p><pre class="programlisting">Collection blackKittens = session.createFilter(
    pk.getKittens(), 
    "where this.color = ?")
    .setParameter( Color.BLACK, Hibernate.custom(ColorUserType.class) )
    .list()
);</pre><p>The returned collection is considered a bag that is a copy of the given collection. The original collection is not modified. This is contrary to the implication of the name "filter", but consistent with expected behavior. </p><p>Observe that filters do not require a <code class="literal">from</code> clause, although they can have one if required. Filters are not limited to returning the collection elements themselves. </p><pre class="programlisting">Collection blackKittenMates = session.createFilter(
    pk.getKittens(), 
    "select this.mate where this.color = eg.Color.BLACK.intValue")
    .list();</pre><p>Even an empty filter query is useful, e.g. to load a subset of elements in a large collection: </p><pre class="programlisting">Collection tenKittens = session.createFilter(
    mother.getKittens(), "")
    .setFirstResult(0).setMaxResults(10)
    .list();</pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="objecstate-querying-criteria"/>10.4.3. Requêtes Criteria</h3></div></div></div><p>HQL is extremely powerful, but some developers prefer to build queries dynamically using an object-oriented API, rather than building query strings. Hibernate provides an intuitive <code class="literal">Criteria</code> query API for these cases: </p><pre class="programlisting">Criteria crit = session.createCriteria(Cat.class);
crit.add( Restrictions.eq( "color", eg.Color.BLACK ) );
crit.setMaxResults(10);
List cats = crit.list();</pre><p>Les APIs <code class="literal">Criteria</code> et <code class="literal">Example</code> associé sont traitées plus en détail dans <a href="#querycriteria" title="Chapitre 15. Requêtes par critères">Chapitre 15, <i xmlns:xlink="http://www.w3.org/1999/xlink">Requêtes par critères</i></a>. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="objectstate-querying-nativesql"/>10.4.4. Requêtes en SQL natif</h3></div></div></div><p>You can express a query in SQL, using <code class="literal">createSQLQuery()</code> and let Hibernate manage the mapping from result sets to objects. You can at any time call <code class="literal">session.connection()</code> and use the JDBC <code class="literal">Connection</code> directly. If you choose to use the Hibernate API, you must enclose SQL aliases in braces: </p><pre class="programlisting">List cats = session.createSQLQuery("SELECT {cat.*} FROM CAT {cat} WHERE ROWNUM&lt;10")
    .addEntity("cat", Cat.class)
.list();</pre><pre class="programlisting">List cats = session.createSQLQuery(
    "SELECT {cat}.ID AS {cat.id}, {cat}.SEX AS {cat.sex}, " +
           "{cat}.MATE AS {cat.mate}, {cat}.SUBCLASS AS {cat.class}, ... " +
    "FROM CAT {cat} WHERE ROWNUM&lt;10")
    .addEntity("cat", Cat.class)
.list()</pre><p>SQL queries can contain named and positional parameters, just like Hibernate queries. More information about native SQL queries in Hibernate can be found in <a href="#querysql" title="Chapitre 16. SQL natif">Chapitre 16, <i xmlns:xlink="http://www.w3.org/1999/xlink">SQL natif</i></a>. </p></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-modifying"/>10.5. Modifier des objets persistants</h2></div></div></div><p><span class="emphasis"><em>Transactional persistent instances</em></span> (i.e. objects loaded, saved, created or queried by the <code class="literal">Session</code>) can be manipulated by the application, and any changes to persistent state will be persisted when the <code class="literal">Session</code> is <span class="emphasis"><em>flushed</em></span>. This is discussed later in this chapter. There is no need to call a particular method (like <code class="literal">update()</code>, which has a different purpose) to make your modifications persistent. The most straightforward way to update the state of an object is to <code class="literal">load()</code> it and then manipulate it directly while the <code class="literal">Session</code> is open: </p><pre class="programlisting">DomesticCat cat = (DomesticCat) sess.load( Cat.class, new Long(69) );
cat.setName("PK");
sess.flush();  // changes to cat are automatically detected and persisted</pre><p>Sometimes this programming model is inefficient, as it requires in the same session both an SQL <code class="literal">SELECT</code> to load an object and an SQL <code class="literal">UPDATE</code> to persist its updated state. Hibernate offers an alternate approach by using detached instances. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>Hibernate does not offer its own API for direct execution of <code class="literal">UPDATE</code> or <code class="literal">DELETE</code> statements. Hibernate is a <span class="emphasis"><em>state management</em></span> service, you do not have to think in <span class="emphasis"><em>statements</em></span> to use it. JDBC is a perfect API for executing SQL statements, you can get a JDBC <code class="literal">Connection</code> at any time by calling <code class="literal">session.connection()</code>. Furthermore, the notion of mass operations conflicts with object/relational mapping for online transaction processing-oriented applications. Future versions of Hibernate can, however, provide special mass operation functions. See <a href="#batch" title="Chapitre 13. Traitement par paquet">Chapitre 13, <i xmlns:xlink="http://www.w3.org/1999/xlink">Traitement par paquet</i></a> for some possible batch operation tricks. </p></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-detached"/>10.6. Modifier des objets détachés</h2></div></div></div><p>Beaucoup d'applications ont besoin de récupérer un objet dans une transaction, l'envoyer à la couche interfacée avec l'utilisateur pour les manipulations, puis sauvegarder les changements dans une nouvelle transaction. Les applications qui utilisent cette approche dans un environnement à haute concurrence utilisent généralement des données versionnées pour assurer l'isolation pour les "longues" unités de travail. </p><p>Hibernate supporte ce modèle en permettant pour le réattachement d'instances détachées l'utilisation des méthodes <code class="literal">Session.update()</code> ou <code class="literal">Session.merge()</code> : </p><pre class="programlisting">// in the first session
Cat cat = (Cat) firstSession.load(Cat.class, catId);
Cat potentialMate = new Cat();
firstSession.save(potentialMate);

// in a higher layer of the application
cat.setMate(potentialMate);

// later, in a new session
secondSession.update(cat);  // update cat
secondSession.update(mate); // update mate</pre><p>Si le <code class="literal">Cat</code> avec l'identifiant <code class="literal">catId</code> avait déjà été chargé par <code class="literal">secondSession</code> lorsque l'application a essayé de le réattacher, une exception aurait été levée. </p><p>Use <code class="literal">update()</code> if you are certain that the session does not contain an already persistent instance with the same identifier. Use <code class="literal">merge()</code> if you want to merge your modifications at any time without consideration of the state of the session. In other words, <code class="literal">update()</code> is usually the first method you would call in a fresh session, ensuring that the reattachment of your detached instances is the first operation that is executed. </p><p>The application should individually <code class="literal">update()</code> detached instances that are reachable from the given detached instance <span class="emphasis"><em>only</em></span> if it wants their state to be updated. This can be automated using <span class="emphasis"><em>transitive persistence</em></span>. See <a href="#objectstate-transitive" title="10.11. Persistance transitive">Section 10.11, « Persistance transitive »</a> for more information. </p><p>The <code class="literal">lock()</code> method also allows an application to reassociate an object with a new session. However, the detached instance has to be unmodified. </p><pre class="programlisting">//just reassociate:
sess.lock(fritz, LockMode.NONE);
//do a version check, then reassociate:
sess.lock(izi, LockMode.READ);
//do a version check, using SELECT ... FOR UPDATE, then reassociate:
sess.lock(pk, LockMode.UPGRADE);</pre><p>Note that <code class="literal">lock()</code> can be used with various <code class="literal">LockMode</code>s. See the API documentation and the chapter on transaction handling for more information. Reattachment is not the only usecase for <code class="literal">lock()</code>. </p><p>D'autres modèles pour de longues unités de travail sont traités dans <a href="#transactions-optimistic" title="11.3. Contrôle de consurrence optimiste">Section 11.3, « Contrôle de consurrence optimiste »</a>. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-saveorupdate"/>10.7. Détection automatique d'un état</h2></div></div></div><p>Les utilisateurs d'Hibernate ont demandé une méthode dont l'intention générale serait soit de sauvegarder une instance éphémère en générant un nouvel identifiant, soit mettre à jour/réattacher les instances détachées associées à l'identifiant courant. La méthode <code class="literal">saveOrUpdate()</code> implémente cette fonctionnalité. </p><pre class="programlisting">// in the first session
Cat cat = (Cat) firstSession.load(Cat.class, catID);

// in a higher tier of the application
Cat mate = new Cat();
cat.setMate(mate);

// later, in a new session
secondSession.saveOrUpdate(cat);   // update existing state (cat has a non-null id)
secondSession.saveOrUpdate(mate);  // save the new instance (mate has a null id)</pre><p>L'usage et la sémantique de <code class="literal">saveOrUpdate()</code> semble être confuse pour les nouveaux utilisateurs. Premièrement, aussi longtemps que vous n'essayez pas d'utiliser des instances d'une session dans une autre, vous ne devriez pas avoir besoin d'utiliser <code class="literal">update()</code>, <code class="literal">saveOrUpdate()</code>, ou <code class="literal">merge()</code>. Certaines applications n'utiliseront jamais ces méthodes. </p><p>Généralement <code class="literal">update()</code> ou <code class="literal">saveOrUpdate()</code> sont utilisées dans le scénario suivant : </p><div class="itemizedlist"><ul compact="compact"><li><p>l'application charge un objet dans la première session </p></li><li><p>l'objet est passé à la couche utilisateur </p></li><li><p>certaines modifications sont effectuées sur l'objet </p></li><li><p>l'objet est retourné à la couche logique métier </p></li><li><p>l'application persiste ces modifications en appelant <code class="literal">update()</code> dans une seconde sessin </p></li></ul></div><p><code class="literal">saveOrUpdate()</code> s'utilise dans le cas suivant : </p><div class="itemizedlist"><ul compact="compact"><li><p>si l'objet est déjà persistant dans cette session, ne rien faire </p></li><li><p>si un autre objet associé à la session a le même identifiant, lever une exception </p></li><li><p>si l'objet n'a pas de propriété d'identifiant, appeler <code class="literal">save()</code> </p></li><li><p>si l'identifiant de l'objet a une valeur assignée à un objet nouvellement instancié, appeler <code class="literal">save()</code> </p></li><li><p>if the object is versioned by a <code class="literal">&lt;version&gt;</code> or <code class="literal">&lt;timestamp&gt;</code>, and the version property value is the same value assigned to a newly instantiated object, <code class="literal">save()</code> it </p></li><li><p>sinon mettre à jour l'objet avec <code class="literal">update()</code> </p></li></ul></div><p>et <code class="literal">merge()</code> est très différent : </p><div class="itemizedlist"><ul compact="compact"><li><p>s'il y a une instance persistante avec le même identifiant couramment associée à la session, copier l'état de l'objet donné dans l'instance persistante </p></li><li><p>s'il n'y a pas d'instance persistante associée à cette session, essayer de le charger à partir de la base de données, ou créer une nouvelle instance persistante </p></li><li><p>l'instance persistante est retournée </p></li><li><p>l'instance donnée ne devient pas associée à la session, elle reste détachée </p></li></ul></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-deleting"/>10.8. Suppression d'objets persistants</h2></div></div></div><p><code class="literal">Session.delete()</code> will remove an object's state from the database. Your application, however, can still hold a reference to a deleted object. It is best to think of <code class="literal">delete()</code> as making a persistent instance, transient. </p><pre class="programlisting">sess.delete(cat);</pre><p>You can delete objects in any order, without risk of foreign key constraint violations. It is still possible to violate a <code class="literal">NOT NULL</code> constraint on a foreign key column by deleting objects in the wrong order, e.g. if you delete the parent, but forget to delete the children. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-replicating"/>10.9. Réplication d'objets entre deux entrepôts de données</h2></div></div></div><p>It is sometimes useful to be able to take a graph of persistent instances and make them persistent in a different datastore, without regenerating identifier values. </p><pre class="programlisting">//retrieve a cat from one database
Session session1 = factory1.openSession();
Transaction tx1 = session1.beginTransaction();
Cat cat = session1.get(Cat.class, catId);
tx1.commit();
session1.close();

//reconcile with a second database
Session session2 = factory2.openSession();
Transaction tx2 = session2.beginTransaction();
session2.replicate(cat, ReplicationMode.LATEST_VERSION);
tx2.commit();
session2.close();</pre><p>The <code class="literal">ReplicationMode</code> determines how <code class="literal">replicate()</code> will deal with conflicts with existing rows in the database: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">ReplicationMode.IGNORE</code>: ignores the object when there is an existing database row with the same identifier </p></li><li><p><code class="literal">ReplicationMode.OVERWRITE</code>: overwrites any existing database row with the same identifier </p></li><li><p><code class="literal">ReplicationMode.EXCEPTION</code>: throws an exception if there is an existing database row with the same identifier </p></li><li><p><code class="literal">ReplicationMode.LATEST_VERSION</code>: overwrites the row if its version number is earlier than the version number of the object, or ignore the object otherwise </p></li></ul></div><p>Les cas d'utilisation de cette fonctionnalité incluent la réconciliation de données entrées dans différentes base de données, l'extension des informations de configuration du système durant une mise à jour du produit, retour en arrière sur les changements effectués durant des transactions non-ACID, et plus. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-flushing"/>10.10. Flush de la session</h2></div></div></div><p>Sometimes the <code class="literal">Session</code> will execute the SQL statements needed to synchronize the JDBC connection's state with the state of objects held in memory. This process, called <span class="emphasis"><em>flush</em></span>, occurs by default at the following points: </p><div class="itemizedlist"><ul compact="compact"><li><p>lors de certaines exécutions de requête </p></li><li><p>lors d'un appel à <code class="literal">org.hibernate.Transaction.commit()</code> </p></li><li><p>lors d'un appel à <code class="literal">Session.flush()</code> </p></li></ul></div><p>The SQL statements are issued in the following order: </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>all entity insertions in the same order the corresponding objects were saved using <code class="literal">Session.save()</code> </p></li><li><p>mise à jours des entités </p></li><li><p>suppression des collections </p></li><li><p>suppression, mise à jour et insertion des éléments des collections </p></li><li><p>insertion des collections </p></li><li><p>all entity deletions in the same order the corresponding objects were deleted using <code class="literal">Session.delete()</code> </p></li></ol></div><p>An exception is that objects using <code class="literal">native</code> ID generation are inserted when they are saved. </p><p>Except when you explicitly <code class="literal">flush()</code>, there are absolutely no guarantees about <span class="emphasis"><em>when</em></span> the <code class="literal">Session</code> executes the JDBC calls, only the <span class="emphasis"><em>order</em></span> in which they are executed. However, Hibernate does guarantee that the <code class="literal">Query.list(..)</code> will never return stale or incorrect data. </p><p>It is possible to change the default behavior so that flush occurs less frequently. The <code class="literal">FlushMode</code> class defines three different modes: only flush at commit time when the Hibernate <code class="literal">Transaction</code> API is used, flush automatically using the explained routine, or never flush unless <code class="literal">flush()</code> is called explicitly. The last mode is useful for long running units of work, where a <code class="literal">Session</code> is kept open and disconnected for a long time (see <a href="#transactions-optimistic-longsession" title="11.3.2. Les sessions longues et le versionnage automatique.">Section 11.3.2, « Les sessions longues et le versionnage automatique. »</a>). </p><pre class="programlisting">sess = sf.openSession();
Transaction tx = sess.beginTransaction();
sess.setFlushMode(FlushMode.COMMIT); // allow queries to return stale state

Cat izi = (Cat) sess.load(Cat.class, id);
izi.setName(iznizi);

// might return stale data
sess.find("from Cat as cat left outer join cat.kittens kitten");

// change to izi is not flushed!
...
tx.commit(); // flush occurs
sess.close();</pre><p>Durant le flush, une exception peut se produire (par exemple, si une opération de la DML viole une contrainte). Puisque les exceptions de gestion impliquent une certaine compréhension du comportement transactionnel d'Hibernate, nous le traitons dans <a href="#transactions" title="Chapitre 11. Transactions and Concurrency">Chapitre 11, <i xmlns:xlink="http://www.w3.org/1999/xlink">Transactions and Concurrency</i></a>. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-transitive"/>10.11. Persistance transitive</h2></div></div></div><p>Il est assez pénible de sauvegarder, supprimer, ou réattacher des objets un par un, surtout si vous traitez un graphe d'objets associés. Un cas habituel est une relation parent/enfant. Considérez l'exemple suivant : </p><p>If the children in a parent/child relationship would be value typed (e.g. a collection of addresses or strings), their life cycle would depend on the parent and no further action would be required for convenient "cascading" of state changes. When the parent is saved, the value-typed child objects are saved and when the parent is deleted, the children will be deleted, etc. This works for operations such as the removal of a child from the collection. Since value-typed objects cannot have shared references, Hibernate will detect this and delete the child from the database. </p><p>Now consider the same scenario with parent and child objects being entities, not value-types (e.g. categories and items, or parent and child cats). Entities have their own life cycle and support shared references. Removing an entity from the collection does not mean it can be deleted), and there is by default no cascading of state from one entity to any other associated entities. Hibernate does not implement <span class="emphasis"><em>persistence by reachability</em></span> by default. </p><p>Pour chaque opération basique de la session d'Hibernate - incluant <code class="literal">persist(), merge(), saveOrUpdate(), delete(), lock(), refresh(), evict(), replicate()</code> - il y a un style de cascade correspondant. Respectivement, les styles de cascade s'appellent <code class="literal">persist, merge, save-update, delete, lock, refresh, evict, replicate</code>. Si vous voulez qu'une opération soit cascadée le long d'une association, vous devez l'indiquer dans le document de mapping. Par exemple : </p><pre class="programlisting">&lt;one-to-one name="person" cascade="persist"/&gt;</pre><p>Les styles de cascade peuvent être combinés : </p><pre class="programlisting">&lt;one-to-one name="person" cascade="persist,delete,lock"/&gt;</pre><p>You can even use <code class="literal">cascade="all"</code> to specify that <span class="emphasis"><em>all</em></span> operations should be cascaded along the association. The default <code class="literal">cascade="none"</code> specifies that no operations are to be cascaded. </p><p>Une style de cascade spécial, <code class="literal">delete-orphan</code>, s'applique seulement aux associations un-vers-plusieurs, et indique que l'opération <code class="literal">delete()</code> devrait être appliquée à n'importe quel enfant qui est supprimé de l'association. </p><p>Recommandations : </p><div class="itemizedlist"><ul compact="compact"><li><p>It does not usually make sense to enable cascade on a <code class="literal">&lt;many-to-one&gt;</code> or <code class="literal">&lt;many-to-many&gt;</code> association. Cascade is often useful for <code class="literal">&lt;one-to-one&gt;</code> and <code class="literal">&lt;one-to-many&gt;</code> associations. </p></li><li><p>Si la durée de vie de l'objet enfant est liée à la durée de vie de l'objet parent, faites en un <span class="emphasis"><em>objet du cycle de vie</em></span> en spécifiant <code class="literal">cascade="all,delete-orphan"</code>. </p></li><li><p>Sinon, vous pourriez ne pas avoir besoin de cascade du tout. Mais si vous pensez que vous travaillerez souvent avec le parent et les enfants ensemble dans la même transaction, et que vous voulez vous éviter quelques frappes, considérez l'utilisation de <code class="literal">cascade="persist,merge,save-update"</code>. </p></li></ul></div><p>Mapper une association (soit une simple association valuée, soit une collection) avec <code class="literal">cascade="all"</code> marque l'association comme une relation de style <span class="emphasis"><em>parent/enfant</em></span> où la sauvegarde/mise à jour/suppression du parent entraîne la sauvegarde/mise à jour/suppression de l'enfant ou des enfants. </p><p>Furthermore, a mere reference to a child from a persistent parent will result in save/update of the child. This metaphor is incomplete, however. A child which becomes unreferenced by its parent is <span class="emphasis"><em>not</em></span> automatically deleted, except in the case of a <code class="literal">&lt;one-to-many&gt;</code> association mapped with <code class="literal">cascade="delete-orphan"</code>. The precise semantics of cascading operations for a parent/child relationship are as follows: </p><div class="itemizedlist"><ul compact="compact"><li><p>Si un parent est passé à <code class="literal">persist()</code>, tous les enfant sont passés à <code class="literal">persist()</code> </p></li><li><p>Si un parent est passé à <code class="literal">merge()</code>, tous les enfants sont passés à <code class="literal">merge()</code> </p></li><li><p>Si un parent est passé à <code class="literal">save()</code>, <code class="literal">update()</code> ou <code class="literal">saveOrUpdate()</code>, tous les enfants sont passés à <code class="literal">saveOrUpdate()</code> </p></li><li><p>Si un enfant détaché ou éphémère devient référencé par un parent persistant, il est passé à <code class="literal">saveOrUpdate()</code> </p></li><li><p>Si un parent est supprimé, tous les enfants sont passés à <code class="literal">delete()</code> </p></li><li><p>Si un enfant est déréférencé par un parent persistant, <span class="emphasis"><em>rien de spécial n'arrive</em></span> - l'application devrait explicitement supprimer l'enfant si nécessaire - à moins que <code class="literal">cascade="delete-orphan"</code> soit paramétré, au quel cas l'enfant "orphelin" est supprimé. </p></li></ul></div><p>Finally, note that cascading of operations can be applied to an object graph at <span class="emphasis"><em>call time</em></span> or at <span class="emphasis"><em>flush time</em></span>. All operations, if enabled, are cascaded to associated entities reachable when the operation is executed. However, <code class="literal">save-update</code> and <code class="literal">delete-orphan</code> are transitive for all associated entities reachable during flush of the <code class="literal">Session</code>. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-metadata"/>10.12. Utilisation des méta-données</h2></div></div></div><p>Hibernate requires a rich meta-level model of all entity and value types. This model can be useful to the application itself. For example, the application might use Hibernate's metadata to implement a "smart" deep-copy algorithm that understands which objects should be copied (eg. mutable value types) and which objects that should not (e.g. immutable value types and, possibly, associated entities). </p><p>Hibernate exposes metadata via the <code class="literal">ClassMetadata</code> and <code class="literal">CollectionMetadata</code> interfaces and the <code class="literal">Type</code> hierarchy. Instances of the metadata interfaces can be obtained from the <code class="literal">SessionFactory</code>. </p><pre class="programlisting">Cat fritz = ......;
ClassMetadata catMeta = sessionfactory.getClassMetadata(Cat.class);

Object[] propertyValues = catMeta.getPropertyValues(fritz);
String[] propertyNames = catMeta.getPropertyNames();
Type[] propertyTypes = catMeta.getPropertyTypes();

// get a Map of all properties which are not collections or associations
Map namedValues = new HashMap();
for ( int i=0; i&lt;propertyNames.length; i++ ) {
    if ( !propertyTypes[i].isEntityType() &amp;&amp; !propertyTypes[i].isCollectionType() ) {
        namedValues.put( propertyNames[i], propertyValues[i] );
    }
}</pre></div></div><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions"/>Chapitre 11. Transactions and Concurrency</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#transactions-basics">11.1. Gestion de session et délimitation de transactions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-basics-uow">11.1.1. Unité de travail</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-apptx">11.1.2. Longue conversation</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-identity">11.1.3. L'identité des objets</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-issues">11.1.4. Problèmes communs</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-demarcation">11.2. Démarcation des transactions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-demarcation-nonmanaged">11.2.1. Environnement non managé</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-jta">11.2.2. Utilisation de JTA</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-exceptions">11.2.3. Gestion des exceptions</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-timeout">11.2.4. Timeout de transaction</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-optimistic">11.3. Contrôle de consurrence optimiste</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-optimistic-manual">11.3.1. Gestion du versionnage au niveau applicatif</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-longsession">11.3.2. Les sessions longues et le versionnage automatique.</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-detached">11.3.3. Les objets détachés et le versionnage automatique</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-customizing">11.3.4. Personnaliser le versionnage automatique</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-locking">11.4. Pessimistic locking</a></span></dt><dt><span class="sect1"><a href="#transactions-connection-release">11.5. Connection release modes</a></span></dt></dl></div><p>The most important point about Hibernate and concurrency control is that it is easy to understand. Hibernate directly uses JDBC connections and JTA resources without adding any additional locking behavior. It is recommended that you spend some time with the JDBC, ANSI, and transaction isolation specification of your database management system. </p><p>Hibernate does not lock objects in memory. Your application can expect the behavior as defined by the isolation level of your database transactions. Through <code class="literal">Session</code>, which is also a transaction-scoped cache, Hibernate provides repeatable reads for lookup by identifier and entity queries and not reporting queries that return scalar values. </p><p>In addition to versioning for automatic optimistic concurrency control, Hibernate also offers, using the <code class="literal">SELECT FOR UPDATE</code> syntax, a (minor) API for pessimistic locking of rows. Optimistic concurrency control and this API are discussed later in this chapter. </p><p>The discussion of concurrency control in Hibernate begins with the granularity of <code class="literal">Configuration</code>, <code class="literal">SessionFactory</code>, and <code class="literal">Session</code>, as well as database transactions and long conversations. </p><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-basics"/>11.1. Gestion de session et délimitation de transactions</h2></div></div></div><p>A <code class="literal">SessionFactory</code> is an expensive-to-create, threadsafe object, intended to be shared by all application threads. It is created once, usually on application startup, from a <code class="literal">Configuration</code> instance. </p><p>A <code class="literal">Session</code> is an inexpensive, non-threadsafe object that should be used once and then discarded for: a single request, a conversation or a single unit of work. A <code class="literal">Session</code> will not obtain a JDBC <code class="literal">Connection</code>, or a <code class="literal">Datasource</code>, unless it is needed. It will not consume any resources until used. </p><p>In order to reduce lock contention in the database, a database transaction has to be as short as possible. Long database transactions will prevent your application from scaling to a highly concurrent load. It is not recommended that you hold a database transaction open during user think time until the unit of work is complete. </p><p>What is the scope of a unit of work? Can a single Hibernate <code class="literal">Session</code> span several database transactions, or is this a one-to-one relationship of scopes? When should you open and close a <code class="literal">Session</code> and how do you demarcate the database transaction boundaries? These questions are addressed in the following sections. </p><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-uow"/>11.1.1. Unité de travail</h3></div></div></div><p>First, let's define a unit of work. A unit of work is a design pattern described by Martin Fowler as « <span class="quote"> [maintaining] a list of objects affected by a business transaction and coordinates the writing out of changes and the resolution of concurrency problems. </span> »[<a href="#biblio-PoEAA"><span class="citation">PoEAA</span></a>] In other words, its a series of operations we wish to carry out against the database together. Basically, it is a transaction, though fulfilling a unit of work will often span multiple physical database transactions (see <a href="#transactions-basics-apptx" title="11.1.2. Longue conversation">Section 11.1.2, « Longue conversation »</a>). So really we are talking about a more abstract notion of a transaction. The term "business transaction" is also sometimes used in lieu of unit of work. </p><p>Do not use the <span class="emphasis"><em>session-per-operation</em></span> antipattern: do not open and close a <code class="literal">Session</code> for every simple database call in a single thread. The same is true for database transactions. Database calls in an application are made using a planned sequence; they are grouped into atomic units of work. This also means that auto-commit after every single SQL statement is useless in an application as this mode is intended for ad-hoc SQL console work. Hibernate disables, or expects the application server to disable, auto-commit mode immediately. Database transactions are never optional. All communication with a database has to occur inside a transaction. Auto-commit behavior for reading data should be avoided, as many small transactions are unlikely to perform better than one clearly defined unit of work. The latter is also more maintainable and extensible. </p><p>The most common pattern in a multi-user client/server application is <span class="emphasis"><em>session-per-request</em></span>. In this model, a request from the client is sent to the server, where the Hibernate persistence layer runs. A new Hibernate <code class="literal">Session</code> is opened, and all database operations are executed in this unit of work. On completion of the work, and once the response for the client has been prepared, the session is flushed and closed. Use a single database transaction to serve the clients request, starting and committing it when you open and close the <code class="literal">Session</code>. The relationship between the two is one-to-one and this model is a perfect fit for many applications. </p><p>The challenge lies in the implementation. Hibernate provides built-in management of the "current session" to simplify this pattern. Start a transaction when a server request has to be processed, and end the transaction before the response is sent to the client. Common solutions are <code class="literal">ServletFilter</code>, AOP interceptor with a pointcut on the service methods, or a proxy/interception container. An EJB container is a standardized way to implement cross-cutting aspects such as transaction demarcation on EJB session beans, declaratively with CMT. If you use programmatic transaction demarcation, for ease of use and code portability use the Hibernate <code class="literal">Transaction</code> API shown later in this chapter. </p><p>Your application code can access a "current session" to process the request by calling <code class="literal">sessionFactory.getCurrentSession()</code>. You will always get a <code class="literal">Session</code> scoped to the current database transaction. This has to be configured for either resource-local or JTA environments, see <a href="#architecture-current-session" title="2.5. Contextual sessions">Section 2.5, « Contextual sessions »</a>. </p><p>You can extend the scope of a <code class="literal">Session</code> and database transaction until the "view has been rendered". This is especially useful in servlet applications that utilize a separate rendering phase after the request has been processed. Extending the database transaction until view rendering, is achieved by implementing your own interceptor. However, this will be difficult if you rely on EJBs with container-managed transactions. A transaction will be completed when an EJB method returns, before rendering of any view can start. See the Hibernate website and forum for tips and examples relating to this <span class="emphasis"><em>Open Session in View</em></span> pattern. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-apptx"/>11.1.2. Longue conversation</h3></div></div></div><p>The session-per-request pattern is not the only way of designing units of work. Many business processes require a whole series of interactions with the user that are interleaved with database accesses. In web and enterprise applications, it is not acceptable for a database transaction to span a user interaction. Consider the following example: </p><div class="itemizedlist"><ul><li><p>The first screen of a dialog opens. The data seen by the user has been loaded in a particular <code class="literal">Session</code> and database transaction. The user is free to modify the objects. </p></li><li><p>The user clicks "Save" after 5 minutes and expects their modifications to be made persistent. The user also expects that they were the only person editing this information and that no conflicting modification has occurred. </p></li></ul></div><p>From the point of view of the user, we call this unit of work a long-running <span class="emphasis"><em>conversation</em></span> or <span class="emphasis"><em>application transaction</em></span>. There are many ways to implement this in your application. </p><p>A first naive implementation might keep the <code class="literal">Session</code> and database transaction open during user think time, with locks held in the database to prevent concurrent modification and to guarantee isolation and atomicity. This is an anti-pattern, since lock contention would not allow the application to scale with the number of concurrent users. </p><p>You have to use several database transactions to implement the conversation. In this case, maintaining isolation of business processes becomes the partial responsibility of the application tier. A single conversation usually spans several database transactions. It will be atomic if only one of these database transactions (the last one) stores the updated data. All others simply read data (for example, in a wizard-style dialog spanning several request/response cycles). This is easier to implement than it might sound, especially if you utilize some of Hibernate's features: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Automatic Versioning</em></span>: Hibernate can perform automatic optimistic concurrency control for you. It can automatically detect if a concurrent modification occurred during user think time. Check for this at the end of the conversation. </p></li><li><p><span class="emphasis"><em>Detached Objects</em></span>: if you decide to use the <span class="emphasis"><em>session-per-request</em></span> pattern, all loaded instances will be in the detached state during user think time. Hibernate allows you to reattach the objects and persist the modifications. The pattern is called <span class="emphasis"><em>session-per-request-with-detached-objects</em></span>. Automatic versioning is used to isolate concurrent modifications. </p></li><li><p><span class="emphasis"><em>Extended (or Long) Session</em></span>: the Hibernate <code class="literal">Session</code> can be disconnected from the underlying JDBC connection after the database transaction has been committed and reconnected when a new client request occurs. This pattern is known as <span class="emphasis"><em>session-per-conversation</em></span> and makes even reattachment unnecessary. Automatic versioning is used to isolate concurrent modifications and the <code class="literal">Session</code> will not be allowed to be flushed automatically, but explicitly. </p></li></ul></div><p>Both <span class="emphasis"><em>session-per-request-with-detached-objects</em></span> and <span class="emphasis"><em>session-per-conversation</em></span> have advantages and disadvantages. These disadvantages are discussed later in this chapter in the context of optimistic concurrency control. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-identity"/>11.1.3. L'identité des objets</h3></div></div></div><p>An application can concurrently access the same persistent state in two different <code class="literal">Session</code>s. However, an instance of a persistent class is never shared between two <code class="literal">Session</code> instances. It is for this reason that there are two different notions of identity: </p><div class="variablelist"><dl><dt><span class="term">Identité BD</span></dt><dd><p>
                            <code class="literal">foo.getId().equals( bar.getId() )</code>
                        </p></dd><dt><span class="term">Identité JVM</span></dt><dd><p>
                            <code class="literal">foo==bar</code>
                        </p></dd></dl></div><p>For objects attached to a <span class="emphasis"><em>particular</em></span> <code class="literal">Session</code> (i.e., in the scope of a <code class="literal">Session</code>), the two notions are equivalent and JVM identity for database identity is guaranteed by Hibernate. While the application might concurrently access the "same" (persistent identity) business object in two different sessions, the two instances will actually be "different" (JVM identity). Conflicts are resolved using an optimistic approach and automatic versioning at flush/commit time. </p><p>This approach leaves Hibernate and the database to worry about concurrency. It also provides the best scalability, since guaranteeing identity in single-threaded units of work means that it does not need expensive locking or other means of synchronization. The application does not need to synchronize on any business object, as long as it maintains a single thread per <code class="literal">Session</code>. Within a <code class="literal">Session</code> the application can safely use <code class="literal">==</code> to compare objects. </p><p>However, an application that uses <code class="literal">==</code> outside of a <code class="literal">Session</code> might produce unexpected results. This might occur even in some unexpected places. For example, if you put two detached instances into the same <code class="literal">Set</code>, both might have the same database identity (i.e., they represent the same row). JVM identity, however, is by definition not guaranteed for instances in a detached state. The developer has to override the <code class="literal">equals()</code> and <code class="literal">hashCode()</code> methods in persistent classes and implement their own notion of object equality. There is one caveat: never use the database identifier to implement equality. Use a business key that is a combination of unique, usually immutable, attributes. The database identifier will change if a transient object is made persistent. If the transient instance (usually together with detached instances) is held in a <code class="literal">Set</code>, changing the hashcode breaks the contract of the <code class="literal">Set</code>. Attributes for business keys do not have to be as stable as database primary keys; you only have to guarantee stability as long as the objects are in the same <code class="literal">Set</code>. See the Hibernate website for a more thorough discussion of this issue. Please note that this is not a Hibernate issue, but simply how Java object identity and equality has to be implemented. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-issues"/>11.1.4. Problèmes communs</h3></div></div></div><p>Do not use the anti-patterns <span class="emphasis"><em>session-per-user-session</em></span> or <span class="emphasis"><em>session-per-application</em></span> (there are, however, rare exceptions to this rule). Some of the following issues might also arise within the recommended patterns, so ensure that you understand the implications before making a design decision: </p><div class="itemizedlist"><ul><li><p>A <code class="literal">Session</code> is not thread-safe. Things that work concurrently, like HTTP requests, session beans, or Swing workers, will cause race conditions if a <code class="literal">Session</code> instance is shared. If you keep your Hibernate <code class="literal">Session</code> in your <code class="literal">HttpSession</code> (this is discussed later in the chapter), you should consider synchronizing access to your Http session. Otherwise, a user that clicks reload fast enough can use the same <code class="literal">Session</code> in two concurrently running threads. </p></li><li><p>An exception thrown by Hibernate means you have to rollback your database transaction and close the <code class="literal">Session</code> immediately (this is discussed in more detail later in the chapter). If your <code class="literal">Session</code> is bound to the application, you have to stop the application. Rolling back the database transaction does not put your business objects back into the state they were at the start of the transaction. This means that the database state and the business objects will be out of sync. Usually this is not a problem, because exceptions are not recoverable and you will have to start over after rollback anyway. </p></li><li><p>The <code class="literal">Session</code> caches every object that is in a persistent state (watched and checked for dirty state by Hibernate). If you keep it open for a long time or simply load too much data, it will grow endlessly until you get an OutOfMemoryException. One solution is to call <code class="literal">clear()</code> and <code class="literal">evict()</code> to manage the <code class="literal">Session</code> cache, but you should consider a Stored Procedure if you need mass data operations. Some solutions are shown in <a href="#batch" title="Chapitre 13. Traitement par paquet">Chapitre 13, <i xmlns:xlink="http://www.w3.org/1999/xlink">Traitement par paquet</i></a>. Keeping a <code class="literal">Session</code> open for the duration of a user session also means a higher probability of stale data. </p></li></ul></div></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-demarcation"/>11.2. Démarcation des transactions</h2></div></div></div><p>Database, or system, transaction boundaries are always necessary. No communication with the database can occur outside of a database transaction (this seems to confuse many developers who are used to the auto-commit mode). Always use clear transaction boundaries, even for read-only operations. Depending on your isolation level and database capabilities this might not be required, but there is no downside if you always demarcate transactions explicitly. Certainly, a single database transaction is going to perform better than many small transactions, even for reading data. </p><p>A Hibernate application can run in non-managed (i.e., standalone, simple Web- or Swing applications) and managed J2EE environments. In a non-managed environment, Hibernate is usually responsible for its own database connection pool. The application developer has to manually set transaction boundaries (begin, commit, or rollback database transactions) themselves. A managed environment usually provides container-managed transactions (CMT), with the transaction assembly defined declaratively (in deployment descriptors of EJB session beans, for example). Programmatic transaction demarcation is then no longer necessary. </p><p>However, it is often desirable to keep your persistence layer portable between non-managed resource-local environments, and systems that can rely on JTA but use BMT instead of CMT. In both cases use programmatic transaction demarcation. Hibernate offers a wrapper API called <code class="literal">Transaction</code> that translates into the native transaction system of your deployment environment. This API is actually optional, but we strongly encourage its use unless you are in a CMT session bean. </p><p>Ending a <code class="literal">Session</code> usually involves four distinct phases: </p><div class="itemizedlist"><ul compact="compact"><li><p>flush de la session </p></li><li><p>commit de la transaction </p></li><li><p>Fermeture de la session (Close) </p></li><li><p>Gestion des exceptions </p></li></ul></div><p>We discussed Flushing the session earlier, so we will now have a closer look at transaction demarcation and exception handling in both managed and non-managed environments. </p><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-nonmanaged"/>11.2.1. Environnement non managé</h3></div></div></div><p>If a Hibernate persistence layer runs in a non-managed environment, database connections are usually handled by simple (i.e., non-DataSource) connection pools from which Hibernate obtains connections as needed. The session/transaction handling idiom looks like this: </p><pre class="programlisting">// Non-managed environment idiom
Session sess = factory.openSession();
Transaction tx = null;
try {
    tx = sess.beginTransaction();

    // do some work
    ...

    tx.commit();
}
catch (RuntimeException e) {
    if (tx != null) tx.rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}</pre><p>You do not have to <code class="literal">flush()</code> the <code class="literal">Session</code> explicitly: the call to <code class="literal">commit()</code> automatically triggers the synchronization depending on the <a href="#objectstate-flushing" title="10.10. Flush de la session">FlushMode</a> for the session. A call to <code class="literal">close()</code> marks the end of a session. The main implication of <code class="literal">close()</code> is that the JDBC connection will be relinquished by the session. This Java code is portable and runs in both non-managed and JTA environments. </p><p>As outlined earlier, a much more flexible solution is Hibernate's built-in "current session" context management: </p><pre class="programlisting">// Non-managed environment idiom with getCurrentSession()
try {
    factory.getCurrentSession().beginTransaction();

    // do some work
    ...

    factory.getCurrentSession().getTransaction().commit();
}
catch (RuntimeException e) {
    factory.getCurrentSession().getTransaction().rollback();
    throw e; // or display error message
}</pre><p>You will not see these code snippets in a regular application; fatal (system) exceptions should always be caught at the "top". In other words, the code that executes Hibernate calls in the persistence layer, and the code that handles <code class="literal">RuntimeException</code> (and usually can only clean up and exit), are in different layers. The current context management by Hibernate can significantly simplify this design by accessing a <code class="literal">SessionFactory</code>. Exception handling is discussed later in this chapter. </p><p>You should select <code class="literal">org.hibernate.transaction.JDBCTransactionFactory</code>, which is the default, and for the second example select <code class="literal">"thread"</code> as your <code class="literal">hibernate.current_session_context_class</code>. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-jta"/>11.2.2. Utilisation de JTA</h3></div></div></div><p>If your persistence layer runs in an application server (for example, behind EJB session beans), every datasource connection obtained by Hibernate will automatically be part of the global JTA transaction. You can also install a standalone JTA implementation and use it without EJB. Hibernate offers two strategies for JTA integration. </p><p>If you use bean-managed transactions (BMT), Hibernate will tell the application server to start and end a BMT transaction if you use the <code class="literal">Transaction</code> API. The transaction management code is identical to the non-managed environment. </p><pre class="programlisting">// BMT idiom
Session sess = factory.openSession();
Transaction tx = null;
try {
    tx = sess.beginTransaction();

    // do some work
    ...

    tx.commit();
}
catch (RuntimeException e) {
    if (tx != null) tx.rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}</pre><p>If you want to use a transaction-bound <code class="literal">Session</code>, that is, the <code class="literal">getCurrentSession()</code> functionality for easy context propagation, use the JTA <code class="literal">UserTransaction</code> API directly: </p><pre class="programlisting">// BMT idiom with getCurrentSession()
try {
    UserTransaction tx = (UserTransaction)new InitialContext()
                            .lookup("java:comp/UserTransaction");

    tx.begin();

    // Do some work on Session bound to transaction
    factory.getCurrentSession().load(...);
    factory.getCurrentSession().persist(...);

    tx.commit();
}
catch (RuntimeException e) {
    tx.rollback();
    throw e; // or display error message
}</pre><p>With CMT, transaction demarcation is completed in session bean deployment descriptors, not programmatically. The code is reduced to: </p><pre class="programlisting">// CMT idiom
 Session sess = factory.getCurrentSession();

 // do some work
 ...
</pre><p>In a CMT/EJB, even rollback happens automatically. An unhandled <code class="literal">RuntimeException</code> thrown by a session bean method tells the container to set the global transaction to rollback. <span class="emphasis"><em>You do not need to use the Hibernate <code class="literal">Transaction</code> API at all with BMT or CMT, and you get automatic propagation of the "current" Session bound to the transaction.</em></span> </p><p>When configuring Hibernate's transaction factory, choose <code class="literal">org.hibernate.transaction.JTATransactionFactory</code> if you use JTA directly (BMT), and <code class="literal">org.hibernate.transaction.CMTTransactionFactory</code> in a CMT session bean. Remember to also set <code class="literal">hibernate.transaction.manager_lookup_class</code>. Ensure that your <code class="literal">hibernate.current_session_context_class</code> is either unset (backwards compatibility), or is set to <code class="literal">"jta"</code>. </p><p>The <code class="literal">getCurrentSession()</code> operation has one downside in a JTA environment. There is one caveat to the use of <code class="literal">after_statement</code> connection release mode, which is then used by default. Due to a limitation of the JTA spec, it is not possible for Hibernate to automatically clean up any unclosed <code class="literal">ScrollableResults</code> or <code class="literal">Iterator</code> instances returned by <code class="literal">scroll()</code> or <code class="literal">iterate()</code>. You <span class="emphasis"><em>must</em></span> release the underlying database cursor by calling <code class="literal">ScrollableResults.close()</code> or <code class="literal">Hibernate.close(Iterator)</code> explicitly from a <code class="literal">finally</code> block. Most applications can easily avoid using <code class="literal">scroll()</code> or <code class="literal">iterate()</code> from the JTA or CMT code.) </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-exceptions"/>11.2.3. Gestion des exceptions</h3></div></div></div><p>If the <code class="literal">Session</code> throws an exception, including any <code class="literal">SQLException</code>, immediately rollback the database transaction, call <code class="literal">Session.close()</code> and discard the <code class="literal">Session</code> instance. Certain methods of <code class="literal">Session</code> will <span class="emphasis"><em>not</em></span> leave the session in a consistent state. No exception thrown by Hibernate can be treated as recoverable. Ensure that the <code class="literal">Session</code> will be closed by calling <code class="literal">close()</code> in a <code class="literal">finally</code> block. </p><p>The <code class="literal">HibernateException</code>, which wraps most of the errors that can occur in a Hibernate persistence layer, is an unchecked exception. It was not in older versions of Hibernate. In our opinion, we should not force the application developer to catch an unrecoverable exception at a low layer. In most systems, unchecked and fatal exceptions are handled in one of the first frames of the method call stack (i.e., in higher layers) and either an error message is presented to the application user or some other appropriate action is taken. Note that Hibernate might also throw other unchecked exceptions that are not a <code class="literal">HibernateException</code>. These are not recoverable and appropriate action should be taken. </p><p>Hibernate wraps <code class="literal">SQLException</code>s thrown while interacting with the database in a <code class="literal">JDBCException</code>. In fact, Hibernate will attempt to convert the exception into a more meaningful subclass of <code class="literal">JDBCException</code>. The underlying <code class="literal">SQLException</code> is always available via <code class="literal">JDBCException.getCause()</code>. Hibernate converts the <code class="literal">SQLException</code> into an appropriate <code class="literal">JDBCException</code> subclass using the <code class="literal">SQLExceptionConverter</code> attached to the <code class="literal">SessionFactory</code>. By default, the <code class="literal">SQLExceptionConverter</code> is defined by the configured dialect. However, it is also possible to plug in a custom implementation. See the javadocs for the <code class="literal">SQLExceptionConverterFactory</code> class for details. The standard <code class="literal">JDBCException</code> subtypes are: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">JDBCConnectionException</code>: indicates an error with the underlying JDBC communication. </p></li><li><p><code class="literal">SQLGrammarException</code>: indicates a grammar or syntax problem with the issued SQL. </p></li><li><p><code class="literal">ConstraintViolationException</code>: indicates some form of integrity constraint violation. </p></li><li><p><code class="literal">LockAcquisitionException</code>: indicates an error acquiring a lock level necessary to perform the requested operation. </p></li><li><p><code class="literal">GenericJDBCException</code>: a generic exception which did not fall into any of the other categories. </p></li></ul></div></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-timeout"/>11.2.4. Timeout de transaction</h3></div></div></div><p>An important feature provided by a managed environment like EJB, that is never provided for non-managed code, is transaction timeout. Transaction timeouts ensure that no misbehaving transaction can indefinitely tie up resources while returning no response to the user. Outside a managed (JTA) environment, Hibernate cannot fully provide this functionality. However, Hibernate can at least control data access operations, ensuring that database level deadlocks and queries with huge result sets are limited by a defined timeout. In a managed environment, Hibernate can delegate transaction timeout to JTA. This functionality is abstracted by the Hibernate <code class="literal">Transaction</code> object. </p><pre class="programlisting">
Session sess = factory.openSession();
try {
    //set transaction timeout to 3 seconds
    sess.getTransaction().setTimeout(3);
    sess.getTransaction().begin();

    // do some work
    ...

    sess.getTransaction().commit()
}
catch (RuntimeException e) {
    sess.getTransaction().rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}</pre><p><code class="literal">setTimeout()</code> cannot be called in a CMT bean, where transaction timeouts must be defined declaratively. </p></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-optimistic"/>11.3. Contrôle de consurrence optimiste</h2></div></div></div><p>The only approach that is consistent with high concurrency and high scalability, is optimistic concurrency control with versioning. Version checking uses version numbers, or timestamps, to detect conflicting updates and to prevent lost updates. Hibernate provides three possible approaches to writing application code that uses optimistic concurrency. The use cases we discuss are in the context of long conversations, but version checking also has the benefit of preventing lost updates in single database transactions. </p><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-manual"/>11.3.1. Gestion du versionnage au niveau applicatif</h3></div></div></div><p>In an implementation without much help from Hibernate, each interaction with the database occurs in a new <code class="literal">Session</code> and the developer is responsible for reloading all persistent instances from the database before manipulating them. The application is forced to carry out its own version checking to ensure conversation transaction isolation. This approach is the least efficient in terms of database access. It is the approach most similar to entity EJBs. </p><pre class="programlisting">// foo is an instance loaded by a previous Session
session = factory.openSession();
Transaction t = session.beginTransaction();

int oldVersion = foo.getVersion();
session.load( foo, foo.getKey() ); // load the current state
if ( oldVersion != foo.getVersion() ) throw new StaleObjectStateException();
foo.setProperty("bar");

t.commit();
session.close();</pre><p>Le mapping de la propriété <code class="literal">version</code> est fait via <code class="literal">&lt;version&gt;</code> et Hibernate l'incrémentera automatiquement à chaque flush() si l'entité doit être mise à jour. </p><p>If you are operating in a low-data-concurrency environment, and do not require version checking, you can use this approach and skip the version check. In this case, <span class="emphasis"><em>last commit wins</em></span> is the default strategy for long conversations. Be aware that this might confuse the users of the application, as they might experience lost updates without error messages or a chance to merge conflicting changes. </p><p>Manual version checking is only feasible in trivial circumstances and not practical for most applications. Often not only single instances, but complete graphs of modified objects, have to be checked. Hibernate offers automatic version checking with either an extended <code class="literal">Session</code> or detached instances as the design paradigm. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-longsession"/>11.3.2. Les sessions longues et le versionnage automatique.</h3></div></div></div><p>A single <code class="literal">Session</code> instance and its persistent instances that are used for the whole conversation are known as <span class="emphasis"><em>session-per-conversation</em></span>. Hibernate checks instance versions at flush time, throwing an exception if concurrent modification is detected. It is up to the developer to catch and handle this exception. Common options are the opportunity for the user to merge changes or to restart the business conversation with non-stale data. </p><p>The <code class="literal">Session</code> is disconnected from any underlying JDBC connection when waiting for user interaction. This approach is the most efficient in terms of database access. The application does not version check or reattach detached instances, nor does it have to reload instances in every database transaction. </p><pre class="programlisting">// foo is an instance loaded earlier by the old session
Transaction t = session.beginTransaction(); // Obtain a new JDBC connection, start transaction

foo.setProperty("bar");

session.flush();    // Only for last transaction in conversation
t.commit();         // Also return JDBC connection
session.close();    // Only for last transaction in conversation</pre><p>The <code class="literal">foo</code> object knows which <code class="literal">Session</code> it was loaded in. Beginning a new database transaction on an old session obtains a new connection and resumes the session. Committing a database transaction disconnects a session from the JDBC connection and returns the connection to the pool. After reconnection, to force a version check on data you are not updating, you can call <code class="literal">Session.lock()</code> with <code class="literal">LockMode.READ</code> on any objects that might have been updated by another transaction. You do not need to lock any data that you <span class="emphasis"><em>are</em></span> updating. Usually you would set <code class="literal">FlushMode.MANUAL</code> on an extended <code class="literal">Session</code>, so that only the last database transaction cycle is allowed to actually persist all modifications made in this conversation. Only this last database transaction will include the <code class="literal">flush()</code> operation, and then <code class="literal">close()</code> the session to end the conversation. </p><p>This pattern is problematic if the <code class="literal">Session</code> is too big to be stored during user think time (for example, an <code class="literal">HttpSession</code> should be kept as small as possible). As the <code class="literal">Session</code> is also the first-level cache and contains all loaded objects, we can probably use this strategy only for a few request/response cycles. Use a <code class="literal">Session</code> only for a single conversation as it will soon have stale data. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Earlier versions of Hibernate required explicit disconnection and reconnection of a <code class="literal">Session</code>. These methods are deprecated, as beginning and ending a transaction has the same effect. </p></div><p>Keep the disconnected <code class="literal">Session</code> close to the persistence layer. Use an EJB stateful session bean to hold the <code class="literal">Session</code> in a three-tier environment. Do not transfer it to the web layer, or even serialize it to a separate tier, to store it in the <code class="literal">HttpSession</code>. </p><p>The extended session pattern, or <span class="emphasis"><em>session-per-conversation</em></span>, is more difficult to implement with automatic current session context management. You need to supply your own implementation of the <code class="literal">CurrentSessionContext</code> for this. See the Hibernate Wiki for examples. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-detached"/>11.3.3. Les objets détachés et le versionnage automatique</h3></div></div></div><p>Chaque interaction avec le système de persistance se fait via une nouvelle <code class="literal">Session</code> . Toutefois, les mêmes instances d'objets persistants sont réutilisées pour chacune de ces interactions. L'application doit pouvoir manipuler l'état des instances détachées ayant été chargées antérieurement via une autre session. Pour ce faire, ces objets persistants doivent être rattachés à la <code class="literal">Session</code> courante en utilisant <code class="literal">Session.update()</code> , <code class="literal">Session.saveOrUpdate()</code> , ou <code class="literal">Session.merge()</code> . </p><pre class="programlisting">// foo is an instance loaded by a previous Session
foo.setProperty("bar");
session = factory.openSession();
Transaction t = session.beginTransaction();
session.saveOrUpdate(foo); // Use merge() if "foo" might have been loaded already
t.commit();
session.close();</pre><p>Again, Hibernate will check instance versions during flush, throwing an exception if conflicting updates occurred. </p><p>You can also call <code class="literal">lock()</code> instead of <code class="literal">update()</code>, and use <code class="literal">LockMode.READ</code> (performing a version check and bypassing all caches) if you are sure that the object has not been modified. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-customizing"/>11.3.4. Personnaliser le versionnage automatique</h3></div></div></div><p>You can disable Hibernate's automatic version increment for particular properties and collections by setting the <code class="literal">optimistic-lock</code> mapping attribute to <code class="literal">false</code>. Hibernate will then no longer increment versions if the property is dirty. </p><p>Legacy database schemas are often static and cannot be modified. Or, other applications might access the same database and will not know how to handle version numbers or even timestamps. In both cases, versioning cannot rely on a particular column in a table. To force a version check with a comparison of the state of all fields in a row but without a version or timestamp property mapping, turn on <code class="literal">optimistic-lock="all"</code> in the <code class="literal">&lt;class&gt;</code> mapping. This conceptually only works if Hibernate can compare the old and the new state (i.e., if you use a single long <code class="literal">Session</code> and not session-per-request-with-detached-objects). </p><p>Concurrent modification can be permitted in instances where the changes that have been made do not overlap. If you set <code class="literal">optimistic-lock="dirty"</code> when mapping the <code class="literal">&lt;class&gt;</code>, Hibernate will only compare dirty fields during flush. </p><p>In both cases, with dedicated version/timestamp columns or with a full/dirty field comparison, Hibernate uses a single <code class="literal">UPDATE</code> statement, with an appropriate <code class="literal">WHERE</code> clause, per entity to execute the version check and update the information. If you use transitive persistence to cascade reattachment to associated entities, Hibernate may execute unnecessary updates. This is usually not a problem, but <span class="emphasis"><em>on update</em></span> triggers in the database might be executed even when no changes have been made to detached instances. You can customize this behavior by setting <code class="literal">select-before-update="true"</code> in the <code class="literal">&lt;class&gt;</code> mapping, forcing Hibernate to <code class="literal">SELECT</code> the instance to ensure that changes did occur before updating the row. </p></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-locking"/>11.4. Pessimistic locking</h2></div></div></div><p>It is not intended that users spend much time worrying about locking strategies. It is usually enough to specify an isolation level for the JDBC connections and then simply let the database do all the work. However, advanced users may wish to obtain exclusive pessimistic locks or re-obtain locks at the start of a new transaction. </p><p>Hibernate will always use the locking mechanism of the database; it never lock objects in memory. </p><p>The <code class="literal">LockMode</code> class defines the different lock levels that can be acquired by Hibernate. A lock is obtained by the following mechanisms: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">LockMode.WRITE</code> est obtenu automatiquement quand Hibernate actualise ou insert un enregistrement. </p></li><li><p><code class="literal">LockMode.UPGRADE</code> can be acquired upon explicit user request using <code class="literal">SELECT ... FOR UPDATE</code> on databases which support that syntax. </p></li><li><p><code class="literal">LockMode.UPGRADE_NOWAIT</code> can be acquired upon explicit user request using a <code class="literal">SELECT ... FOR UPDATE NOWAIT</code> under Oracle. </p></li><li><p><code class="literal">LockMode.READ</code> is acquired automatically when Hibernate reads data under Repeatable Read or Serializable isolation level. It can be re-acquired by explicit user request. </p></li><li><p><code class="literal">LockMode.NONE</code> représente l'absence de verouillage. Tous les objets migrent vers ce mode a la fin d'une <code class="literal">Transaction</code> . Les objets associés à une session via un appel à <code class="literal">saveOrUpdate()</code> commencent également leur cycle de vie dans cet état. </p></li></ul></div><p>Les niveaux de verrouillage peuvent être explicitement obtenus de l'une des manières suivantes: </p><div class="itemizedlist"><ul compact="compact"><li><p>Un appel à <code class="literal">Session.load()</code> , en spécifiant un niveau verrouillage <code class="literal">LockMode</code> . </p></li><li><p>Un appel à <code class="literal">Session.lock()</code> . </p></li><li><p>Une appel à <code class="literal">Query.setLockMode()</code> . </p></li></ul></div><p>Si <code class="literal">Session.load()</code> est appelé avec le paramètre de niveau de verouillage <code class="literal">UPGRADE</code> ou <code class="literal">UPGRADE_NOWAIT</code> et que l'objet demandé n'est pas présent dans la session, celui-ci sera chargé à l'aide d'une requête <code class="literal">SELECT ... FOR UPDATE</code> . Si la méthode <code class="literal">load()</code> est appelée pour un objet déjà en session avec un verrouillage moindre que celui demandé, Hibernate appellera la méthode <code class="literal">lock()</code> pour cet objet. </p><p><code class="literal">Session.lock()</code> performs a version number check if the specified lock mode is <code class="literal">READ</code>, <code class="literal">UPGRADE</code> or <code class="literal">UPGRADE_NOWAIT</code>. In the case of <code class="literal">UPGRADE</code> or <code class="literal">UPGRADE_NOWAIT</code>, <code class="literal">SELECT ... FOR UPDATE</code> is used. </p><p>If the requested lock mode is not supported by the database, Hibernate uses an appropriate alternate mode instead of throwing an exception. This ensures that applications are portable. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-connection-release"/>11.5. Connection release modes</h2></div></div></div><p>One of the legacies of Hibernate 2.x JDBC connection management meant that a <code class="literal">Session</code> would obtain a connection when it was first required and then maintain that connection until the session was closed. Hibernate 3.x introduced the notion of connection release modes that would instruct a session how to handle its JDBC connections. The following discussion is pertinent only to connections provided through a configured <code class="literal">ConnectionProvider</code>. User-supplied connections are outside the breadth of this discussion. The different release modes are identified by the enumerated values of <code class="literal">org.hibernate.ConnectionReleaseMode</code>: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">ON_CLOSE</code>: is the legacy behavior described above. The Hibernate session obtains a connection when it first needs to perform some JDBC access and maintains that connection until the session is closed. </p></li><li><p><code class="literal">AFTER_TRANSACTION</code>: releases connections after a <code class="literal">org.hibernate.Transaction</code> has been completed. </p></li><li><p><code class="literal">AFTER_STATEMENT</code> (also referred to as aggressive release): releases connections after every statement execution. This aggressive releasing is skipped if that statement leaves open resources associated with the given session. Currently the only situation where this occurs is through the use of <code class="literal">org.hibernate.ScrollableResults</code>. </p></li></ul></div><p>The configuration parameter <code class="literal">hibernate.connection.release_mode</code> is used to specify which release mode to use. The possible values are as follows: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">auto</code> (the default): this choice delegates to the release mode returned by the <code class="literal">org.hibernate.transaction.TransactionFactory.getDefaultReleaseMode()</code> method. For JTATransactionFactory, this returns ConnectionReleaseMode.AFTER_STATEMENT; for JDBCTransactionFactory, this returns ConnectionReleaseMode.AFTER_TRANSACTION. Do not change this default behavior as failures due to the value of this setting tend to indicate bugs and/or invalid assumptions in user code. </p></li><li><p><code class="literal">on_close</code>: uses ConnectionReleaseMode.ON_CLOSE. This setting is left for backwards compatibility, but its use is discouraged. </p></li><li><p><code class="literal">after_transaction</code>: uses ConnectionReleaseMode.AFTER_TRANSACTION. This setting should not be used in JTA environments. Also note that with ConnectionReleaseMode.AFTER_TRANSACTION, if a session is considered to be in auto-commit mode, connections will be released as if the release mode were AFTER_STATEMENT. </p></li><li><p><code class="literal">after_statement</code>: uses ConnectionReleaseMode.AFTER_STATEMENT. Additionally, the configured <code class="literal">ConnectionProvider</code> is consulted to see if it supports this setting (<code class="literal">supportsAggressiveRelease()</code>). If not, the release mode is reset to ConnectionReleaseMode.AFTER_TRANSACTION. This setting is only safe in environments where we can either re-acquire the same underlying JDBC connection each time you make a call into <code class="literal">ConnectionProvider.getConnection()</code> or in auto-commit environments where it does not matter if we re-establish the same connection. </p></li></ul></div></div></div><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="events"/>Chapitre 12. Les intercepteurs et les événements</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#objectstate-interceptors">12.1. Intercepteurs</a></span></dt><dt><span class="sect1"><a href="#objectstate-events">12.2. Système d'événements</a></span></dt><dt><span class="sect1"><a href="#objectstate-decl-security">12.3. Sécurité déclarative d'Hibernate</a></span></dt></dl></div><p>It is useful for the application to react to certain events that occur inside Hibernate. This allows for the implementation of generic functionality and the extension of Hibernate functionality. </p><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-interceptors"/>12.1. Intercepteurs</h2></div></div></div><p>The <code class="literal">Interceptor</code> interface provides callbacks from the session to the application, allowing the application to inspect and/or manipulate properties of a persistent object before it is saved, updated, deleted or loaded. One possible use for this is to track auditing information. For example, the following <code class="literal">Interceptor</code> automatically sets the <code class="literal">createTimestamp</code> when an <code class="literal">Auditable</code> is created and updates the <code class="literal">lastUpdateTimestamp</code> property when an <code class="literal">Auditable</code> is updated. </p><p>You can either implement <code class="literal">Interceptor</code> directly or extend <code class="literal">EmptyInterceptor</code>. </p><pre class="programlisting">package org.hibernate.test;

import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;

import org.hibernate.EmptyInterceptor;
import org.hibernate.Transaction;
import org.hibernate.type.Type;

public class AuditInterceptor extends EmptyInterceptor {

    private int updates;
    private int creates;
    private int loads;

    public void onDelete(Object entity,
                         Serializable id,
                         Object[] state,
                         String[] propertyNames,
                         Type[] types) {
        // do nothing
    }

    public boolean onFlushDirty(Object entity,
                                Serializable id,
                                Object[] currentState,
                                Object[] previousState,
                                String[] propertyNames,
                                Type[] types) {

        if ( entity instanceof Auditable ) {
            updates++;
            for ( int i=0; i &lt; propertyNames.length; i++ ) {
                if ( "lastUpdateTimestamp".equals( propertyNames[i] ) ) {
                    currentState[i] = new Date();
                    return true;
                }
            }
        }
        return false;
    }

    public boolean onLoad(Object entity,
                          Serializable id,
                          Object[] state,
                          String[] propertyNames,
                          Type[] types) {
        if ( entity instanceof Auditable ) {
            loads++;
        }
        return false;
    }

    public boolean onSave(Object entity,
                          Serializable id,
                          Object[] state,
                          String[] propertyNames,
                          Type[] types) {

        if ( entity instanceof Auditable ) {
            creates++;
            for ( int i=0; i&lt;propertyNames.length; i++ ) {
                if ( "createTimestamp".equals( propertyNames[i] ) ) {
                    state[i] = new Date();
                    return true;
                }
            }
        }
        return false;
    }

    public void afterTransactionCompletion(Transaction tx) {
        if ( tx.wasCommitted() ) {
            System.out.println("Creations: " + creates + ", Updates: " + updates, "Loads: " + loads);
        }
        updates=0;
        creates=0;
        loads=0;
    }

}</pre><p>There are two kinds of inteceptors: <code class="literal">Session</code>-scoped and <code class="literal">SessionFactory</code>-scoped. </p><p>A <code class="literal">Session</code>-scoped interceptor is specified when a session is opened using one of the overloaded SessionFactory.openSession() methods accepting an <code class="literal">Interceptor</code>. </p><pre class="programlisting">Session session = sf.openSession( new AuditInterceptor() );</pre><p>A <code class="literal">SessionFactory</code>-scoped interceptor is registered with the <code class="literal">Configuration</code> object prior to building the <code class="literal">SessionFactory</code>. Unless a session is opened explicitly specifying the interceptor to use, the supplied interceptor will be applied to all sessions opened from that <code class="literal">SessionFactory</code>. <code class="literal">SessionFactory</code>-scoped interceptors must be thread safe. Ensure that you do not store session-specific states, since multiple sessions will use this interceptor potentially concurrently. </p><pre class="programlisting">new Configuration().setInterceptor( new AuditInterceptor() );</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-events"/>12.2. Système d'événements</h2></div></div></div><p>If you have to react to particular events in your persistence layer, you can also use the Hibernate3 <span class="emphasis"><em>event</em></span> architecture. The event system can be used in addition, or as a replacement, for interceptors. </p><p>All the methods of the <code class="literal">Session</code> interface correlate to an event. You have a <code class="literal">LoadEvent</code>, a <code class="literal">FlushEvent</code>, etc. Consult the XML configuration-file DTD or the <code class="literal">org.hibernate.event</code> package for the full list of defined event types. When a request is made of one of these methods, the Hibernate <code class="literal">Session</code> generates an appropriate event and passes it to the configured event listeners for that type. Out-of-the-box, these listeners implement the same processing in which those methods always resulted. However, you are free to implement a customization of one of the listener interfaces (i.e., the <code class="literal">LoadEvent</code> is processed by the registered implementation of the <code class="literal">LoadEventListener</code> interface), in which case their implementation would be responsible for processing any <code class="literal">load()</code> requests made of the <code class="literal">Session</code>. </p><p>The listeners should be considered singletons. This means they are shared between requests, and should not save any state as instance variables. </p><p>A custom listener implements the appropriate interface for the event it wants to process and/or extend one of the convenience base classes (or even the default event listeners used by Hibernate out-of-the-box as these are declared non-final for this purpose). Custom listeners can either be registered programmatically through the <code class="literal">Configuration</code> object, or specified in the Hibernate configuration XML. Declarative configuration through the properties file is not supported. Here is an example of a custom load event listener: </p><pre class="programlisting">public class MyLoadListener implements LoadEventListener {
    // this is the single method defined by the LoadEventListener interface
    public void onLoad(LoadEvent event, LoadEventListener.LoadType loadType)
            throws HibernateException {
        if ( !MySecurity.isAuthorized( event.getEntityClassName(), event.getEntityId() ) ) {
            throw MySecurityException("Unauthorized access");
        }
    }
}</pre><p>Vous avez aussi besoin d'une entrée de configuration disant à Hibernate d'utiliser ce listener en plus du listener par défaut : </p><pre class="programlisting">&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
        ...
        &lt;event type="load"&gt;
            &lt;listener class="com.eg.MyLoadListener"/&gt;
            &lt;listener class="org.hibernate.event.def.DefaultLoadEventListener"/&gt;
        &lt;/event&gt;
    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;</pre><p>Instead, you can register it programmatically: </p><pre class="programlisting">Configuration cfg = new Configuration();
LoadEventListener[] stack = { new MyLoadListener(), new DefaultLoadEventListener() };
cfg.EventListeners().setLoadEventListeners(stack);</pre><p>Listeners registered declaratively cannot share instances. If the same class name is used in multiple <code class="literal">&lt;listener/&gt;</code> elements, each reference will result in a separate instance of that class. If you need to share listener instances between listener types you must use the programmatic registration approach. </p><p>Why implement an interface and define the specific type during configuration? A listener implementation could implement multiple event listener interfaces. Having the type additionally defined during registration makes it easier to turn custom listeners on or off during configuration. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-decl-security"/>12.3. Sécurité déclarative d'Hibernate</h2></div></div></div><p>Usually, declarative security in Hibernate applications is managed in a session facade layer. Hibernate3 allows certain actions to be permissioned via JACC, and authorized via JAAS. This is an optional functionality that is built on top of the event architecture. </p><p>D'abord, vous devez configurer les listeners d'événements appropriés pour permettre l'utilisation d'autorisations JAAS. </p><pre class="programlisting">&lt;listener type="pre-delete" class="org.hibernate.secure.JACCPreDeleteEventListener"/&gt;
&lt;listener type="pre-update" class="org.hibernate.secure.JACCPreUpdateEventListener"/&gt;
&lt;listener type="pre-insert" class="org.hibernate.secure.JACCPreInsertEventListener"/&gt;
&lt;listener type="pre-load" class="org.hibernate.secure.JACCPreLoadEventListener"/&gt;</pre><p>Note that <code class="literal">&lt;listener type="..." class="..."/&gt;</code> is shorthand for <code class="literal">&lt;event type="..."&gt;&lt;listener class="..."/&gt;&lt;/event&gt;</code> when there is exactly one listener for a particular event type. </p><p>Next, while still in <code class="literal">hibernate.cfg.xml</code>, bind the permissions to roles: </p><pre class="programlisting">&lt;grant role="admin" entity-name="User" actions="insert,update,read"/&gt;
&lt;grant role="su" entity-name="User" actions="*"/&gt;</pre><p>Les noms de rôle sont les rôles compris par votre fournisseur JAAC. </p></div></div><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="batch"/>Chapitre 13. Traitement par paquet</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#batch-inserts">13.1. Paquet de mises Ã  jour</a></span></dt><dt><span class="sect1"><a href="#batch-update">13.2. L'interface StatelessSession</a></span></dt><dt><span class="sect1"><a href="#batch-statelesssession">13.3. Notez que dans le code de l'exemple, les intances de <code class="literal">Customer</code> retournÃ©es par la requÃªte sont immÃ©diatement dÃ©tachÃ©es. Elles ne sont jamais associÃ©es Ã  un contexte de persistance.</a></span></dt><dt><span class="sect1"><a href="#batch-direct">13.4. La pseudo-syntaxe pour les expressions <code class="literal">UPDATE</code> et <code class="literal">DELETE</code> est : <code class="literal">( UPDATE | DELETE ) FROM? EntityName (WHERE where_conditions)?</code>. Certains points sont Ã  noter :</a></span></dt></dl></div><p>A naive approach to inserting 100,000 rows in the database using Hibernate might look like this: </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
for ( int i=0; i&lt;100000; i++ ) {
    Customer customer = new Customer(.....);
    session.save(customer);
}
tx.commit();
session.close();</pre><p>This would fall over with an <code class="literal">OutOfMemoryException</code> somewhere around the 50,000th row. That is because Hibernate caches all the newly inserted <code class="literal">Customer</code> instances in the session-level cache. In this chapter we will show you how to avoid this problem. </p><p>If you are undertaking batch processing you will need to enable the use of JDBC batching. This is absolutely essential if you want to achieve optimal performance. Set the JDBC batch size to a reasonable number (10-50, for example): </p><pre class="programlisting">hibernate.jdbc.batch_size 20</pre><p><a id="disablebatching"/>Hibernate disables insert batching at the JDBC level transparently if you use an <code class="literal">identity</code> identifier generator. </p><p>You can also do this kind of work in a process where interaction with the second-level cache is completely disabled: </p><pre class="programlisting">hibernate.cache.use_second_level_cache false</pre><p>Lorsque vous rendez des nouveaux objets persistants, vous devez rÃ©guliÃ¨rement appeler <code class="literal">flush()</code> et puis <code class="literal">clear()</code> sur la session, pour contrÃ´ler la taille du cache de premier niveau. </p><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="batch-inserts"/>13.1. Paquet de mises Ã  jour</h2></div></div></div><p>When making new objects persistent <code class="literal">flush()</code> and then <code class="literal">clear()</code> the session regularly in order to control the size of the first-level cache. </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
   
for ( int i=0; i&lt;100000; i++ ) {
    Customer customer = new Customer(.....);
    session.save(customer);
    if ( i % 20 == 0 ) { //20, same as the JDBC batch size
        //flush a batch of inserts and release memory:
        session.flush();
        session.clear();
    }
}
   
tx.commit();
session.close();</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="batch-update"/>13.2. L'interface StatelessSession</h2></div></div></div><p>For retrieving and updating data, the same ideas apply. In addition, you need to use <code class="literal">scroll()</code> to take advantage of server-side cursors for queries that return many rows of data. </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
   
ScrollableResults customers = session.getNamedQuery("GetCustomers")
    .setCacheMode(CacheMode.IGNORE)
    .scroll(ScrollMode.FORWARD_ONLY);
int count=0;
while ( customers.next() ) {
    Customer customer = (Customer) customers.get(0);
    customer.updateStuff(...);
    if ( ++count % 20 == 0 ) {
        //flush a batch of updates and release memory:
        session.flush();
        session.clear();
    }
}
   
tx.commit();
session.close();</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="batch-statelesssession"/>13.3. Notez que dans le code de l'exemple, les intances de <code class="literal">Customer</code> retournÃ©es par la requÃªte sont immÃ©diatement dÃ©tachÃ©es. Elles ne sont jamais associÃ©es Ã  un contexte de persistance.</h2></div></div></div><p>Alternatively, Hibernate provides a command-oriented API that can be used for streaming data to and from the database in the form of detached objects. A <code class="literal">StatelessSession</code> has no persistence context associated with it and does not provide many of the higher-level life cycle semantics. In particular, a stateless session does not implement a first-level cache nor interact with any second-level or query cache. It does not implement transactional write-behind or automatic dirty checking. Operations performed using a stateless session never cascade to associated instances. Collections are ignored by a stateless session. Operations performed via a stateless session bypass Hibernate's event model and interceptors. Due to the lack of a first-level cache, Stateless sessions are vulnerable to data aliasing effects. A stateless session is a lower-level abstraction that is much closer to the underlying JDBC. </p><pre class="programlisting">StatelessSession session = sessionFactory.openStatelessSession();
Transaction tx = session.beginTransaction();
   
ScrollableResults customers = session.getNamedQuery("GetCustomers")
    .scroll(ScrollMode.FORWARD_ONLY);
while ( customers.next() ) {
    Customer customer = (Customer) customers.get(0);
    customer.updateStuff(...);
    session.update(customer);
}
   
tx.commit();
session.close();</pre><p>In this code example, the <code class="literal">Customer</code> instances returned by the query are immediately detached. They are never associated with any persistence context. </p><p>The <code class="literal">insert(), update()</code> and <code class="literal">delete()</code> operations defined by the <code class="literal">StatelessSession</code> interface are considered to be direct database row-level operations. They result in the immediate execution of a SQL <code class="literal">INSERT, UPDATE</code> or <code class="literal">DELETE</code> respectively. They have different semantics to the <code class="literal">save(), saveOrUpdate()</code> and <code class="literal">delete()</code> operations defined by the <code class="literal">Session</code> interface. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="batch-direct"/>13.4. La pseudo-syntaxe pour les expressions <code class="literal">UPDATE</code> et <code class="literal">DELETE</code> est : <code class="literal">( UPDATE | DELETE ) FROM? EntityName (WHERE where_conditions)?</code>. Certains points sont Ã  noter :</h2></div></div></div><p>As already discussed, automatic and transparent object/relational mapping is concerned with the management of the object state. The object state is available in memory. This means that manipulating data directly in the database (using the SQL <code class="literal">Data Manipulation Language</code> (DML) the statements: <code class="literal">INSERT</code>, <code class="literal">UPDATE</code>, <code class="literal">DELETE</code>) will not affect in-memory state. However, Hibernate provides methods for bulk SQL-style DML statement execution that is performed through the Hibernate Query Language (<a href="#queryhql" title="Chapitre 14. HQL: Langage de requêtage d'Hibernate">HQL</a>). </p><p>The pseudo-syntax for <code class="literal">UPDATE</code> and <code class="literal">DELETE</code> statements is: <code class="literal">( UPDATE | DELETE ) FROM? EntityName (WHERE where_conditions)?</code>. </p><p>Some points to note: </p><div class="itemizedlist"><ul compact="compact"><li><p>Aucune jointure (implicite ou explicite) ne peut Ãªtre spÃ©cifiÃ©e dans une requÃªte HQL. Les sous-requÃªtes peuvent Ãªtre utilisÃ©es dans la clause where ; les sous-requÃªtes, elles-mÃªmes, peuvent contenir des jointures. </p></li><li><p>There can only be a single entity named in the from-clause. It can, however, be aliased. If the entity name is aliased, then any property references must be qualified using that alias. If the entity name is not aliased, then it is illegal for any property references to be qualified. </p></li><li><p>No <a href="#queryhql-joins-forms" title="14.4. Formes de syntaxes pour les jointures">joins</a>, either implicit or explicit, can be specified in a bulk HQL query. Sub-queries can be used in the where-clause, where the subqueries themselves may contain joins. </p></li><li><p>Pour exÃ©cuter un <code class="literal">DELETE</code> HQL, utilisez la mÃªme mÃ©thode <code class="literal">Query.executeUpdate()</code> : </p></li></ul></div><p>As an example, to execute an HQL <code class="literal">UPDATE</code>, use the <code class="literal">Query.executeUpdate()</code> method. The method is named for those familiar with JDBC's <code class="literal">PreparedStatement.executeUpdate()</code>: </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

String hqlUpdate = "update Customer c set c.name = :newName where c.name = :oldName";
// or String hqlUpdate = "update Customer set name = :newName where name = :oldName";
int updatedEntities = s.createQuery( hqlUpdate )
        .setString( "newName", newName )
        .setString( "oldName", oldName )
        .executeUpdate();
tx.commit();
session.close();</pre><p>In keeping with the EJB3 specification, HQL <code class="literal">UPDATE</code> statements, by default, do not effect the <a href="#mapping-declaration-version" title="5.1.9. Version (optional)">version</a> or the <a href="#mapping-declaration-timestamp" title="5.1.10. Timestamp (optional)">timestamp</a> property values for the affected entities. However, you can force Hibernate to reset the <code class="literal">version</code> or <code class="literal">timestamp</code> property values through the use of a <code class="literal">versioned update</code>. This is achieved by adding the <code class="literal">VERSIONED</code> keyword after the <code class="literal">UPDATE</code> keyword. </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
String hqlVersionedUpdate = "update versioned Customer set name = :newName where name = :oldName";
int updatedEntities = s.createQuery( hqlUpdate )
        .setString( "newName", newName )
        .setString( "oldName", oldName )
        .executeUpdate();
tx.commit();
session.close();</pre><p>Custom version types, <code class="literal">org.hibernate.usertype.UserVersionType</code>, are not allowed in conjunction with a <code class="literal">update versioned</code> statement. </p><p>La properties_list est analogue Ã  la <code class="literal">spÃ©cification de la colonne</code> The properties_list is analogous to the <code class="literal">column speficiation</code> dans l'expression SQL <code class="literal">INSERT</code>. Pour les entitÃ©s impliquÃ©es dans un hÃ©ritage mappÃ©, seules les propriÃ©tÃ©s directement dÃ©finies Ã  ce niveau de classe donnÃ© peuvent Ãªtre utilisÃ©es dans properties_list. Les propriÃ©tÃ©s de la classe mÃ¨re ne sont pas permises ; et les propriÃ©tÃ©s des classes filles n'ont pas de sens. En d'autres mots, les expressions <code class="literal">INSERT</code> par nature non polymorphiques. </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

String hqlDelete = "delete Customer c where c.name = :oldName";
// or String hqlDelete = "delete Customer where name = :oldName";
int deletedEntities = s.createQuery( hqlDelete )
        .setString( "oldName", oldName )
        .executeUpdate();
tx.commit();
session.close();</pre><p>The <code class="literal">int</code> value returned by the <code class="literal">Query.executeUpdate()</code> method indicates the number of entities effected by the operation. This may or may not correlate to the number of rows effected in the database. An HQL bulk operation might result in multiple actual SQL statements being executed (for joined-subclass, for example). The returned number indicates the number of actual entities affected by the statement. Going back to the example of joined-subclass, a delete against one of the subclasses may actually result in deletes against not just the table to which that subclass is mapped, but also the "root" table and potentially joined-subclass tables further down the inheritance hierarchy. </p><p>Pour la propriÃ©te id, l'expression d'insertion vous donne deux options. Vous pouvez soit spÃ©cifier explicitement la propriÃ©tÃ© id dans properties_list (auquel cas sa valeur est extraite de l'expression de sÃ©lection correspondante), soit l'omettre de properties_list (auquel cas une valeur gÃ©nÃ©rÃ©e est utilisÃ©e). Cette derniÃ¨re option est seulement disponible en utilisant le gÃ©nÃ©rateur d'identifiant qui opÃ¨re dans la base de donnÃ©es ; tenter d'utiliser cette option avec n'importe quel type de gÃ©nÃ©rateur "en mÃ©moire" causera une exception durant l'analyse. Notez que pour les buts de cette discussion, les gÃ©nÃ©rateurs "en base" sont considÃ©rÃ©s Ãªtre <code class="literal">org.hibernate.id.SequenceGenerator</code> (et ses classes filles) et n'importe quelles implÃ©mentations de <code class="literal">org.hibernate.id.PostInsertIdentifierGenerator</code>. L'exception la plus notable ici est <code class="literal">org.hibernate.id.TableHiLoGenerator</code>, qu ne peut pas Ãªtre utilisÃ©e parce qu'il ne propose pas un moyen de d'exposer ses valeurs par un select. </p><div class="itemizedlist"><ul compact="compact"><li><p>Pour des propriÃ©tÃ©s mappÃ©es comme <code class="literal">version</code> ou <code class="literal">timestamp</code>, l'expression d'insertion vous donne deux options. Vous pouvez soit spÃ©cifier la propriÃ©tÃ© dans properties_list (auquel cas sa valeur est extraite des expressions select correspondantes), soit l'omettre de properties_list (auquel cas la <code class="literal">valeur de graine</code> (NdT : seed value) dÃ©finie par le <code class="literal">org.hibernate.type.VersionType</code> est utilisÃ©e). </p><p>The properties_list is analogous to the <code class="literal">column specification</code> in the SQL <code class="literal">INSERT</code> statement. For entities involved in mapped inheritance, only properties directly defined on that given class-level can be used in the properties_list. Superclass properties are not allowed and subclass properties do not make sense. In other words, <code class="literal">INSERT</code> statements are inherently non-polymorphic. </p></li><li><p>select_statement can be any valid HQL select query, with the caveat that the return types must match the types expected by the insert. Currently, this is checked during query compilation rather than allowing the check to relegate to the database. This might, however, cause problems between Hibernate <code class="literal">Type</code>s which are <span class="emphasis"><em>equivalent</em></span> as opposed to <span class="emphasis"><em>equal</em></span>. This might cause issues with mismatches between a property defined as a <code class="literal">org.hibernate.type.DateType</code> and a property defined as a <code class="literal">org.hibernate.type.TimestampType</code>, even though the database might not make a distinction or might be able to handle the conversion. </p></li><li><p>For the id property, the insert statement gives you two options. You can either explicitly specify the id property in the properties_list, in which case its value is taken from the corresponding select expression, or omit it from the properties_list, in which case a generated value is used. This latter option is only available when using id generators that operate in the database; attempting to use this option with any "in memory" type generators will cause an exception during parsing. For the purposes of this discussion, in-database generators are considered to be <code class="literal">org.hibernate.id.SequenceGenerator</code> (and its subclasses) and any implementers of <code class="literal">org.hibernate.id.PostInsertIdentifierGenerator</code>. The most notable exception here is <code class="literal">org.hibernate.id.TableHiLoGenerator</code>, which cannot be used because it does not expose a selectable way to get its values. </p></li><li><p>For properties mapped as either <code class="literal">version</code> or <code class="literal">timestamp</code>, the insert statement gives you two options. You can either specify the property in the properties_list, in which case its value is taken from the corresponding select expressions, or omit it from the properties_list, in which case the <code class="literal">seed value</code> defined by the <code class="literal">org.hibernate.type.VersionType</code> is used. </p></li></ul></div><p>The following is an example of an HQL <code class="literal">INSERT</code> statement execution: </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

String hqlInsert = "insert into DelinquentAccount (id, name) select c.id, c.name from Customer c where ...";
int createdEntities = s.createQuery( hqlInsert )
        .executeUpdate();
tx.commit();
session.close();</pre></div></div><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql"/>Chapitre 14. HQL: Langage de requêtage d'Hibernate</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#queryhql-casesensitivity">14.1. Sensibilité à la casse</a></span></dt><dt><span class="sect1"><a href="#queryhql-from">14.2. La clause from</a></span></dt><dt><span class="sect1"><a href="#queryhql-joins">14.3. Associations et jointures</a></span></dt><dt><span class="sect1"><a href="#queryhql-joins-forms">14.4. Formes de syntaxes pour les jointures</a></span></dt><dt><span class="sect1"><a href="#queryhql-identifier-property">14.5. Referring to identifier property</a></span></dt><dt><span class="sect1"><a href="#queryhql-select">14.6. La clause select</a></span></dt><dt><span class="sect1"><a href="#queryhql-aggregation">14.7. Fonctions d'aggrégation</a></span></dt><dt><span class="sect1"><a href="#queryhql-polymorphism">14.8. Requêtes polymorphiques</a></span></dt><dt><span class="sect1"><a href="#queryhql-where">14.9. La clause where</a></span></dt><dt><span class="sect1"><a href="#queryhql-expressions">14.10. Expressions</a></span></dt><dt><span class="sect1"><a href="#queryhql-ordering">14.11. La clause order by</a></span></dt><dt><span class="sect1"><a href="#queryhql-grouping">14.12. La clause group by</a></span></dt><dt><span class="sect1"><a href="#queryhql-subqueries">14.13. Sous-requêtes</a></span></dt><dt><span class="sect1"><a href="#queryhql-examples">14.14. Exemples HQL</a></span></dt><dt><span class="sect1"><a href="#queryhql-bulk">14.15. Mise à jour et suppression</a></span></dt><dt><span class="sect1"><a href="#queryhql-tipstricks">14.16. Trucs &amp; Astuces</a></span></dt><dt><span class="sect1"><a href="#queryhql-components">14.17. translator-credits</a></span></dt><dt><span class="sect1"><a href="#queryhql-tuple">14.18. Row value constructor syntax</a></span></dt></dl></div><p>Hibernate uses a powerful query language (HQL) that is similar in appearance to SQL. Compared with SQL, however, HQL is fully object-oriented and understands notions like inheritance, polymorphism and association. </p><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-casesensitivity"/>14.1. Sensibilité à la casse</h2></div></div></div><p>With the exception of names of Java classes and properties, queries are case-insensitive. So <code class="literal">SeLeCT</code> is the same as <code class="literal">sELEct</code> is the same as <code class="literal">SELECT</code>, but <code class="literal">org.hibernate.eg.FOO</code> is not <code class="literal">org.hibernate.eg.Foo</code>, and <code class="literal">foo.barSet</code> is not <code class="literal">foo.BARSET</code>. </p><p>This manual uses lowercase HQL keywords. Some users find queries with uppercase keywords more readable, but this convention is unsuitable for queries embedded in Java code. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-from"/>14.2. La clause from</h2></div></div></div><p>La requête Hibernate la plus simple est de la forme : </p><pre class="programlisting">from eg.Cat</pre><p>This returns all instances of the class <code class="literal">eg.Cat</code>. You do not usually need to qualify the class name, since <code class="literal">auto-import</code> is the default. For example: </p><pre class="programlisting">from Cat</pre><p>In order to refer to the <code class="literal">Cat</code> in other parts of the query, you will need to assign an <span class="emphasis"><em>alias</em></span>. For example: </p><pre class="programlisting">from Cat as cat</pre><p>This query assigns the alias <code class="literal">cat</code> to <code class="literal">Cat</code> instances, so you can use that alias later in the query. The <code class="literal">as</code> keyword is optional. You could also write: </p><pre class="programlisting">from Cat cat</pre><p>Multiple classes can appear, resulting in a cartesian product or "cross" join. </p><pre class="programlisting">from Formula, Parameter</pre><pre class="programlisting">from Formula as form, Parameter as param</pre><p>It is good practice to name query aliases using an initial lowercase as this is consistent with Java naming standards for local variables (e.g. <code class="literal">domesticCat</code>). </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-joins"/>14.3. Associations et jointures</h2></div></div></div><p>You can also assign aliases to associated entities or to elements of a collection of values using a <code class="literal">join</code>. For example: </p><pre class="programlisting">from Cat as cat
    inner join cat.mate as mate
    left outer join cat.kittens as kitten</pre><pre class="programlisting">from Cat as cat left join cat.mate.kittens as kittens</pre><pre class="programlisting">from Formula form full join form.parameter param</pre><p>The supported join types are borrowed from ANSI SQL: </p><div class="itemizedlist"><ul compact="compact"><li><p>
                    <code class="literal"><code class="literal">inner join</code> (jointure fermée)</code>
                </p></li><li><p>
                    <code class="literal"><code class="literal">left outer join</code> (jointure ouverte par la gauche)</code>
                </p></li><li><p>
                    <code class="literal"><code class="literal">right outer join</code> (jointure ouverte par la droite)</code>
                </p></li><li><p><code class="literal">full join</code> (jointure ouverte totalement - généralement inutile) </p></li></ul></div><p>Les constructions des jointures <code class="literal">inner join</code>, <code class="literal">left outer join</code> et <code class="literal">right outer join</code> peuvent être abbrégées. </p><pre class="programlisting">from Cat as cat
    join cat.mate as mate
    left join cat.kittens as kitten</pre><p>Nous pouvons soumettre des conditions de jointure supplémentaires en utilisant le mot-clef HQL <code class="literal">with</code>. </p><pre class="programlisting">from Cat as cat
    left join cat.kittens as kitten
        with kitten.bodyWeight &gt; 10.0</pre><p>A "fetch" join allows associations or collections of values to be initialized along with their parent objects using a single select. This is particularly useful in the case of a collection. It effectively overrides the outer join and lazy declarations of the mapping file for associations and collections. See <a href="#performance-fetching" title="19.1. Stratégies de chargement">Section 19.1, « Stratégies de chargement »</a> for more information. </p><pre class="programlisting">from Cat as cat
    inner join fetch cat.mate
    left join fetch cat.kittens</pre><p>A fetch join does not usually need to assign an alias, because the associated objects should not be used in the <code class="literal">where</code> clause (or any other clause). The associated objects are also not returned directly in the query results. Instead, they may be accessed via the parent object. The only reason you might need an alias is if you are recursively join fetching a further collection: </p><pre class="programlisting">from Cat as cat
    inner join fetch cat.mate
    left join fetch cat.kittens child
    left join fetch child.kittens</pre><p>The <code class="literal">fetch</code> construct cannot be used in queries called using <code class="literal">iterate()</code> (though <code class="literal">scroll()</code> can be used). <code class="literal">Fetch</code> should be used together with <code class="literal">setMaxResults()</code> or <code class="literal">setFirstResult()</code>, as these operations are based on the result rows which usually contain duplicates for eager collection fetching, hence, the number of rows is not what you would expect. <code class="literal">Fetch</code> should also not be used together with impromptu <code class="literal">with</code> condition. It is possible to create a cartesian product by join fetching more than one collection in a query, so take care in this case. Join fetching multiple collection roles can produce unexpected results for bag mappings, so user discretion is advised when formulating queries in this case. Finally, note that <code class="literal">full join fetch</code> and <code class="literal">right join fetch</code> are not meaningful. </p><p>If you are using property-level lazy fetching (with bytecode instrumentation), it is possible to force Hibernate to fetch the lazy properties in the first query immediately using <code class="literal">fetch all properties</code>. </p><pre class="programlisting">from Document fetch all properties order by name</pre><pre class="programlisting">from Document doc fetch all properties where lower(doc.name) like '%cats%'</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-joins-forms"/>14.4. Formes de syntaxes pour les jointures</h2></div></div></div><p>HQL supporte deux formes pour joindre les associations: <code class="literal">implicite</code> et <code class="literal">explicite</code>. </p><p>The queries shown in the previous section all use the <code class="literal">explicit</code> form, that is, where the join keyword is explicitly used in the from clause. This is the recommended form. </p><p>La forme <code class="literal">implicite</code> n'utilise pas le mot clé join. A la place, les associations sont "déréférencées" en utilisant le notation '.'. Ces jointures peuvent apparaitre dans toutes les clauses. Les jointures <code class="literal">implicites</code> résultent en des inner join dans le SQL généré. </p><pre class="programlisting">from Cat as cat where cat.mate.name like '%s%'</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-identifier-property"/>14.5. Referring to identifier property</h2></div></div></div><p>There are 2 ways to refer to an entity's identifier property: </p><div class="itemizedlist"><ul compact="compact"><li><p>The special property (lowercase) <code class="literal">id</code> may be used to reference the identifier property of an entity <span class="emphasis"><em>provided that the entity does not define a non-identifier property named id</em></span>. </p></li><li><p>If the entity defines a named identifier property, you can use that property name. </p></li></ul></div><p>References to composite identifier properties follow the same naming rules. If the entity has a non-identifier property named id, the composite identifier property can only be referenced by its defined named. Otherwise, the special <code class="literal">id</code> property can be used to reference the identifier property. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>Please note that, starting in version 3.2.2, this has changed significantly. In previous versions, <code class="literal">id</code> <span class="emphasis"><em>always</em></span> referred to the identifier property regardless of its actual name. A ramification of that decision was that non-identifier properties named <code class="literal">id</code> could never be referenced in Hibernate queries. </p></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-select"/>14.6. La clause select</h2></div></div></div><p>The <code class="literal">select</code> clause picks which objects and properties to return in the query result set. Consider the following: </p><pre class="programlisting">select mate
from Cat as cat
    inner join cat.mate as mate</pre><p>The query will select <code class="literal">mate</code>s of other <code class="literal">Cat</code>s. You can express this query more compactly as: </p><pre class="programlisting">select cat.mate from Cat cat</pre><p>Queries can return properties of any value type including properties of component type: </p><pre class="programlisting">select cat.name from DomesticCat cat
where cat.name like 'fri%'</pre><pre class="programlisting">select cust.name.firstName from Customer as cust</pre><p>Queries can return multiple objects and/or properties as an array of type <code class="literal">Object[]</code>: </p><pre class="programlisting">select mother, offspr, mate.name
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>Or as a <code class="literal">List</code>: </p><pre class="programlisting">select new list(mother, offspr, mate.name)
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>Or - assuming that the class <code class="literal">Family</code> has an appropriate constructor - as an actual typesafe Java object: </p><pre class="programlisting">select new Family(mother, mate, offspr)
from DomesticCat as mother
    join mother.mate as mate
    left join mother.kittens as offspr</pre><p>You can assign aliases to selected expressions using <code class="literal">as</code>: </p><pre class="programlisting">select max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n
from Cat cat</pre><p>C'est surtout utile lorsque c'est utilisé avec <code class="literal">select new map</code> : </p><pre class="programlisting">select new map( max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n )
from Cat cat</pre><p>Cette requête retourne une <code class="literal">Map</code> à partir des alias vers les valeurs sélectionnées. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-aggregation"/>14.7. Fonctions d'aggrégation</h2></div></div></div><p>HQL queries can even return the results of aggregate functions on properties: </p><pre class="programlisting">select avg(cat.weight), sum(cat.weight), max(cat.weight), count(cat)
from Cat cat</pre><p>The supported aggregate functions are: </p><div class="itemizedlist"><ul compact="compact"><li><p>
                    <code class="literal">avg(...), sum(...), min(...), max(...)</code>
                </p></li><li><p>
                    <code class="literal">count(*)</code>
                </p></li><li><p>
                    <code class="literal">count(...), count(distinct ...), count(all...)</code>
                </p></li></ul></div><p>You can use arithmetic operators, concatenation, and recognized SQL functions in the select clause: </p><pre class="programlisting">select cat.weight + sum(kitten.weight)
from Cat cat
    join cat.kittens kitten
group by cat.id, cat.weight</pre><pre class="programlisting">select firstName||' '||initial||' '||upper(lastName) from Person</pre><p>The <code class="literal">distinct</code> and <code class="literal">all</code> keywords can be used and have the same semantics as in SQL. </p><pre class="programlisting">select distinct cat.name from Cat cat

select count(distinct cat.name), count(cat) from Cat cat</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-polymorphism"/>14.8. Requêtes polymorphiques</h2></div></div></div><p>Une requête comme: </p><pre class="programlisting">from Cat as cat</pre><p>returns instances not only of <code class="literal">Cat</code>, but also of subclasses like <code class="literal">DomesticCat</code>. Hibernate queries can name <span class="emphasis"><em>any</em></span> Java class or interface in the <code class="literal">from</code> clause. The query will return instances of all persistent classes that extend that class or implement the interface. The following query would return all persistent objects: </p><pre class="programlisting">from java.lang.Object o</pre><p>L'interface <code class="literal">Named</code> peut être implémentée par plusieurs classes persistantes : </p><pre class="programlisting">from Named n, Named m where n.name = m.name</pre><p>These last two queries will require more than one SQL <code class="literal">SELECT</code>. This means that the <code class="literal">order by</code> clause does not correctly order the whole result set. It also means you cannot call these queries using <code class="literal">Query.scroll()</code>. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-where"/>14.9. La clause where</h2></div></div></div><p>The <code class="literal">where</code> clause allows you to refine the list of instances returned. If no alias exists, you can refer to properties by name: </p><pre class="programlisting">from Cat where name='Fritz'</pre><p>S'il y a un alias, utilisez un nom de propriété qualifié : </p><pre class="programlisting">from Cat as cat where cat.name='Fritz'</pre><p>This returns instances of <code class="literal">Cat</code> named 'Fritz'. </p><p>The following query: </p><pre class="programlisting">select foo
from Foo foo, Bar bar
where foo.startDate = bar.date</pre><p> returns all instances of <code class="literal">Foo</code> with an instance of <code class="literal">bar</code> with a <code class="literal">date</code> property equal to the <code class="literal">startDate</code> property of the <code class="literal">Foo</code>. Compound path expressions make the <code class="literal">where</code> clause extremely powerful. Consider the following: </p><pre class="programlisting">from Cat cat where cat.mate.name is not null</pre><p>This query translates to an SQL query with a table (inner) join. For example: </p><pre class="programlisting">from Foo foo
where foo.bar.baz.customer.address.city is not null</pre><p>would result in a query that would require four table joins in SQL. </p><p>The <code class="literal">=</code> operator can be used to compare not only properties, but also instances: </p><pre class="programlisting">from Cat cat, Cat rival where cat.mate = rival.mate</pre><pre class="programlisting">select cat, mate
from Cat cat, Cat mate
where cat.mate = mate</pre><p>The special property (lowercase) <code class="literal">id</code> can be used to reference the unique identifier of an object. See <a href="#queryhql-identifier-property" title="14.5. Referring to identifier property">Section 14.5, « Referring to identifier property »</a> for more information. </p><pre class="programlisting">from Cat as cat where cat.id = 123

from Cat as cat where cat.mate.id = 69</pre><p>The second query is efficient and does not require a table join. </p><p>Properties of composite identifiers can also be used. Consider the following example where <code class="literal">Person</code> has composite identifiers consisting of <code class="literal">country</code> and <code class="literal">medicareNumber</code>: </p><pre class="programlisting">from bank.Person person
where person.id.country = 'AU'
    and person.id.medicareNumber = 123456</pre><pre class="programlisting">from bank.Account account
where account.owner.id.country = 'AU'
    and account.owner.id.medicareNumber = 123456</pre><p>Once again, the second query does not require a table join. </p><p>See <a href="#queryhql-identifier-property" title="14.5. Referring to identifier property">Section 14.5, « Referring to identifier property »</a> for more information regarding referencing identifier properties) </p><p>The special property <code class="literal">class</code> accesses the discriminator value of an instance in the case of polymorphic persistence. A Java class name embedded in the where clause will be translated to its discriminator value. </p><pre class="programlisting">from Cat cat where cat.class = DomesticCat</pre><p>You can also use components or composite user types, or properties of said component types. See <a href="#queryhql-components" title="14.17. translator-credits">Section 14.17, « translator-credits »</a> for more information. </p><p>An "any" type has the special properties <code class="literal">id</code> and <code class="literal">class</code> that allows you to express a join in the following way (where <code class="literal">AuditLog.item</code> is a property mapped with <code class="literal">&lt;any&gt;</code>): </p><pre class="programlisting">from AuditLog log, Payment payment
where log.item.class = 'Payment' and log.item.id = payment.id</pre><p>The <code class="literal">log.item.class</code> and <code class="literal">payment.class</code> would refer to the values of completely different database columns in the above query. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-expressions"/>14.10. Expressions</h2></div></div></div><p>Expressions used in the <code class="literal">where</code> clause include the following: </p><div class="itemizedlist"><ul compact="compact"><li><p>mathematical operators: <code class="literal">+, -, *, /</code> </p></li><li><p>binary comparison operators: <code class="literal">=, &gt;=, &lt;=, &lt;&gt;, !=, like</code> </p></li><li><p>opérateurs logiques <code class="literal">and, or, not</code> </p></li><li><p>Parentheses <code class="literal">( )</code> that indicates grouping </p></li><li><p><code class="literal">in</code>, <code class="literal">not in</code>, <code class="literal">between</code>, <code class="literal">is null</code>, <code class="literal">is not null</code>, <code class="literal">is empty</code>, <code class="literal">is not empty</code>, <code class="literal">member of</code> and <code class="literal">not member of</code> </p></li><li><p>"Simple" case, <code class="literal">case ... when ... then ... else ... end</code>, and "searched" case, <code class="literal">case when ... then ... else ... end</code> </p></li><li><p>concatenation de chaîne de caractères <code class="literal">...||...</code> ou <code class="literal">concat(...,...)</code> </p></li><li><p><code class="literal">current_date()</code>, <code class="literal">current_time()</code>, and <code class="literal">current_timestamp()</code> </p></li><li><p><code class="literal">second(...)</code>, <code class="literal">minute(...)</code>, <code class="literal">hour(...)</code>, <code class="literal">day(...)</code>, <code class="literal">month(...)</code>, and <code class="literal">year(...)</code> </p></li><li><p>N'importe quel fonction ou opérateur défini par EJB-QL 3.0 : <code class="literal">substring(), trim(), lower(), upper(), length(), locate(), abs(), sqrt(), bit_length(), mod()</code> </p></li><li><p><code class="literal">coalesce()</code> et <code class="literal">nullif()</code> </p></li><li><p><code class="literal">str()</code> pour convertir des valeurs numériques ou temporelles vers une chaîne de caractères lisible </p></li><li><p><code class="literal">cast(... as ...)</code>, où le second argument est le nom d'un type Hibernate, et <code class="literal">extract(... from ...)</code> si le <code class="literal">cast()</code> ANSI et <code class="literal">extract()</code> sont supportés par la base de données sous-jacente </p></li><li><p>La fonction HQL <code class="literal">index()</code>, qui s'applique aux alias d'une collection indexée jointe </p></li><li><p>HQL functions that take collection-valued path expressions: <code class="literal">size(), minelement(), maxelement(), minindex(), maxindex()</code>, along with the special <code class="literal">elements()</code> and <code class="literal">indices</code> functions that can be quantified using <code class="literal">some, all, exists, any, in</code>. </p></li><li><p>Any database-supported SQL scalar function like <code class="literal">sign()</code>, <code class="literal">trunc()</code>, <code class="literal">rtrim()</code>, and <code class="literal">sin()</code> </p></li><li><p>Les paramètres positionnels de JDBC <code class="literal">?</code> </p></li><li><p>named parameters <code class="literal">:name</code>, <code class="literal">:start_date</code>, and <code class="literal">:x1</code> </p></li><li><p>littéral SQL <code class="literal">'foo'</code>, <code class="literal">69</code>, <code class="literal">'1970-01-01 10:00:01.0'</code> </p></li><li><p>Constantes Java <code class="literal">public static final</code><code class="literal">eg.Color.TABBY</code> </p></li></ul></div><p><code class="literal">in</code> and <code class="literal">between</code> can be used as follows: </p><pre class="programlisting">from DomesticCat cat where cat.name between 'A' and 'B'</pre><pre class="programlisting">from DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )</pre><p>The negated forms can be written as follows: </p><pre class="programlisting">from DomesticCat cat where cat.name not between 'A' and 'B'</pre><pre class="programlisting">from DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )</pre><p>Similarly, <code class="literal">is null</code> and <code class="literal">is not null</code> can be used to test for null values. </p><p>Booleans can be easily used in expressions by declaring HQL query substitutions in Hibernate configuration: </p><pre class="programlisting">&lt;property name="hibernate.query.substitutions"&gt;true 1, false 0&lt;/property&gt;</pre><p>Ce qui remplacera les mots clés <code class="literal">true</code> et <code class="literal">false</code> par <code class="literal">1</code> et <code class="literal">0</code> dans la traduction SQL du HQL suivant : </p><pre class="programlisting">from Cat cat where cat.alive = true</pre><p>You can test the size of a collection with the special property <code class="literal">size</code> or the special <code class="literal">size()</code> function. </p><pre class="programlisting">from Cat cat where cat.kittens.size &gt; 0</pre><pre class="programlisting">from Cat cat where size(cat.kittens) &gt; 0</pre><p>For indexed collections, you can refer to the minimum and maximum indices using <code class="literal">minindex</code> and <code class="literal">maxindex</code> functions. Similarly, you can refer to the minimum and maximum elements of a collection of basic type using the <code class="literal">minelement</code> and <code class="literal">maxelement</code> functions. For example: </p><pre class="programlisting">from Calendar cal where maxelement(cal.holidays) &gt; current_date</pre><pre class="programlisting">from Order order where maxindex(order.items) &gt; 100</pre><pre class="programlisting">from Order order where minelement(order.items) &gt; 10000</pre><p>The SQL functions <code class="literal">any, some, all, exists, in</code> are supported when passed the element or index set of a collection (<code class="literal">elements</code> and <code class="literal">indices</code> functions) or the result of a subquery (see below): </p><pre class="programlisting">select mother from Cat as mother, Cat as kit
where kit in elements(foo.kittens)</pre><pre class="programlisting">select p from NameList list, Person p
where p.name = some elements(list.names)</pre><pre class="programlisting">from Cat cat where exists elements(cat.kittens)</pre><pre class="programlisting">from Player p where 3 &gt; all elements(p.scores)</pre><pre class="programlisting">from Show show where 'fizard' in indices(show.acts)</pre><p>Note that these constructs - <code class="literal">size</code>, <code class="literal">elements</code>, <code class="literal">indices</code>, <code class="literal">minindex</code>, <code class="literal">maxindex</code>, <code class="literal">minelement</code>, <code class="literal">maxelement</code> - can only be used in the where clause in Hibernate3. </p><p>Elements of indexed collections (arrays, lists, and maps) can be referred to by index in a where clause only: </p><pre class="programlisting">from Order order where order.items[0].id = 1234</pre><pre class="programlisting">select person from Person person, Calendar calendar
where calendar.holidays['national day'] = person.birthDay
    and person.nationality.calendar = calendar</pre><pre class="programlisting">select item from Item item, Order order
where order.items[ order.deliveredItemIndices[0] ] = item and order.id = 11</pre><pre class="programlisting">select item from Item item, Order order
where order.items[ maxindex(order.items) ] = item and order.id = 11</pre><p>The expression inside <code class="literal">[]</code> can even be an arithmetic expression: </p><pre class="programlisting">select item from Item item, Order order
where order.items[ size(order.items) - 1 ] = item</pre><p>HQL also provides the built-in <code class="literal">index()</code> function for elements of a one-to-many association or collection of values. </p><pre class="programlisting">select item, index(item) from Order order
    join order.items item
where index(item) &lt; 5</pre><p>Scalar SQL functions supported by the underlying database can be used: </p><pre class="programlisting">from DomesticCat cat where upper(cat.name) like 'FRI%'</pre><p>Consider how much longer and less readable the following query would be in SQL: </p><pre class="programlisting">select cust
from Product prod,
    Store store
    inner join store.customers cust
where prod.name = 'widget'
    and store.location.name in ( 'Melbourne', 'Sydney' )
    and prod = all elements(cust.currentOrder.lineItems)</pre><p><span class="emphasis"><em>Un indice :</em></span> cela donnerait quelque chose comme </p><pre class="programlisting">SELECT cust.name, cust.address, cust.phone, cust.id, cust.current_order
FROM customers cust,
    stores store,
    locations loc,
    store_customers sc,
    product prod
WHERE prod.name = 'widget'
    AND store.loc_id = loc.id
    AND loc.name IN ( 'Melbourne', 'Sydney' )
    AND sc.store_id = store.id
    AND sc.cust_id = cust.id
    AND prod.id = ALL(
        SELECT item.prod_id
        FROM line_items item, orders o
        WHERE item.order_id = o.id
            AND cust.current_order = o.id
    )</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-ordering"/>14.11. La clause order by</h2></div></div></div><p>The list returned by a query can be ordered by any property of a returned class or components: </p><pre class="programlisting">from DomesticCat cat
order by cat.name asc, cat.weight desc, cat.birthdate</pre><p>Le mot optionnel <code class="literal">asc</code> ou <code class="literal">desc</code> indique respectivement si le tri doit être croissant ou décroissant. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-grouping"/>14.12. La clause group by</h2></div></div></div><p>A query that returns aggregate values can be grouped by any property of a returned class or components: </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat)
from Cat cat
group by cat.color</pre><pre class="programlisting">select foo.id, avg(name), max(name)
from Foo foo join foo.names name
group by foo.id</pre><p>Une clause <code class="literal">having</code> est aussi permise. </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat)
from Cat cat
group by cat.color
having cat.color in (eg.Color.TABBY, eg.Color.BLACK)</pre><p>SQL functions and aggregate functions are allowed in the <code class="literal">having</code> and <code class="literal">order by</code> clauses if they are supported by the underlying database (i.e., not in MySQL). </p><pre class="programlisting">select cat
from Cat cat
    join cat.kittens kitten
group by cat.id, cat.name, cat.other, cat.properties
having avg(kitten.weight) &gt; 100
order by count(kitten) asc, sum(kitten.weight) desc</pre><p>Neither the <code class="literal">group by</code> clause nor the <code class="literal">order by</code> clause can contain arithmetic expressions. Hibernate also does not currently expand a grouped entity, so you cannot write <code class="literal">group by cat</code> if all properties of <code class="literal">cat</code> are non-aggregated. You have to list all non-aggregated properties explicitly. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-subqueries"/>14.13. Sous-requêtes</h2></div></div></div><p>Pour les bases de données le supportant, Hibernate supporte les sous requêtes dans les requêtes. Une sous requête doit être entre parenthèses (souvent pour un appel à une fonction d'agrégation SQL) Même les sous requêtes corrélées (celles qui font référence à un alias de la requête principale) sont supportées. </p><pre class="programlisting">from Cat as fatcat
where fatcat.weight &gt; (
    select avg(cat.weight) from DomesticCat cat
)</pre><pre class="programlisting">from DomesticCat as cat
where cat.name = some (
    select name.nickName from Name as name
)</pre><pre class="programlisting">from Cat as cat
where not exists (
    from Cat as mate where mate.mate = cat
)</pre><pre class="programlisting">from DomesticCat as cat
where cat.name not in (
    select name.nickName from Name as name
)</pre><pre class="programlisting">select cat.id, (select max(kit.weight) from cat.kitten kit)
from Cat as cat</pre><p>Note that HQL subqueries can occur only in the select or where clauses. </p><p>Note that subqueries can also utilize <code class="literal">row value constructor</code> syntax. See <a href="#queryhql-tuple" title="14.18. Row value constructor syntax">Section 14.18, « Row value constructor syntax »</a> for more information. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-examples"/>14.14. Exemples HQL</h2></div></div></div><p>Hibernate queries can be quite powerful and complex. In fact, the power of the query language is one of Hibernate's main strengths. The following example queries are similar to queries that have been used on recent projects. Please note that most queries you will write will be much simpler than the following examples. </p><p>The following query returns the order id, number of items, the given minimum total value and the total value of the order for all unpaid orders for a particular customer. The results are ordered by total value. In determining the prices, it uses the current catalog. The resulting SQL query, against the <code class="literal">ORDER</code>, <code class="literal">ORDER_LINE</code>, <code class="literal">PRODUCT</code>, <code class="literal">CATALOG</code> and <code class="literal">PRICE</code> tables has four inner joins and an (uncorrelated) subselect. </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog.effectiveDate &lt; sysdate
    and catalog.effectiveDate &gt;= all (
        select cat.effectiveDate
        from Catalog as cat
        where cat.effectiveDate &lt; sysdate
    )
group by order
having sum(price.amount) &gt; :minAmount
order by sum(price.amount) desc</pre><p>Quel monstre ! En principe, nous ne sommes pas très fan des sous-requêtes, la requête ressemblait donc plutôt à cela : </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog = :currentCatalog
group by order
having sum(price.amount) &gt; :minAmount
order by sum(price.amount) desc</pre><p>La requête suivante compte le nombre de paiements (payments) pour chaque status, en excluant les paiements dans le status <code class="literal">AWAITING_APPROVAL</code> où le changement de status le plus récent à été fait par l'utilisateur courant. En SQL, cette requête effectue deux jointures internes et des sous requêtes corrélées sur les tables <code class="literal">PAYMENT</code>, <code class="literal">PAYMENT_STATUS</code> et <code class="literal">PAYMENT_STATUS_CHANGE</code>. </p><pre class="programlisting">select count(payment), status.name
from Payment as payment
    join payment.currentStatus as status
    join payment.statusChanges as statusChange
where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL
    or (
        statusChange.timeStamp = (
            select max(change.timeStamp)
            from PaymentStatusChange change
            where change.payment = payment
        )
        and statusChange.user &lt;&gt; :currentUser
    )
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>If the <code class="literal">statusChanges</code> collection was mapped as a list, instead of a set, the query would have been much simpler to write. </p><pre class="programlisting">select count(payment), status.name
from Payment as payment
    join payment.currentStatus as status
where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL
    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user &lt;&gt; :currentUser
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>La requête qui suit utilise la fonction de MS SQL <code class="literal">isNull()</code> pour retourner tous les comptes (accounts) et paiements (payments) impayés pour l'organisation à laquelle l'uilisateur (user) courant appartient. Elle est traduite en SQL par trois jointures internes, une jointure externe ainsi qu'une sous requête sur les tables <code class="literal">ACCOUNT</code>, <code class="literal">PAYMENT</code>, <code class="literal">PAYMENT_STATUS</code>, <code class="literal">ACCOUNT_TYPE</code>, <code class="literal">ORGANIZATION</code> et <code class="literal">ORG_USER</code>. </p><pre class="programlisting">select account, payment
from Account as account
    left outer join account.payments as payment
where :currentUser in elements(account.holder.users)
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre><p>Pour d'autres base de données, nous aurions dû faire sans la sous-requête (corrélée). </p><pre class="programlisting">select account, payment
from Account as account
    join account.holder.users as user
    left outer join account.payments as payment
where :currentUser = user
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-bulk"/>14.15. Mise à jour et suppression</h2></div></div></div><p>HQL now supports <code class="literal">update</code>, <code class="literal">delete</code> and <code class="literal">insert ... select ...</code> statements. See <a href="#batch-direct" title="13.4. La pseudo-syntaxe pour les expressions UPDATE et DELETE est : ( UPDATE | DELETE ) FROM? EntityName (WHERE where_conditions)?. Certains points sont Ã  noter :">Section 13.4, « La pseudo-syntaxe pour les expressions <code class="literal">UPDATE</code> et <code class="literal">DELETE</code> est : <code class="literal">( UPDATE | DELETE ) FROM? EntityName (WHERE where_conditions)?</code>. Certains points sont Ã  noter : »</a> for more information. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-tipstricks"/>14.16. Trucs &amp; Astuces</h2></div></div></div><p>You can count the number of query results without returning them: </p><pre class="programlisting">( (Integer) session.createQuery("select count(*) from ....").iterate().next() ).intValue()</pre><p>Pour trier les résultats par la taille d'une collection, utilisez la requête suivante : </p><pre class="programlisting">select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
order by count(msg)</pre><p>Si votre base de données supporte les sous-requêtes, vous pouvez placer des conditions sur la taille de la sélection dans la clause where de votre requête: </p><pre class="programlisting">from User usr where size(usr.messages) &gt;= 1</pre><p>If your database does not support subselects, use the following query: </p><pre class="programlisting">select usr.id, usr.name
from User usr.name
    join usr.messages msg
group by usr.id, usr.name
having count(msg) &gt;= 1</pre><p>As this solution cannot return a <code class="literal">User</code> with zero messages because of the inner join, the following form is also useful: </p><pre class="programlisting">select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
having count(msg) = 0</pre><p>Les propriétés d'un JavaBean peuvent être injectées dans les paramètres nommés d'un requête : </p><pre class="programlisting">Query q = s.createQuery("from foo Foo as foo where foo.name=:name and foo.size=:size");
q.setProperties(fooBean); // fooBean has getName() and getSize()
List foos = q.list();</pre><p>Les collections sont paginables via l'utilisation de l'interface <code class="literal">Query</code> avec un filtre : </p><pre class="programlisting">Query q = s.createFilter( collection, "" ); // the trivial filter
q.setMaxResults(PAGE_SIZE);
q.setFirstResult(PAGE_SIZE * pageNumber);
List page = q.list();</pre><p>Collection elements can be ordered or grouped using a query filter: </p><pre class="programlisting">Collection orderedCollection = s.filter( collection, "order by this.amount" );
Collection counts = s.filter( collection, "select this.type, count(this) group by this.type" );</pre><p>Vous pouvez récupérer la taille d'une collection sans l'initialiser : </p><pre class="programlisting">( (Integer) session.createQuery("select count(*) from ....").iterate().next() ).intValue();</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-components"/>14.17. translator-credits</h2></div></div></div><p>Components can be used similarly to the simple value types that are used in HQL queries. They can appear in the <code class="literal">select</code> clause as follows: </p><pre class="programlisting">select p.name from Person p</pre><pre class="programlisting">select p.name.first from Person p</pre><p>where the Person's name property is a component. Components can also be used in the <code class="literal">where</code> clause: </p><pre class="programlisting">from Person p where p.name = :name</pre><pre class="programlisting">from Person p where p.name.first = :firstName</pre><p>Components can also be used in the <code class="literal">order by</code> clause: </p><pre class="programlisting">from Person p order by p.name</pre><pre class="programlisting">from Person p order by p.name.first</pre><p>Another common use of components is in <a href="#queryhql-tuple" title="14.18. Row value constructor syntax">row value constructors</a>. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-tuple"/>14.18. Row value constructor syntax</h2></div></div></div><p>HQL supports the use of ANSI SQL <code class="literal">row value constructor</code> syntax, sometimes referred to AS <code class="literal">tuple</code> syntax, even though the underlying database may not support that notion. Here, we are generally referring to multi-valued comparisons, typically associated with components. Consider an entity Person which defines a name component: </p><pre class="programlisting">from Person p where p.name.first='John' and p.name.last='Jingleheimer-Schmidt'</pre><p>That is valid syntax although it is a little verbose. You can make this more concise by using <code class="literal">row value constructor</code> syntax: </p><pre class="programlisting">from Person p where p.name=('John', 'Jingleheimer-Schmidt')</pre><p>It can also be useful to specify this in the <code class="literal">select</code> clause: </p><pre class="programlisting">select p.name from Person p</pre><p>Using <code class="literal">row value constructor</code> syntax can also be beneficial when using subqueries that need to compare against multiple values: </p><pre class="programlisting">from Cat as cat
where not ( cat.name, cat.color ) in (
    select cat.name, cat.color from DomesticCat cat
)</pre><p>One thing to consider when deciding if you want to use this syntax, is that the query will be dependent upon the ordering of the component sub-properties in the metadata. </p></div></div><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria"/>Chapitre 15. Requêtes par critères</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#querycriteria-creating">15.1. Créer une instance de <code class="literal">Criteria</code></a></span></dt><dt><span class="sect1"><a href="#querycriteria-narrowing">15.2. Restriction du résultat</a></span></dt><dt><span class="sect1"><a href="#querycriteria-ordering">15.3. Trier les résultats</a></span></dt><dt><span class="sect1"><a href="#querycriteria-associations">15.4. Associations</a></span></dt><dt><span class="sect1"><a href="#querycriteria-dynamicfetching">15.5. Peuplement d'associations de manière dynamique</a></span></dt><dt><span class="sect1"><a href="#querycriteria-examples">15.6. Requêtes par l'exemple</a></span></dt><dt><span class="sect1"><a href="#querycriteria-projection">15.7. Projections, agrégation et regroupement</a></span></dt><dt><span class="sect1"><a href="#querycriteria-detachedqueries">15.8. Requêtes et sous-requêtes détachées</a></span></dt><dt><span class="sect1"><a href="#query-criteria-naturalid">15.9. Requêtes par identifiant naturel</a></span></dt></dl></div><p>Hibernate offre une API d'interrogation par critères intuitive et extensible. </p><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-creating"/>15.1. Créer une instance de <code class="literal">Criteria</code></h2></div></div></div><p>L'interface <code class="literal">net.sf.hibernate.Criteria</code> représente une requête sur une classe persistente donnée. La <code class="literal">Session</code> fournit les instances de <code class="literal">Criteria</code>. </p><pre class="programlisting">Criteria crit = sess.createCriteria(Cat.class);
crit.setMaxResults(50);
List cats = crit.list();</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-narrowing"/>15.2. Restriction du résultat</h2></div></div></div><p>Un criterion (critère de recherche) est une instance de l'interface <code class="literal">org.hibernate.criterion.Criterion</code>. La classe <code class="literal">org.hibernate.criterion.Restrictions</code> définit des méthodes pour obtenir des types de <code class="literal">Criterion</code> pré-définis. </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "Fritz%") )
    .add( Restrictions.between("weight", minWeight, maxWeight) )
    .list();</pre><p>Restrictions can be grouped logically. </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "Fritz%") )
    .add( Restrictions.or(
        Restrictions.eq( "age", new Integer(0) ),
        Restrictions.isNull("age")
    ) )
    .list();</pre><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.in( "name", new String[] { "Fritz", "Izi", "Pk" } ) )
    .add( Restrictions.disjunction()
        .add( Restrictions.isNull("age") )
        .add( Restrictions.eq("age", new Integer(0) ) )
        .add( Restrictions.eq("age", new Integer(1) ) )
        .add( Restrictions.eq("age", new Integer(2) ) )
    ) )
    .list();</pre><p>There are a range of built-in criterion types (<code class="literal">Restrictions</code> subclasses). One of the most useful allows you to specify SQL directly. </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.sqlRestriction("lower({alias}.name) like lower(?)", "Fritz%", Hibernate.STRING) )
    .list();</pre><p>La zone <code class="literal">{alias}</code> sera remplacée par l'alias de colonne de l'entité que l'on souhaite intérroger. </p><p>You can also obtain a criterion from a <code class="literal">Property</code> instance. You can create a <code class="literal">Property</code> by calling <code class="literal">Property.forName()</code>: </p><pre class="programlisting">
Property age = Property.forName("age");
List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.disjunction()
        .add( age.isNull() )
        .add( age.eq( new Integer(0) ) )
        .add( age.eq( new Integer(1) ) )
        .add( age.eq( new Integer(2) ) )
    ) )
    .add( Property.forName("name").in( new String[] { "Fritz", "Izi", "Pk" } ) )
    .list();</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-ordering"/>15.3. Trier les résultats</h2></div></div></div><p>You can order the results using <code class="literal">org.hibernate.criterion.Order</code>. </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "F%")
    .addOrder( Order.asc("name") )
    .addOrder( Order.desc("age") )
    .setMaxResults(50)
    .list();</pre><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Property.forName("name").like("F%") )
    .addOrder( Property.forName("name").asc() )
    .addOrder( Property.forName("age").desc() )
    .setMaxResults(50)
    .list();</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-associations"/>15.4. Associations</h2></div></div></div><p>By navigating associations using <code class="literal">createCriteria()</code> you can specify constraints upon related entities: </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "F%") )
    .createCriteria("kittens")
        .add( Restrictions.like("name", "F%") )
    .list();</pre><p>The second <code class="literal">createCriteria()</code> returns a new instance of <code class="literal">Criteria</code> that refers to the elements of the <code class="literal">kittens</code> collection. </p><p>There is also an alternate form that is useful in certain circumstances: </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .createAlias("kittens", "kt")
    .createAlias("mate", "mt")
    .add( Restrictions.eqProperty("kt.name", "mt.name") )
    .list();</pre><p>(<code class="literal">createAlias()</code> ne crée pas de nouvelle instance de <code class="literal">Criteria</code>.) </p><p>The kittens collections held by the <code class="literal">Cat</code> instances returned by the previous two queries are <span class="emphasis"><em>not</em></span> pre-filtered by the criteria. If you want to retrieve just the kittens that match the criteria, you must use a <code class="literal">ResultTransformer</code>. </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .createCriteria("kittens", "kt")
        .add( Restrictions.eq("name", "F%") )
    .setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP)
    .list();
Iterator iter = cats.iterator();
while ( iter.hasNext() ) {
    Map map = (Map) iter.next();
    Cat cat = (Cat) map.get(Criteria.ROOT_ALIAS);
    Cat kitten = (Cat) map.get("kt");
}</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-dynamicfetching"/>15.5. Peuplement d'associations de manière dynamique</h2></div></div></div><p>You can specify association fetching semantics at runtime using <code class="literal">setFetchMode()</code>. </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "Fritz%") )
    .setFetchMode("mate", FetchMode.EAGER)
    .setFetchMode("kittens", FetchMode.EAGER)
    .list();</pre><p>Cette requête recherchera <code class="literal">mate</code> et <code class="literal">kittens</code> via les jointures externes. Voir <a href="#performance-fetching" title="19.1. Stratégies de chargement">Section 19.1, « Stratégies de chargement »</a> pour plus d'informations. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-examples"/>15.6. Requêtes par l'exemple</h2></div></div></div><p>La classe <code class="literal">org.hibernate.criterion.Example</code> vous permet de construire un critère suivant une instance d'objet donnée. </p><pre class="programlisting">Cat cat = new Cat();
cat.setSex('F');
cat.setColor(Color.BLACK);
List results = session.createCriteria(Cat.class)
    .add( Example.create(cat) )
    .list();</pre><p>Les propriétés de type version, identifiant et association sont ignorées. Par défaut, les valeurs null sont exclues. </p><p>Vous pouvez ajuster la stratégie d'utilisation de valeurs de l'<code class="literal">Exemple</code>. </p><pre class="programlisting">Example example = Example.create(cat)
    .excludeZeroes()           //exclude zero valued properties
    .excludeProperty("color")  //exclude the property named "color"
    .ignoreCase()              //perform case insensitive string comparisons
    .enableLike();             //use like for string comparisons
List results = session.createCriteria(Cat.class)
    .add(example)
    .list();</pre><p>Vous pouvez utiliser les "exemples" pour des critères sur les objets associés. </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .add( Example.create(cat) )
    .createCriteria("mate")
        .add( Example.create( cat.getMate() ) )
    .list();</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-projection"/>15.7. Projections, agrégation et regroupement</h2></div></div></div><p>The class <code class="literal">org.hibernate.criterion.Projections</code> is a factory for <code class="literal">Projection</code> instances. You can apply a projection to a query by calling <code class="literal">setProjection()</code>. </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.rowCount() )
    .add( Restrictions.eq("color", Color.BLACK) )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.projectionList()
        .add( Projections.rowCount() )
        .add( Projections.avg("weight") )
        .add( Projections.max("weight") )
        .add( Projections.groupProperty("color") )
    )
    .list();</pre><p>Il n'y a pas besoin de "group by" explicite dans une requête par critère. Certains types de projection sont définis pour être des <span class="emphasis"><em>projections de regroupement</em></span>, lesquels apparaissent aussi dans la clause <code class="literal">group by</code> SQL. </p><p>An alias can be assigned to a projection so that the projected value can be referred to in restrictions or orderings. Here are two different ways to do this: </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.alias( Projections.groupProperty("color"), "colr" ) )
    .addOrder( Order.asc("colr") )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.groupProperty("color").as("colr") )
    .addOrder( Order.asc("colr") )
    .list();</pre><p>Les méthodes <code class="literal">alias()</code> et <code class="literal">as()</code> enveloppe simplement une instance de projection dans une autre instance (aliasée) de <code class="literal">Projection</code>. Comme un raccourci, vous pouvez assignez un alias lorsque vous ajoutez la projection à la liste de projections : </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.projectionList()
        .add( Projections.rowCount(), "catCountByColor" )
        .add( Projections.avg("weight"), "avgWeight" )
        .add( Projections.max("weight"), "maxWeight" )
        .add( Projections.groupProperty("color"), "color" )
    )
    .addOrder( Order.desc("catCountByColor") )
    .addOrder( Order.desc("avgWeight") )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Domestic.class, "cat")
    .createAlias("kittens", "kit")
    .setProjection( Projections.projectionList()
        .add( Projections.property("cat.name"), "catName" )
        .add( Projections.property("kit.name"), "kitName" )
    )
    .addOrder( Order.asc("catName") )
    .addOrder( Order.asc("kitName") )
    .list();</pre><p>Vous pouvez aussi utiliser <code class="literal">Property.forName()</code> pour formuler des projections : </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Property.forName("name") )
    .add( Property.forName("color").eq(Color.BLACK) )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.projectionList()
        .add( Projections.rowCount().as("catCountByColor") )
        .add( Property.forName("weight").avg().as("avgWeight") )
        .add( Property.forName("weight").max().as("maxWeight") )
        .add( Property.forName("color").group().as("color" )
    )
    .addOrder( Order.desc("catCountByColor") )
    .addOrder( Order.desc("avgWeight") )
    .list();</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-detachedqueries"/>15.8. Requêtes et sous-requêtes détachées</h2></div></div></div><p>The <code class="literal">DetachedCriteria</code> class allows you to create a query outside the scope of a session and then execute it using an arbitrary <code class="literal">Session</code>. </p><pre class="programlisting">DetachedCriteria query = DetachedCriteria.forClass(Cat.class)
    .add( Property.forName("sex").eq('F') );
    
Session session = ....;
Transaction txn = session.beginTransaction();
List results = query.getExecutableCriteria(session).setMaxResults(100).list();
txn.commit();
session.close();</pre><p>A <code class="literal">DetachedCriteria</code> can also be used to express a subquery. Criterion instances involving subqueries can be obtained via <code class="literal">Subqueries</code> or <code class="literal">Property</code>. </p><pre class="programlisting">DetachedCriteria avgWeight = DetachedCriteria.forClass(Cat.class)
    .setProjection( Property.forName("weight").avg() );
session.createCriteria(Cat.class)
    .add( Property.forName("weight").gt(avgWeight) )
    .list();</pre><pre class="programlisting">DetachedCriteria weights = DetachedCriteria.forClass(Cat.class)
    .setProjection( Property.forName("weight") );
session.createCriteria(Cat.class)
    .add( Subqueries.geAll("weight", weights) )
    .list();</pre><p>Correlated subqueries are also possible: </p><pre class="programlisting">DetachedCriteria avgWeightForSex = DetachedCriteria.forClass(Cat.class, "cat2")
    .setProjection( Property.forName("weight").avg() )
    .add( Property.forName("cat2.sex").eqProperty("cat.sex") );
session.createCriteria(Cat.class, "cat")
    .add( Property.forName("weight").gt(avgWeightForSex) )
    .list();</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="query-criteria-naturalid"/>15.9. Requêtes par identifiant naturel</h2></div></div></div><p>For most queries, including criteria queries, the query cache is not efficient because query cache invalidation occurs too frequently. However, there is a special kind of query where you can optimize the cache invalidation algorithm: lookups by a constant natural key. In some applications, this kind of query occurs frequently. The criteria API provides special provision for this use case. </p><p>First, map the natural key of your entity using <code class="literal">&lt;natural-id&gt;</code> and enable use of the second-level cache. </p><pre class="programlisting">&lt;class name="User"&gt;
    &lt;cache usage="read-write"/&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;natural-id&gt;
        &lt;property name="name"/&gt;
        &lt;property name="org"/&gt;
    &lt;/natural-id&gt;
    &lt;property name="password"/&gt;
&lt;/class&gt;</pre><p>This functionality is not intended for use with entities with <span class="emphasis"><em>mutable</em></span> natural keys. </p><p>Once you have enabled the Hibernate query cache, the <code class="literal">Restrictions.naturalId()</code> allows you to make use of the more efficient cache algorithm. </p><pre class="programlisting">session.createCriteria(User.class)
    .add( Restrictions.naturalId()
        .set("name", "gavin")
        .set("org", "hb") 
    ).setCacheable(true)
    .uniqueResult();</pre></div></div><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="querysql"/>Chapitre 16. SQL natif</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#querysql-creating">16.1. Utiliser une <code class="literal">SQLQuery</code></a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e13429">16.1.1. Scalar queries</a></span></dt><dt><span class="sect2"><a href="#d0e13479">16.1.2. Entity queries</a></span></dt><dt><span class="sect2"><a href="#d0e13515">16.1.3. Handling associations and collections</a></span></dt><dt><span class="sect2"><a href="#d0e13546">16.1.4. Returning multiple entities</a></span></dt><dt><span class="sect2"><a href="#d0e13687">16.1.5. Returning non-managed entities</a></span></dt><dt><span class="sect2"><a href="#d0e13708">16.1.6. Handling inheritance</a></span></dt><dt><span class="sect2"><a href="#d0e13713">16.1.7. Parameters</a></span></dt></dl></dd><dt><span class="sect1"><a href="#querysql-namedqueries">16.2. Requêtes SQL nommées</a></span></dt><dd><dl><dt><span class="sect2"><a href="#propertyresults">16.2.1. Utilisation de return-property pour spécifier explicitement les noms des colonnes/alias</a></span></dt><dt><span class="sect2"><a href="#sp_query">16.2.2. Utilisation de procédures stockées pour les requêtes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#querysql-cud">16.3. SQL personnalisé pour créer, mettre à jour et effacer</a></span></dt><dt><span class="sect1"><a href="#querysql-load">16.4. SQL personnalisé pour le chargement</a></span></dt></dl></div><p>You can also express queries in the native SQL dialect of your database. This is useful if you want to utilize database-specific features such as query hints or the <code class="literal">CONNECT</code> keyword in Oracle. It also provides a clean migration path from a direct SQL/JDBC based application to Hibernate.</p><p>Hibernate3 allows you to specify handwritten SQL, including stored procedures, for all create, update, delete, and load operations.</p><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="querysql-creating"/>16.1. Utiliser une <code class="literal">SQLQuery</code></h2></div></div></div><p>Execution of native SQL queries is controlled via the <code class="literal">SQLQuery</code> interface, which is obtained by calling <code class="literal">Session.createSQLQuery()</code>. The following sections describe how to use this API for querying.</p><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13429"/>16.1.1. Scalar queries</h3></div></div></div><p>The most basic SQL query is to get a list of scalars (values).</p><pre class="programlisting">sess.createSQLQuery("SELECT * FROM CATS").list();
sess.createSQLQuery("SELECT ID, NAME, BIRTHDATE FROM CATS").list();
</pre><p>These will return a List of Object arrays (Object[]) with scalar values for each column in the CATS table. Hibernate will use ResultSetMetadata to deduce the actual order and types of the returned scalar values.</p><p>To avoid the overhead of using <code class="literal">ResultSetMetadata</code>, or simply to be more explicit in what is returned, one can use <code class="literal">addScalar()</code>:</p><pre class="programlisting">sess.createSQLQuery("SELECT * FROM CATS")
 .addScalar("ID", Hibernate.LONG)
 .addScalar("NAME", Hibernate.STRING)
 .addScalar("BIRTHDATE", Hibernate.DATE)
</pre><p>This query specified:</p><div class="itemizedlist"><ul><li><p>the SQL query string</p></li><li><p>the columns and types to return</p></li></ul></div><p>This will return Object arrays, but now it will not use <code class="literal">ResultSetMetadata</code> but will instead explicitly get the ID, NAME and BIRTHDATE column as respectively a Long, String and a Short from the underlying resultset. This also means that only these three columns will be returned, even though the query is using <code class="literal">*</code> and could return more than the three listed columns.</p><p>It is possible to leave out the type information for all or some of the scalars.</p><pre class="programlisting">sess.createSQLQuery("SELECT * FROM CATS")
 .addScalar("ID", Hibernate.LONG)
 .addScalar("NAME")
 .addScalar("BIRTHDATE")
</pre><p>This is essentially the same query as before, but now <code class="literal">ResultSetMetaData</code> is used to determine the type of NAME and BIRTHDATE, where as the type of ID is explicitly specified.</p><p>How the java.sql.Types returned from ResultSetMetaData is mapped to Hibernate types is controlled by the Dialect. If a specific type is not mapped, or does not result in the expected type, it is possible to customize it via calls to <code class="literal">registerHibernateType</code> in the Dialect.</p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13479"/>16.1.2. Entity queries</h3></div></div></div><p>The above queries were all about returning scalar values, basically returning the "raw" values from the resultset. The following shows how to get entity objects from a native sql query via <code class="literal">addEntity()</code>.</p><pre class="programlisting">sess.createSQLQuery("SELECT * FROM CATS").addEntity(Cat.class);
sess.createSQLQuery("SELECT ID, NAME, BIRTHDATE FROM CATS").addEntity(Cat.class);
</pre><p>This query specified:</p><div class="itemizedlist"><ul><li><p>the SQL query string</p></li><li><p>the entity returned by the query</p></li></ul></div><p>Assuming that Cat is mapped as a class with the columns ID, NAME and BIRTHDATE the above queries will both return a List where each element is a Cat entity.</p><p>If the entity is mapped with a <code class="literal">many-to-one</code> to another entity it is required to also return this when performing the native query, otherwise a database specific "column not found" error will occur. The additional columns will automatically be returned when using the * notation, but we prefer to be explicit as in the following example for a <code class="literal">many-to-one</code> to a <code class="literal">Dog</code>:</p><pre class="programlisting">sess.createSQLQuery("SELECT ID, NAME, BIRTHDATE, DOG_ID FROM CATS").addEntity(Cat.class);
</pre><p>This will allow cat.getDog() to function properly.</p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13515"/>16.1.3. Handling associations and collections</h3></div></div></div><p>It is possible to eagerly join in the <code class="literal">Dog</code> to avoid the possible extra roundtrip for initializing the proxy. This is done via the <code class="literal">addJoin()</code> method, which allows you to join in an association or collection.</p><pre class="programlisting">sess.createSQLQuery("SELECT c.ID, NAME, BIRTHDATE, DOG_ID, D_ID, D_NAME FROM CATS c, DOGS d WHERE c.DOG_ID = d.D_ID")
 .addEntity("cat", Cat.class)
 .addJoin("cat.dog");
</pre><p>In this example, the returned <code class="literal">Cat</code>'s will have their <code class="literal">dog</code> property fully initialized without any extra roundtrip to the database. Notice that you added an alias name ("cat") to be able to specify the target property path of the join. It is possible to do the same eager joining for collections, e.g. if the <code class="literal">Cat</code> had a one-to-many to <code class="literal">Dog</code> instead.</p><pre class="programlisting">sess.createSQLQuery("SELECT ID, NAME, BIRTHDATE, D_ID, D_NAME, CAT_ID FROM CATS c, DOGS d WHERE c.ID = d.CAT_ID")
 .addEntity("cat", Cat.class)
 .addJoin("cat.dogs");
</pre><p>At this stage you are reaching the limits of what is possible with native queries, without starting to enhance the sql queries to make them usable in Hibernate. Problems can arise when returning multiple entities of the same type or when the default alias/column names are not enough. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13546"/>16.1.4. Returning multiple entities</h3></div></div></div><p>Until now, the result set column names are assumed to be the same as the column names specified in the mapping document. This can be problematic for SQL queries that join multiple tables, since the same column names can appear in more than one table.</p><p>Column alias injection is needed in the following query (which most likely will fail):</p><pre class="programlisting">sess.createSQLQuery("SELECT c.*, m.*  FROM CATS c, CATS m WHERE c.MOTHER_ID = c.ID")
 .addEntity("cat", Cat.class)
 .addEntity("mother", Cat.class)
</pre><p>The query was intended to return two Cat instances per row: a cat and its mother. The query will, however, fail because there is a conflict of names; the instances are mapped to the same column names. Also, on some databases the returned column aliases will most likely be on the form "c.ID", "c.NAME", etc. which are not equal to the columns specified in the mappings ("ID" and "NAME"). </p><p>The following form is not vulnerable to column name duplication:</p><pre class="programlisting">sess.createSQLQuery("SELECT {cat.*}, {mother.*}  FROM CATS c, CATS m WHERE c.MOTHER_ID = c.ID")
 .addEntity("cat", Cat.class)
 .addEntity("mother", Cat.class)
</pre><p>This query specified:</p><div class="itemizedlist"><ul><li><p>the SQL query string, with placeholders for Hibernate to inject column aliases</p></li><li><p>the entities returned by the query</p></li></ul></div><p>The {cat.*} and {mother.*} notation used above is a shorthand for "all properties". Alternatively, you can list the columns explicitly, but even in this case Hibernate injects the SQL column aliases for each property. The placeholder for a column alias is just the property name qualified by the table alias. In the following example, you retrieve Cats and their mothers from a different table (cat_log) to the one declared in the mapping metadata. You can even use the property aliases in the where clause.</p><pre class="programlisting">String sql = "SELECT ID as {c.id}, NAME as {c.name}, " + 
         "BIRTHDATE as {c.birthDate}, MOTHER_ID as {c.mother}, {mother.*} " +
         "FROM CAT_LOG c, CAT_LOG m WHERE {c.mother} = c.ID";

List loggedCats = sess.createSQLQuery(sql)
        .addEntity("cat", Cat.class)
        .addEntity("mother", Cat.class).list()
</pre><div class="sect3" lang="fr-FR"><div class="titlepage"><div><div><h4 class="title"><a id="querysql-aliasreferences"/>16.1.4.1. Alias and property references</h4></div></div></div><p>In most cases the above alias injection is needed. For queries relating to more complex mappings, like composite properties, inheritance discriminators, collections etc., you can use specific aliases that allow Hibernate to inject the proper aliases.</p><p>The following table shows the different ways you can use the alias injection. Please note that the alias names in the result are simply examples; each alias will have a unique and probably different name when used.</p><div class="table"><a id="aliasinjection-summary"/><p class="title"><b>Tableau 16.1. Alias injection names</b></p><div class="table-contents"><table summary="Alias injection names" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Description</th><th>Syntax</th><th>Example</th></tr></thead><tbody><tr><td>A simple property</td><td><code class="literal">{[aliasname].[propertyname]</code></td><td><code class="literal">A_NAME as {item.name}</code></td></tr><tr><td>A composite property</td><td><code class="literal">{[aliasname].[componentname].[propertyname]}</code></td><td><code class="literal">CURRENCY as {item.amount.currency}, VALUE as {item.amount.value}</code></td></tr><tr><td>Discriminator of an entity</td><td><code class="literal">{[aliasname].class}</code></td><td><code class="literal">DISC as {item.class}</code></td></tr><tr><td>All properties of an entity</td><td><code class="literal">{[aliasname].*}</code></td><td><code class="literal">{item.*}</code></td></tr><tr><td>A collection key</td><td><code class="literal">{[aliasname].key}</code></td><td><code class="literal">ORGID as {coll.key}</code></td></tr><tr><td>The id of an collection</td><td><code class="literal">{[aliasname].id}</code></td><td><code class="literal">EMPID as {coll.id}</code></td></tr><tr><td>The element of an collection</td><td><code class="literal">{[aliasname].element}</code></td><td><code class="literal">XID as {coll.element}</code></td></tr><tr><td>property of the element in the collection</td><td><code class="literal">{[aliasname].element.[propertyname]}</code></td><td><code class="literal">NAME as {coll.element.name}</code></td></tr><tr><td>All properties of the element in the collection</td><td><code class="literal">{[aliasname].element.*}</code></td><td><code class="literal">{coll.element.*}</code></td></tr><tr><td>All properties of the the collection</td><td><code class="literal">{[aliasname].*}</code></td><td><code class="literal">{coll.*}</code></td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13687"/>16.1.5. Returning non-managed entities</h3></div></div></div><p>It is possible to apply a ResultTransformer to native SQL queries, allowing it to return non-managed entities.</p><pre class="programlisting">sess.createSQLQuery("SELECT NAME, BIRTHDATE FROM CATS")
        .setResultTransformer(Transformers.aliasToBean(CatDTO.class))</pre><p>This query specified:</p><div class="itemizedlist"><ul><li><p>the SQL query string</p></li><li><p>a result transformer</p></li></ul></div><p>The above query will return a list of <code class="literal">CatDTO</code> which has been instantiated and injected the values of NAME and BIRTHNAME into its corresponding properties or fields. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13708"/>16.1.6. Handling inheritance</h3></div></div></div><p>Native SQL queries which query for entities that are mapped as part of an inheritance must include all properties for the baseclass and all its subclasses.</p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13713"/>16.1.7. Parameters</h3></div></div></div><p>Native SQL queries support positional as well as named parameters:</p><pre class="programlisting">Query query = sess.createSQLQuery("SELECT * FROM CATS WHERE NAME like ?").addEntity(Cat.class);
List pusList = query.setString(0, "Pus%").list();
     
query = sess.createSQLQuery("SELECT * FROM CATS WHERE NAME like :name").addEntity(Cat.class);
List pusList = query.setString("name", "Pus%").list();          </pre></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="querysql-namedqueries"/>16.2. Requêtes SQL nommées</h2></div></div></div><p>Named SQL queries can be defined in the mapping document and called in exactly the same way as a named HQL query. In this case, you do <span class="emphasis"><em>not</em></span> need to call <code class="literal">addEntity()</code>.</p><pre class="programlisting">&lt;sql-query name="persons"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex}
    FROM PERSON person
    WHERE person.NAME LIKE :namePattern
&lt;/sql-query&gt;</pre><pre class="programlisting">List people = sess.getNamedQuery("persons")
    .setString("namePattern", namePattern)
    .setMaxResults(50)
    .list();</pre><p>The <code class="literal">&lt;return-join&gt;</code> element is use to join associations and the <code class="literal">&lt;load-collection&gt;</code> element is used to define queries which initialize collections, </p><pre class="programlisting">&lt;sql-query name="personsWith"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    &lt;return-join alias="address" property="person.mailingAddress"/&gt;
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex},
           address.STREET AS {address.street},
           address.CITY AS {address.city},
           address.STATE AS {address.state},
           address.ZIP AS {address.zip}
    FROM PERSON person
    JOIN ADDRESS address
        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'
    WHERE person.NAME LIKE :namePattern
&lt;/sql-query&gt;</pre><p>Une requête SQL nommée peut retourner une valeur scalaire. Vous devez spécifier l'alias de colonne et le type Hibernate utilisant l'élément <code class="literal">&lt;return-scalar&gt;</code> :</p><pre class="programlisting">&lt;sql-query name="mySqlQuery"&gt;
    &lt;return-scalar column="name" type="string"/&gt;
    &lt;return-scalar column="age" type="long"/&gt;
    SELECT p.NAME AS name,
           p.AGE AS age,
    FROM PERSON p WHERE p.NAME LIKE 'Hiber%'
&lt;/sql-query&gt;</pre><p>You can externalize the resultset mapping information in a <code class="literal">&lt;resultset&gt;</code> element which will allow you to either reuse them across several named queries or through the <code class="literal">setResultSetMapping()</code> API.</p><pre class="programlisting">&lt;resultset name="personAddress"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    &lt;return-join alias="address" property="person.mailingAddress"/&gt;
&lt;/resultset&gt;

&lt;sql-query name="personsWith" resultset-ref="personAddress"&gt;
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex},
           address.STREET AS {address.street},
           address.CITY AS {address.city},
           address.STATE AS {address.state},
           address.ZIP AS {address.zip}
    FROM PERSON person
    JOIN ADDRESS address
        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'
    WHERE person.NAME LIKE :namePattern
&lt;/sql-query&gt;</pre><p>You can, alternatively, use the resultset mapping information in your hbm files directly in java code.</p><pre class="programlisting">List cats = sess.createSQLQuery(
        "select {cat.*}, {kitten.*} from cats cat, cats kitten where kitten.mother = cat.id"
    )
    .setResultSetMapping("catAndKitten")
    .list();</pre><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="propertyresults"/>16.2.1. Utilisation de return-property pour spécifier explicitement les noms des colonnes/alias</h3></div></div></div><p>You can explicitly tell Hibernate what column aliases to use with <code class="literal">&lt;return-property&gt;</code>, instead of using the <code class="literal">{}</code>-syntax to let Hibernate inject its own aliases.For example:</p><pre class="programlisting">&lt;sql-query name="mySqlQuery"&gt;
    &lt;return alias="person" class="eg.Person"&gt;
        &lt;return-property name="name" column="myName"/&gt;
        &lt;return-property name="age" column="myAge"/&gt;
        &lt;return-property name="sex" column="mySex"/&gt;
    &lt;/return&gt;
    SELECT person.NAME AS myName,
           person.AGE AS myAge,
           person.SEX AS mySex,
    FROM PERSON person WHERE person.NAME LIKE :name
&lt;/sql-query&gt;
</pre><p><code class="literal">&lt;return-property&gt;</code> also works with multiple columns. This solves a limitation with the <code class="literal">{}</code>-syntax which cannot allow fine grained control of multi-column properties.</p><pre class="programlisting">&lt;sql-query name="organizationCurrentEmployments"&gt;
    &lt;return alias="emp" class="Employment"&gt;
        &lt;return-property name="salary"&gt;
            &lt;return-column name="VALUE"/&gt;
            &lt;return-column name="CURRENCY"/&gt;
        &lt;/return-property&gt;
        &lt;return-property name="endDate" column="myEndDate"/&gt;
    &lt;/return&gt;
        SELECT EMPLOYEE AS {emp.employee}, EMPLOYER AS {emp.employer},
        STARTDATE AS {emp.startDate}, ENDDATE AS {emp.endDate},
        REGIONCODE as {emp.regionCode}, EID AS {emp.id}, VALUE, CURRENCY
        FROM EMPLOYMENT
        WHERE EMPLOYER = :id AND ENDDATE IS NULL
        ORDER BY STARTDATE ASC
&lt;/sql-query&gt;</pre><p>In this example <code class="literal">&lt;return-property&gt;</code> was used in combination with the <code class="literal">{}</code>-syntax for injection. This allows users to choose how they want to refer column and properties.</p><p>Si votre mapping a un discriminant vous devez utiliser <code class="literal">&lt;return-discriminator&gt;</code> pour spécifier la colonne discriminante.</p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="sp_query"/>16.2.2. Utilisation de procédures stockées pour les requêtes</h3></div></div></div><p>Hibernate3 provides support for queries via stored procedures and functions. Most of the following documentation is equivalent for both. The stored procedure/function must return a resultset as the first out-parameter to be able to work with Hibernate. An example of such a stored function in Oracle 9 and higher is as follows:</p><pre class="programlisting">CREATE OR REPLACE FUNCTION selectAllEmployments
    RETURN SYS_REFCURSOR
AS
    st_cursor SYS_REFCURSOR;
BEGIN
    OPEN st_cursor FOR
 SELECT EMPLOYEE, EMPLOYER,
 STARTDATE, ENDDATE,
 REGIONCODE, EID, VALUE, CURRENCY
 FROM EMPLOYMENT;
      RETURN  st_cursor;
 END;</pre><p>Pour utiliser cette requête dans Hibernate vous avez besoin de la mapper via une requête nommée.</p><pre class="programlisting">&lt;sql-query name="selectAllEmployees_SP" callable="true"&gt;
    &lt;return alias="emp" class="Employment"&gt;
        &lt;return-property name="employee" column="EMPLOYEE"/&gt;
        &lt;return-property name="employer" column="EMPLOYER"/&gt;
        &lt;return-property name="startDate" column="STARTDATE"/&gt;
        &lt;return-property name="endDate" column="ENDDATE"/&gt;
        &lt;return-property name="regionCode" column="REGIONCODE"/&gt;
        &lt;return-property name="id" column="EID"/&gt;
        &lt;return-property name="salary"&gt;
            &lt;return-column name="VALUE"/&gt;
            &lt;return-column name="CURRENCY"/&gt;
        &lt;/return-property&gt;
    &lt;/return&gt;
    { ? = call selectAllEmployments() }
&lt;/sql-query&gt;</pre><p>Stored procedures currently only return scalars and entities. <code class="literal">&lt;return-join&gt;</code> and <code class="literal">&lt;load-collection&gt;</code> are not supported.</p><div class="sect3" lang="fr-FR"><div class="titlepage"><div><div><h4 class="title"><a id="querysql-limits-storedprocedures"/>16.2.2.1. Règles/limitations lors de l'utilisation des procédures stockées</h4></div></div></div><p>You cannot use stored procedures with Hibernate unless you follow some procedure/function rules. If they do not follow those rules they are not usable with Hibernate. If you still want to use these procedures you have to execute them via <code class="literal">session.connection()</code>. The rules are different for each database, since database vendors have different stored procedure semantics/syntax.</p><p>Stored procedure queries cannot be paged with <code class="literal">setFirstResult()/setMaxResults()</code>.</p><p>The recommended call form is standard SQL92: <code class="literal">{ ? = call functionName(&lt;parameters&gt;) }</code> or <code class="literal">{ ? = call procedureName(&lt;parameters&gt;}</code>. Native call syntax is not supported.</p><p>Pour Oracle les règles suivantes s'appliquent :</p><div class="itemizedlist"><ul compact="compact"><li><p>A function must return a result set. The first parameter of a procedure must be an <code class="literal">OUT</code> that returns a result set. This is done by using a <code class="literal">SYS_REFCURSOR</code> type in Oracle 9 or 10. In Oracle you need to define a <code class="literal">REF CURSOR</code> type. See Oracle literature for further information.</p></li></ul></div><p>Pour Sybase ou MS SQL server les règles suivantes s'appliquent :</p><div class="itemizedlist"><ul compact="compact"><li><p>The procedure must return a result set. Note that since these servers can return multiple result sets and update counts, Hibernate will iterate the results and take the first result that is a result set as its return value. Everything else will be discarded.</p></li><li><p>Si vous pouvez activer <code class="literal">SET NOCOUNT ON</code> dans votre procédure, elle sera probablement plus efficace, mais ce n'est pas une obligation.</p></li></ul></div></div></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="querysql-cud"/>16.3. SQL personnalisé pour créer, mettre à jour et effacer</h2></div></div></div><p>Hibernate3 peut utiliser des expression SQL personnalisées pour des opérations de création, de mise à jour, et de suppression. Les objets persistants les classes et les collections dans Hibernate contiennent déjà un ensemble de chaînes de caractères générées lors de la configuration (insertsql, deletesql, updatesql, etc). Les tages de mapping <code class="literal">&lt;sql-insert&gt;</code>, <code class="literal">&lt;sql-delete&gt;</code>, et <code class="literal">&lt;sql-update&gt;</code> surchargent ces chaînes de caractères :</p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true"/&gt;
    &lt;sql-insert&gt;INSERT INTO PERSON (NAME, ID) VALUES ( UPPER(?), ? )&lt;/sql-insert&gt;
    &lt;sql-update&gt;UPDATE PERSON SET NAME=UPPER(?) WHERE ID=?&lt;/sql-update&gt;
    &lt;sql-delete&gt;DELETE FROM PERSON WHERE ID=?&lt;/sql-delete&gt;
&lt;/class&gt;</pre><p>The SQL is directly executed in your database, so you can use any dialect you like. This will reduce the portability of your mapping if you use database specific SQL.</p><p>Les procédures stockées sont supportées si l'attribut <code class="literal">callable</code> est paramétré :</p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true"/&gt;
    &lt;sql-insert callable="true"&gt;{call createPerson (?, ?)}&lt;/sql-insert&gt;
    &lt;sql-delete callable="true"&gt;{? = call deletePerson (?)}&lt;/sql-delete&gt;
    &lt;sql-update callable="true"&gt;{? = call updatePerson (?, ?)}&lt;/sql-update&gt;
&lt;/class&gt;</pre><p>The order of the positional parameters is vital, as they must be in the same sequence as Hibernate expects them.</p><p>You can view the expected order by enabling debug logging for the <code class="literal">org.hibernate.persister.entity</code> level. With this level enabled, Hibernate will print out the static SQL that is used to create, update, delete etc. entities. To view the expected sequence, do not include your custom SQL in the mapping files, as this will override the Hibernate generated static SQL.</p><p>The stored procedures are in most cases required to return the number of rows inserted, updated and deleted, as Hibernate has some runtime checks for the success of the statement. Hibernate always registers the first statement parameter as a numeric output parameter for the CUD operations:</p><pre class="programlisting">CREATE OR REPLACE FUNCTION updatePerson (uid IN NUMBER, uname IN VARCHAR2)
    RETURN NUMBER IS
BEGIN

    update PERSON
    set
        NAME = uname,
    where
        ID = uid;

    return SQL%ROWCOUNT;

END updatePerson;</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="querysql-load"/>16.4. SQL personnalisé pour le chargement</h2></div></div></div><p>You can also declare your own SQL (or HQL) queries for entity loading:</p><pre class="programlisting">&lt;sql-query name="person"&gt;
    &lt;return alias="pers" class="Person" lock-mode="upgrade"/&gt;
    SELECT NAME AS {pers.name}, ID AS {pers.id}
    FROM PERSON
    WHERE ID=?
    FOR UPDATE
&lt;/sql-query&gt;</pre><p>This is just a named query declaration, as discussed earlier. You can reference this named query in a class mapping:</p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true"/&gt;
    &lt;loader query-ref="person"/&gt;
&lt;/class&gt;</pre><p>Ceci fonctionne même avec des procédures stockées.</p><p>You can even define a query for collection loading:</p><pre class="programlisting">&lt;set name="employments" inverse="true"&gt;
    &lt;key/&gt;
    &lt;one-to-many class="Employment"/&gt;
    &lt;loader query-ref="employments"/&gt;
&lt;/set&gt;</pre><pre class="programlisting">&lt;sql-query name="employments"&gt;
    &lt;load-collection alias="emp" role="Person.employments"/&gt;
    SELECT {emp.*}
    FROM EMPLOYMENT emp
    WHERE EMPLOYER = :id
    ORDER BY STARTDATE ASC, EMPLOYEE ASC
&lt;/sql-query&gt;</pre><p>You can also define an entity loader that loads a collection by join fetching:</p><pre class="programlisting">&lt;sql-query name="person"&gt;
    &lt;return alias="pers" class="Person"/&gt;
    &lt;return-join alias="emp" property="pers.employments"/&gt;
    SELECT NAME AS {pers.*}, {emp.*}
    FROM PERSON pers
    LEFT OUTER JOIN EMPLOYMENT emp
        ON pers.ID = emp.PERSON_ID
    WHERE ID=?
&lt;/sql-query&gt;</pre></div></div><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="filters"/>Chapitre 17. Filtrer les données</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#objectstate-filters">17.1. Filtres Hibernate</a></span></dt></dl></div><p>Hibernate3 provides an innovative new approach to handling data with "visibility" rules. A <span class="emphasis"><em>Hibernate filter</em></span> is a global, named, parameterized filter that can be enabled or disabled for a particular Hibernate session. </p><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-filters"/>17.1. Filtres Hibernate</h2></div></div></div><p>Hibernate3 has the ability to pre-define filter criteria and attach those filters at both a class level and a collection level. A filter criteria allows you to define a restriction clause similar to the existing "where" attribute available on the class and various collection elements. These filter conditions, however, can be parameterized. The application can then decide at runtime whether certain filters should be enabled and what their parameter values should be. Filters can be used like database views, but they are parameterized inside the application. </p><p>Afin d'utiliser des filtres, ils doivent d'abord être définis, puis attachés aux éléments de mapping appropriés. Pour définir un filtre, utilisez l'élément <code class="literal">&lt;filter-def/&gt;</code> dans un élément <code class="literal">&lt;hibernate-mapping/&gt;</code> : </p><pre class="programlisting">&lt;filter-def name="myFilter"&gt;
    &lt;filter-param name="myFilterParam" type="string"/&gt;
&lt;/filter-def&gt;</pre><p>This filter can then be attached to a class: </p><pre class="programlisting">&lt;class name="myClass" ...&gt;
    ...
    &lt;filter name="myFilter" condition=":myFilterParam = MY_FILTERED_COLUMN"/&gt;
&lt;/class&gt;</pre><p>Or, to a collection: </p><pre class="programlisting">&lt;set ...&gt;
    &lt;filter name="myFilter" condition=":myFilterParam = MY_FILTERED_COLUMN"/&gt;
&lt;/set&gt;</pre><p>Or, to both or multiples of each at the same time. </p><p>The methods on <code class="literal">Session</code> are: <code class="literal">enableFilter(String filterName)</code>, <code class="literal">getEnabledFilter(String filterName)</code>, and <code class="literal">disableFilter(String filterName)</code>. By default, filters are <span class="emphasis"><em>not</em></span> enabled for a given session. Filters must be enabled through use of the <code class="literal">Session.enableFilter()</code> method, which returns an instance of the <code class="literal">Filter</code> interface. If you used the simple filter defined above, it would look like this: </p><pre class="programlisting">session.enableFilter("myFilter").setParameter("myFilterParam", "some-value");</pre><p>Methods on the org.hibernate.Filter interface do allow the method-chaining common to much of Hibernate. </p><p>The following is a full example, using temporal data with an effective record date pattern: </p><pre class="programlisting">&lt;filter-def name="effectiveDate"&gt;
    &lt;filter-param name="asOfDate" type="date"/&gt;
&lt;/filter-def&gt;

&lt;class name="Employee" ...&gt;
...
    &lt;many-to-one name="department" column="dept_id" class="Department"/&gt;
    &lt;property name="effectiveStartDate" type="date" column="eff_start_dt"/&gt;
    &lt;property name="effectiveEndDate" type="date" column="eff_end_dt"/&gt;
...
    &lt;!--
        Note that this assumes non-terminal records have an eff_end_dt set to
        a max db date for simplicity-sake
    --&gt;
    &lt;filter name="effectiveDate"
            condition=":asOfDate BETWEEN eff_start_dt and eff_end_dt"/&gt;
&lt;/class&gt;

&lt;class name="Department" ...&gt;
...
    &lt;set name="employees" lazy="true"&gt;
        &lt;key column="dept_id"/&gt;
        &lt;one-to-many class="Employee"/&gt;
        &lt;filter name="effectiveDate"
                condition=":asOfDate BETWEEN eff_start_dt and eff_end_dt"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>In order to ensure that you are provided with currently effective records, enable the filter on the session prior to retrieving employee data: </p><pre class="programlisting">Session session = ...;
session.enableFilter("effectiveDate").setParameter("asOfDate", new Date());
List results = session.createQuery("from Employee as e where e.salary &gt; :targetSalary")
         .setLong("targetSalary", new Long(1000000))
         .list();
</pre><p>Even though a salary constraint was mentioned explicitly on the results in the above HQL, because of the enabled filter, the query will return only currently active employees who have a salary greater than one million dollars. </p><p>If you want to use filters with outer joining, either through HQL or load fetching, be careful of the direction of the condition expression. It is safest to set this up for left outer joining. Place the parameter first followed by the column name(s) after the operator. </p><p>After being defined, a filter might be attached to multiple entities and/or collections each with its own condition. This can be problematic when the conditions are the same each time. Using <code class="literal">&lt;filter-def/&gt;</code> allows you to definine a default condition, either as an attribute or CDATA: </p><pre class="programlisting">&lt;filter-def name="myFilter" condition="abc &gt; xyz"&gt;...&lt;/filter-def&gt;
&lt;filter-def name="myOtherFilter"&gt;abc=xyz&lt;/filter-def&gt;</pre><p>This default condition will be used whenever the filter is attached to something without specifying a condition. This means you can give a specific condition as part of the attachment of the filter that overrides the default condition in that particular case. </p></div></div><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="xml"/>Chapitre 18. Mapping XML</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#xml-intro">18.1. Travailler avec des données XML</a></span></dt><dd><dl><dt><span class="sect2"><a href="#xml-intro-mapping">18.1.1. Spécifier le mapping XML et le mapping d'une classe ensemble</a></span></dt><dt><span class="sect2"><a href="#xml-onlyxml">18.1.2. Spécifier seulement un mapping XML</a></span></dt></dl></dd><dt><span class="sect1"><a href="#xml-mapping">18.2. Métadonnées du mapping XML</a></span></dt><dt><span class="sect1"><a href="#xml-manipulation">18.3. Manipuler des données XML</a></span></dt></dl></div><p><span class="emphasis"><em>XML Mapping is an experimental feature in Hibernate 3.0 and is currently under active development. </em></span></p><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="xml-intro"/>18.1. Travailler avec des données XML</h2></div></div></div><p>Hibernate allows you to work with persistent XML data in much the same way you work with persistent POJOs. A parsed XML tree can be thought of as another way of representing the relational data at the object level, instead of POJOs. </p><p>Hibernate supporte dom4j en tant qu'API pour la manipulation des arbres XML. Vous pouvez écrire des requêtes qui récupèrent des arbres dom4j à partie de la base de données, et avoir toutes les modifications que vous faites sur l'arbre automatiquement synchronisées dans la base de données. Vous pouvez même prendre un document XML, l'analyser en utilisant dom4j, et l'écrire dans la base de données via les opérations basiques d'Hibernate : <code class="literal">persist(), saveOrUpdate(), merge(), delete(), replicate()</code> (merge() n'est pas encore supporté). </p><p>Cette fonctionnalité a plusieurs applications dont l'import/export de données, l'externalisation d'entités via JMS ou SOAP et les rapports XSLT. </p><p>A single mapping can be used to simultaneously map properties of a class and nodes of an XML document to the database, or, if there is no class to map, it can be used to map just the XML. </p><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="xml-intro-mapping"/>18.1.1. Spécifier le mapping XML et le mapping d'une classe ensemble</h3></div></div></div><p>Voici un exemple de mapping d'un POJO et du XML simultanément : </p><pre class="programlisting">&lt;class name="Account" 
        table="ACCOUNTS" 
        node="account"&gt;
        
    &lt;id name="accountId" 
            column="ACCOUNT_ID" 
            node="@id"/&gt;
            
    &lt;many-to-one name="customer" 
            column="CUSTOMER_ID" 
            node="customer/@id" 
            embed-xml="false"/&gt;
            
    &lt;property name="balance" 
            column="BALANCE" 
            node="balance"/&gt;
            
    ...
    
&lt;/class&gt;</pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="xml-onlyxml"/>18.1.2. Spécifier seulement un mapping XML</h3></div></div></div><p>Voici un exemple dans lequel il n'y a pas de class POJO : </p><pre class="programlisting">&lt;class entity-name="Account" 
        table="ACCOUNTS" 
        node="account"&gt;
        
    &lt;id name="id" 
            column="ACCOUNT_ID" 
            node="@id" 
            type="string"/&gt;
            
    &lt;many-to-one name="customerId" 
            column="CUSTOMER_ID" 
            node="customer/@id" 
            embed-xml="false" 
            entity-name="Customer"/&gt;
            
    &lt;property name="balance" 
            column="BALANCE" 
            node="balance" 
            type="big_decimal"/&gt;
            
    ...
    
&lt;/class&gt;</pre><p>This mapping allows you to access the data as a dom4j tree, or as a graph of property name/value pairs or java <code class="literal">Map</code>s. The property names are purely logical constructs that can be referred to in HQL queries. </p></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="xml-mapping"/>18.2. Métadonnées du mapping XML</h2></div></div></div><p>A range of Hibernate mapping elements accept the <code class="literal">node</code> attribute. This lets you specify the name of an XML attribute or element that holds the property or entity data. The format of the <code class="literal">node</code> attribute must be one of the following: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">"element-name"</code>: map to the named XML element</p></li><li><p><code class="literal">"@attribute-name"</code>: map to the named XML attribute</p></li><li><p><code class="literal">"."</code>: map to the parent element</p></li><li><p><code class="literal">"element-name/@attribute-name"</code>: map to the named attribute of the named element </p></li></ul></div><p>For collections and single valued associations, there is an additional <code class="literal">embed-xml</code> attribute. If <code class="literal">embed-xml="true"</code>, the default, the XML tree for the associated entity (or collection of value type) will be embedded directly in the XML tree for the entity that owns the association. Otherwise, if <code class="literal">embed-xml="false"</code>, then only the referenced identifier value will appear in the XML for single point associations and collections will not appear at all. </p><p>Do not leave <code class="literal">embed-xml="true"</code> for too many associations, since XML does not deal well with circularity. </p><pre class="programlisting">&lt;class name="Customer" 
        table="CUSTOMER" 
        node="customer"&gt;
        
    &lt;id name="id" 
            column="CUST_ID" 
            node="@id"/&gt;
            
    &lt;map name="accounts" 
            node="." 
            embed-xml="true"&gt;
        &lt;key column="CUSTOMER_ID" 
                not-null="true"/&gt;
        &lt;map-key column="SHORT_DESC" 
                node="@short-desc" 
                type="string"/&gt;
        &lt;one-to-many entity-name="Account"
                embed-xml="false" 
                node="account"/&gt;
    &lt;/map&gt;
    
    &lt;component name="name" 
            node="name"&gt;
        &lt;property name="firstName" 
                node="first-name"/&gt;
        &lt;property name="initial" 
                node="initial"/&gt;
        &lt;property name="lastName" 
                node="last-name"/&gt;
    &lt;/component&gt;
    
    ...
    
&lt;/class&gt;</pre><p>In this case, the collection of account ids is embedded, but not the actual account data. The following HQL query: </p><pre class="programlisting">from Customer c left join fetch c.accounts where c.lastName like :lastName</pre><p>would return datasets such as this: </p><pre class="programlisting">&lt;customer id="123456789"&gt;
    &lt;account short-desc="Savings"&gt;987632567&lt;/account&gt;
    &lt;account short-desc="Credit Card"&gt;985612323&lt;/account&gt;
    &lt;name&gt;
        &lt;first-name&gt;Gavin&lt;/first-name&gt;
        &lt;initial&gt;A&lt;/initial&gt;
        &lt;last-name&gt;King&lt;/last-name&gt;
    &lt;/name&gt;
    ...
&lt;/customer&gt;</pre><p>Si vous positionnez <code class="literal">embed-xml="true"</code> sur le mapping <code class="literal">&lt;one-to-many&gt;</code>, les données pourraient ressembler plus à ça : </p><pre class="programlisting">&lt;customer id="123456789"&gt;
    &lt;account id="987632567" short-desc="Savings"&gt;
        &lt;customer id="123456789"/&gt;
        &lt;balance&gt;100.29&lt;/balance&gt;
    &lt;/account&gt;
    &lt;account id="985612323" short-desc="Credit Card"&gt;
        &lt;customer id="123456789"/&gt;
        &lt;balance&gt;-2370.34&lt;/balance&gt;
    &lt;/account&gt;
    &lt;name&gt;
        &lt;first-name&gt;Gavin&lt;/first-name&gt;
        &lt;initial&gt;A&lt;/initial&gt;
        &lt;last-name&gt;King&lt;/last-name&gt;
    &lt;/name&gt;
    ...
&lt;/customer&gt;</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="xml-manipulation"/>18.3. Manipuler des données XML</h2></div></div></div><p>You can also re-read and update XML documents in the application. You can do this by obtaining a dom4j session: </p><pre class="programlisting">Document doc = ....;
       
Session session = factory.openSession();
Session dom4jSession = session.getSession(EntityMode.DOM4J);
Transaction tx = session.beginTransaction();

List results = dom4jSession
    .createQuery("from Customer c left join fetch c.accounts where c.lastName like :lastName")
    .list();
for ( int i=0; i&lt;results.size(); i++ ) {
    //add the customer data to the XML document
    Element customer = (Element) results.get(i);
    doc.add(customer);
}

tx.commit();
session.close();</pre><pre class="programlisting">Session session = factory.openSession();
Session dom4jSession = session.getSession(EntityMode.DOM4J);
Transaction tx = session.beginTransaction();

Element cust = (Element) dom4jSession.get("Customer", customerId);
for ( int i=0; i&lt;results.size(); i++ ) {
    Element customer = (Element) results.get(i);
    //change the customer name in the XML and database
    Element name = customer.element("name");
    name.element("first-name").setText(firstName);
    name.element("initial").setText(initial);
    name.element("last-name").setText(lastName);
}

tx.commit();
session.close();</pre><p>When implementing XML-based data import/export, it is useful to combine this feature with Hibernate's <code class="literal">replicate()</code> operation. </p></div></div><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="performance"/>Chapitre 19. Améliorer les performances</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#performance-fetching">19.1. Stratégies de chargement</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-fetching-lazy">19.1.1. Travailler avec des associations chargées tardivement</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-custom">19.1.2. Personnalisation des stratégies de chargement</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-proxies">19.1.3. Proxys pour des associations vers un seul objet</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-initialization">19.1.4. Initialisation des collections et des proxys</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-batch">19.1.5. Utiliser le chargement par lot</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-subselect">19.1.6. Utilisation du chargement par sous select</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-lazyproperties">19.1.7. Utiliser le chargement tardif des propriétés</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-cache">19.2. Le cache de second niveau</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-cache-mapping">19.2.1. Mapping de Cache</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readonly">19.2.2. Strategie : lecture seule</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readwrite">19.2.3. Stratégie : lecture/écriture</a></span></dt><dt><span class="sect2"><a href="#performance-cache-nonstrict">19.2.4. Stratégie : lecture/écriture non stricte</a></span></dt><dt><span class="sect2"><a href="#performance-cache-transactional">19.2.5. Stratégie : transactionelle</a></span></dt><dt><span class="sect2"><a href="#performance-cache-compat-matrix">19.2.6. Cache-provider/concurrency-strategy compatibility</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-sessioncache">19.3. Gérer les caches</a></span></dt><dt><span class="sect1"><a href="#performance-querycache">19.4. Le cache de requêtes</a></span></dt><dt><span class="sect1"><a href="#performance-collections">19.5. Comprendre les performances des Collections</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-collections-taxonomy">19.5.1. Classification</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficientupdate">19.5.2. Les lists, les maps, les idbags et les sets sont les collections les plus efficaces pour la mise à jour</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficentinverse">19.5.3. Les Bags et les lists sont les plus efficaces pour les collections inverse</a></span></dt><dt><span class="sect2"><a href="#performance-collections-oneshotdelete">19.5.4. Suppression en un coup</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-monitoring">19.6. Moniteur de performance</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-monitoring-sf">19.6.1. Suivi d'une SessionFactory</a></span></dt><dt><span class="sect2"><a href="#performance-monitoring-metrics">19.6.2. Métriques</a></span></dt></dl></dd></dl></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-fetching"/>19.1. Stratégies de chargement</h2></div></div></div><p>Hibernate uses a <span class="emphasis"><em>fetching strategy</em></span> to retrieve associated objects if the application needs to navigate the association. Fetch strategies can be declared in the O/R mapping metadata, or over-ridden by a particular HQL or <code class="literal">Criteria</code> query. </p><p>Hibernate3 définit les stratégies de chargement suivantes : </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Join fetching</em></span>: Hibernate retrieves the associated instance or collection in the same <code class="literal">SELECT</code>, using an <code class="literal">OUTER JOIN</code>. </p></li><li><p><span class="emphasis"><em>Select fetching</em></span>: a second <code class="literal">SELECT</code> is used to retrieve the associated entity or collection. Unless you explicitly disable lazy fetching by specifying <code class="literal">lazy="false"</code>, this second select will only be executed when you access the association. </p></li><li><p><span class="emphasis"><em>Subselect fetching</em></span>: a second <code class="literal">SELECT</code> is used to retrieve the associated collections for all entities retrieved in a previous query or fetch. Unless you explicitly disable lazy fetching by specifying <code class="literal">lazy="false"</code>, this second select will only be executed when you access the association. </p></li><li><p><span class="emphasis"><em>Batch fetching</em></span>: an optimization strategy for select fetching. Hibernate retrieves a batch of entity instances or collections in a single <code class="literal">SELECT</code> by specifying a list of primary or foreign keys. </p></li></ul></div><p>Hibernate fait également la distinction entre : </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Immediate fetching</em></span>: an association, collection or attribute is fetched immediately when the owner is loaded. </p></li><li><p><span class="emphasis"><em>Lazy collection fetching</em></span>: a collection is fetched when the application invokes an operation upon that collection. This is the default for collections. </p></li><li><p><span class="emphasis"><em>"Extra-lazy" collection fetching</em></span>: individual elements of the collection are accessed from the database as needed. Hibernate tries not to fetch the whole collection into memory unless absolutely needed. It is suitable for large collections. </p></li><li><p><span class="emphasis"><em>Proxy fetching</em></span>: a single-valued association is fetched when a method other than the identifier getter is invoked upon the associated object. </p></li><li><p><span class="emphasis"><em>"No-proxy" fetching</em></span>: a single-valued association is fetched when the instance variable is accessed. Compared to proxy fetching, this approach is less lazy; the association is fetched even when only the identifier is accessed. It is also more transparent, since no proxy is visible to the application. This approach requires buildtime bytecode instrumentation and is rarely necessary. </p></li><li><p><span class="emphasis"><em>Lazy attribute fetching</em></span>: an attribute or single valued association is fetched when the instance variable is accessed. This approach requires buildtime bytecode instrumentation and is rarely necessary. </p></li></ul></div><p>We have two orthogonal notions here: <span class="emphasis"><em>when</em></span> is the association fetched and <span class="emphasis"><em>how</em></span> is it fetched. It is important that you do not confuse them. We use <code class="literal">fetch</code> to tune performance. We can use <code class="literal">lazy</code> to define a contract for what data is always available in any detached instance of a particular class. </p><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-lazy"/>19.1.1. Travailler avec des associations chargées tardivement</h3></div></div></div><p>By default, Hibernate3 uses lazy select fetching for collections and lazy proxy fetching for single-valued associations. These defaults make sense for most associations in the majority of applications. </p><p>If you set <code class="literal">hibernate.default_batch_fetch_size</code>, Hibernate will use the batch fetch optimization for lazy fetching. This optimization can also be enabled at a more granular level. </p><p>Please be aware that access to a lazy association outside of the context of an open Hibernate session will result in an exception. For example: </p><pre class="programlisting">s = sessions.openSession();
Transaction tx = s.beginTransaction();
            
User u = (User) s.createQuery("from User u where u.name=:userName")
    .setString("userName", userName).uniqueResult();
Map permissions = u.getPermissions();

tx.commit();
s.close();

Integer accessLevel = (Integer) permissions.get("accounts");  // Error!</pre><p>Since the permissions collection was not initialized when the <code class="literal">Session</code> was closed, the collection will not be able to load its state. <span class="emphasis"><em>Hibernate does not support lazy initialization for detached objects</em></span>. This can be fixed by moving the code that reads from the collection to just before the transaction is committed. </p><p>Alternatively, you can use a non-lazy collection or association, by specifying <code class="literal">lazy="false"</code> for the association mapping. However, it is intended that lazy initialization be used for almost all collections and associations. If you define too many non-lazy associations in your object model, Hibernate will fetch the entire database into memory in every transaction. </p><p>On the other hand, you can use join fetching, which is non-lazy by nature, instead of select fetching in a particular transaction. We will now explain how to customize the fetching strategy. In Hibernate3, the mechanisms for choosing a fetch strategy are identical for single-valued associations and collections. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-custom"/>19.1.2. Personnalisation des stratégies de chargement</h3></div></div></div><p>Le chargement par select (mode par défaut) est très vulnérable au problème du N+1 selects, du coup vous pouvez avoir envie d'activer le chargement par jointure dans les fichiers de mapping : </p><pre class="programlisting">&lt;set name="permissions" 
            fetch="join"&gt;
    &lt;key column="userId"/&gt;
    &lt;one-to-many class="Permission"/&gt;
&lt;/set</pre><pre class="programlisting">&lt;many-to-one name="mother" class="Cat" fetch="join"/&gt;</pre><p>La stratégie de chargement définie à l'aide du mot <code class="literal">fetch</code> dans les fichiers de mapping affecte : </p><div class="itemizedlist"><ul><li><p>La récupération via <code class="literal">get()</code> ou <code class="literal">load()</code> </p></li><li><p>La récupération implicite lorsque l'on navigue à travers une association </p></li><li><p>Les requêtes de type <code class="literal">Criteria</code> </p></li><li><p>Les requêtes HQL si l'on utilise le chargement par <code class="literal">subselect</code> </p></li></ul></div><p>Irrespective of the fetching strategy you use, the defined non-lazy graph is guaranteed to be loaded into memory. This might, however, result in several immediate selects being used to execute a particular HQL query. </p><p>Usually, the mapping document is not used to customize fetching. Instead, we keep the default behavior, and override it for a particular transaction, using <code class="literal">left join fetch</code> in HQL. This tells Hibernate to fetch the association eagerly in the first select, using an outer join. In the <code class="literal">Criteria</code> query API, you would use <code class="literal">setFetchMode(FetchMode.JOIN)</code>. </p><p>If you want to change the fetching strategy used by <code class="literal">get()</code> or <code class="literal">load()</code>, you can use a <code class="literal">Criteria</code> query. For example: </p><pre class="programlisting">User user = (User) session.createCriteria(User.class)
                .setFetchMode("permissions", FetchMode.JOIN)
                .add( Restrictions.idEq(userId) )
                .uniqueResult();</pre><p>This is Hibernate's equivalent of what some ORM solutions call a "fetch plan". </p><p>A completely different approach to problems with N+1 selects is to use the second-level cache. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-proxies"/>19.1.3. Proxys pour des associations vers un seul objet</h3></div></div></div><p>Lazy fetching for collections is implemented using Hibernate's own implementation of persistent collections. However, a different mechanism is needed for lazy behavior in single-ended associations. The target entity of the association must be proxied. Hibernate implements lazy initializing proxies for persistent objects using runtime bytecode enhancement which is accessed via the CGLIB library. </p><p>At startup, Hibernate3 generates proxies by default for all persistent classes and uses them to enable lazy fetching of <code class="literal">many-to-one</code> and <code class="literal">one-to-one</code> associations. </p><p>The mapping file may declare an interface to use as the proxy interface for that class, with the <code class="literal">proxy</code> attribute. By default, Hibernate uses a subclass of the class. <span class="emphasis"><em>The proxied class must implement a default constructor with at least package visibility. This constructor is recommended for all persistent classes</em></span>. </p><p>There are potential problems to note when extending this approach to polymorphic classes.For example: </p><pre class="programlisting">&lt;class name="Cat" proxy="Cat"&gt;
    ......
    &lt;subclass name="DomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>Tout d'abord, les instances de <code class="literal">Cat</code> ne pourront jamais être "castées" en <code class="literal">DomesticCat</code>, même si l'instance sous jacente est une instance de <code class="literal">DomesticCat</code> : </p><pre class="programlisting">Cat cat = (Cat) session.load(Cat.class, id);  // instantiate a proxy (does not hit the db)
if ( cat.isDomesticCat() ) {                  // hit the db to initialize the proxy
    DomesticCat dc = (DomesticCat) cat;       // Error!
    ....
}</pre><p>Secondly, it is possible to break proxy <code class="literal">==</code>: </p><pre class="programlisting">Cat cat = (Cat) session.load(Cat.class, id);            // instantiate a Cat proxy
DomesticCat dc = 
        (DomesticCat) session.load(DomesticCat.class, id);  // acquire new DomesticCat proxy!
System.out.println(cat==dc);                            // false</pre><p>Cette situation n'est pas si mauvaise qu'il n'y parait. Même si nous avons deux références à deux objets proxys différents, l'instance de base sera quand même le même objet : </p><pre class="programlisting">cat.setWeight(11.0);  // hit the db to initialize the proxy
System.out.println( dc.getWeight() );  // 11.0</pre><p>Third, you cannot use a CGLIB proxy for a <code class="literal">final</code> class or a class with any <code class="literal">final</code> methods. </p><p>Finally, if your persistent object acquires any resources upon instantiation (e.g. in initializers or default constructor), then those resources will also be acquired by the proxy. The proxy class is an actual subclass of the persistent class. </p><p>These problems are all due to fundamental limitations in Java's single inheritance model. To avoid these problems your persistent classes must each implement an interface that declares its business methods. You should specify these interfaces in the mapping file where <code class="literal">CatImpl</code> implements the interface <code class="literal">Cat</code> and <code class="literal">DomesticCatImpl</code> implements the interface <code class="literal">DomesticCat</code>. For example: </p><pre class="programlisting">&lt;class name="CatImpl" proxy="Cat"&gt;
    ......
    &lt;subclass name="DomesticCatImpl" proxy="DomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>Then proxies for instances of <code class="literal">Cat</code> and <code class="literal">DomesticCat</code> can be returned by <code class="literal">load()</code> or <code class="literal">iterate()</code>. </p><pre class="programlisting">Cat cat = (Cat) session.load(CatImpl.class, catid);
Iterator iter = session.createQuery("from CatImpl as cat where cat.name='fritz'").iterate();
Cat fritz = (Cat) iter.next();</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p><code class="literal">list()</code> does not usually return proxies. </p></div><p>Les relations sont aussi initialisées tardivement. Ceci signifie que vous devez déclarer chaque propriété comme étant de type <code class="literal">Cat</code>, et non <code class="literal">CatImpl</code>. </p><p>Certain operations do <span class="emphasis"><em>not</em></span> require proxy initialization: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">equals()</code>: if the persistent class does not override <code class="literal">equals()</code> </p></li><li><p><code class="literal">hashCode()</code>: if the persistent class does not override <code class="literal">hashCode()</code> </p></li><li><p>Le getter de l'identifiant </p></li></ul></div><p>Hibernate détectera les classes qui surchargent <code class="literal">equals()</code> ou <code class="literal">hashCode()</code>. </p><p>By choosing <code class="literal">lazy="no-proxy"</code> instead of the default <code class="literal">lazy="proxy"</code>, you can avoid problems associated with typecasting. However, buildtime bytecode instrumentation is required, and all operations will result in immediate proxy initialization. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-initialization"/>19.1.4. Initialisation des collections et des proxys</h3></div></div></div><p>A <code class="literal">LazyInitializationException</code> will be thrown by Hibernate if an uninitialized collection or proxy is accessed outside of the scope of the <code class="literal">Session</code>, i.e., when the entity owning the collection or having the reference to the proxy is in the detached state. </p><p>Sometimes a proxy or collection needs to be initialized before closing the <code class="literal">Session</code>. You can force initialization by calling <code class="literal">cat.getSex()</code> or <code class="literal">cat.getKittens().size()</code>, for example. However, this can be confusing to readers of the code and it is not convenient for generic code. </p><p>The static methods <code class="literal">Hibernate.initialize()</code> and <code class="literal">Hibernate.isInitialized()</code>, provide the application with a convenient way of working with lazily initialized collections or proxies. <code class="literal">Hibernate.initialize(cat)</code> will force the initialization of a proxy, <code class="literal">cat</code>, as long as its <code class="literal">Session</code> is still open. <code class="literal">Hibernate.initialize( cat.getKittens() )</code> has a similar effect for the collection of kittens. </p><p>Another option is to keep the <code class="literal">Session</code> open until all required collections and proxies have been loaded. In some application architectures, particularly where the code that accesses data using Hibernate, and the code that uses it are in different application layers or different physical processes, it can be a problem to ensure that the <code class="literal">Session</code> is open when a collection is initialized. There are two basic ways to deal with this issue: </p><div class="itemizedlist"><ul><li><p>In a web-based application, a servlet filter can be used to close the <code class="literal">Session</code> only at the end of a user request, once the rendering of the view is complete (the <span class="emphasis"><em>Open Session in View</em></span> pattern). Of course, this places heavy demands on the correctness of the exception handling of your application infrastructure. It is vitally important that the <code class="literal">Session</code> is closed and the transaction ended before returning to the user, even when an exception occurs during rendering of the view. See the Hibernate Wiki for examples of this "Open Session in View" pattern. </p></li><li><p>In an application with a separate business tier, the business logic must "prepare" all collections that the web tier needs before returning. This means that the business tier should load all the data and return all the data already initialized to the presentation/web tier that is required for a particular use case. Usually, the application calls <code class="literal">Hibernate.initialize()</code> for each collection that will be needed in the web tier (this call must occur before the session is closed) or retrieves the collection eagerly using a Hibernate query with a <code class="literal">FETCH</code> clause or a <code class="literal">FetchMode.JOIN</code> in <code class="literal">Criteria</code>. This is usually easier if you adopt the <span class="emphasis"><em>Command</em></span> pattern instead of a <span class="emphasis"><em>Session Facade</em></span>. </p></li><li><p>You can also attach a previously loaded object to a new <code class="literal">Session</code> with <code class="literal">merge()</code> or <code class="literal">lock()</code> before accessing uninitialized collections or other proxies. Hibernate does not, and certainly <span class="emphasis"><em>should</em></span> not, do this automatically since it would introduce impromptu transaction semantics. </p></li></ul></div><p>Sometimes you do not want to initialize a large collection, but still need some information about it, like its size, for example, or a subset of the data. </p><p>Vous pouvez utiliser un filtre de collection pour récupérer sa taille sans l'initialiser : </p><pre class="programlisting">( (Integer) s.createFilter( collection, "select count(*)" ).list().get(0) ).intValue()</pre><p>La méthode <code class="literal">createFilter()</code> est également utilisée pour récupérer de manière efficace des sous ensembles d'une collection sans avoir besoin de l'initialiser dans son ensemble. </p><pre class="programlisting">s.createFilter( lazyCollection, "").setFirstResult(0).setMaxResults(10).list();</pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-batch"/>19.1.5. Utiliser le chargement par lot</h3></div></div></div><p>Using batch fetching, Hibernate can load several uninitialized proxies if one proxy is accessed. Batch fetching is an optimization of the lazy select fetching strategy. There are two ways you can configure batch fetching: on the class level and the collection level. </p><p>Batch fetching for classes/entities is easier to understand. Consider the following example: at runtime you have 25 <code class="literal">Cat</code> instances loaded in a <code class="literal">Session</code>, and each <code class="literal">Cat</code> has a reference to its <code class="literal">owner</code>, a <code class="literal">Person</code>. The <code class="literal">Person</code> class is mapped with a proxy, <code class="literal">lazy="true"</code>. If you now iterate through all cats and call <code class="literal">getOwner()</code> on each, Hibernate will, by default, execute 25 <code class="literal">SELECT</code> statements to retrieve the proxied owners. You can tune this behavior by specifying a <code class="literal">batch-size</code> in the mapping of <code class="literal">Person</code>: </p><pre class="programlisting">&lt;class name="Person" batch-size="10"&gt;...&lt;/class&gt;</pre><p>Hibernate will now execute only three queries: the pattern is 10, 10, 5. </p><p>You can also enable batch fetching of collections. For example, if each <code class="literal">Person</code> has a lazy collection of <code class="literal">Cat</code>s, and 10 persons are currently loaded in the <code class="literal">Session</code>, iterating through all persons will generate 10 <code class="literal">SELECT</code>s, one for every call to <code class="literal">getCats()</code>. If you enable batch fetching for the <code class="literal">cats</code> collection in the mapping of <code class="literal">Person</code>, Hibernate can pre-fetch collections: </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;set name="cats" batch-size="3"&gt;
        ...
    &lt;/set&gt;
&lt;/class&gt;</pre><p>Avec une taille de lot (<code class="literal">batch-size</code>) de 3, Hibernate chargera respectivement 3, 3, 3, et 1 collections en quatre <code class="literal">SELECT</code>s. Encore une fois, la valeur de l'attribut dépend du nombre de collections non initialisées dans une <code class="literal">Session</code> particulière. </p><p>Batch fetching of collections is particularly useful if you have a nested tree of items, i.e. the typical bill-of-materials pattern. However, a <span class="emphasis"><em>nested set</em></span> or a <span class="emphasis"><em>materialized path</em></span> might be a better option for read-mostly trees. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-subselect"/>19.1.6. Utilisation du chargement par sous select</h3></div></div></div><p>If one lazy collection or single-valued proxy has to be fetched, Hibernate will load all of them, re-running the original query in a subselect. This works in the same way as batch-fetching but without the piecemeal loading. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-lazyproperties"/>19.1.7. Utiliser le chargement tardif des propriétés</h3></div></div></div><p>Hibernate3 supports the lazy fetching of individual properties. This optimization technique is also known as <span class="emphasis"><em>fetch groups</em></span>. Please note that this is mostly a marketing feature; optimizing row reads is much more important than optimization of column reads. However, only loading some properties of a class could be useful in extreme cases. For example, when legacy tables have hundreds of columns and the data model cannot be improved. </p><p>Pour activer le chargement tardif d'une propriété, il faut mettre l'attribut <code class="literal">lazy</code> sur une propriété particulière du mapping : </p><pre class="programlisting">&lt;class name="Document"&gt;
       &lt;id name="id"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true" length="50"/&gt;
    &lt;property name="summary" not-null="true" length="200" lazy="true"/&gt;
    &lt;property name="text" not-null="true" length="2000" lazy="true"/&gt;
&lt;/class&gt;</pre><p>Lazy property loading requires buildtime bytecode instrumentation. If your persistent classes are not enhanced, Hibernate will ignore lazy property settings and return to immediate fetching. </p><p>Pour l'instrumentation du bytecode vous pouvez utiliser la tâche Ant suivante : </p><pre class="programlisting">&lt;target name="instrument" depends="compile"&gt;
    &lt;taskdef name="instrument" classname="org.hibernate.tool.instrument.InstrumentTask"&gt;
        &lt;classpath path="${jar.path}"/&gt;
        &lt;classpath path="${classes.dir}"/&gt;
        &lt;classpath refid="lib.class.path"/&gt;
    &lt;/taskdef&gt;

    &lt;instrument verbose="true"&gt;
        &lt;fileset dir="${testclasses.dir}/org/hibernate/auction/model"&gt;
            &lt;include name="*.class"/&gt;
        &lt;/fileset&gt;
    &lt;/instrument&gt;
&lt;/target&gt;</pre><p>A different way of avoiding unnecessary column reads, at least for read-only transactions, is to use the projection features of HQL or Criteria queries. This avoids the need for buildtime bytecode processing and is certainly a preferred solution. </p><p>You can force the usual eager fetching of properties using <code class="literal">fetch all properties</code> in HQL. </p></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-cache"/>19.2. Le cache de second niveau</h2></div></div></div><p>A Hibernate <code class="literal">Session</code> is a transaction-level cache of persistent data. It is possible to configure a cluster or JVM-level (<code class="literal">SessionFactory</code>-level) cache on a class-by-class and collection-by-collection basis. You can even plug in a clustered cache. Be aware that caches are not aware of changes made to the persistent store by another application. They can, however, be configured to regularly expire cached data. </p><p>You have the option to tell Hibernate which caching implementation to use by specifying the name of a class that implements <code class="literal">org.hibernate.cache.CacheProvider</code> using the property <code class="literal">hibernate.cache.provider_class</code>. Hibernate is bundled with a number of built-in integrations with the open-source cache providers that are listed below. You can also implement your own and plug it in as outlined above. Note that versions prior to 3.2 use EhCache as the default cache provider. </p><div class="table"><a id="cacheproviders"/><p class="title"><b>Tableau 19.1. Fournisseur de cache</b></p><div class="table-contents"><table summary="Fournisseur de cache" border="1"><colgroup><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/></colgroup><thead><tr><th align="left">Cache</th><th align="left">Classe pourvoyeuse</th><th align="left">Type</th><th align="left">Support en Cluster</th><th align="left">Cache de requêtes supporté</th></tr></thead><tbody><tr><td align="left">Hashtable (not intended for production use)</td><td align="left"><code class="literal">org.hibernate.cache.HashtableCacheProvider</code></td><td align="left">mémoire</td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">EHCache</td><td align="left"><code class="literal">org.hibernate.cache.EhCacheProvider</code></td><td align="left">mémoire, disque</td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">OSCache</td><td align="left"><code class="literal">org.hibernate.cache.OSCacheProvider</code></td><td align="left">mémoire, disque</td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">SwarmCache</td><td align="left"><code class="literal">org.hibernate.cache.SwarmCacheProvider</code></td><td align="left">en cluster (multicast ip)</td><td align="left">oui (invalidation de cluster)</td><td align="left"> </td></tr><tr><td align="left">JBoss Cache 1.x</td><td align="left"><code class="literal">org.hibernate.cache.TreeCacheProvider</code></td><td align="left">en cluster (multicast ip), transactionnel</td><td align="left">oui (replication)</td><td align="left">oui (horloge sync. nécessaire)</td></tr><tr><td align="left">JBoss Cache 2</td><td align="left"><code class="literal">org.hibernate.cache.jbc2.JBossCacheRegionFactory</code></td><td align="left">en cluster (multicast ip), transactionnel</td><td align="left">yes (replication or invalidation)</td><td align="left">oui (horloge sync. nécessaire)</td></tr></tbody></table></div></div><br class="table-break"/><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-mapping"/>19.2.1. Mapping de Cache</h3></div></div></div><p>L'élément <code class="literal">&lt;cache&gt;</code> d'une classe ou d'une collection à la forme suivante : </p><div class="programlistingco"><pre class="programlisting">&lt;cache 
    usage="transactional|read-write|nonstrict-read-write|read-only"  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
    region="RegionName"                                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
    include="all|non-lazy"                                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">usage</code> (requis) spécifie la stratégie de cache : <code class="literal">transactionel</code>, <code class="literal">lecture-écriture</code>, <code class="literal">lecture-écriture non stricte</code> ou <code class="literal">lecture seule</code> </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">region</code> (optional: defaults to the class or collection role name): specifies the name of the second level cache region </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">include</code> (optional: defaults to <code class="literal">all</code>) <code class="literal">non-lazy</code>: specifies that properties of the entity mapped with <code class="literal">lazy="true"</code> cannot be cached when attribute-level lazy fetching is enabled </p></td></tr></table></div></div><p>Alternatively, you can specify <code class="literal">&lt;class-cache&gt;</code> and <code class="literal">&lt;collection-cache&gt;</code> elements in <code class="literal">hibernate.cfg.xml</code>. </p><p>L'attribut <code class="literal">usage</code> spécifie une <span class="emphasis"><em>stratégie de concurrence d'accès au cache</em></span>. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-readonly"/>19.2.2. Strategie : lecture seule</h3></div></div></div><p>If your application needs to read, but not modify, instances of a persistent class, a <code class="literal">read-only</code> cache can be used. This is the simplest and optimal performing strategy. It is even safe for use in a cluster. </p><pre class="programlisting">&lt;class name="eg.Immutable" mutable="false"&gt;
    &lt;cache usage="read-only"/&gt;
    ....
&lt;/class&gt;</pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-readwrite"/>19.2.3. Stratégie : lecture/écriture</h3></div></div></div><p>If the application needs to update data, a <code class="literal">read-write</code> cache might be appropriate. This cache strategy should never be used if serializable transaction isolation level is required. If the cache is used in a JTA environment, you must specify the property <code class="literal">hibernate.transaction.manager_lookup_class</code> and naming a strategy for obtaining the JTA <code class="literal">TransactionManager</code>. In other environments, you should ensure that the transaction is completed when <code class="literal">Session.close()</code> or <code class="literal">Session.disconnect()</code> is called. If you want to use this strategy in a cluster, you should ensure that the underlying cache implementation supports locking. The built-in cache providers <span class="emphasis"><em>do not</em></span> support locking. </p><pre class="programlisting">&lt;class name="eg.Cat" .... &gt;
    &lt;cache usage="read-write"/&gt;
    ....
    &lt;set name="kittens" ... &gt;
        &lt;cache usage="read-write"/&gt;
        ....
    &lt;/set&gt;
&lt;/class&gt;</pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-nonstrict"/>19.2.4. Stratégie : lecture/écriture non stricte</h3></div></div></div><p>If the application only occasionally needs to update data (i.e. if it is extremely unlikely that two transactions would try to update the same item simultaneously), and strict transaction isolation is not required, a <code class="literal">nonstrict-read-write</code> cache might be appropriate. If the cache is used in a JTA environment, you must specify <code class="literal">hibernate.transaction.manager_lookup_class</code>. In other environments, you should ensure that the transaction is completed when <code class="literal">Session.close()</code> or <code class="literal">Session.disconnect()</code> is called. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-transactional"/>19.2.5. Stratégie : transactionelle</h3></div></div></div><p>The <code class="literal">transactional</code> cache strategy provides support for fully transactional cache providers such as JBoss TreeCache. Such a cache can only be used in a JTA environment and you must specify <code class="literal">hibernate.transaction.manager_lookup_class</code>. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-compat-matrix"/>19.2.6. Cache-provider/concurrency-strategy compatibility</h3></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>None of the cache providers support all of the cache concurrency strategies. </p></div><p>The following table shows which providers are compatible with which concurrency strategies. </p><div class="table"><a id="d0e14967"/><p class="title"><b>Tableau 19.2. Stratégie de concurrence du cache</b></p><div class="table-contents"><table summary="Stratégie de concurrence du cache" border="1"><colgroup><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/></colgroup><thead><tr><th align="left">Cache</th><th align="left">read-only (lecture seule)</th><th align="left">nonstrict-read-write (lecture-écriture non stricte)</th><th align="left">read-write (lecture-ériture)</th><th align="left">transactional (transactionnel)</th></tr></thead><tbody><tr><td align="left">Hashtable (not intended for production use)</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td></tr><tr><td align="left">EHCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td></tr><tr><td align="left">OSCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td></tr><tr><td align="left">SwarmCache</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">JBoss Cache 1.x</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">JBoss Cache 2</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td><td align="left">yes</td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-sessioncache"/>19.3. Gérer les caches</h2></div></div></div><p>Whenever you pass an object to <code class="literal">save()</code>, <code class="literal">update()</code> or <code class="literal">saveOrUpdate()</code>, and whenever you retrieve an object using <code class="literal">load()</code>, <code class="literal">get()</code>, <code class="literal">list()</code>, <code class="literal">iterate()</code> or <code class="literal">scroll()</code>, that object is added to the internal cache of the <code class="literal">Session</code>. </p><p>When <code class="literal">flush()</code> is subsequently called, the state of that object will be synchronized with the database. If you do not want this synchronization to occur, or if you are processing a huge number of objects and need to manage memory efficiently, the <code class="literal">evict()</code> method can be used to remove the object and its collections from the first-level cache. </p><pre class="programlisting">ScrollableResult cats = sess.createQuery("from Cat as cat").scroll(); //a huge result set
while ( cats.next() ) {
    Cat cat = (Cat) cats.get(0);
    doSomethingWithACat(cat);
    sess.evict(cat);
}</pre><p>La <code class="literal">Session</code> dispose aussi de la méthode <code class="literal">contains()</code> pour déterminer si une instance appartient au cache de la session. </p><p>To evict all objects from the session cache, call <code class="literal">Session.clear()</code> </p><p>Pour le cache de second niveau, il existe des méthodes définies dans <code class="literal">SessionFactory</code> pour retirer des instances du cache, la classe entière, une instance de collection ou le rôle entier d'une collection. </p><pre class="programlisting">sessionFactory.evict(Cat.class, catId); //evict a particular Cat
sessionFactory.evict(Cat.class);  //evict all Cats
sessionFactory.evictCollection("Cat.kittens", catId); //evict a particular collection of kittens
sessionFactory.evictCollection("Cat.kittens"); //evict all kitten collections</pre><p>The <code class="literal">CacheMode</code> controls how a particular session interacts with the second-level cache: </p><div class="itemizedlist"><ul><li><p><code class="literal">CacheMode.NORMAL</code>: will read items from and write items to the second-level cache </p></li><li><p><code class="literal">CacheMode.GET</code>: will read items from the second-level cache. Do not write to the second-level cache except when updating data </p></li><li><p><code class="literal">CacheMode.PUT</code>: will write items to the second-level cache. Do not read from the second-level cache </p></li><li><p><code class="literal">CacheMode.REFRESH</code>: will write items to the second-level cache. Do not read from the second-level cache. Bypass the effect of <code class="literal">hibernate.cache.use_minimal_puts</code> forcing a refresh of the second-level cache for all items read from the database </p></li></ul></div><p>Pour parcourir le contenu du cache de second niveau ou la région du cache dédiée au requêtes, vous pouvez utiliser l'API <code class="literal">Statistics</code> API: </p><pre class="programlisting">Map cacheEntries = sessionFactory.getStatistics()
        .getSecondLevelCacheStatistics(regionName)
        .getEntries();</pre><p>You will need to enable statistics and, optionally, force Hibernate to keep the cache entries in a more readable format: </p><pre class="programlisting">hibernate.generate_statistics true
hibernate.cache.use_structured_entries true</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-querycache"/>19.4. Le cache de requêtes</h2></div></div></div><p>Query result sets can also be cached. This is only useful for queries that are run frequently with the same parameters. You will first need to enable the query cache: </p><pre class="programlisting">hibernate.cache.use_query_cache true</pre><p>This setting creates two new cache regions: one holding cached query result sets (<code class="literal">org.hibernate.cache.StandardQueryCache</code>), the other holding timestamps of the most recent updates to queryable tables (<code class="literal">org.hibernate.cache.UpdateTimestampsCache</code>). Note that the query cache does not cache the state of the actual entities in the result set; it caches only identifier values and results of value type. The query cache should always be used in conjunction with the second-level cache. </p><p>Most queries do not benefit from caching, so by default, queries are not cached. To enable caching, call <code class="literal">Query.setCacheable(true)</code>. This call allows the query to look for existing cache results or add its results to the cache when it is executed. </p><p>If you require fine-grained control over query cache expiration policies, you can specify a named cache region for a particular query by calling <code class="literal">Query.setCacheRegion()</code>. </p><pre class="programlisting">List blogs = sess.createQuery("from Blog blog where blog.blogger = :blogger")
    .setEntity("blogger", blogger)
    .setMaxResults(15)
    .setCacheable(true)
    .setCacheRegion("frontpages")
    .list();</pre><p>Si une requête doit forcer le rafraîchissement de sa région de cache, vous devez appeler <code class="literal">Query.setCacheMode(CacheMode.REFRESH)</code>. C'est particulièrement utile lorsque les données peuvent avoir été mises à jour par un processus séparé (e.g. elles n'ont pas été modifiées par Hibernate). Cela permet à l'application de rafraîchir de manière sélective les résultats d'une requête particulière. Il s'agit d'une alternative plus efficace à l'éviction d'une région du cache à l'aide de la méthode <code class="literal">SessionFactory.evictQueries()</code>. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-collections"/>19.5. Comprendre les performances des Collections</h2></div></div></div><p>In the previous sections we have covered collections and their applications. In this section we explore some more issues in relation to collections at runtime. </p><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-taxonomy"/>19.5.1. Classification</h3></div></div></div><p>Hibernate définit trois types de collections :</p><div class="itemizedlist"><ul><li><p>les collections de valeurs</p></li><li><p>one-to-many associations</p></li><li><p>many-to-many associations</p></li></ul></div><p>Cette classification distingue les différentes relations entre les tables et les clés étrangères mais ne nous apprend rien de ce que nous devons savoir sur le modèle relationnel. Pour comprendre parfaitement la structure relationnelle et les caractéristiques des performances, nous devons considérer la structure de la clé primaire qui est utilisée par Hibernate pour mettre à jour ou supprimer les éléments des collections. Celà nous amène aux classifications suivantes : </p><div class="itemizedlist"><ul><li><p>collections indexées</p></li><li><p>sets</p></li><li><p>bags</p></li></ul></div><p>All indexed collections (maps, lists, and arrays) have a primary key consisting of the <code class="literal">&lt;key&gt;</code> and <code class="literal">&lt;index&gt;</code> columns. In this case, collection updates are extremely efficient. The primary key can be efficiently indexed and a particular row can be efficiently located when Hibernate tries to update or delete it. </p><p>Sets have a primary key consisting of <code class="literal">&lt;key&gt;</code> and element columns. This can be less efficient for some types of collection element, particularly composite elements or large text or binary fields, as the database may not be able to index a complex primary key as efficiently. However, for one-to-many or many-to-many associations, particularly in the case of synthetic identifiers, it is likely to be just as efficient. If you want <code class="literal">SchemaExport</code> to actually create the primary key of a <code class="literal">&lt;set&gt;</code>, you must declare all columns as <code class="literal">not-null="true"</code>. </p><p><code class="literal">&lt;idbag&gt;</code> mappings define a surrogate key, so they are efficient to update. In fact, they are the best case. </p><p>Bags are the worst case since they permit duplicate element values and, as they have no index column, no primary key can be defined. Hibernate has no way of distinguishing between duplicate rows. Hibernate resolves this problem by completely removing in a single <code class="literal">DELETE</code> and recreating the collection whenever it changes. This can be inefficient. </p><p>For a one-to-many association, the "primary key" may not be the physical primary key of the database table. Even in this case, the above classification is still useful. It reflects how Hibernate "locates" individual rows of the collection. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-mostefficientupdate"/>19.5.2. Les lists, les maps, les idbags et les sets sont les collections les plus efficaces pour la mise à jour</h3></div></div></div><p>From the discussion above, it should be clear that indexed collections and sets allow the most efficient operation in terms of adding, removing and updating elements. </p><p>There is, arguably, one more advantage that indexed collections have over sets for many-to-many associations or collections of values. Because of the structure of a <code class="literal">Set</code>, Hibernate does not <code class="literal">UPDATE</code> a row when an element is "changed". Changes to a <code class="literal">Set</code> always work via <code class="literal">INSERT</code> and <code class="literal">DELETE</code> of individual rows. Once again, this consideration does not apply to one-to-many associations. </p><p>After observing that arrays cannot be lazy, you can conclude that lists, maps and idbags are the most performant (non-inverse) collection types, with sets not far behind. You can expect sets to be the most common kind of collection in Hibernate applications. This is because the "set" semantics are most natural in the relational model. </p><p>However, in well-designed Hibernate domain models, most collections are in fact one-to-many associations with <code class="literal">inverse="true"</code>. For these associations, the update is handled by the many-to-one end of the association, and so considerations of collection update performance simply do not apply. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-mostefficentinverse"/>19.5.3. Les Bags et les lists sont les plus efficaces pour les collections inverse</h3></div></div></div><p>There is a particular case, however, in which bags, and also lists, are much more performant than sets. For a collection with <code class="literal">inverse="true"</code>, the standard bidirectional one-to-many relationship idiom, for example, we can add elements to a bag or list without needing to initialize (fetch) the bag elements. This is because, unlike a <code class="literal">set</code>, <code class="literal">Collection.add()</code> or <code class="literal">Collection.addAll()</code> must always return true for a bag or <code class="literal">List</code>. This can make the following common code much faster: </p><pre class="programlisting">Parent p = (Parent) sess.load(Parent.class, id);
Child c = new Child();
c.setParent(p);
p.getChildren().add(c);  //no need to fetch the collection!
sess.flush();</pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-oneshotdelete"/>19.5.4. Suppression en un coup</h3></div></div></div><p>Deleting collection elements one by one can sometimes be extremely inefficient. Hibernate knows not to do that in the case of an newly-empty collection (if you called <code class="literal">list.clear()</code>, for example). In this case, Hibernate will issue a single <code class="literal">DELETE</code>. </p><p>Suppose you added a single element to a collection of size twenty and then remove two elements. Hibernate will issue one <code class="literal">INSERT</code> statement and two <code class="literal">DELETE</code> statements, unless the collection is a bag. This is certainly desirable. </p><p>Cependant, supposons que nous enlevions dix huit éléments, laissant ainsi deux éléments, puis que nous ajoutions trois nouveaux éléments. Il y a deux moyens de procéder. </p><div class="itemizedlist"><ul><li><p>effacer dix huit enregistrements un à un puis en insérer trois</p></li><li><p>remove the whole collection in one SQL <code class="literal">DELETE</code> and insert all five current elements one by one</p></li></ul></div><p>Hibernate cannot know that the second option is probably quicker. It would probably be undesirable for Hibernate to be that intuitive as such behavior might confuse database triggers, etc. </p><p>Fortunately, you can force this behavior (i.e. the second strategy) at any time by discarding (i.e. dereferencing) the original collection and returning a newly instantiated collection with all the current elements. </p><p>One-shot-delete does not apply to collections mapped <code class="literal">inverse="true"</code>. </p></div></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-monitoring"/>19.6. Moniteur de performance</h2></div></div></div><p>L'optimisation n'est pas d'un grand intérêt sans le suivi et l'accès aux données de performance. Hibernate fournit toute une panoplie de rapport sur ses opérations internes. Les statistiques dans Hibernate sont fournies par <code class="literal">SessionFactory</code>. </p><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-monitoring-sf"/>19.6.1. Suivi d'une SessionFactory</h3></div></div></div><p>Vous pouvez accéder au métriques d'une <code class="literal">SessionFactory</code> de deux manières. La première option est d'appeler <code class="literal">sessionFactory.getStatistics()</code> et de lire ou d'afficher les <code class="literal">Statistics</code> vous même. </p><p>Hibernate can also use JMX to publish metrics if you enable the <code class="literal">StatisticsService</code> MBean. You can enable a single MBean for all your <code class="literal">SessionFactory</code> or one per factory. See the following code for minimalistic configuration examples: </p><pre class="programlisting">// MBean service registration for a specific SessionFactory
Hashtable tb = new Hashtable();
tb.put("type", "statistics");
tb.put("sessionFactory", "myFinancialApp");
ObjectName on = new ObjectName("hibernate", tb); // MBean object name

StatisticsService stats = new StatisticsService(); // MBean implementation
stats.setSessionFactory(sessionFactory); // Bind the stats to a SessionFactory
server.registerMBean(stats, on); // Register the Mbean on the server</pre><pre class="programlisting">// MBean service registration for all SessionFactory's
Hashtable tb = new Hashtable();
tb.put("type", "statistics");
tb.put("sessionFactory", "all");
ObjectName on = new ObjectName("hibernate", tb); // MBean object name

StatisticsService stats = new StatisticsService(); // MBean implementation
server.registerMBean(stats, on); // Register the MBean on the server</pre><p>You can activate and deactivate the monitoring for a <code class="literal">SessionFactory</code>: </p><div class="itemizedlist"><ul><li><p>au moment de la configuration en mettant <code class="literal">hibernate.generate_statistics</code> à <code class="literal">false</code> </p></li></ul></div><div class="itemizedlist"><ul><li><p>à chaud avec <code class="literal">sf.getStatistics().setStatisticsEnabled(true)</code> ou <code class="literal">hibernateStatsBean.setStatisticsEnabled(true)</code> </p></li></ul></div><p>Statistics can be reset programmatically using the <code class="literal">clear()</code> method. A summary can be sent to a logger (info level) using the <code class="literal">logSummary()</code> method. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-monitoring-metrics"/>19.6.2. Métriques</h3></div></div></div><p>Hibernate provides a number of metrics, from basic information to more specialized information that is only relevant in certain scenarios. All available counters are described in the <code class="literal">Statistics</code> interface API, in three categories: </p><div class="itemizedlist"><ul><li><p>Les métriques relatives à l'usage général de la <code class="literal">Session</code> comme le nombre de sessions ouvertes, le nombre de connexions JDBC récupérées, etc... </p></li><li><p>Metrics related to the entities, collections, queries, and caches as a whole (aka global metrics). </p></li><li><p>Les métriques détaillées relatives à une entité, une collection, une requête ou une région de cache particulière. </p></li></ul></div><p>For example, you can check the cache hit, miss, and put ratio of entities, collections and queries, and the average time a query needs. Be aware that the number of milliseconds is subject to approximation in Java. Hibernate is tied to the JVM precision and on some platforms this might only be accurate to 10 seconds. </p><p>Simple getters are used to access the global metrics (i.e. not tied to a particular entity, collection, cache region, etc.). You can access the metrics of a particular entity, collection or cache region through its name, and through its HQL or SQL representation for queries. Please refer to the <code class="literal">Statistics</code>, <code class="literal">EntityStatistics</code>, <code class="literal">CollectionStatistics</code>, <code class="literal">SecondLevelCacheStatistics</code>, and <code class="literal">QueryStatistics</code> API Javadoc for more information. The following code is a simple example: </p><pre class="programlisting">Statistics stats = HibernateUtil.sessionFactory.getStatistics();

double queryCacheHitCount  = stats.getQueryCacheHitCount();
double queryCacheMissCount = stats.getQueryCacheMissCount();
double queryCacheHitRatio =
  queryCacheHitCount / (queryCacheHitCount + queryCacheMissCount);

log.info("Query Hit ratio:" + queryCacheHitRatio);

EntityStatistics entityStats =
  stats.getEntityStatistics( Cat.class.getName() );
long changes =
        entityStats.getInsertCount()
        + entityStats.getUpdateCount()
        + entityStats.getDeleteCount();
log.info(Cat.class.getName() + " changed " + changes + "times"  );</pre><p>You can work on all entities, collections, queries and region caches, by retrieving the list of names of entities, collections, queries and region caches using the following methods: <code class="literal">getQueries()</code>, <code class="literal">getEntityNames()</code>, <code class="literal">getCollectionRoleNames()</code>, and <code class="literal">getSecondLevelCacheRegionNames()</code>. </p></div></div></div><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="toolsetguide"/>Chapitre 20. Guide des outils</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#toolsetguide-s1">20.1. Génération automatique du schéma</a></span></dt><dd><dl><dt><span class="sect2"><a href="#toolsetguide-s1-2">20.1.1. Personnaliser le schéma</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-3">20.1.2. Exécuter l'outil</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-4">20.1.3. Propriétés</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-5">20.1.4. Utiliser Ant</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-6">20.1.5. Mises à jour incrémentales du schéma</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-7">20.1.6. Utiliser Ant pour des mises à jour de schéma par incrément</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-8">20.1.7. Validation du schéma</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-9">20.1.8. Utiliser Ant pour la validation du Schéma</a></span></dt></dl></dd></dl></div><p>Roundtrip engineering with Hibernate is possible using a set of Eclipse plugins, commandline tools, and Ant tasks. </p><p><span class="emphasis"><em>Hibernate Tools</em></span> currently include plugins for the Eclipse IDE as well as Ant tasks for reverse engineering of existing databases: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Mapping Editor:</em></span> an editor for Hibernate XML mapping files that supports auto-completion and syntax highlighting. It also supports semantic auto-completion for class names and property/field names, making it more versatile than a normal XML editor. </p></li><li><p><span class="emphasis"><em>Console:</em></span> the console is a new view in Eclipse. In addition to a tree overview of your console configurations, you are also provided with an interactive view of your persistent classes and their relationships. The console allows you to execute HQL queries against your database and browse the result directly in Eclipse. </p></li><li><p><span class="emphasis"><em>Development Wizards:</em></span> several wizards are provided with the Hibernate Eclipse tools. You can use a wizard to quickly generate Hibernate configuration (cfg.xml) files, or to reverse engineer an existing database schema into POJO source files and Hibernate mapping files. The reverse engineering wizard supports customizable templates. </p></li><li><p>

        </p></li></ul></div><p>Please refer to the <span class="emphasis"><em>Hibernate Tools</em></span> package documentation for more information. </p><p>However, the Hibernate main package comes bundled with an integrated tool : <span class="emphasis"><em>SchemaExport</em></span> aka <code class="literal">hbm2ddl</code>.It can even be used from "inside" Hibernate. </p><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="toolsetguide-s1"/>20.1. Génération automatique du schéma</h2></div></div></div><p>DDL can be generated from your mapping files by a Hibernate utility. The generated schema includes referential integrity constraints, primary and foreign keys, for entity and collection tables. Tables and sequences are also created for mapped identifier generators. </p><p>You <span class="emphasis"><em>must</em></span> specify a SQL <code class="literal">Dialect</code> via the <code class="literal">hibernate.dialect</code> property when using this tool, as DDL is highly vendor-specific. </p><p>First, you must customize your mapping files to improve the generated schema. The next section covers schema customization. </p><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-2"/>20.1.1. Personnaliser le schéma</h3></div></div></div><p>Many Hibernate mapping elements define optional attributes named <code class="literal">length</code>, <code class="literal">precision</code> and <code class="literal">scale</code>. You can set the length, precision and scale of a column with this attribute. </p><pre class="programlisting">&lt;property name="zip" length="5"/&gt;</pre><pre class="programlisting">&lt;property name="balance" precision="12" scale="2"/&gt;</pre><p>Some tags also accept a <code class="literal">not-null</code> attribute for generating a <code class="literal">NOT NULL</code> constraint on table columns, and a <code class="literal">unique</code> attribute for generating <code class="literal">UNIQUE</code> constraint on table columns. </p><pre class="programlisting">&lt;many-to-one name="bar" column="barId" not-null="true"/&gt;</pre><pre class="programlisting">&lt;element column="serialNumber" type="long" not-null="true" unique="true"/&gt;</pre><p>A <code class="literal">unique-key</code> attribute can be used to group columns in a single, unique key constraint. Currently, the specified value of the <code class="literal">unique-key</code> attribute is <span class="emphasis"><em>not</em></span> used to name the constraint in the generated DDL. It is only used to group the columns in the mapping file. </p><pre class="programlisting">&lt;many-to-one name="org" column="orgId" unique-key="OrgEmployeeId"/&gt;
&lt;property name="employeeId" unique-key="OrgEmployee"/&gt;</pre><p>An <code class="literal">index</code> attribute specifies the name of an index that will be created using the mapped column or columns. Multiple columns can be grouped into the same index by simply specifying the same index name. </p><pre class="programlisting">&lt;property name="lastName" index="CustName"/&gt;
&lt;property name="firstName" index="CustName"/&gt;</pre><p>A <code class="literal">foreign-key</code> attribute can be used to override the name of any generated foreign key constraint. </p><pre class="programlisting">&lt;many-to-one name="bar" column="barId" foreign-key="FKFooBar"/&gt;</pre><p>Plusieurs éléments de mapping acceptent aussi un élément fils <code class="literal">&lt;column&gt;</code>. Ceci est utile pour les type multi-colonnes: </p><pre class="programlisting">&lt;property name="name" type="my.customtypes.Name"/&gt;
    &lt;column name="last" not-null="true" index="bar_idx" length="30"/&gt;
    &lt;column name="first" not-null="true" index="bar_idx" length="20"/&gt;
    &lt;column name="initial"/&gt;
&lt;/property&gt;</pre><p>The <code class="literal">default</code> attribute allows you to specify a default value for a column.You should assign the same value to the mapped property before saving a new instance of the mapped class. </p><pre class="programlisting">&lt;property name="credits" type="integer" insert="false"&gt;
    &lt;column name="credits" default="10"/&gt;
&lt;/property&gt;</pre><pre class="programlisting">&lt;version name="version" type="integer" insert="false"&gt;
    &lt;column name="version" default="0"/&gt;
&lt;/property&gt;</pre><p>L'attribut <code class="literal">sql-type</code> laisse l'utilisateur surcharger le mapping par défaut du type Hibernate vers un type SQL. </p><pre class="programlisting">&lt;property name="balance" type="float"&gt;
    &lt;column name="balance" sql-type="decimal(13,3)"/&gt;
&lt;/property&gt;</pre><p>L'attribut <code class="literal">check</code> permet de spécifier une contrainte de vérification. </p><pre class="programlisting">&lt;property name="foo" type="integer"&gt;
    &lt;column name="foo" check="foo &gt; 10"/&gt;
&lt;/property&gt;</pre><pre class="programlisting">&lt;class name="Foo" table="foos" check="bar &lt; 100.0"&gt;
    ...
    &lt;property name="bar" type="float"/&gt;
&lt;/class&gt;</pre><p>The following table summarizes these optional attributes.</p><div class="table"><a id="schemattributes-summary"/><p class="title"><b>Tableau 20.1. Summary</b></p><div class="table-contents"><table summary="Summary" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Attribut</th><th>Valeur</th><th>Interprétation</th></tr></thead><tbody><tr><td><code class="literal">length</code></td><td>numérique</td><td>taille d'une colonne</td></tr><tr><td><code class="literal">precision</code></td><td>numérique</td><td>précision décimale de la colonne</td></tr><tr><td><code class="literal">scale</code></td><td>numérique</td><td>scale décimale de la colonne</td></tr><tr><td><code class="literal">not-null</code></td><td><code class="literal">true|false</code></td><td>specifies that the column should be non-nullable</td></tr><tr><td><code class="literal">unique</code></td><td><code class="literal">true|false</code></td><td>spécifie que la colonne doit avoir une contrainte d'unicité</td></tr><tr><td><code class="literal">index</code></td><td><code class="literal">index_name</code></td><td>spécifie le nom d'un index (multi-colonnes)</td></tr><tr><td><code class="literal">unique-key</code></td><td><code class="literal">unique_key_name</code></td><td>spécifie le nom d'une contrainte d'unicité multi-colonnes</td></tr><tr><td><code class="literal">foreign-key</code></td><td><code class="literal">foreign_key_name</code></td><td>specifies the name of the foreign key constraint generated for an association, for a <code class="literal">&lt;one-to-one&gt;</code>, <code class="literal">&lt;many-to-one&gt;</code>, <code class="literal">&lt;key&gt;</code>, or <code class="literal">&lt;many-to-many&gt;</code> mapping element. Note that <code class="literal">inverse="true"</code> sides will not be considered by <code class="literal">SchemaExport</code>. </td></tr><tr><td><code class="literal">sql-type</code></td><td><code class="literal">SQL column_type</code></td><td>overrides the default column type (attribute of <code class="literal">&lt;column&gt;</code> element only) </td></tr><tr><td><code class="literal">default</code></td><td>SQL expression</td><td>spécifie une valeur par défaut pour la colonne </td></tr><tr><td><code class="literal">check</code></td><td>SQL expression</td><td>crée une contrainte de vérification sur la table ou la colonne </td></tr></tbody></table></div></div><br class="table-break"/><p>L'élément <code class="literal">&lt;comment&gt;</code> vous permet de spécifier un commentaire pour le schéma généré. </p><pre class="programlisting">&lt;class name="Customer" table="CurCust"&gt;
    &lt;comment&gt;Current customers only&lt;/comment&gt;
    ...
&lt;/class&gt;</pre><pre class="programlisting">&lt;property name="balance"&gt;
    &lt;column name="bal"&gt;
        &lt;comment&gt;Balance in USD&lt;/comment&gt;
    &lt;/column&gt;
&lt;/property&gt;</pre><p>This results in a <code class="literal">comment on table</code> or <code class="literal">comment on column</code> statement in the generated DDL where supported. </p></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-3"/>20.1.2. Exécuter l'outil</h3></div></div></div><p>L'outil <code class="literal">SchemaExport</code> génère un script DDL vers la sortie standard et/ou exécute les ordres DDL. </p><p>The following table displays the <code class="literal">SchemaExport</code> command line options</p><p><code class="literal">java -cp </code><span class="emphasis"><em>hibernate_classpaths</em></span> <code class="literal">org.hibernate.tool.hbm2ddl.SchemaExport</code> <span class="emphasis"><em>options mapping_files</em></span> </p><div class="table"><a id="d0e15795"/><p class="title"><b>Tableau 20.2. <code class="literal">SchemaExport</code> Options de la ligne de commande</b></p><div class="table-contents"><table summary="SchemaExport Options de la ligne de commande" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><code class="literal">--quiet</code></td><td>do not output the script to stdout</td></tr><tr><td><code class="literal">--drop</code></td><td>supprime seuleument les tables</td></tr><tr><td><code class="literal">--create</code></td><td>ne créé que les tables</td></tr><tr><td><code class="literal">--text</code></td><td>do not export to the database</td></tr><tr><td><code class="literal">--output=my_schema.ddl</code></td><td>écrit le script ddl vers un fichier</td></tr><tr><td><code class="literal">--naming=eg.MyNamingStrategy</code></td><td>select a <code class="literal">NamingStrategy</code></td></tr><tr><td><code class="literal">--config=hibernate.cfg.xml</code></td><td>lit la configuration Hibernate à partir d'un fichier XML</td></tr><tr><td><code class="literal">--properties=hibernate.properties</code></td><td>read database properties from a file</td></tr><tr><td><code class="literal">--format</code></td><td>formatte proprement le SQL généré dans le script</td></tr><tr><td><code class="literal">--delimiter=x</code></td><td>paramètre un délimiteur de fin de ligne pour le script</td></tr></tbody></table></div></div><br class="table-break"/><p>You can even embed <code class="literal">SchemaExport</code> in your application: </p><pre class="programlisting">Configuration cfg = ....;
new SchemaExport(cfg).create(false, true);</pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-4"/>20.1.3. Propriétés</h3></div></div></div><p>Database properties can be specified: </p><div class="itemizedlist"><ul compact="compact"><li><p>comme propriétés système avec <code class="literal">-D</code><span class="emphasis"><em>&lt;property&gt;</em></span></p></li><li><p>dans <code class="literal">hibernate.properties</code></p></li><li><p>dans un fichier de propriétés déclaré avec <code class="literal">--properties</code></p></li></ul></div><p>Les propriétés nécessaires sont : </p><div class="table"><a id="d0e15904"/><p class="title"><b>Tableau 20.3. SchemaExport Connection Properties</b></p><div class="table-contents"><table summary="SchemaExport Connection Properties" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Nom de la propriété</th><th>Description</th></tr></thead><tbody><tr><td><code class="literal">hibernate.connection.driver_class</code></td><td>classe du driver JDBC</td></tr><tr><td><code class="literal">hibernate.connection.url</code></td><td>URL JDBC</td></tr><tr><td><code class="literal">hibernate.connection.username</code></td><td>utilisateur de la base de données</td></tr><tr><td><code class="literal">hibernate.connection.password</code></td><td>mot de passe de l'utilisateur</td></tr><tr><td><code class="literal">hibernate.dialect</code></td><td>dialecte</td></tr></tbody></table></div></div><br class="table-break"/></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-5"/>20.1.4. Utiliser Ant</h3></div></div></div><p>Vous pouvez appeler <code class="literal">SchemaExport</code> depuis votre script de construction Ant : </p><pre class="programlisting">&lt;target name="schemaexport"&gt;
    &lt;taskdef name="schemaexport"
        classname="org.hibernate.tool.hbm2ddl.SchemaExportTask"
        classpathref="class.path"/&gt;
    
    &lt;schemaexport
        properties="hibernate.properties"
        quiet="no"
        text="no"
        drop="no"
        delimiter=";"
        output="schema-export.sql"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemaexport&gt;
&lt;/target&gt;</pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-6"/>20.1.5. Mises à jour incrémentales du schéma</h3></div></div></div><p>The <code class="literal">SchemaUpdate</code> tool will update an existing schema with "incremental" changes. The <code class="literal">SchemaUpdate</code> depends upon the JDBC metadata API and, as such, will not work with all JDBC drivers. </p><p><code class="literal">java -cp </code><span class="emphasis"><em>hibernate_classpaths</em></span> <code class="literal">org.hibernate.tool.hbm2ddl.SchemaUpdate</code> <span class="emphasis"><em>options mapping_files</em></span> </p><div class="table"><a id="d0e15980"/><p class="title"><b>Tableau 20.4. <code class="literal">SchemaUpdate</code> Options de ligne de commande</b></p><div class="table-contents"><table summary="SchemaUpdate Options de ligne de commande" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><code class="literal">--quiet</code></td><td>do not output the script to stdout</td></tr><tr><td><code class="literal">--text</code></td><td>do not export the script to the database</td></tr><tr><td><code class="literal">--naming=eg.MyNamingStrategy</code></td><td>select a <code class="literal">NamingStrategy</code></td></tr><tr><td><code class="literal">--properties=hibernate.properties</code></td><td>read database properties from a file</td></tr><tr><td><code class="literal">--config=hibernate.cfg.xml</code></td><td>specify a <code class="literal">.cfg.xml</code> file</td></tr></tbody></table></div></div><br class="table-break"/><p>You can embed <code class="literal">SchemaUpdate</code> in your application: </p><pre class="programlisting">Configuration cfg = ....;
new SchemaUpdate(cfg).execute(false);</pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-7"/>20.1.6. Utiliser Ant pour des mises à jour de schéma par incrément</h3></div></div></div><p>Vous pouvez appeler <code class="literal">SchemaUpdate</code> depuis le script Ant : </p><pre class="programlisting">&lt;target name="schemaupdate"&gt;
    &lt;taskdef name="schemaupdate"
        classname="org.hibernate.tool.hbm2ddl.SchemaUpdateTask"
        classpathref="class.path"/&gt;
    
    &lt;schemaupdate
        properties="hibernate.properties"
        quiet="no"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemaupdate&gt;
&lt;/target&gt;</pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-8"/>20.1.7. Validation du schéma</h3></div></div></div><p>The <code class="literal">SchemaValidator</code> tool will validate that the existing database schema "matches" your mapping documents. The <code class="literal">SchemaValidator</code> depends heavily upon the JDBC metadata API and, as such, will not work with all JDBC drivers. This tool is extremely useful for testing. </p><p><code class="literal">java -cp </code><span class="emphasis"><em>hibernate_classpaths</em></span> <code class="literal">org.hibernate.tool.hbm2ddl.SchemaValidator</code> <span class="emphasis"><em>options mapping_files</em></span> </p><div class="table"><a id="d0e16070"/><p class="title"><b>Tableau 20.5. <code class="literal">SchemaValidator</code> Options de ligne de commande</b></p><div class="table-contents"><table summary="SchemaValidator Options de ligne de commande" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><code class="literal">--naming=eg.MyNamingStrategy</code></td><td>select a <code class="literal">NamingStrategy</code></td></tr><tr><td><code class="literal">--properties=hibernate.properties</code></td><td>read database properties from a file</td></tr><tr><td><code class="literal">--config=hibernate.cfg.xml</code></td><td>specify a <code class="literal">.cfg.xml</code> file</td></tr></tbody></table></div></div><br class="table-break"/><p>You can embed <code class="literal">SchemaValidator</code> in your application: </p><pre class="programlisting">Configuration cfg = ....;
new SchemaValidator(cfg).validate();</pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-9"/>20.1.8. Utiliser Ant pour la validation du Schéma</h3></div></div></div><p>Vous pouvez appeler <code class="literal">SchemaValidator</code> depuis le script Ant: </p><pre class="programlisting">&lt;target name="schemavalidate"&gt;
    &lt;taskdef name="schemavalidator"
        classname="org.hibernate.tool.hbm2ddl.SchemaValidatorTask"
        classpathref="class.path"/&gt;
    
    &lt;schemavalidator
        properties="hibernate.properties"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemavalidator&gt;
&lt;/target&gt;</pre></div></div></div><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild"/>Chapitre 21. Exemple : Père/Fils</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#example-parentchild-collections">21.1. Une note à propos des collections</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-bidir">21.2. un-vers-plusieurs bidirectionnel</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-cascades">21.3. Cycle de vie en cascade</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-update">21.4. Cascades et <code class="literal">unsaved-value</code></a></span></dt><dt><span class="sect1"><a href="#example-parentchild-conclusion">21.5. Conclusion</a></span></dt></dl></div><p>One of the first things that new users want to do with Hibernate is to model a parent/child type relationship. There are two different approaches to this. The most convenient approach, especially for new users, is to model both <code class="literal">Parent</code> and <code class="literal">Child</code> as entity classes with a <code class="literal">&lt;one-to-many&gt;</code> association from <code class="literal">Parent</code> to <code class="literal">Child</code>. The alternative approach is to declare the <code class="literal">Child</code> as a <code class="literal">&lt;composite-element&gt;</code>. The default semantics of a one-to-many association in Hibernate are much less close to the usual semantics of a parent/child relationship than those of a composite element mapping. We will explain how to use a <span class="emphasis"><em>bidirectional one-to-many association with cascades</em></span> to model a parent/child relationship efficiently and elegantly. </p><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-collections"/>21.1. Une note à propos des collections</h2></div></div></div><p>Hibernate collections are considered to be a logical part of their owning entity and not of the contained entities. Be aware that this is a critical distinction that has the following consequences: </p><div class="itemizedlist"><ul><li><p>When you remove/add an object from/to a collection, the version number of the collection owner is incremented. </p></li><li><p>If an object that was removed from a collection is an instance of a value type (e.g. a composite element), that object will cease to be persistent and its state will be completely removed from the database. Likewise, adding a value type instance to the collection will cause its state to be immediately persistent. </p></li><li><p>Conversely, if an entity is removed from a collection (a one-to-many or many-to-many association), it will not be deleted by default. This behavior is completely consistent; a change to the internal state of another entity should not cause the associated entity to vanish. Likewise, adding an entity to a collection does not cause that entity to become persistent, by default. </p></li></ul></div><p>Adding an entity to a collection, by default, merely creates a link between the two entities. Removing the entity will remove the link. This is appropriate for all sorts of cases. However, it is not appropriate in the case of a parent/child relationship. In this case, the life of the child is bound to the life cycle of the parent. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-bidir"/>21.2. un-vers-plusieurs bidirectionnel</h2></div></div></div><p>Supposons que nous ayons une simple association <code class="literal">&lt;one-to-many&gt;</code> de <code class="literal">Parent</code> vers <code class="literal">Child</code>. </p><pre class="programlisting">&lt;set name="children"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>If we were to execute the following code: </p><pre class="programlisting">Parent p = .....;
Child c = new Child();
p.getChildren().add(c);
session.save(c);
session.flush();</pre><p>Hibernate exécuterait deux ordres SQL: </p><div class="itemizedlist"><ul><li><p>un <code class="literal">INSERT</code> pour créer l'enregistrement pour <code class="literal">c</code></p></li><li><p>un <code class="literal">UPDATE</code> pour créer le lien de <code class="literal">p</code> vers <code class="literal">c</code> </p></li></ul></div><p>This is not only inefficient, but also violates any <code class="literal">NOT NULL</code> constraint on the <code class="literal">parent_id</code> column. You can fix the nullability constraint violation by specifying <code class="literal">not-null="true"</code> in the collection mapping: </p><pre class="programlisting">&lt;set name="children"&gt;
    &lt;key column="parent_id" not-null="true"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>Cependant ce n'est pas la solution recommandée. </p><p>The underlying cause of this behavior is that the link (the foreign key <code class="literal">parent_id</code>) from <code class="literal">p</code> to <code class="literal">c</code> is not considered part of the state of the <code class="literal">Child</code> object and is therefore not created in the <code class="literal">INSERT</code>. The solution is to make the link part of the <code class="literal">Child</code> mapping. </p><pre class="programlisting">&lt;many-to-one name="parent" column="parent_id" not-null="true"/&gt;</pre><p>You also need to add the <code class="literal">parent</code> property to the <code class="literal">Child</code> class. </p><p>Now that the <code class="literal">Child</code> entity is managing the state of the link, we tell the collection not to update the link. We use the <code class="literal">inverse</code> attribute to do this: </p><pre class="programlisting">&lt;set name="children" inverse="true"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>The following code would be used to add a new <code class="literal">Child</code>: </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
c.setParent(p);
p.getChildren().add(c);
session.save(c);
session.flush();</pre><p>Only one SQL <code class="literal">INSERT</code> would now be issued. </p><p>You could also create an <code class="literal">addChild()</code> method of <code class="literal">Parent</code>. </p><pre class="programlisting">public void addChild(Child c) {
    c.setParent(this);
    children.add(c);
}</pre><p>The code to add a <code class="literal">Child</code> looks like this: </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
p.addChild(c);
session.save(c);
session.flush();</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-cascades"/>21.3. Cycle de vie en cascade</h2></div></div></div><p>You can address the frustrations of the explicit call to <code class="literal">save()</code> by using cascades. </p><pre class="programlisting">&lt;set name="children" inverse="true" cascade="all"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>This simplifies the code above to: </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
p.addChild(c);
session.flush();</pre><p>Similarly, we do not need to iterate over the children when saving or deleting a <code class="literal">Parent</code>. The following removes <code class="literal">p</code> and all its children from the database. </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
session.delete(p);
session.flush();</pre><p>However, the following code: </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = (Child) p.getChildren().iterator().next();
p.getChildren().remove(c);
c.setParent(null);
session.flush();</pre><p>will not remove <code class="literal">c</code> from the database. In this case, it will only remove the link to <code class="literal">p</code> and cause a <code class="literal">NOT NULL</code> constraint violation. You need to explicitly <code class="literal">delete()</code> the <code class="literal">Child</code>. </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = (Child) p.getChildren().iterator().next();
p.getChildren().remove(c);
session.delete(c);
session.flush();</pre><p>In our case, a <code class="literal">Child</code> cannot exist without its parent. So if we remove a <code class="literal">Child</code> from the collection, we do want it to be deleted. To do this, we must use <code class="literal">cascade="all-delete-orphan"</code>. </p><pre class="programlisting">&lt;set name="children" inverse="true" cascade="all-delete-orphan"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>Even though the collection mapping specifies <code class="literal">inverse="true"</code>, cascades are still processed by iterating the collection elements. If you need an object be saved, deleted or updated by cascade, you must add it to the collection. It is not enough to simply call <code class="literal">setParent()</code>. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-update"/>21.4. Cascades et <code class="literal">unsaved-value</code></h2></div></div></div><p>Suppose we loaded up a <code class="literal">Parent</code> in one <code class="literal">Session</code>, made some changes in a UI action and wanted to persist these changes in a new session by calling <code class="literal">update()</code>. The <code class="literal">Parent</code> will contain a collection of children and, since the cascading update is enabled, Hibernate needs to know which children are newly instantiated and which represent existing rows in the database. We will also assume that both <code class="literal">Parent</code> and <code class="literal">Child</code> have generated identifier properties of type <code class="literal">Long</code>. Hibernate will use the identifier and version/timestamp property value to determine which of the children are new. (See <a href="#objectstate-saveorupdate" title="10.7. Détection automatique d'un état">Section 10.7, « Détection automatique d'un état »</a>.) <span class="emphasis"><em>In Hibernate3, it is no longer necessary to specify an <code class="literal">unsaved-value</code> explicitly.</em></span> </p><p>The following code will update <code class="literal">parent</code> and <code class="literal">child</code> and insert <code class="literal">newChild</code>: </p><pre class="programlisting">//parent and child were both loaded in a previous session
parent.addChild(child);
Child newChild = new Child();
parent.addChild(newChild);
session.update(parent);
session.flush();</pre><p>This may be suitable for the case of a generated identifier, but what about assigned identifiers and composite identifiers? This is more difficult, since Hibernate cannot use the identifier property to distinguish between a newly instantiated object, with an identifier assigned by the user, and an object loaded in a previous session. In this case, Hibernate will either use the timestamp or version property, or will actually query the second-level cache or, worst case, the database, to see if the row exists. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-conclusion"/>21.5. Conclusion</h2></div></div></div><p>The sections we have just covered can be a bit confusing. However, in practice, it all works out nicely. Most Hibernate applications use the parent/child pattern in many places. </p><p>We mentioned an alternative in the first paragraph. None of the above issues exist in the case of <code class="literal">&lt;composite-element&gt;</code> mappings, which have exactly the semantics of a parent/child relationship. Unfortunately, there are two big limitations with composite element classes: composite elements cannot own collections and they should not be the child of any entity other than the unique parent. </p></div></div><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="example-weblog"/>Chapitre 22. Exemple : application Weblog</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#example-weblog-classes">22.1. Classes persistantes</a></span></dt><dt><span class="sect1"><a href="#example-weblog-mappings">22.2. Mappings Hibernate</a></span></dt><dt><span class="sect1"><a href="#example-weblog-code">22.3. Code Hibernate</a></span></dt></dl></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="example-weblog-classes"/>22.1. Classes persistantes</h2></div></div></div><p>The persistent classes here represent a weblog and an item posted in a weblog. They are to be modelled as a standard parent/child relationship, but we will use an ordered bag, instead of a set: </p><pre class="programlisting">package eg;

import java.util.List;

public class Blog {
    private Long _id;
    private String _name;
    private List _items;

    public Long getId() {
        return _id;
    }
    public List getItems() {
        return _items;
    }
    public String getName() {
        return _name;
    }
    public void setId(Long long1) {
        _id = long1;
    }
    public void setItems(List list) {
        _items = list;
    }
    public void setName(String string) {
        _name = string;
    }
}</pre><pre class="programlisting">package eg;

import java.text.DateFormat;
import java.util.Calendar;

public class BlogItem {
    private Long _id;
    private Calendar _datetime;
    private String _text;
    private String _title;
    private Blog _blog;

    public Blog getBlog() {
        return _blog;
    }
    public Calendar getDatetime() {
        return _datetime;
    }
    public Long getId() {
        return _id;
    }
    public String getText() {
        return _text;
    }
    public String getTitle() {
        return _title;
    }
    public void setBlog(Blog blog) {
        _blog = blog;
    }
    public void setDatetime(Calendar calendar) {
        _datetime = calendar;
    }
    public void setId(Long long1) {
        _id = long1;
    }
    public void setText(String string) {
        _text = string;
    }
    public void setTitle(String string) {
        _title = string;
    }
}</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="example-weblog-mappings"/>22.2. Mappings Hibernate</h2></div></div></div><p>The XML mappings are now straightforward. For example: </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

    &lt;class
        name="Blog"
        table="BLOGS"&gt;

        &lt;id
            name="id"
            column="BLOG_ID"&gt;

            &lt;generator class="native"/&gt;

        &lt;/id&gt;

        &lt;property
            name="name"
            column="NAME"
            not-null="true"
            unique="true"/&gt;

        &lt;bag
            name="items"
            inverse="true"
            order-by="DATE_TIME"
            cascade="all"&gt;

            &lt;key column="BLOG_ID"/&gt;
            &lt;one-to-many class="BlogItem"/&gt;

        &lt;/bag&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

    &lt;class
        name="BlogItem"
        table="BLOG_ITEMS"
        dynamic-update="true"&gt;

        &lt;id
            name="id"
            column="BLOG_ITEM_ID"&gt;

            &lt;generator class="native"/&gt;

        &lt;/id&gt;

        &lt;property
            name="title"
            column="TITLE"
            not-null="true"/&gt;

        &lt;property
            name="text"
            column="TEXT"
            not-null="true"/&gt;

        &lt;property
            name="datetime"
            column="DATE_TIME"
            not-null="true"/&gt;

        &lt;many-to-one
            name="blog"
            column="BLOG_ID"
            not-null="true"/&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="example-weblog-code"/>22.3. Code Hibernate</h2></div></div></div><p>The following class demonstrates some of the kinds of things we can do with these classes using Hibernate: </p><pre class="programlisting">package eg;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Iterator;
import java.util.List;

import org.hibernate.HibernateException;
import org.hibernate.Query;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;
import org.hibernate.tool.hbm2ddl.SchemaExport;

public class BlogMain {
    
    private SessionFactory _sessions;
    
    public void configure() throws HibernateException {
        _sessions = new Configuration()
            .addClass(Blog.class)
            .addClass(BlogItem.class)
            .buildSessionFactory();
    }
    
    public void exportTables() throws HibernateException {
        Configuration cfg = new Configuration()
            .addClass(Blog.class)
            .addClass(BlogItem.class);
        new SchemaExport(cfg).create(true, true);
    }
    
    public Blog createBlog(String name) throws HibernateException {
        
        Blog blog = new Blog();
        blog.setName(name);
        blog.setItems( new ArrayList() );
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.persist(blog);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return blog;
    }
    
    public BlogItem createBlogItem(Blog blog, String title, String text)
                        throws HibernateException {
        
        BlogItem item = new BlogItem();
        item.setTitle(title);
        item.setText(text);
        item.setBlog(blog);
        item.setDatetime( Calendar.getInstance() );
        blog.getItems().add(item);
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.update(blog);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return item;
    }
    
    public BlogItem createBlogItem(Long blogid, String title, String text)
                        throws HibernateException {
        
        BlogItem item = new BlogItem();
        item.setTitle(title);
        item.setText(text);
        item.setDatetime( Calendar.getInstance() );
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            Blog blog = (Blog) session.load(Blog.class, blogid);
            item.setBlog(blog);
            blog.getItems().add(item);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return item;
    }
    
    public void updateBlogItem(BlogItem item, String text)
                    throws HibernateException {
        
        item.setText(text);
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.update(item);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
    }
    
    public void updateBlogItem(Long itemid, String text)
                    throws HibernateException {
    
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            BlogItem item = (BlogItem) session.load(BlogItem.class, itemid);
            item.setText(text);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
    }
    
    public List listAllBlogNamesAndItemCounts(int max)
                    throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        List result = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "select blog.id, blog.name, count(blogItem) " +
                "from Blog as blog " +
                "left outer join blog.items as blogItem " +
                "group by blog.name, blog.id " +
                "order by max(blogItem.datetime)"
            );
            q.setMaxResults(max);
            result = q.list();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return result;
    }
    
    public Blog getBlogAndAllItems(Long blogid)
                    throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        Blog blog = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "from Blog as blog " +
                "left outer join fetch blog.items " +
                "where blog.id = :blogid"
            );
            q.setParameter("blogid", blogid);
            blog  = (Blog) q.uniqueResult();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return blog;
    }
    
    public List listBlogsAndRecentItems() throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        List result = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "from Blog as blog " +
                "inner join blog.items as blogItem " +
                "where blogItem.datetime &gt; :minDate"
            );

            Calendar cal = Calendar.getInstance();
            cal.roll(Calendar.MONTH, false);
            q.setCalendar("minDate", cal);
            
            result = q.list();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return result;
    }
}</pre></div></div><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="example-mappings"/>Chapitre 23. Exemple : quelques mappings</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#example-mappings-emp">23.1. Employeur/Employé (Employer/Employee)</a></span></dt><dt><span class="sect1"><a href="#example-mappings-authorwork">23.2. Auteur/Travail (Author/Work)</a></span></dt><dt><span class="sect1"><a href="#example-mappings-customerorderproduct">23.3. Client/Commande/Produit (Customer/Order/Product)</a></span></dt><dt><span class="sect1"><a href="#misc">23.4. Divers mappings d'exemple</a></span></dt><dd><dl><dt><span class="sect2"><a href="#example-mappings-typed-onetone">23.4.1. "Typed" one-to-one association</a></span></dt><dt><span class="sect2"><a href="#example-mappings-composite-key">23.4.2. Exemple de clef composée</a></span></dt><dt><span class="sect2"><a href="#example-mappings-composite-key-manytomany">23.4.3. Many-to-many avec une clef composée partagée</a></span></dt><dt><span class="sect2"><a href="#example-mappings-content-discrimination">23.4.4. Contenu basé sur une discrimination</a></span></dt><dt><span class="sect2"><a href="#example-mappings-association-alternatekeys">23.4.5. Associations sur des clefs alternées</a></span></dt></dl></dd></dl></div><p>This chapters explores some more complex association mappings. </p><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="example-mappings-emp"/>23.1. Employeur/Employé (Employer/Employee)</h2></div></div></div><p>The following model of the relationship between <code class="literal">Employer</code> and <code class="literal">Employee</code> uses an entity class (<code class="literal">Employment</code>) to represent the association. You can do this when there might be more than one period of employment for the same two parties. Components are used to model monetary values and employee names. </p><div class="mediaobject" align="center"><img src="../images/EmployerEmployee.png" align="middle"/></div><p>Here is a possible mapping document: </p><pre class="programlisting">&lt;hibernate-mapping&gt;
        
    &lt;class name="Employer" table="employers"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employer_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

    &lt;class name="Employment" table="employment_periods"&gt;

        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employment_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="startDate" column="start_date"/&gt;
        &lt;property name="endDate" column="end_date"/&gt;

        &lt;component name="hourlyRate" class="MonetaryAmount"&gt;
            &lt;property name="amount"&gt;
                &lt;column name="hourly_rate" sql-type="NUMERIC(12, 2)"/&gt;
            &lt;/property&gt;
            &lt;property name="currency" length="12"/&gt;
        &lt;/component&gt;

        &lt;many-to-one name="employer" column="employer_id" not-null="true"/&gt;
        &lt;many-to-one name="employee" column="employee_id" not-null="true"/&gt;

    &lt;/class&gt;

    &lt;class name="Employee" table="employees"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employee_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="taxfileNumber"/&gt;
        &lt;component name="name" class="Name"&gt;
            &lt;property name="firstName"/&gt;
            &lt;property name="initial"/&gt;
            &lt;property name="lastName"/&gt;
        &lt;/component&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>Here is the table schema generated by <code class="literal">SchemaExport</code>. </p><pre class="programlisting">create table employers (
    id BIGINT not null, 
    name VARCHAR(255), 
    primary key (id)
)

create table employment_periods (
    id BIGINT not null,
    hourly_rate NUMERIC(12, 2),
    currency VARCHAR(12), 
    employee_id BIGINT not null, 
    employer_id BIGINT not null, 
    end_date TIMESTAMP, 
    start_date TIMESTAMP, 
    primary key (id)
)

create table employees (
    id BIGINT not null, 
    firstName VARCHAR(255), 
    initial CHAR(1), 
    lastName VARCHAR(255), 
    taxfileNumber VARCHAR(255), 
    primary key (id)
)

alter table employment_periods 
    add constraint employment_periodsFK0 foreign key (employer_id) references employers
alter table employment_periods 
    add constraint employment_periodsFK1 foreign key (employee_id) references employees
create sequence employee_id_seq
create sequence employment_id_seq
create sequence employer_id_seq</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="example-mappings-authorwork"/>23.2. Auteur/Travail (Author/Work)</h2></div></div></div><p>Consider the following model of the relationships between <code class="literal">Work</code>, <code class="literal">Author</code> and <code class="literal">Person</code>. In the example, the relationship between <code class="literal">Work</code> and <code class="literal">Author</code> is represented as a many-to-many association and the relationship between <code class="literal">Author</code> and <code class="literal">Person</code> is represented as one-to-one association. Another possibility would be to have <code class="literal">Author</code> extend <code class="literal">Person</code>. </p><div class="mediaobject" align="center"><img src="../images/AuthorWork.png" align="middle"/></div><p>Le mapping suivant représente exactement ces relations : </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Work" table="works" discriminator-value="W"&gt;

        &lt;id name="id" column="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;discriminator column="type" type="character"/&gt;

        &lt;property name="title"/&gt;
        &lt;set name="authors" table="author_work"&gt;
            &lt;key column name="work_id"/&gt;
            &lt;many-to-many class="Author" column name="author_id"/&gt;
        &lt;/set&gt;

        &lt;subclass name="Book" discriminator-value="B"&gt;
            &lt;property name="text"/&gt;
        &lt;/subclass&gt;

        &lt;subclass name="Song" discriminator-value="S"&gt;
            &lt;property name="tempo"/&gt;
            &lt;property name="genre"/&gt;
        &lt;/subclass&gt;

    &lt;/class&gt;

    &lt;class name="Author" table="authors"&gt;

        &lt;id name="id" column="id"&gt;
            &lt;!-- The Author must have the same identifier as the Person --&gt;
            &lt;generator class="assigned"/&gt; 
        &lt;/id&gt;

        &lt;property name="alias"/&gt;
        &lt;one-to-one name="person" constrained="true"/&gt;

        &lt;set name="works" table="author_work" inverse="true"&gt;
            &lt;key column="author_id"/&gt;
            &lt;many-to-many class="Work" column="work_id"/&gt;
        &lt;/set&gt;

    &lt;/class&gt;

    &lt;class name="Person" table="persons"&gt;
        &lt;id name="id" column="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>There are four tables in this mapping: <code class="literal">works</code>, <code class="literal">authors</code> and <code class="literal">persons</code> hold work, author and person data respectively. <code class="literal">author_work</code> is an association table linking authors to works. Here is the table schema, as generated by <code class="literal">SchemaExport</code>: </p><pre class="programlisting">create table works (
    id BIGINT not null generated by default as identity, 
    tempo FLOAT, 
    genre VARCHAR(255), 
    text INTEGER, 
    title VARCHAR(255), 
    type CHAR(1) not null, 
    primary key (id)
)

create table author_work (
    author_id BIGINT not null, 
    work_id BIGINT not null, 
    primary key (work_id, author_id)
)

create table authors (
    id BIGINT not null generated by default as identity, 
    alias VARCHAR(255), 
    primary key (id)
)

create table persons (
    id BIGINT not null generated by default as identity, 
    name VARCHAR(255), 
    primary key (id)
)

alter table authors 
    add constraint authorsFK0 foreign key (id) references persons
alter table author_work 
    add constraint author_workFK0 foreign key (author_id) references authors
alter table author_work
    add constraint author_workFK1 foreign key (work_id) references works</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="example-mappings-customerorderproduct"/>23.3. Client/Commande/Produit (Customer/Order/Product)</h2></div></div></div><p>In this section we consider a model of the relationships between <code class="literal">Customer</code>, <code class="literal">Order</code>, <code class="literal">Line Item</code> and <code class="literal">Product</code>. There is a one-to-many association between <code class="literal">Customer</code> and <code class="literal">Order</code>, but how can you represent <code class="literal">Order</code> / <code class="literal">LineItem</code> / <code class="literal">Product</code>? In the example, <code class="literal">LineItem</code> is mapped as an association class representing the many-to-many association between <code class="literal">Order</code> and <code class="literal">Product</code>. In Hibernate this is called a composite element. </p><div class="mediaobject" align="center"><img src="../images/CustomerOrderProduct.png" align="middle"/></div><p>The mapping document will look like this: </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Customer" table="customers"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
        &lt;set name="orders" inverse="true"&gt;
            &lt;key column="customer_id"/&gt;
            &lt;one-to-many class="Order"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Order" table="orders"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="date"/&gt;
        &lt;many-to-one name="customer" column="customer_id"/&gt;
        &lt;list name="lineItems" table="line_items"&gt;
            &lt;key column="order_id"/&gt;
            &lt;list-index column="line_number"/&gt;
            &lt;composite-element class="LineItem"&gt;
                &lt;property name="quantity"/&gt;
                &lt;many-to-one name="product" column="product_id"/&gt;
            &lt;/composite-element&gt;
        &lt;/list&gt;
    &lt;/class&gt;

    &lt;class name="Product" table="products"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="serialNumber"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p><code class="literal">customers</code>, <code class="literal">orders</code>, <code class="literal">line_items</code> et <code class="literal">products</code> contiennent les données de customer, order, order line item et product. <code class="literal">line_items</code> est aussi la table d'association liant orders à products. </p><pre class="programlisting">create table customers (
    id BIGINT not null generated by default as identity, 
    name VARCHAR(255), 
    primary key (id)
)

create table orders (
    id BIGINT not null generated by default as identity, 
    customer_id BIGINT, 
    date TIMESTAMP, 
    primary key (id)
)

create table line_items (
    line_number INTEGER not null, 
    order_id BIGINT not null, 
    product_id BIGINT, 
    quantity INTEGER, 
    primary key (order_id, line_number)
)

create table products (
    id BIGINT not null generated by default as identity, 
    serialNumber VARCHAR(255), 
    primary key (id)
)

alter table orders 
    add constraint ordersFK0 foreign key (customer_id) references customers
alter table line_items
    add constraint line_itemsFK0 foreign key (product_id) references products
alter table line_items
    add constraint line_itemsFK1 foreign key (order_id) references orders</pre></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="misc"/>23.4. Divers mappings d'exemple</h2></div></div></div><p>These examples are available from the Hibernate test suite. You will find many other useful example mappings there by searching in the <code class="literal">test</code> folder of the Hibernate distribution. </p><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="example-mappings-typed-onetone"/>23.4.1. "Typed" one-to-one association</h3></div></div></div><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="name"/&gt;
    &lt;one-to-one name="address" 
            cascade="all"&gt;
        &lt;formula&gt;name&lt;/formula&gt;
        &lt;formula&gt;'HOME'&lt;/formula&gt;
    &lt;/one-to-one&gt;
    &lt;one-to-one name="mailingAddress" 
            cascade="all"&gt;
        &lt;formula&gt;name&lt;/formula&gt;
        &lt;formula&gt;'MAILING'&lt;/formula&gt;
    &lt;/one-to-one&gt;
&lt;/class&gt;

&lt;class name="Address" batch-size="2" 
        check="addressType in ('MAILING', 'HOME', 'BUSINESS')"&gt;
    &lt;composite-id&gt;
        &lt;key-many-to-one name="person" 
                column="personName"/&gt;
        &lt;key-property name="type" 
                column="addressType"/&gt;
    &lt;/composite-id&gt;
    &lt;property name="street" type="text"/&gt;
    &lt;property name="state"/&gt;
    &lt;property name="zip"/&gt;
&lt;/class&gt;</pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="example-mappings-composite-key"/>23.4.2. Exemple de clef composée</h3></div></div></div><pre class="programlisting">&lt;class name="Customer"&gt;

    &lt;id name="customerId"
        length="10"&gt;
        &lt;generator class="assigned"/&gt;
    &lt;/id&gt;

    &lt;property name="name" not-null="true" length="100"/&gt;
    &lt;property name="address" not-null="true" length="200"/&gt;

    &lt;list name="orders"
            inverse="true"
            cascade="save-update"&gt;
        &lt;key column="customerId"/&gt;
        &lt;index column="orderNumber"/&gt;
        &lt;one-to-many class="Order"/&gt;
    &lt;/list&gt;

&lt;/class&gt;

&lt;class name="Order" table="CustomerOrder" lazy="true"&gt;
    &lt;synchronize table="LineItem"/&gt;
    &lt;synchronize table="Product"/&gt;
    
    &lt;composite-id name="id" 
            class="Order$Id"&gt;
        &lt;key-property name="customerId" length="10"/&gt;
        &lt;key-property name="orderNumber"/&gt;
    &lt;/composite-id&gt;
    
    &lt;property name="orderDate" 
            type="calendar_date"
            not-null="true"/&gt;
    
    &lt;property name="total"&gt;
        &lt;formula&gt;
            ( select sum(li.quantity*p.price) 
            from LineItem li, Product p 
            where li.productId = p.productId 
                and li.customerId = customerId 
                and li.orderNumber = orderNumber )
        &lt;/formula&gt;
    &lt;/property&gt;
    
    &lt;many-to-one name="customer"
            column="customerId"
            insert="false"
            update="false" 
            not-null="true"/&gt;
        
    &lt;bag name="lineItems"
            fetch="join" 
            inverse="true"
            cascade="save-update"&gt;
        &lt;key&gt;
            &lt;column name="customerId"/&gt;
            &lt;column name="orderNumber"/&gt;
        &lt;/key&gt;
        &lt;one-to-many class="LineItem"/&gt;
    &lt;/bag&gt;
    
&lt;/class&gt;
    
&lt;class name="LineItem"&gt;
    
    &lt;composite-id name="id" 
            class="LineItem$Id"&gt;
        &lt;key-property name="customerId" length="10"/&gt;
        &lt;key-property name="orderNumber"/&gt;
        &lt;key-property name="productId" length="10"/&gt;
    &lt;/composite-id&gt;
    
    &lt;property name="quantity"/&gt;
    
    &lt;many-to-one name="order"
            insert="false"
            update="false" 
            not-null="true"&gt;
        &lt;column name="customerId"/&gt;
        &lt;column name="orderNumber"/&gt;
    &lt;/many-to-one&gt;
    
    &lt;many-to-one name="product"
            insert="false"
            update="false" 
            not-null="true"
            column="productId"/&gt;
        
&lt;/class&gt;

&lt;class name="Product"&gt;
    &lt;synchronize table="LineItem"/&gt;

    &lt;id name="productId"
        length="10"&gt;
        &lt;generator class="assigned"/&gt;
    &lt;/id&gt;
    
    &lt;property name="description" 
        not-null="true" 
        length="200"/&gt;
    &lt;property name="price" length="3"/&gt;
    &lt;property name="numberAvailable"/&gt;
    
    &lt;property name="numberOrdered"&gt;
        &lt;formula&gt;
            ( select sum(li.quantity) 
            from LineItem li 
            where li.productId = productId )
        &lt;/formula&gt;
    &lt;/property&gt;
    
&lt;/class&gt;</pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="example-mappings-composite-key-manytomany"/>23.4.3. Many-to-many avec une clef composée partagée</h3></div></div></div><pre class="programlisting">&lt;class name="User" table="`User`"&gt;
    &lt;composite-id&gt;
        &lt;key-property name="name"/&gt;
        &lt;key-property name="org"/&gt;
    &lt;/composite-id&gt;
    &lt;set name="groups" table="UserGroup"&gt;
        &lt;key&gt;
            &lt;column name="userName"/&gt;
            &lt;column name="org"/&gt;
        &lt;/key&gt;
        &lt;many-to-many class="Group"&gt;
            &lt;column name="groupName"/&gt;
            &lt;formula&gt;org&lt;/formula&gt;
        &lt;/many-to-many&gt;
    &lt;/set&gt;
&lt;/class&gt;
    
&lt;class name="Group" table="`Group`"&gt;
    &lt;composite-id&gt;
        &lt;key-property name="name"/&gt;
        &lt;key-property name="org"/&gt;
    &lt;/composite-id&gt;
    &lt;property name="description"/&gt;
    &lt;set name="users" table="UserGroup" inverse="true"&gt;
        &lt;key&gt;
            &lt;column name="groupName"/&gt;
            &lt;column name="org"/&gt;
        &lt;/key&gt;
        &lt;many-to-many class="User"&gt;
            &lt;column name="userName"/&gt;
            &lt;formula&gt;org&lt;/formula&gt;
        &lt;/many-to-many&gt;
    &lt;/set&gt;
&lt;/class&gt;
</pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="example-mappings-content-discrimination"/>23.4.4. Contenu basé sur une discrimination</h3></div></div></div><pre class="programlisting">&lt;class name="Person"
    discriminator-value="P"&gt;
    
    &lt;id name="id" 
        column="person_id" 
        unsaved-value="0"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    
            
    &lt;discriminator 
        type="character"&gt;
        &lt;formula&gt;
            case 
                when title is not null then 'E' 
                when salesperson is not null then 'C' 
                else 'P' 
            end
        &lt;/formula&gt;
    &lt;/discriminator&gt;

    &lt;property name="name" 
        not-null="true"
        length="80"/&gt;
        
    &lt;property name="sex" 
        not-null="true"
        update="false"/&gt;
    
    &lt;component name="address"&gt;
        &lt;property name="address"/&gt;
        &lt;property name="zip"/&gt;
        &lt;property name="country"/&gt;
    &lt;/component&gt;
    
    &lt;subclass name="Employee" 
        discriminator-value="E"&gt;
            &lt;property name="title"
                length="20"/&gt;
            &lt;property name="salary"/&gt;
            &lt;many-to-one name="manager"/&gt;
    &lt;/subclass&gt;
    
    &lt;subclass name="Customer" 
        discriminator-value="C"&gt;
            &lt;property name="comments"/&gt;
            &lt;many-to-one name="salesperson"/&gt;
    &lt;/subclass&gt;
    
&lt;/class&gt;</pre></div><div class="sect2" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="example-mappings-association-alternatekeys"/>23.4.5. Associations sur des clefs alternées</h3></div></div></div><pre class="programlisting">&lt;class name="Person"&gt;
    
    &lt;id name="id"&gt;
        &lt;generator class="hilo"/&gt;
    &lt;/id&gt;
    
    &lt;property name="name" length="100"/&gt;
    
    &lt;one-to-one name="address" 
        property-ref="person"
        cascade="all"
        fetch="join"/&gt;
    
    &lt;set name="accounts" 
        inverse="true"&gt;
        &lt;key column="userId"
            property-ref="userId"/&gt;
        &lt;one-to-many class="Account"/&gt;
    &lt;/set&gt;
    
    &lt;property name="userId" length="8"/&gt;

&lt;/class&gt;

&lt;class name="Address"&gt;

    &lt;id name="id"&gt;
        &lt;generator class="hilo"/&gt;
    &lt;/id&gt;

    &lt;property name="address" length="300"/&gt;
    &lt;property name="zip" length="5"/&gt;
    &lt;property name="country" length="25"/&gt;
    &lt;many-to-one name="person" unique="true" not-null="true"/&gt;

&lt;/class&gt;

&lt;class name="Account"&gt;
    &lt;id name="accountId" length="32"&gt;
        &lt;generator class="uuid"/&gt;
    &lt;/id&gt;
    
    &lt;many-to-one name="user"
        column="userId"
        property-ref="userId"/&gt;
    
    &lt;property name="type" not-null="true"/&gt;
    
&lt;/class&gt;</pre></div></div></div><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="best-practices"/>Chapitre 24. Meilleures pratiques</h2></div></div></div><div class="variablelist"><dl><dt><span class="term">Write fine-grained classes and map them using <code class="literal">&lt;component&gt;</code>:</span></dt><dd><p>Utilisez une classe <code class="literal">Adresse</code> pour encapsuler <code class="literal">Rue</code>, <code class="literal">Region</code>, <code class="literal">CodePostal</code>. Ceci permet la réutilisation du code et simplifie la maintenance. </p></dd><dt><span class="term">Declare identifier properties on persistent classes:</span></dt><dd><p>Hibernate makes identifier properties optional. There are a range of reasons why you should use them. We recommend that identifiers be 'synthetic', that is, generated with no business meaning. </p></dd><dt><span class="term">Identify natural keys:</span></dt><dd><p>Identifiez les clefs naturelles pour toutes les entités, et mappez les avec <code class="literal">&lt;natural-id&gt;</code>. Implémentez <code class="literal">equals()</code> et <code class="literal">hashCode()</code> pour comparer les propriétés qui composent la clef naturelle. </p></dd><dt><span class="term">Place each class mapping in its own file:</span></dt><dd><p>Do not use a single monolithic mapping document. Map <code class="literal">com.eg.Foo</code> in the file <code class="literal">com/eg/Foo.hbm.xml</code>. This makes sense, particularly in a team environment. </p></dd><dt><span class="term">Load mappings as resources:</span></dt><dd><p>Déployez les mappings en même temps que les classes qu'ils mappent. </p></dd><dt><span class="term">Consider externalizing query strings:</span></dt><dd><p>This is recommended if your queries call non-ANSI-standard SQL functions. Externalizing the query strings to mapping files will make the application more portable. </p></dd><dt><span class="term">Utilisez les variables "bindées".</span></dt><dd><p>As in JDBC, always replace non-constant values by "?". Do not use string manipulation to bind a non-constant value in a query. You should also consider using named parameters in queries. </p></dd><dt><span class="term">Do not manage your own JDBC connections:</span></dt><dd><p>Hibernate allows the application to manage JDBC connections, but his approach should be considered a last-resort. If you cannot use the built-in connection providers, consider providing your own implementation of <code class="literal">org.hibernate.connection.ConnectionProvider</code>. </p></dd><dt><span class="term">Consider using a custom type:</span></dt><dd><p>Suppose you have a Java type from a library that needs to be persisted but does not provide the accessors needed to map it as a component. You should consider implementing <code class="literal">org.hibernate.UserType</code>. This approach frees the application code from implementing transformations to/from a Hibernate type. </p></dd><dt><span class="term">Use hand-coded JDBC in bottlenecks:</span></dt><dd><p>In performance-critical areas of the system, some kinds of operations might benefit from direct JDBC. Do not assume, however, that JDBC is necessarily faster. Please wait until you <span class="emphasis"><em>know</em></span> something is a bottleneck. If you need to use direct JDBC, you can open a Hibernate <code class="literal">Session</code> and usingfile:///usr/share/doc/HTML/en-US/index.html that JDBC connection. This way you can still use the same transaction strategy and underlying connection provider. </p></dd><dt><span class="term">Understand <code class="literal">Session</code> flushing:</span></dt><dd><p>Sometimes the Session synchronizes its persistent state with the database. Performance will be affected if this process occurs too often. You can sometimes minimize unnecessary flushing by disabling automatic flushing, or even by changing the order of queries and other operations within a particular transaction. </p></dd><dt><span class="term">In a three tiered architecture, consider using detached objects:</span></dt><dd><p>When using a servlet/session bean architecture, you can pass persistent objects loaded in the session bean to and from the servlet/JSP layer. Use a new session to service each request. Use <code class="literal">Session.merge()</code> or <code class="literal">Session.saveOrUpdate()</code> to synchronize objects with the database. </p></dd><dt><span class="term">In a two tiered architecture, consider using long persistence contexts:</span></dt><dd><p>Database Transactions have to be as short as possible for best scalability. However, it is often necessary to implement long running <span class="emphasis"><em>application transactions</em></span>, a single unit-of-work from the point of view of a user. An application transaction might span several client request/response cycles. It is common to use detached objects to implement application transactions. An appropriate alternative in a two tiered architecture, is to maintain a single open persistence contact session for the whole life cycle of the application transaction. Then simply disconnect from the JDBC connection at the end of each request and reconnect at the beginning of the subsequent request. Never share a single session across more than one application transaction or you will be working with stale data. </p></dd><dt><span class="term">Do not treat exceptions as recoverable:</span></dt><dd><p>This is more of a necessary practice than a "best" practice. When an exception occurs, roll back the <code class="literal">Transaction</code> and close the <code class="literal">Session</code>. If you do not do this, Hibernate cannot guarantee that in-memory state accurately represents the persistent state. For example, do not use <code class="literal">Session.load()</code> to determine if an instance with the given identifier exists on the database; use <code class="literal">Session.get()</code> or a query instead. </p></dd><dt><span class="term">Prefer lazy fetching for associations:</span></dt><dd><p>Use eager fetching sparingly. Use proxies and lazy collections for most associations to classes that are not likely to be completely held in the second-level cache. For associations to cached classes, where there is an a extremely high probability of a cache hit, explicitly disable eager fetching using <code class="literal">lazy="false"</code>. When join fetching is appropriate to a particular use case, use a query with a <code class="literal">left join fetch</code>. </p></dd><dt><span class="term">Use the <span class="emphasis"><em>open session in view</em></span> pattern, or a disciplined <span class="emphasis"><em>assembly phase</em></span> to avoid problems with unfetched data: </span></dt><dd><p>Hibernate frees the developer from writing tedious <span class="emphasis"><em>Data Transfer Objects</em></span> (DTO). In a traditional EJB architecture, DTOs serve dual purposes: first, they work around the problem that entity beans are not serializable; second, they implicitly define an assembly phase where all data to be used by the view is fetched and marshalled into the DTOs before returning control to the presentation tier. Hibernate eliminates the first purpose. Unless you are prepared to hold the persistence context (the session) open across the view rendering process, you will still need an assembly phase. Think of your business methods as having a strict contract with the presentation tier about what data is available in the detached objects. This is not a limitation of Hibernate. It is a fundamental requirement of safe transactional data access. </p></dd><dt><span class="term">Consider abstracting your business logic from Hibernate:</span></dt><dd><p>Hide Hibernate data-access code behind an interface. Combine the <span class="emphasis"><em>DAO</em></span> and <span class="emphasis"><em>Thread Local Session</em></span> patterns. You can even have some classes persisted by handcoded JDBC associated to Hibernate via a <code class="literal">UserType</code>. This advice is, however, intended for "sufficiently large" applications. It is not appropriate for an application with five tables. </p></dd><dt><span class="term">Do not use exotic association mappings:</span></dt><dd><p>Practical test cases for real many-to-many associations are rare. Most of the time you need additional information stored in the "link table". In this case, it is much better to use two one-to-many associations to an intermediate link class. In fact, most associations are one-to-many and many-to-one. For this reason, you should proceed cautiously when using any other association style. </p></dd><dt><span class="term">Prefer bidirectional associations:</span></dt><dd><p>Les associations unidirectionnelles sont plus difficiles à questionner. Dans une grande application, la plupart des associations devraient être navigables dans les deux directions dans les requêtes. </p></dd></dl></div></div><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="portability"/>Chapitre 25. Database Portability Considerations</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#portability-basics">25.1. Portability Basics</a></span></dt><dt><span class="sect1"><a href="#portability-dialect">25.2. Dialect</a></span></dt><dt><span class="sect1"><a href="#portability-dialectresolver">25.3. Dialect resolution</a></span></dt><dt><span class="sect1"><a href="#portability-idgen">25.4. Identifier generation</a></span></dt><dt><span class="sect1"><a href="#portability-functions">25.5. Database functions</a></span></dt><dt><span class="sect1"><a href="#portability-types">25.6. Type mappings</a></span></dt></dl></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="portability-basics"/>25.1. Portability Basics</h2></div></div></div><p>One of the selling points of Hibernate (and really Object/Relational Mapping as a whole) is the notion of database portability. This could mean an internal IT user migrating from one database vendor to another, or it could mean a framework or deployable application consuming Hibernate to simultaneously target multiple database products by their users. Regardless of the exact scenario, the basic idea is that you want Hibernate to help you run against any number of databases without changes to your code, and ideally without any changes to the mapping metadata. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="portability-dialect"/>25.2. Dialect</h2></div></div></div><p>The first line of portability for Hibernate is the dialect, which is a specialization of the <code class="classname">org.hibernate.dialect.Dialect</code> contract. A dialect encapsulates all the differences in how Hibernate must communicate with a particular database to accomplish some task like getting a sequence value or structuring a SELECT query. Hibernate bundles a wide range of dialects for many of the most popular databases. If you find that your particular database is not among them, it is not terribly difficult to write your own. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="portability-dialectresolver"/>25.3. Dialect resolution</h2></div></div></div><p>Originally, Hibernate would always require that users specify which dialect to use. In the case of users looking to simultaneously target multiple databases with their build that was problematic. Generally this required their users to configure the Hibernate dialect or defining their own method of setting that value. </p><p>Starting with version 3.2, Hibernate introduced the notion of automatically detecting the dialect to use based on the <code class="interfacename">java.sql.DatabaseMetaData</code> obtained from a <code class="interfacename">java.sql.Connection</code> to that database. This was much better, expect that this resolution was limited to databases Hibernate know about ahead of time and was in no way configurable or overrideable. </p><p>Starting with version 3.3, Hibernate has a fare more powerful way to automatically determine which dialect to should be used by relying on a series of delegates which implement the <code class="interfacename">org.hibernate.dialect.resolver.DialectResolver</code> which defines only a single method:</p><pre class="programlisting">public Dialect resolveDialect(DatabaseMetaData metaData) throws JDBCConnectionException</pre><p>. The basic contract here is that if the resolver 'understands' the given database metadata then it returns the corresponding Dialect; if not it returns null and the process continues to the next resolver. The signature also identifies <code class="exceptionname">org.hibernate.exception.JDBCConnectionException</code> as possibly being thrown. A JDBCConnectionException here is interpreted to imply a "non transient" (aka non-recoverable) connection problem and is used to indicate an immediate stop to resolution attempts. All other exceptions result in a warning and continuing on to the next resolver. </p><p>The cool part about these resolvers is that users can also register their own custom resolvers which will be processed ahead of the built-in Hibernate ones. This might be useful in a number of different situations: it allows easy integration for auto-detection of dialects beyond those shipped with HIbernate itself; it allows you to specify to use a custom dialect when a particular database is recognized; etc. To register one or more resolvers, simply specify them (seperated by commas, tabs or spaces) using the 'hibernate.dialect_resolvers' configuration setting (see the <code class="constant">DIALECT_RESOLVERS</code> constant on <code class="classname">org.hibernate.cfg.Environment</code>). </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="portability-idgen"/>25.4. Identifier generation</h2></div></div></div><p>When considering portability between databases, another important decision is selecting the identifier generation stratagy you want to use. Originally Hibernate provided the <span class="emphasis"><em>native</em></span> generator for this purpose, which was intended to select between a <span class="emphasis"><em>sequence</em></span>, <span class="emphasis"><em>identity</em></span>, or <span class="emphasis"><em>table</em></span> strategy depending on the capability of the underlying database. However, an insidious implication of this approach comes about when targtetting some databases which support <span class="emphasis"><em>identity</em></span> generation and some which do not. <span class="emphasis"><em>identity</em></span> generation relies on the SQL definition of an IDENTITY (or auto-increment) column to manage the identifier value; it is what is known as a post-insert generation strategy becauase the insert must actually happen before we can know the identifier value. Because Hibernate relies on this identifier value to uniquely reference entities within a persistence context it must then issue the insert immediately when the users requests the entitiy be associated with the session (like via save() e.g.) regardless of current transactional semantics. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p> Hibernate was changed slightly once the implication of this was better understood so that the insert is delayed in cases where that is feasible. </p></div><p> The underlying issue is that the actual semanctics of the application itself changes in these cases. </p><p>Starting with version 3.2.3, Hibernate comes with a set of <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://in.relation.to/2082.lace">enhanced</a> identifier generators targetting portability in a much different way. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p> There are specifically 2 bundled <span class="emphasis"><em>enhanced</em></span>generators: </p><div class="itemizedlist"><ul><li><p> <code class="classname">org.hibernate.id.enhanced.SequenceStyleGenerator</code> </p></li><li><p> <code class="classname">org.hibernate.id.enhanced.TableGenerator</code> </p></li></ul></div><p> </p></div><p> The idea behind these generators is to port the actual semantics of the identifer value generation to the different databases. For example, the <code class="classname">org.hibernate.id.enhanced.SequenceStyleGenerator</code> mimics the behavior of a sequence on databases which do not support sequences by using a table. </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="portability-functions"/>25.5. Database functions</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Avertissement</h2><p>This is an area in Hibernate in need of improvement. In terms of portability concerns, this function handling currently works pretty well from HQL; however, it is quite lacking in all other aspects. </p></div><p>SQL functions can be referenced in many ways by users. However, not all databases support the same set of functions. Hibernate, provides a means of mapping a <span class="emphasis"><em>logical</em></span> function name to a a delegate which knows how to render that particular function, perhaps even using a totally different physical function call. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>Technically this function registration is handled through the <code class="classname">org.hibernate.dialect.function.SQLFunctionRegistry</code> class which is intended to allow users to provide custom function definitions without having to provide a custom dialect. This specific behavior is not fully completed as of yet. </p><p>It is sort of implemented such that users can programatically register functions with the <code class="classname">org.hibernate.cfg.Configuration</code> and those functions will be recognized for HQL. </p></div><p>
        </p></div><div class="sect1" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="portability-types"/>25.6. Type mappings</h2></div></div></div><p>This section scheduled for completion at a later date... </p></div></div><div class="bibliography"><div class="titlepage"><div><div><h2 class="title"><a id="d0e17000"/>References</h2></div></div></div><div class="biblioentry"><a id="biblio-PoEAA"/><p>[<abbr class="abbrev">PoEAA</abbr>] <span class="title"><i>Patterns of Enterprise Application Architecture</i>. </span><span class="isbn">0-321-12742-0. </span><span class="authorgroup">par <span class="firstname">Martin</span> <span class="surname">Fowler</span>. </span><span class="copyright">Copyright © 2003 Pearson Education, Inc.. </span><span class="publisher"><span class="publishername">Addison-Wesley Publishing Company. </span></span></p></div><div class="biblioentry"><a id="biblio-JPwH"/><p>[<abbr class="abbrev">JPwH</abbr>] <span class="title"><i>Java Persistence with Hibernate</i>. </span><span class="subtitle">Second Edition of Hibernate in Action. </span><span class="isbn">1-932394-88-5. </span><span class="bibliomisc">
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.manning.com/bauer2">http://www.manning.com/bauer2</a>
        . </span><span class="authorgroup">par <span class="firstname">Christian</span> <span class="surname">Bauer</span> et <span class="firstname">Gavin</span> <span class="surname">King</span>. </span><span class="copyright">Copyright © 2007 Manning Publications Co.. </span><span class="publisher"><span class="publishername">Manning Publications Co.. </span></span></p></div></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2004 Red Hat Middleware, LLC.</p></a></body></html>