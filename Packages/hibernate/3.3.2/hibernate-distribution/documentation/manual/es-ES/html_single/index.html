<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">HIBERNATE - Persistencia Relacional para Java Idiomático</title><link rel="stylesheet" href="css/hibernate-single.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.72.0"/></head><body><div class="book" lang="es-ES"><div class="titlepage"><div><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><div><h1 class="title"><a id="d0e2"/>HIBERNATE - Persistencia Relacional para Java Idiomático</h1></div><div><h2 class="subtitle">Documentación de Referencia de Hibernate</h2></div><div><div xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="authorgroup"><div class="authors">por <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Gavin</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">King</span>, <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Christian</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Bauer</span>, <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Max</span> <span xmlns="http://www.w3.org/1999/xhtml" class="othername">Rydahl</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Andersen</span>, <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Emmanuel</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Bernard</span>, y <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Steve</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Ebersole</span></div><div class="editors"/><div class="others">and thanks to <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">James</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Cobb</span> (Graphic Design), <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Cheyenne</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Weaver</span> (Graphic Design), y <span xmlns="http://www.w3.org/1999/xhtml" class="othername">Bernardo Antonio Buffa Colom&amp;#x00e9</span></div></div></div><div><p class="releaseinfo">3.3.2.GA</p></div><div><p class="copyright">Copyright © 2004 Red Hat Middleware, LLC.</p></div><div><a href="legalnotice.html">Legal Notice</a></div><div><p class="pubdate">June 24, 2009</p></div></div><hr/></div><div class="toc"><dl><dt><span class="preface"><a href="#preface">Prefacio</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e201">1. Feedback</a></span></dt></dl></dd><dt><span class="chapter"><a href="#tutorial">1. Tutorial</a></span></dt><dd><dl><dt><span class="sect1"><a href="#tutorial-firstapp">1.1. Parte 1 - La primera Aplicación Hibernate</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-firstapp-setup">1.1.1. Setup</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-firstclass">1.1.2. La primera clase</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-mapping">1.1.3. El fichero de mapeo</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-configuration">1.1.4. Configuración de Hibernate</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-mvn">1.1.5. Building with Maven</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-helpers">1.1.6. Esto dirá a Ant que agregue todos los ficheros en el directorio lib que terminen con <code class="literal">.jar</code> al classpath usado para la compilación. También copiará todos los ficheros que no sean código Java al directorio objetivo, por ejemplo, ficheros de configuración y mapeos de Hibernate. Si ahora corres Ant, debes obtener esta salida:</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-workingpersistence">1.1.7. Esto también debe compilar sin problemas. Finalmente necesitamos configurar un sistema de logging (registro). Hibernate usa commons logging y te deja la elección entre Log4J y logging de JDK 1.4. La mayoría de los desarrolladores prefieren Log4J: copia <code class="literal">log4j.properties</code> de la distribución de Hibernate (está en el directorio <code class="literal">etc/</code>) a tu directorio <code class="literal">src</code>, junto a <code class="literal">hibernate.cfg.xml</code>. Echa una mirada a la configuración de ejemplo y cambia los ajustes si te gusta tener una salida más verborrágica. Por defecto, sólo se muestra el mensaje de arranque de Hibernate en la salida.</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-associations">1.2. Note: Most new Hibernate users fail at this point and we see questions about <span class="emphasis"><em>Table not found</em></span> error messages regularly. However, if you follow the steps outlined above you will not have this problem, as hbm2ddl creates the database schema on the first run, and subsequent application restarts will use this schema. If you change the mapping and/or database schema, you have to re-enable hbm2ddl once again.</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-associations-mappinguser">1.2.1. Hemos mapeado un clase de entidad persistente a una tabla. Construyamos sobre esto y agreguemos algunas asociaciones de clase. Primero agregaremos personas a nuestra aplicación, y almacenaremos una lista de eventos en las que participan.</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-unidirset">1.2.2. Crearemos ahora una asociación entre estas dos entidades. Obviamente, las personas pueden participar en eventos, y los eventos tienen participantes. Las cuestiones de diseño con que tenemos que tratar son: direccionalidad, multiplicidad y comportamiento de colección.</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-working">1.2.3. 
    _____________        __________________
   |             |      |                  |       _____________
   |   EVENTS    |      |   PERSON_EVENT   |      |             |
   |_____________|      |__________________|      |    PERSON   |
   |             |      |                  |      |_____________|
   | *EVENT_ID   | &lt;--&gt; | *EVENT_ID        |      |             |
   |  EVENT_DATE |      | *PERSON_ID       | &lt;--&gt; | *PERSON_ID  |
   |  TITLE      |      |__________________|      |  AGE        |
   |_____________|                                |  FIRSTNAME  |
                                                  |  LASTNAME   |
                                                  |_____________|
 </a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-valuecollections">1.2.4. Colección de valores</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-bidirectional">1.2.5. Asociaciones bidireccionales</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-usingbidir">1.2.6. Trabajando enlaces bidireccionales</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-webapp">1.3. Part 3 - The EventManager web application</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-webapp-servlet">1.3.1. Writing the basic servlet</a></span></dt><dt><span class="sect2"><a href="#tutorial-webapp-processing">1.3.2. Processing and rendering</a></span></dt><dt><span class="sect2"><a href="#tutorial-webapp-deploy">1.3.3. Deploying and testing</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-summary">1.4. Summary</a></span></dt></dl></dd><dt><span class="chapter"><a href="#architecture">2. Arquitectura</a></span></dt><dd><dl><dt><span class="sect1"><a href="#architecture-overview">2.1. Visión General</a></span></dt><dt><span class="sect1"><a href="#architecture-states">2.2. Estados de instancia</a></span></dt><dt><span class="sect1"><a href="#architecture-jmx">2.3. Integración JMX</a></span></dt><dt><span class="sect1"><a href="#architecture-jca">2.4. Soporte JCA:</a></span></dt><dt><span class="sect1"><a href="#architecture-current-session">2.5. Contextual sessions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#session-configuration">3. Configuración</a></span></dt><dd><dl><dt><span class="sect1"><a href="#configuration-programmatic">3.1. Configuración programática</a></span></dt><dt><span class="sect1"><a href="#configuration-sessionfactory">3.2. Obteniendo una SessionFactory</a></span></dt><dt><span class="sect1"><a href="#configuration-hibernatejdbc">3.3. Conexiones JDBC</a></span></dt><dt><span class="sect1"><a href="#configuration-optional">3.4. Parámetros de configuración opcionales</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuration-optional-dialects">3.4.1. SQL Dialects</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-outerjoin">3.4.2. Recuperación por Unión Externa (Outer Join Fetching)</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-binarystreams">3.4.3. Flujos Binarios</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-cacheprovider">3.4.4. Caché de segundo nivel y de lectura</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-querysubstitution">3.4.5. Sustitución de Lenguaje de Consulta</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-statistics">3.4.6. Hibernate statistics</a></span></dt></dl></dd><dt><span class="sect1"><a href="#configuration-logging">3.5. Registros de mensajes (Logging)</a></span></dt><dt><span class="sect1"><a href="#configuration-namingstrategy">3.6. Implementando una <code class="literal">NamingStrategy</code></a></span></dt><dt><span class="sect1"><a href="#configuration-xmlconfig">3.7. Fichero de configuración XML</a></span></dt><dt><span class="sect1"><a href="#configuration-j2ee">3.8. Integració con Servidores de Aplicaciones J2EE</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuration-optional-transactionstrategy">3.8.1. Configuración de la estrategia de transacción</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-jndi">3.8.2. <code class="literal">SessionFactory</code> ligada a JNDI</a></span></dt><dt><span class="sect2"><a href="#configuration-j2ee-currentsession">3.8.3. Ligado automático de JTA y Session</a></span></dt><dt><span class="sect2"><a href="#configuration-j2ee-jmx">3.8.4. Despliegue JMX</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#persistent-classes">4. Clases Persistentes</a></span></dt><dd><dl><dt><span class="sect1"><a href="#persistent-classes-pojo">4.1. Un ejemplo simple de POJO</a></span></dt><dd><dl><dt><span class="sect2"><a href="#persistent-classes-pojo-constructor">4.1.1. Implementa un constructor sin argumentos</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-identifier">4.1.2. Provee una propiedad identificadora (opcional)</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-final">4.1.3. Prefiere las clases no finales (opcional)</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-accessors">4.1.4. Declara métodos de acceso y modificación para los campos persistentes (opcional)</a></span></dt></dl></dd><dt><span class="sect1"><a href="#persistent-classes-inheritance">4.2. Implementando herencia</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-equalshashcode">4.3. Implementando <code class="literal">equals()</code> y <code class="literal">hashCode()</code></a></span></dt><dt><span class="sect1"><a href="#persistent-classes-dynamicmodels">4.4. Modelos dinámicos</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-tuplizers">4.5. UNTRANSLATED!!! Tuplizers</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-entity-name-resolver">4.6. EntityNameResolvers</a></span></dt></dl></dd><dt><span class="chapter"><a href="#mapping">5. Mapeo O/R Básico</a></span></dt><dd><dl><dt><span class="sect1"><a href="#mapping-declaration">5.1. Declaración de mapeo</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-declaration-doctype">5.1.1. Doctype</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-mapping">5.1.2. Hibernate-mapping</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-class">5.1.3. Class</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id">5.1.4. id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id-enhanced">5.1.5. Enhanced identifier generators</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id-enhanced-optimizers">5.1.6. Identifier generator optimization</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-compositeid">5.1.7. composite-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-discriminator">5.1.8. Discriminator</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-version">5.1.9. Version (optional)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-timestamp">5.1.10. Timestamp (optional)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-property">5.1.11. Property</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-manytoone">5.1.12. Many-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-onetoone">5.1.13. One-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-naturalid">5.1.14. Natural-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-component">5.1.15. Component and dynamic-component</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-properties">5.1.16. Properties</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-subclass">5.1.17. Subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-joinedsubclass">5.1.18. Joined-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-unionsubclass">5.1.19. Union-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-join">5.1.20. Join</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-key">5.1.21. Key</a></span></dt><dt><span class="sect2"><a href="#mapping-column">5.1.22. Column and formula elements</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-import">5.1.23. Import</a></span></dt><dt><span class="sect2"><a href="#mapping-types-anymapping">5.1.24. Any</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-types">5.2. Hibernate types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-types-entitiesvalues">5.2.1. Entidades y Valores</a></span></dt><dt><span class="sect2"><a href="#mapping-types-basictypes">5.2.2. Tipos de valores básicos</a></span></dt><dt><span class="sect2"><a href="#mapping-types-custom">5.2.3. Tipos de valor personalizados</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-entityname">5.3. Mapeando una clase más de una vez</a></span></dt><dt><span class="sect1"><a href="#mapping-quotedidentifiers">5.4. identificadores SQL encomillados</a></span></dt><dt><span class="sect1"><a href="#mapping-alternatives">5.5. Alternativas de metadatos</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-xdoclet">5.5.1. Usando marcado de XDoclet</a></span></dt><dt><span class="sect2"><a href="#mapping-annotations">5.5.2. Usando anotaciones JDK 5.0</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-generated">5.6. Generated properties</a></span></dt><dt><span class="sect1"><a href="#mapping-database-object">5.7. Auxiliary database objects</a></span></dt></dl></dd><dt><span class="chapter"><a href="#collections">6. Collection mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#collections-persistent">6.1. Colecciones persistentes</a></span></dt><dt><span class="sect1"><a href="#collections-mapping">6.2. Mapeos de colección</a></span></dt><dd><dl><dt><span class="sect2"><a href="#collections-foreignkeys">6.2.1. Claves foráneas de collección</a></span></dt><dt><span class="sect2"><a href="#collections-elements">6.2.2. Elementos de collección</a></span></dt><dt><span class="sect2"><a href="#collections-indexed">6.2.3. Colecciones indexadas</a></span></dt><dt><span class="sect2"><a href="#collections-ofvalues">6.2.4. Colecciones de valores y asociaciones muchos-a-muchos</a></span></dt><dt><span class="sect2"><a href="#collections-onetomany">6.2.5. Asociaciones uno-a-muchos</a></span></dt></dl></dd><dt><span class="sect1"><a href="#collections-advancedmappings">6.3. Mapeos de colección avanzados</a></span></dt><dd><dl><dt><span class="sect2"><a href="#collections-sorted">6.3.1. Colecciones ordenadas</a></span></dt><dt><span class="sect2"><a href="#collections-bidirectional">6.3.2. Asociaciones bidireccionales</a></span></dt><dt><span class="sect2"><a href="#collections-indexedbidirectional">6.3.3. Asociaciones bidireccionales con colecciones indexadas</a></span></dt><dt><span class="sect2"><a href="#collections-ternary">6.3.4. Asociaciones ternarias</a></span></dt><dt><span class="sect2"><a href="#collections-idbag">6.3.5. <code class="literal">Usando un &lt;idbag&gt;</code></a></span></dt></dl></dd><dt><span class="sect1"><a href="#collections-example">6.4. Ejemplos de colección</a></span></dt></dl></dd><dt><span class="chapter"><a href="#associations">7. Mapeos de Asociación</a></span></dt><dd><dl><dt><span class="sect1"><a href="#assoc-intro">7.1. Introducción</a></span></dt><dt><span class="sect1"><a href="#assoc-unidirectional">7.2. Asociaciones Unidireccionales</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-unidirectional-m21">7.2.1. Many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-121">7.2.2. One-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-12m">7.2.3. One-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-unidirectional-join">7.3. Asociaciones unidireccionales con tablas de unión</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-unidirectional-join-12m">7.3.1. One-to-many</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-m21">7.3.2. Many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-121">7.3.3. One-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-m2m">7.3.4. Many-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-bidirectional">7.4. Asociaciones Bidireccionales</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-bidirectional-m21">7.4.1. one-to-many / many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-121">7.4.2. One-to-one</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-bidirectional-join">7.5. Asociaciones bidireccionales con tablas de unión</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-bidirectional-join-12m">7.5.1. one-to-many / many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-join-121">7.5.2. uno a uno</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-join-m2m">7.5.3. Many-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-complex">7.6. UNTRANSLATED! More complex association mappings</a></span></dt></dl></dd><dt><span class="chapter"><a href="#components">8. Mapeo de Componentes</a></span></dt><dd><dl><dt><span class="sect1"><a href="#components-dependentobjects">8.1. Objetos dependientes</a></span></dt><dt><span class="sect1"><a href="#components-incollections">8.2. Colecciones de objetos dependientes</a></span></dt><dt><span class="sect1"><a href="#components-asmapindex">8.3. Componentes como índices de Map</a></span></dt><dt><span class="sect1"><a href="#components-compositeid">8.4. Componentes como identificadores compuestos</a></span></dt><dt><span class="sect1"><a href="#components-dynamic">8.5. Componentes dinámicos</a></span></dt></dl></dd><dt><span class="chapter"><a href="#inheritance">9. Inheritance mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#inheritance-strategies">9.1. The three strategies</a></span></dt><dd><dl><dt><span class="sect2"><a href="#inheritance-tableperclass">9.1.1. Tabla por jerarquía de clases</a></span></dt><dt><span class="sect2"><a href="#inheritance-tablepersubclass">9.1.2. Tabla por subclase</a></span></dt><dt><span class="sect2"><a href="#inheritance-tablepersubclass-discriminator">9.1.3. Table per subclass: using a discriminator</a></span></dt><dt><span class="sect2"><a href="#inheritance-mixing-tableperclass-tablepersubclass">9.1.4. Mezclando tabla por jerarquía de clases con tabla por subclase</a></span></dt><dt><span class="sect2"><a href="#inheritance-tableperconcrete">9.1.5. Tabla por clase concreta</a></span></dt><dt><span class="sect2"><a href="#inheritance-tableperconcreate-polymorphism">9.1.6. Table per concrete class using implicit polymorphism</a></span></dt><dt><span class="sect2"><a href="#inheritance-mixingpolymorphism">9.1.7. Mezclando polimorfismo implícito con otros mapeos de herencia</a></span></dt></dl></dd><dt><span class="sect1"><a href="#inheritance-limitations">9.2. Limitaciones</a></span></dt></dl></dd><dt><span class="chapter"><a href="#objectstate">10. Trabajando con objetos</a></span></dt><dd><dl><dt><span class="sect1"><a href="#objectstate-overview">10.1. Estados de objeto de Hibernate</a></span></dt><dt><span class="sect1"><a href="#objectstate-makingpersistent">10.2. Haciendo los objetos persistentes</a></span></dt><dt><span class="sect1"><a href="#objectstate-loading">10.3. Cargando un objeto</a></span></dt><dt><span class="sect1"><a href="#objectstate-querying">10.4. Consultando</a></span></dt><dd><dl><dt><span class="sect2"><a href="#objectstate-querying-executing">10.4.1. Ejecutando consultas</a></span></dt><dt><span class="sect2"><a href="#objectstate-filtering">10.4.2. Filtrando colecciones</a></span></dt><dt><span class="sect2"><a href="#objecstate-querying-criteria">10.4.3. Consultas de criterios</a></span></dt><dt><span class="sect2"><a href="#objectstate-querying-nativesql">10.4.4. Consultas en SQL nativo</a></span></dt></dl></dd><dt><span class="sect1"><a href="#objectstate-modifying">10.5. Modificando objetos persistentes</a></span></dt><dt><span class="sect1"><a href="#objectstate-detached">10.6. Modificando objetos separados</a></span></dt><dt><span class="sect1"><a href="#objectstate-saveorupdate">10.7. Detección automática de estado</a></span></dt><dt><span class="sect1"><a href="#objectstate-deleting">10.8. Borrando objetos persistentes</a></span></dt><dt><span class="sect1"><a href="#objectstate-replicating">10.9. Replicando objetos entre dos almacénes de datos diferentes</a></span></dt><dt><span class="sect1"><a href="#objectstate-flushing">10.10. Limpiando (flushing) la sesión</a></span></dt><dt><span class="sect1"><a href="#objectstate-transitive">10.11. Persistencia transitiva</a></span></dt><dt><span class="sect1"><a href="#objectstate-metadata">10.12. Usando metadatos</a></span></dt></dl></dd><dt><span class="chapter"><a href="#transactions">11. Transactions and Concurrency</a></span></dt><dd><dl><dt><span class="sect1"><a href="#transactions-basics">11.1. Ámbitos de sesión y de transacción</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-basics-uow">11.1.1. Unidad de trabajo</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-apptx">11.1.2. Transacciones de aplicación</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-identity">11.1.3. Considerando la identidad del objeto</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-issues">11.1.4. Temas comunes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-demarcation">11.2. Demarcación de la transacción de base de datos</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-demarcation-nonmanaged">11.2.1. Entorno no manejado</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-jta">11.2.2. Usando JTA</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-exceptions">11.2.3. Manejo de excepciones</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-timeout">11.2.4. Transaction timeout</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-optimistic">11.3. Control optimista de concurrencia</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-optimistic-manual">11.3.1. Chequeo de versiones de aplicación</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-longsession">11.3.2. Sesión larga y versionado automático</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-detached">11.3.3. Objetos separados y versionado automático</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-customizing">11.3.4. Personalizando el versionado automático</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-locking">11.4. Pessimistic locking</a></span></dt><dt><span class="sect1"><a href="#transactions-connection-release">11.5. Connection release modes</a></span></dt></dl></dd><dt><span class="chapter"><a href="#events">12. Interceptores y eventos</a></span></dt><dd><dl><dt><span class="sect1"><a href="#objectstate-interceptors">12.1. Interceptores</a></span></dt><dt><span class="sect1"><a href="#objectstate-events">12.2. Sistema de eventos</a></span></dt><dt><span class="sect1"><a href="#objectstate-decl-security">12.3. Seguridad declarativa de Hibernate</a></span></dt></dl></dd><dt><span class="chapter"><a href="#batch">13. Procesamiento por lotes</a></span></dt><dd><dl><dt><span class="sect1"><a href="#batch-inserts">13.1. Inserciones en lote</a></span></dt><dt><span class="sect1"><a href="#batch-update">13.2. Actualizaciones en lote</a></span></dt><dt><span class="sect1"><a href="#batch-statelesssession">13.3. UNTRANSLATED! The StatelessSession interface</a></span></dt><dt><span class="sect1"><a href="#batch-direct">13.4. update/delete en masa</a></span></dt></dl></dd><dt><span class="chapter"><a href="#queryhql">14. HQL: El Lenguaje de Consulta de Hibernate</a></span></dt><dd><dl><dt><span class="sect1"><a href="#queryhql-casesensitivity">14.1. Sensibilidad a Mayúsculas</a></span></dt><dt><span class="sect1"><a href="#queryhql-from">14.2. La cláusula from</a></span></dt><dt><span class="sect1"><a href="#queryhql-joins">14.3. Asociaciones y uniones (joins)</a></span></dt><dt><span class="sect1"><a href="#queryhql-joins-forms">14.4. UNTRANSLATED!!! Forms of join syntax</a></span></dt><dt><span class="sect1"><a href="#queryhql-identifier-property">14.5. Referring to identifier property</a></span></dt><dt><span class="sect1"><a href="#queryhql-select">14.6. La cláusula select</a></span></dt><dt><span class="sect1"><a href="#queryhql-aggregation">14.7. Funciones de agregación</a></span></dt><dt><span class="sect1"><a href="#queryhql-polymorphism">14.8. Consultas polimórficas</a></span></dt><dt><span class="sect1"><a href="#queryhql-where">14.9. La cláusula where</a></span></dt><dt><span class="sect1"><a href="#queryhql-expressions">14.10. Expresiones</a></span></dt><dt><span class="sect1"><a href="#queryhql-ordering">14.11. La cláusula order by</a></span></dt><dt><span class="sect1"><a href="#queryhql-grouping">14.12. La cláusula group by</a></span></dt><dt><span class="sect1"><a href="#queryhql-subqueries">14.13. Subconsultas</a></span></dt><dt><span class="sect1"><a href="#queryhql-examples">14.14. Ejemplos de HQL</a></span></dt><dt><span class="sect1"><a href="#queryhql-bulk">14.15. Sentencias UPDATE y DELETE masivas</a></span></dt><dt><span class="sect1"><a href="#queryhql-tipstricks">14.16. Consejos y Trucos</a></span></dt><dt><span class="sect1"><a href="#queryhql-components">14.17. UNTRANSLATED! Components</a></span></dt><dt><span class="sect1"><a href="#queryhql-tuple">14.18. Row value constructor syntax</a></span></dt></dl></dd><dt><span class="chapter"><a href="#querycriteria">15. Consultas por Criterios</a></span></dt><dd><dl><dt><span class="sect1"><a href="#querycriteria-creating">15.1. Creando una instancia de <code class="literal">Criteria</code></a></span></dt><dt><span class="sect1"><a href="#querycriteria-narrowing">15.2. Estrechando el conjunto resultado</a></span></dt><dt><span class="sect1"><a href="#querycriteria-ordering">15.3. Ordenando los resultados</a></span></dt><dt><span class="sect1"><a href="#querycriteria-associations">15.4. Asociaciones</a></span></dt><dt><span class="sect1"><a href="#querycriteria-dynamicfetching">15.5. Recuperación dinámica de asociaciones</a></span></dt><dt><span class="sect1"><a href="#querycriteria-examples">15.6. Consultas por ejemplos</a></span></dt><dt><span class="sect1"><a href="#querycriteria-projection">15.7. Proyecciones, agregación y agrupamiento</a></span></dt><dt><span class="sect1"><a href="#querycriteria-detachedqueries">15.8. Consultas y subconsultas separadas</a></span></dt><dt><span class="sect1"><a href="#query-criteria-naturalid">15.9. Consultas por identificador natural</a></span></dt></dl></dd><dt><span class="chapter"><a href="#querysql">16. SQL Nativo</a></span></dt><dd><dl><dt><span class="sect1"><a href="#querysql-creating">16.1. Using a <code class="literal">SQLQuery</code></a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e13411">16.1.1. Scalar queries</a></span></dt><dt><span class="sect2"><a href="#d0e13461">16.1.2. Entity queries</a></span></dt><dt><span class="sect2"><a href="#d0e13497">16.1.3. Handling associations and collections</a></span></dt><dt><span class="sect2"><a href="#d0e13528">16.1.4. Returning multiple entities</a></span></dt><dt><span class="sect2"><a href="#d0e13669">16.1.5. Returning non-managed entities</a></span></dt><dt><span class="sect2"><a href="#d0e13690">16.1.6. Handling inheritance</a></span></dt><dt><span class="sect2"><a href="#d0e13695">16.1.7. Parameters</a></span></dt></dl></dd><dt><span class="sect1"><a href="#querysql-namedqueries">16.2. Consultas SQL con nombre</a></span></dt><dd><dl><dt><span class="sect2"><a href="#propertyresults">16.2.1. Usando return-property para especificar explícitamente nombres de columna/alias</a></span></dt><dt><span class="sect2"><a href="#sp_query">16.2.2. Usando procedimientos almacenados para consultar</a></span></dt></dl></dd><dt><span class="sect1"><a href="#querysql-cud">16.3. SQL personalizado para crear, actualizar y borrar</a></span></dt><dt><span class="sect1"><a href="#querysql-load">16.4. SQL personalizado para carga</a></span></dt></dl></dd><dt><span class="chapter"><a href="#filters">17. Filtrando datos</a></span></dt><dd><dl><dt><span class="sect1"><a href="#objectstate-filters">17.1. Filtros de Hibernate</a></span></dt></dl></dd><dt><span class="chapter"><a href="#xml">18. Mapeo XML</a></span></dt><dd><dl><dt><span class="sect1"><a href="#xml-intro">18.1. Trabajando con datos XML</a></span></dt><dd><dl><dt><span class="sect2"><a href="#xml-intro-mapping">18.1.1. Especificando los mapeos de XML y de clase juntos</a></span></dt><dt><span class="sect2"><a href="#xml-onlyxml">18.1.2. Especificando sólo un mapeo XML</a></span></dt></dl></dd><dt><span class="sect1"><a href="#xml-mapping">18.2. Mapeo de metadatos XML</a></span></dt><dt><span class="sect1"><a href="#xml-manipulation">18.3. Manipulando datos XML</a></span></dt></dl></dd><dt><span class="chapter"><a href="#performance">19. Mejorando el rendimiento</a></span></dt><dd><dl><dt><span class="sect1"><a href="#performance-fetching">19.1. Estrategias de recuperación</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-fetching-lazy">19.1.1. Trabajando con asociaciones perezosas</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-custom">19.1.2. Afinando las estrategias de recuperación</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-proxies">19.1.3. Proxies de asociaciones de un solo extremo</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-initialization">19.1.4. Inicializando colecciones y proxies</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-batch">19.1.5. Usando recuperación en lotes</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-subselect">19.1.6. Usando recuperación por subselección</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-lazyproperties">19.1.7. Usando recuperación perezosa de propiedades</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-cache">19.2. El Caché de Segundo Nivel</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-cache-mapping">19.2.1. Mapeos de caché</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readonly">19.2.2. Estrategia: sólo lectura (read only)</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readwrite">19.2.3. Estrategia: lectura/escritura (read/write)</a></span></dt><dt><span class="sect2"><a href="#performance-cache-nonstrict">19.2.4. Estrategia: lectura/escritura no estricta (nonstrict read/write)</a></span></dt><dt><span class="sect2"><a href="#performance-cache-transactional">19.2.5. Estrategia: transaccional</a></span></dt><dt><span class="sect2"><a href="#performance-cache-compat-matrix">19.2.6. Cache-provider/concurrency-strategy compatibility</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-sessioncache">19.3. Gestionando los cachés</a></span></dt><dt><span class="sect1"><a href="#performance-querycache">19.4. El Caché de Consultas</a></span></dt><dt><span class="sect1"><a href="#performance-collections">19.5. Entendiendo el rendimiento de Colecciones</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-collections-taxonomy">19.5.1. Taxonomia</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficientupdate">19.5.2. Las listas, mapas, idbags y conjuntos son las colecciones más eficientes de actualizar</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficentinverse">19.5.3. Los Bags y las listas son las colecciones inversas más eficientes</a></span></dt><dt><span class="sect2"><a href="#performance-collections-oneshotdelete">19.5.4. Borrado de un solo tiro</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-monitoring">19.6. Monitoreando el rendimiento</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-monitoring-sf">19.6.1. Monitoreando una SessionFactory</a></span></dt><dt><span class="sect2"><a href="#performance-monitoring-metrics">19.6.2. Métricas</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#toolsetguide">20. Guía del Conjunto de Herramientas</a></span></dt><dd><dl><dt><span class="sect1"><a href="#toolsetguide-s1">20.1. Generación automática de esquemas</a></span></dt><dd><dl><dt><span class="sect2"><a href="#toolsetguide-s1-2">20.1.1. Personalizando el esquema</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-3">20.1.2. Ejecutando la herramienta</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-4">20.1.3. Propiedades</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-5">20.1.4. Usando Ant</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-6">20.1.5. Actualizaciones incrementales de esquema</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-7">20.1.6. Usando Ant para actualizaciones incrementales de esquema</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-8">20.1.7. Schema validation</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-9">20.1.8. Using Ant for schema validation</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#example-parentchild">21. Ejemplo: Padre/Hijo</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-parentchild-collections">21.1. Una nota sobre las colecciones</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-bidir">21.2. Uno-a-muchos bidirectional</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-cascades">21.3. Ciclo de vida en cascada</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-update">21.4. Tratamiento en cascada y <code class="literal">unsaved-value</code></a></span></dt><dt><span class="sect1"><a href="#example-parentchild-conclusion">21.5. Conclusión</a></span></dt></dl></dd><dt><span class="chapter"><a href="#example-weblog">22. Ejemplo: Aplicación de Weblog</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-weblog-classes">22.1. Clases Persistentes</a></span></dt><dt><span class="sect1"><a href="#example-weblog-mappings">22.2. Mapeos de Hibernate</a></span></dt><dt><span class="sect1"><a href="#example-weblog-code">22.3. Código Hibernate</a></span></dt></dl></dd><dt><span class="chapter"><a href="#example-mappings">23. Ejemplo: Varios Mapeos</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-mappings-emp">23.1. Empleador/Empleado</a></span></dt><dt><span class="sect1"><a href="#example-mappings-authorwork">23.2. Autor/Obra</a></span></dt><dt><span class="sect1"><a href="#example-mappings-customerorderproduct">23.3. Cliente/Orden/Producto</a></span></dt><dt><span class="sect1"><a href="#misc">23.4. Mapeos misceláneos de ejemplo</a></span></dt><dd><dl><dt><span class="sect2"><a href="#example-mappings-typed-onetone">23.4.1. Asociación uno-a-uno "Tipificada"</a></span></dt><dt><span class="sect2"><a href="#example-mappings-composite-key">23.4.2. Ejemplo de clave compuesta</a></span></dt><dt><span class="sect2"><a href="#example-mappings-composite-key-manytomany">23.4.3. Muchos-a-muchos con atributo de clave compuesta compartido</a></span></dt><dt><span class="sect2"><a href="#example-mappings-content-discrimination">23.4.4. Discriminación basada en contenido</a></span></dt><dt><span class="sect2"><a href="#example-mappings-association-alternatekeys">23.4.5. Asociaciones sobre claves alternativas</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#best-practices">24. Mejores Prácticas</a></span></dt><dt><span class="chapter"><a href="#portability">25. Database Portability Considerations</a></span></dt><dd><dl><dt><span class="sect1"><a href="#portability-basics">25.1. Portability Basics</a></span></dt><dt><span class="sect1"><a href="#portability-dialect">25.2. Dialect</a></span></dt><dt><span class="sect1"><a href="#portability-dialectresolver">25.3. Dialect resolution</a></span></dt><dt><span class="sect1"><a href="#portability-idgen">25.4. Identifier generation</a></span></dt><dt><span class="sect1"><a href="#portability-functions">25.5. Database functions</a></span></dt><dt><span class="sect1"><a href="#portability-types">25.6. Type mappings</a></span></dt></dl></dd><dt><span class="bibliography"><a href="#d0e16988">References</a></span></dt></dl></div><div class="preface" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="preface"/>Prefacio</h2></div></div></div><p>Working with object-oriented software and a relational database can be cumbersome and time consuming in today's enterprise environments. Hibernate is an Object/Relational Mapping tool for Java environments. The term Object/Relational Mapping (ORM) refers to the technique of mapping a data representation from an object model to a relational data model with a SQL-based schema. </p><p>Hibernate not only takes care of the mapping from Java classes to database tables (and from Java data types to SQL data types), but also provides data query and retrieval facilities. It can also significantly reduce development time otherwise spent with manual data handling in SQL and JDBC. </p><p>Hibernate's goal is to relieve the developer from 95 percent of common data persistence related programming tasks. Hibernate may not be the best solution for data-centric applications that only use stored-procedures to implement the business logic in the database, it is most useful with object-oriented domain models and business logic in the Java-based middle-tier. However, Hibernate can certainly help you to remove or encapsulate vendor-specific SQL code and will help with the common task of result set translation from a tabular representation to a graph of objects. </p><p>Si eres nuevo en Hibernate y lo del Mapeo Objeto/Relacional o incluso en Java, sigue por favor estos pasos: </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>Lee <a href="#tutorial" title="Capítulo 1. Tutorial">Capítulo 1, <i xmlns:xlink="http://www.w3.org/1999/xlink">Tutorial</i></a> para un tutorial de 30 minutos, usando Tomcat. </p></li><li><p>Lee <a href="#architecture" title="Capítulo 2. Arquitectura">Capítulo 2, <i xmlns:xlink="http://www.w3.org/1999/xlink">Arquitectura</i></a> para entender los entornos en los que puede ser usado Hibernate. </p></li><li><p>View the <code class="literal">eg/</code> directory in the Hibernate distribution. It contains a simple standalone application. Copy your JDBC driver to the <code class="literal">lib/</code> directory and edit <code class="literal">etc/hibernate.properties</code>, specifying correct values for your database. From a command prompt in the distribution directory, type <code class="literal">ant eg</code> (using Ant), or under Windows, type <code class="literal">build eg</code>. </p></li><li><p>Use this reference documentation as your primary source of information. Consider reading [<a xmlns:xlink="http://www.w3.org/1999/xlink" href="#biblio-JPwH" title="[JPwH]"><abbr class="abbrev">JPwH</abbr></a>] if you need more help with application design, or if you prefer a step-by-step tutorial. Also visit <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://caveatemptor.hibernate.org">http://caveatemptor.hibernate.org</a> and download the example application from [<a xmlns:xlink="http://www.w3.org/1999/xlink" href="#biblio-JPwH" title="[JPwH]"><abbr class="abbrev">JPwH</abbr></a>]. </p></li><li><p>Los FAQs son respondidos en el sitio web de Hibernate. </p></li><li><p>Links to third party demos, examples, and tutorials are maintained on the Hibernate website. </p></li><li><p>El Area de Comunidad en el sitio web de Hibernate es una buena fuente de patrones de diseño y varias soluciones de integración (Tomcat, JBoss, Struts, EJB, etc.). </p></li></ol></div><p>If you have questions, use the user forum linked on the Hibernate website. We also provide a JIRA issue tracking system for bug reports and feature requests. If you are interested in the development of Hibernate, join the developer mailing list. If you are interested in translating this documentation into your language, contact us on the developer mailing list. </p><p>A través de JBoss Inc. (see http://www.hibernate.org/SupportTraining/) hay disponibilidad de soporte comercial de desarrollo, soporte de producción y entrenamiento en Hibernate. Hibernate es un proyecto de la suite de productos de código abierto JBoss Professional. </p><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="d0e201"/>1. Feedback</h2></div></div></div><p>Use <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://opensource.atlassian.com/projects/hibernate">Hibernate JIRA</a> to report errors or request enhacements to this documentation. </p></div></div><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial"/>Capítulo 1. Tutorial</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#tutorial-firstapp">1.1. Parte 1 - La primera Aplicación Hibernate</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-firstapp-setup">1.1.1. Setup</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-firstclass">1.1.2. La primera clase</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-mapping">1.1.3. El fichero de mapeo</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-configuration">1.1.4. Configuración de Hibernate</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-mvn">1.1.5. Building with Maven</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-helpers">1.1.6. Esto dirá a Ant que agregue todos los ficheros en el directorio lib que terminen con <code class="literal">.jar</code> al classpath usado para la compilación. También copiará todos los ficheros que no sean código Java al directorio objetivo, por ejemplo, ficheros de configuración y mapeos de Hibernate. Si ahora corres Ant, debes obtener esta salida:</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-workingpersistence">1.1.7. Esto también debe compilar sin problemas. Finalmente necesitamos configurar un sistema de logging (registro). Hibernate usa commons logging y te deja la elección entre Log4J y logging de JDK 1.4. La mayoría de los desarrolladores prefieren Log4J: copia <code class="literal">log4j.properties</code> de la distribución de Hibernate (está en el directorio <code class="literal">etc/</code>) a tu directorio <code class="literal">src</code>, junto a <code class="literal">hibernate.cfg.xml</code>. Echa una mirada a la configuración de ejemplo y cambia los ajustes si te gusta tener una salida más verborrágica. Por defecto, sólo se muestra el mensaje de arranque de Hibernate en la salida.</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-associations">1.2. Note: Most new Hibernate users fail at this point and we see questions about <span class="emphasis"><em>Table not found</em></span> error messages regularly. However, if you follow the steps outlined above you will not have this problem, as hbm2ddl creates the database schema on the first run, and subsequent application restarts will use this schema. If you change the mapping and/or database schema, you have to re-enable hbm2ddl once again.</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-associations-mappinguser">1.2.1. Hemos mapeado un clase de entidad persistente a una tabla. Construyamos sobre esto y agreguemos algunas asociaciones de clase. Primero agregaremos personas a nuestra aplicación, y almacenaremos una lista de eventos en las que participan.</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-unidirset">1.2.2. Crearemos ahora una asociación entre estas dos entidades. Obviamente, las personas pueden participar en eventos, y los eventos tienen participantes. Las cuestiones de diseño con que tenemos que tratar son: direccionalidad, multiplicidad y comportamiento de colección.</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-working">1.2.3. 
    _____________        __________________
   |             |      |                  |       _____________
   |   EVENTS    |      |   PERSON_EVENT   |      |             |
   |_____________|      |__________________|      |    PERSON   |
   |             |      |                  |      |_____________|
   | *EVENT_ID   | &lt;--&gt; | *EVENT_ID        |      |             |
   |  EVENT_DATE |      | *PERSON_ID       | &lt;--&gt; | *PERSON_ID  |
   |  TITLE      |      |__________________|      |  AGE        |
   |_____________|                                |  FIRSTNAME  |
                                                  |  LASTNAME   |
                                                  |_____________|
 </a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-valuecollections">1.2.4. Colección de valores</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-bidirectional">1.2.5. Asociaciones bidireccionales</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-usingbidir">1.2.6. Trabajando enlaces bidireccionales</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-webapp">1.3. Part 3 - The EventManager web application</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-webapp-servlet">1.3.1. Writing the basic servlet</a></span></dt><dt><span class="sect2"><a href="#tutorial-webapp-processing">1.3.2. Processing and rendering</a></span></dt><dt><span class="sect2"><a href="#tutorial-webapp-deploy">1.3.3. Deploying and testing</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-summary">1.4. Summary</a></span></dt></dl></div><p>Intended for new users, this chapter provides an step-by-step introduction to Hibernate, starting with a simple application using an in-memory database. The tutorial is based on an earlier tutorial developed by Michael Gloegl. All code is contained in the <code class="filename">tutorials/web</code> directory of the project source. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Importante</h2><p>This tutorial expects the user have knowledge of both Java and SQL. If you have a limited knowledge of JAVA or SQL, it is advised that you start with a good introduction to that technology prior to attempting to learn Hibernate. </p></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Nota</h2><p>The distribution contains another example application under the <code class="filename">tutorial/eg</code> project source directory. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial-firstapp"/>1.1. Parte 1 - La primera Aplicación Hibernate</h2></div></div></div><p>For this example, we will set up a small database application that can store events we want to attend and information about the host(s) of these events. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Nota</h2><p>Although you can use whatever database you feel comfortable using, we will use <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://hsqldb.org/">HSQLDB</a> (an in-memory, Java database) to avoid describing installation/setup of any particular database servers. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-setup"/>1.1.1. Setup</h3></div></div></div><p>The first thing we need to do is to set up the development environment. We will be using the "standard layout" advocated by alot of build tools such as <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://maven.org">Maven</a>. Maven, in particular, has a good resource describing this <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html">layout</a>. As this tutorial is to be a web application, we will be creating and making use of <code class="filename">src/main/java</code>, <code class="filename">src/main/resources</code> and <code class="filename">src/main/webapp</code> directories. </p><p>We will be using Maven in this tutorial, taking advantage of its transitive dependency management capabilities as well as the ability of many IDEs to automatically set up a project for us based on the maven descriptor. </p><pre class="programlisting">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;

    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.hibernate.tutorials&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-tutorial&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;First Hibernate Tutorial&lt;/name&gt;

    &lt;build&gt;
         &lt;!-- we dont want the version to be part of the generated war file name --&gt;
         &lt;finalName&gt;${artifactId}&lt;/finalName&gt;
    &lt;/build&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- Because this is a web app, we also have a dependency on the servlet api. --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- Hibernate uses slf4j for logging, for our purposes here use the simple backend --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- Hibernate gives you a choice of bytecode providers between cglib and javassist --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javassist&lt;/groupId&gt;
            &lt;artifactId&gt;javassist&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Sugerencia</h2><p>It is not a requirement to use Maven. If you wish to use something else to build this tutoial (such as Ant), the layout will remain the same. The only change is that you will need to manually account for all the needed dependencies. If you use something like <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://ant.apache.org/ivy/">Ivy</a> providing transitive dependency management you would still use the dependencies mentioned below. Otherwise, you'd need to grab <span class="emphasis"><em>all</em></span> dependencies, both explicit and transitive, and add them to the project's classpath. If working from the Hibernate distribution bundle, this would mean <code class="filename">hibernate3.jar</code>, all artifacts in the <code class="filename">lib/required</code> directory and all files from either the <code class="filename">lib/bytecode/cglib</code> or <code class="filename">lib/bytecode/javassist</code> directory; additionally you will need both the servlet-api jar and one of the slf4j logging backends. </p></div><p>Save this file as <code class="filename">pom.xml</code> in the project root directory. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-firstclass"/>1.1.2. La primera clase</h3></div></div></div><p>Next, we create a class that represents the event we want to store in the database; it is a simple JavaBean class with some properties: </p><pre class="programlisting">package org.hibernate.tutorial.domain;

import java.util.Date;

public class Event {
    private Long id;

    private String title;
    private Date date;

    public Event() {}

    public Long getId() {
        return id;
    }

    private void setId(Long id) {
        this.id = id;
    }

    public Date getDate() {
        return date;
    }

    public void setDate(Date date) {
        this.date = date;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }
}</pre><p>This class uses standard JavaBean naming conventions for property getter and setter methods, as well as private visibility for the fields. Although this is the recommended design, it is not required. Hibernate can also access fields directly, the benefit of accessor methods is robustness for refactoring. </p><p>The <code class="literal">id</code> property holds a unique identifier value for a particular event. All persistent entity classes (there are less important dependent classes as well) will need such an identifier property if we want to use the full feature set of Hibernate. In fact, most applications, especially web applications, need to distinguish objects by identifier, so you should consider this a feature rather than a limitation. However, we usually do not manipulate the identity of an object, hence the setter method should be private. Only Hibernate will assign identifiers when an object is saved. Hibernate can access public, private, and protected accessor methods, as well as public, private and protected fields directly. The choice is up to you and you can match it to fit your application design. </p><p>The no-argument constructor is a requirement for all persistent classes; Hibernate has to create objects for you, using Java Reflection. The constructor can be private, however package or public visibility is required for runtime proxy generation and efficient data retrieval without bytecode instrumentation. </p><p>Save this file to the <code class="filename">src/main/java/org/hibernate/tutorial/domain</code> directory. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-mapping"/>1.1.3. El fichero de mapeo</h3></div></div></div><p>Hibernate necesita saber cómo cargar y almacenar objetos de la clase persistente. Aquí es donde el fichero de mapeo de Hibernate entra en juego. El fichero de mapeo le dice a Hibernate a qué tabla en la base de datos tiene que acceder, y qué columnas en esta tabla debe usar. </p><p>La estructura básica de un fichero de mapeo se parece a esto: </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;
[...]
&lt;/hibernate-mapping&gt;</pre><p>Hibernate DTD is sophisticated. You can use it for auto-completion of XML mapping elements and attributes in your editor or IDE. Opening up the DTD file in your text editor is the easiest way to get an overview of all elements and attributes, and to view the defaults, as well as some comments. Hibernate will not load the DTD file from the web, but first look it up from the classpath of the application. The DTD file is included in <code class="filename">hibernate-core.jar</code> (it is also included in the <code class="filename">hibernate3.jar</code>, if using the distribution bundle). </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Importante</h2><p>We will omit the DTD declaration in future examples to shorten the code. It is, of course, not optional. </p></div><p>Between the two <code class="literal">hibernate-mapping</code> tags, include a <code class="literal">class</code> element. All persistent entity classes (again, there might be dependent classes later on, which are not first-class entities) need a mapping to a table in the SQL database: </p><pre class="programlisting">&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;

    &lt;class name="Event" table="EVENTS"&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>So far we have told Hibernate how to persist and load object of class <code class="literal">Event</code> to the table <code class="literal">EVENTS</code>. Each instance is now represented by a row in that table. Now we can continue by mapping the unique identifier property to the tables primary key. As we do not want to care about handling this identifier, we configure Hibernate's identifier generation strategy for a surrogate primary key column: </p><pre class="programlisting">&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;

    &lt;class name="Event" table="EVENTS"&gt;
        &lt;id name="id" column="EVENT_ID"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>The <code class="literal">id</code> element is the declaration of the identifier property. The <code class="literal">name="id"</code> mapping attribute declares the name of the JavaBean property and tells Hibernate to use the <code class="literal">getId()</code> and <code class="literal">setId()</code> methods to access the property. The column attribute tells Hibernate which column of the <code class="literal">EVENTS</code> table holds the primary key value. </p><p>The nested <code class="literal">generator</code> element specifies the identifier generation strategy (aka how are identifier values generated?). In this case we choose <code class="literal">native</code>, which offers a level of portability depending on the configured database dialect. Hibernate supports database generated, globally unique, as well as application assigned, identifiers. Identifier value generation is also one of Hibernate's many extension points and you can plugin in your own strategy. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Sugerencia</h2><p><code class="literal">native</code> is no longer consider the best strategy in terms of portability. for further discussion, see <a href="#portability-idgen" title="25.4. Identifier generation">Sección 25.4, “Identifier generation”</a> </p></div><p>Lastly, we need to tell Hibernate about the remaining entity class properties. By default, no properties of the class are considered persistent: </p><pre class="programlisting">
&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;

    &lt;class name="Event" table="EVENTS"&gt;
        &lt;id name="id" column="EVENT_ID"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="date" type="timestamp" column="EVENT_DATE"/&gt;
        &lt;property name="title"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>Similar to the <code class="literal">id</code> element, the <code class="literal">name</code> attribute of the <code class="literal">property</code> element tells Hibernate which getter and setter methods to use. In this case, Hibernate will search for <code class="literal">getDate()</code>, <code class="literal">setDate()</code>, <code class="literal">getTitle()</code> and <code class="literal">setTitle()</code> methods. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Nota</h2><p>Why does the <code class="literal">date</code> property mapping include the <code class="literal">column</code> attribute, but the <code class="literal">title</code> does not? Without the <code class="literal">column</code> attribute, Hibernate by default uses the property name as the column name. This works for <code class="literal">title</code>, however, <code class="literal">date</code> is a reserved keyword in most databases so you will need to map it to a different name. </p></div><p>The <code class="literal">title</code> mapping also lacks a <code class="literal">type</code> attribute. The types declared and used in the mapping files are not Java data types; they are not SQL database types either. These types are called <span class="emphasis"><em>Hibernate mapping types</em></span>, converters which can translate from Java to SQL data types and vice versa. Again, Hibernate will try to determine the correct conversion and mapping type itself if the <code class="literal">type</code> attribute is not present in the mapping. In some cases this automatic detection using Reflection on the Java class might not have the default you expect or need. This is the case with the <code class="literal">date</code> property. Hibernate cannot know if the property, which is of <code class="literal">java.util.Date</code>, should map to a SQL <code class="literal">date</code>, <code class="literal">timestamp</code>, or <code class="literal">time</code> column. Full date and time information is preserved by mapping the property with a <code class="literal">timestamp</code> converter. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Sugerencia</h2><p>Hibernate makes this mapping type determination using reflection when the mapping files are processed. This can take time and resources, so if startup performance is important you should consider explicitly defining the type to use. </p></div><p>Save this mapping file as <code class="filename">src/main/resources/org/hibernate/tutorial/domain/Event.hbm.xml</code>. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-configuration"/>1.1.4. Configuración de Hibernate</h3></div></div></div><p>At this point, you should have the persistent class and its mapping file in place. It is now time to configure Hibernate. First let's set up HSQLDB to run in "server mode" </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Nota</h2><p>We do this do that the data remains between runs. </p></div><p>We will utilize the Maven exec plugin to launch the HSQLDB server by running: <code class="command"> mvn exec:java -Dexec.mainClass="org.hsqldb.Server" -Dexec.args="-database.0 file:target/data/tutorial"</code> You will see it start up and bind to a TCP/IP socket; this is where our application will connect later. If you want to start with a fresh database during this tutorial, shutdown HSQLDB, delete all files in the <code class="filename">target/data</code> directory, and start HSQLDB again. </p><p>Hibernate will be connecting to the database on behalf of your application, so it needs to know how to obtain connections. For this tutorial we will be using a standalone connection pool (as opposed to a <code class="interfacename">javax.sql.DataSource</code>). Hibernate comes with support for two third-party open source JDBC connection pools: <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://sourceforge.net/projects/c3p0">c3p0</a> and <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://proxool.sourceforge.net/">proxool</a>. However, we will be using the Hibernate built-in connection pool for this tutorial. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="caution"><h2>Atención</h2><p>The built-in Hibernate connection pool is in no way intended for production use. It lacks several features found on any decent connection pool. </p></div><p>For Hibernate's configuration, we can use a simple <code class="literal">hibernate.properties</code> file, a more sophisticated <code class="literal">hibernate.cfg.xml</code> file, or even complete programmatic setup. Most users prefer the XML configuration file: </p><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;

&lt;hibernate-configuration&gt;

    &lt;session-factory&gt;

        &lt;!-- Database connection settings --&gt;
        &lt;property name="connection.driver_class"&gt;org.hsqldb.jdbcDriver&lt;/property&gt;
        &lt;property name="connection.url"&gt;jdbc:hsqldb:hsql://localhost&lt;/property&gt;
        &lt;property name="connection.username"&gt;sa&lt;/property&gt;
        &lt;property name="connection.password"&gt;&lt;/property&gt;

        &lt;!-- JDBC connection pool (use the built-in) --&gt;
        &lt;property name="connection.pool_size"&gt;1&lt;/property&gt;

        &lt;!-- SQL dialect --&gt;
        &lt;property name="dialect"&gt;org.hibernate.dialect.HSQLDialect&lt;/property&gt;

        &lt;!-- Enable Hibernate's automatic session context management --&gt;
        &lt;property name="current_session_context_class"&gt;thread&lt;/property&gt;

        &lt;!-- Disable the second-level cache  --&gt;
        &lt;property name="cache.provider_class"&gt;org.hibernate.cache.NoCacheProvider&lt;/property&gt;

        &lt;!-- Echo all executed SQL to stdout --&gt;
        &lt;property name="show_sql"&gt;true&lt;/property&gt;

        &lt;!-- Drop and re-create the database schema on startup --&gt;
        &lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt;

        &lt;mapping resource="org/hibernate/tutorial/domain/Event.hbm.xml"/&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Nota</h2><p>Notice that this configuration file specifies a different DTD</p></div><p>You configure Hibernate's <code class="literal">SessionFactory</code>. SessionFactory is a global factory responsible for a particular database. If you have several databases, for easier startup you should use several <code class="literal">&lt;session-factory&gt;</code> configurations in several configuration files. </p><p>The first four <code class="literal">property</code> elements contain the necessary configuration for the JDBC connection. The dialect <code class="literal">property</code> element specifies the particular SQL variant Hibernate generates. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Sugerencia</h2><p>In most cases, Hibernate is able to properly determine which dialect to use. See <a href="#portability-dialectresolver" title="25.3. Dialect resolution">Sección 25.3, “Dialect resolution”</a> for more information. </p></div><p>Hibernate's automatic session management for persistence contexts is particularly useful in this context. The <code class="literal">hbm2ddl.auto</code> option turns on automatic generation of database schemas directly into the database. This can also be turned off by removing the configuration option, or redirected to a file with the help of the <code class="literal">SchemaExport</code> Ant task. Finally, add the mapping file(s) for persistent classes to the configuration. </p><p>Save this file as <code class="filename">hibernate.cfg.xml</code> into the <code class="filename">src/main/resources</code> directory. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-mvn"/>1.1.5. Building with Maven</h3></div></div></div><p>We will now build the tutorial with Maven. You will need to have Maven installed; it is available from the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://maven.apache.org/download.html">Maven download page</a>. Maven will read the <code class="filename">/pom.xml</code> file we created earlier and know how to perform some basic project tasks. First, lets run the <code class="literal">compile</code> goal to make sure we can compile everything so far: </p><pre class="programlisting">[hibernateTutorial]$ mvn compile
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Building First Hibernate Tutorial
[INFO]    task-segment: [compile]
[INFO] ------------------------------------------------------------------------
[INFO] [resources:resources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:compile]
[INFO] Compiling 1 source file to /home/steve/projects/sandbox/hibernateTutorial/target/classes
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 2 seconds
[INFO] Finished at: Tue Jun 09 12:25:25 CDT 2009
[INFO] Final Memory: 5M/547M
[INFO] ------------------------------------------------------------------------</pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-helpers"/>1.1.6. Esto dirá a Ant que agregue todos los ficheros en el directorio lib que terminen con <code class="literal">.jar</code> al classpath usado para la compilación. También copiará todos los ficheros que no sean código Java al directorio objetivo, por ejemplo, ficheros de configuración y mapeos de Hibernate. Si ahora corres Ant, debes obtener esta salida:</h3></div></div></div><p>It is time to load and store some <code class="literal">Event</code> objects, but first you have to complete the setup with some infrastructure code. You have to startup Hibernate by building a global <code class="interfacename">org.hibernate.SessionFactory</code> object and storing it somewhere for easy access in application code. A <code class="interfacename">org.hibernate.SessionFactory</code> is used to obtain <code class="interfacename">org.hibernate.Session</code> instances. A <code class="interfacename">org.hibernate.Session</code> represents a single-threaded unit of work. The <code class="interfacename">org.hibernate.SessionFactory</code> is a thread-safe global object that is instantiated once. </p><p>We will create a <code class="literal">HibernateUtil</code> helper class that takes care of startup and makes accessing the <code class="interfacename">org.hibernate.SessionFactory</code> more convenient. </p><pre class="programlisting">package org.hibernate.tutorial.util;

import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;

public class HibernateUtil {

    private static final SessionFactory sessionFactory = buildSessionFactory();

    private static SessionFactory buildSessionFactory() {
        try {
            // Create the SessionFactory from hibernate.cfg.xml
            return new Configuration().configure().buildSessionFactory();
        }
        catch (Throwable ex) {
            // Make sure you log the exception, as it might be swallowed
            System.err.println("Initial SessionFactory creation failed." + ex);
            throw new ExceptionInInitializerError(ex);
        }
    }

    public static SessionFactory getSessionFactory() {
        return sessionFactory;
    }

}</pre><p>Save this code as <code class="filename">src/main/java/org/hibernate/tutorial/util/HibernateUtil.java</code> </p><p>This class not only produces the global <code class="interfacename">org.hibernate.SessionFactory</code> reference in its static initializer; it also hides the fact that it uses a static singleton. We might just as well have looked up the <code class="interfacename">org.hibernate.SessionFactory</code> reference from JNDI in an application server or any other location for that matter. </p><p>If you give the <code class="interfacename">org.hibernate.SessionFactory</code> a name in your configuration, Hibernate will try to bind it to JNDI under that name after it has been built. Another, better option is to use a JMX deployment and let the JMX-capable container instantiate and bind a <code class="literal">HibernateService</code> to JNDI. Such advanced options are discussed later. </p><p>You now need to configure a logging system. Hibernate uses commons logging and provides two choices: Log4j and JDK 1.4 logging. Most developers prefer Log4j: copy <code class="literal">log4j.properties</code> from the Hibernate distribution in the <code class="literal">etc/</code> directory to your <code class="literal">src</code> directory, next to <code class="literal">hibernate.cfg.xml</code>. If you prefer to have more verbose output than that provided in the example configuration, you can change the settings. By default, only the Hibernate startup message is shown on stdout. </p><p>The tutorial infrastructure is complete and you are now ready to do some real work with Hibernate. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-workingpersistence"/>1.1.7. Esto también debe compilar sin problemas. Finalmente necesitamos configurar un sistema de logging (registro). Hibernate usa commons logging y te deja la elección entre Log4J y logging de JDK 1.4. La mayoría de los desarrolladores prefieren Log4J: copia <code class="literal">log4j.properties</code> de la distribución de Hibernate (está en el directorio <code class="literal">etc/</code>) a tu directorio <code class="literal">src</code>, junto a <code class="literal">hibernate.cfg.xml</code>. Echa una mirada a la configuración de ejemplo y cambia los ajustes si te gusta tener una salida más verborrágica. Por defecto, sólo se muestra el mensaje de arranque de Hibernate en la salida.</h3></div></div></div><p>We are now ready to start doing some real worjk with Hibernate. Let's start by writing an <code class="literal">EventManager</code> class with a <code class="literal">main()</code> method: </p><pre class="programlisting">package org.hibernate.tutorial;

import org.hibernate.Session;

import java.util.*;

import org.hibernate.tutorial.domain.Event;
import org.hibernate.tutorial.util.HibernateUtil;

public class EventManager {

    public static void main(String[] args) {
        EventManager mgr = new EventManager();

        if (args[0].equals("store")) {
            mgr.createAndStoreEvent("My Event", new Date());
        }

        HibernateUtil.getSessionFactory().close();
    }

    private void createAndStoreEvent(String title, Date theDate) {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();

        Event theEvent = new Event();
        theEvent.setTitle(title);
        theEvent.setDate(theDate);
        session.save(theEvent);

        session.getTransaction().commit();
    }

}</pre><p>In <code class="literal">createAndStoreEvent()</code> we created a new <code class="literal">Event</code> object and handed it over to Hibernate. At that point, Hibernate takes care of the SQL and executes an <code class="literal">INSERT</code> on the database. </p><p>A <span class="interface">org.hibernate.Session</span> is designed to represent a single unit of work (a single atmoic piece of work to be performed). For now we will keep things simple and assume a one-to-one granularity between a Hibernate <span class="interface">org.hibernate.Session</span> and a database transaction. To shield our code from the actual underlying transaction system we use the Hibernate <code class="interfacename">org.hibernate.Transaction</code> API. In this particular case we are using JDBC-based transactional semantics, but it could also run with JTA. </p><p>What does <code class="literal">sessionFactory.getCurrentSession()</code> do? First, you can call it as many times and anywhere you like once you get hold of your <code class="interfacename">org.hibernate.SessionFactory</code>. The <code class="literal">getCurrentSession()</code> method always returns the "current" unit of work. Remember that we switched the configuration option for this mechanism to "thread" in our <code class="filename">src/main/resources/hibernate.cfg.xml</code>? Due to that setting, the context of a current unit of work is bound to the current Java thread that executes the application. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Importante</h2><p>Hibernate offers three methods of current session tracking. The "thread" based method is not intended for production use; it is merely useful for prototyping and tutorials such as this one. Current session tracking is discussed in more detail later on. </p></div><p>A <span class="interface">org.hibernate.Session</span> begins when the first call to <code class="literal">getCurrentSession()</code> is made for the current thread. It is then bound by Hibernate to the current thread. When the transaction ends, either through commit or rollback, Hibernate automatically unbinds the <span class="interface">org.hibernate.Session</span> from the thread and closes it for you. If you call <code class="literal">getCurrentSession()</code> again, you get a new <span class="interface">org.hibernate.Session</span> and can start a new unit of work. </p><p>Related to the unit of work scope, should the Hibernate <span class="interface">org.hibernate.Session</span> be used to execute one or several database operations? The above example uses one <span class="interface">org.hibernate.Session</span> for one operation. However this is pure coincidence; the example is just not complex enough to show any other approach. The scope of a Hibernate <span class="interface">org.hibernate.Session</span> is flexible but you should never design your application to use a new Hibernate <span class="interface">org.hibernate.Session</span> for <span class="emphasis"><em>every</em></span> database operation. Even though it is used in the following examples, consider <span class="emphasis"><em>session-per-operation</em></span> an anti-pattern. A real web application is shown later in the tutorial which will help illustrate this. </p><p>See <a href="#transactions" title="Capítulo 11. Transactions and Concurrency">Capítulo 11, <i xmlns:xlink="http://www.w3.org/1999/xlink">Transactions and Concurrency</i></a> for more information about transaction handling and demarcation. The previous example also skipped any error handling and rollback. </p><p>To run this, we will make use of the Maven exec plugin to call our class with the necessary classpath setup: <code class="command">mvn exec:java -Dexec.mainClass="org.hibernate.tutorial.EventManager" -Dexec.args="store"</code> </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Nota</h2><p>You may need to perform <code class="command">mvn compile</code> first. </p></div><p>You should see Hibernate starting up and, depending on your configuration, lots of log output. Towards the end, the following line will be displayed: </p><pre class="programlisting">Debes ver, después de la compilación, a Hibernate arrancando y, dependiendo de tu configuración mucha salida de registro (log). Al final encontrarás la siguiente línea:</pre><p>This is the <code class="literal">INSERT</code> executed by Hibernate. </p><p>To list stored events an option is added to the main method: </p><pre class="programlisting">        if (args[0].equals("store")) {
            mgr.createAndStoreEvent("My Event", new Date());
        }
        else if (args[0].equals("list")) {
            List events = mgr.listEvents();
            for (int i = 0; i &lt; events.size(); i++) {
                Event theEvent = (Event) events.get(i);
                System.out.println(
                        "Event: " + theEvent.getTitle() + " Time: " + theEvent.getDate()
                );
            }
        }</pre><p>A new <code class="literal">listEvents() method is also added</code>: </p><pre class="programlisting">    private List listEvents() {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();
        List result = session.createQuery("from Event").list();
        session.getTransaction().commit();
        return result;
    }</pre><p>Here, we are using a Hibernate Query Language (HQL) query to load all existing <code class="literal">Event</code> objects from the database. Hibernate will generate the appropriate SQL, send it to the database and populate <code class="literal">Event</code> objects with the data. You can create more complex queries with HQL. See <a href="#queryhql" title="Capítulo 14. HQL: El Lenguaje de Consulta de Hibernate">Capítulo 14, <i xmlns:xlink="http://www.w3.org/1999/xlink">HQL: El Lenguaje de Consulta de Hibernate</i></a> for more information. </p><p>Now we can call our new functionality, again using the Maven exec plugin: <code class="command">mvn exec:java -Dexec.mainClass="org.hibernate.tutorial.EventManager" -Dexec.args="list"</code> </p></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial-associations"/>1.2. Note: Most new Hibernate users fail at this point and we see questions about <span class="emphasis"><em>Table not found</em></span> error messages regularly. However, if you follow the steps outlined above you will not have this problem, as hbm2ddl creates the database schema on the first run, and subsequent application restarts will use this schema. If you change the mapping and/or database schema, you have to re-enable hbm2ddl once again.</h2></div></div></div><p>So far we have mapped a single persistent entity class to a table in isolation. Let's expand on that a bit and add some class associations. We will add people to the application and store a list of events in which they participate. </p><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-mappinguser"/>1.2.1. Hemos mapeado un clase de entidad persistente a una tabla. Construyamos sobre esto y agreguemos algunas asociaciones de clase. Primero agregaremos personas a nuestra aplicación, y almacenaremos una lista de eventos en las que participan.</h3></div></div></div><p>The first cut of the <code class="literal">Person</code> class looks like this: </p><pre class="programlisting">package org.hibernate.tutorial.domain;

public class Person {

    private Long id;
    private int age;
    private String firstname;
    private String lastname;

    public Person() {}

    // Accessor methods for all properties, private setter for 'id'

}</pre><p>Save this to a file named <code class="filename">src/main/java/org/hibernate/tutorial/domain/Person.java</code> </p><p>Next, create the new mapping file as <code class="filename">src/main/resources/org/hibernate/tutorial/domain/Person.hbm.xml</code> </p><pre class="programlisting">&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;

    &lt;class name="Person" table="PERSON"&gt;
        &lt;id name="id" column="PERSON_ID"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="age"/&gt;
        &lt;property name="firstname"/&gt;
        &lt;property name="lastname"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>&lt;hibernate-mapping&gt;

    &lt;class name="Person" table="PERSON"&gt;
        &lt;id name="id" column="PERSON_ID"&gt;
            &lt;generator class="increment"/&gt;
        &lt;/id&gt;
        &lt;property name="age"/&gt;
        &lt;property name="firstname"/&gt;
        &lt;property name="lastname"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping
&gt; </p><pre class="programlisting">Finalmente, agrega el nuevo mapeo a la configuración de Hibernate:</pre><p>Create an association between these two entities. Persons can participate in events, and events have participants. The design questions you have to deal with are: directionality, multiplicity, and collection behavior. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-unidirset"/>1.2.2. Crearemos ahora una asociación entre estas dos entidades. Obviamente, las personas pueden participar en eventos, y los eventos tienen participantes. Las cuestiones de diseño con que tenemos que tratar son: direccionalidad, multiplicidad y comportamiento de colección.</h3></div></div></div><p>By adding a collection of events to the <code class="literal">Person</code> class, you can easily navigate to the events for a particular person, without executing an explicit query - by calling <code class="literal">Person#getEvents</code>. Multi-valued associations are represented in Hibernate by one of the Java Collection Framework contracts; here we choose a <code class="interfacename">java.util.Set</code> because the collection will not contain duplicate elements and the ordering is not relevant to our examples: </p><pre class="programlisting">Hasta ahora hemos diseñado asociaciones unidireccionales multivaluadas, implementadas con un <code class="literal">Set</code>. Escribamos el código para esto en las clases Java y luego lo mapeemos:</pre><p>Before mapping this association, let's consider the other side. We could just keep this unidirectional or create another collection on the <code class="literal">Event</code>, if we wanted to be able to navigate it from both directions. This is not necessary, from a functional perspective. You can always execute an explicit query to retrieve the participants for a particular event. This is a design choice left to you, but what is clear from this discussion is the multiplicity of the association: "many" valued on both sides is called a <span class="emphasis"><em>many-to-many</em></span> association. Hence, we use Hibernate's many-to-many mapping: </p><pre class="programlisting">&lt;class name="Person" table="PERSON"&gt;
    &lt;id name="id" column="PERSON_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="age"/&gt;
    &lt;property name="firstname"/&gt;
    &lt;property name="lastname"/&gt;

    &lt;set name="events" table="PERSON_EVENT"&gt;
        &lt;key column="PERSON_ID"/&gt;
        &lt;many-to-many column="EVENT_ID" class="Event"/&gt;
    &lt;/set&gt;

&lt;/class&gt;</pre><p>Hibernate supports a broad range of collection mappings, a <code class="literal">set</code> being most common. For a many-to-many association, or <span class="emphasis"><em>n:m</em></span> entity relationship, an association table is required. Each row in this table represents a link between a person and an event. The table name is decalred using the <code class="literal">table</code> attribute of the <code class="literal">set</code> element. The identifier column name in the association, for the person side, is defined with the <code class="literal">key</code> element, the column name for the event's side with the <code class="literal">column</code> attribute of the <code class="literal">many-to-many</code>. You also have to tell Hibernate the class of the objects in your collection (the class on the other side of the collection of references). </p><p>Hibernate soporta todo tipo de mapeos de colección, siendo el más común un <code class="literal">&lt;set&gt;</code>. Para una asociación muchos-a-muchos (o relación de entidad <span class="emphasis"><em>n:m</em></span>), se necesita una tabla de asociación. Cada fila en esta tabla representa un enlace entre una persona y un evento. Esta tabla se configura con el atributo <code class="literal">table</code> del elemento <code class="literal">set</code>. El nombre de la columna identificadora en la asociación, para el lado de la persona, se define con el elemento <code class="literal">&lt;key&gt;</code>. El nombre de columna para el lado del evento se define con el atributo <code class="literal">column</code> del <code class="literal">&lt;many-to-many&gt;</code>. También tienes que decirle a Hibernate la clase de los objetos en tu colección (correcto: la clase del otro lado de la colección de referencias). </p><pre class="programlisting">El esquema de base de datos para este mapeo es, por lo tanto:</pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-working"/>1.2.3. 
    _____________        __________________
   |             |      |                  |       _____________
   |   EVENTS    |      |   PERSON_EVENT   |      |             |
   |_____________|      |__________________|      |    PERSON   |
   |             |      |                  |      |_____________|
   | *EVENT_ID   | &lt;--&gt; | *EVENT_ID        |      |             |
   |  EVENT_DATE |      | *PERSON_ID       | &lt;--&gt; | *PERSON_ID  |
   |  TITLE      |      |__________________|      |  AGE        |
   |_____________|                                |  FIRSTNAME  |
                                                  |  LASTNAME   |
                                                  |_____________|
 </h3></div></div></div><p>Now we will bring some people and events together in a new method in <code class="literal">EventManager</code>: </p><pre class="programlisting">    private void addPersonToEvent(Long personId, Long eventId) {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();

        Person aPerson = (Person) session.load(Person.class, personId);
        Event anEvent = (Event) session.load(Event.class, eventId);
        aPerson.getEvents().add(anEvent);

        session.getTransaction().commit();
    }</pre><p>After loading a <code class="literal">Person</code> and an <code class="literal">Event</code>, simply modify the collection using the normal collection methods. There is no explicit call to <code class="literal">update()</code> or <code class="literal">save()</code>; Hibernate automatically detects that the collection has been modified and needs to be updated. This is called <span class="emphasis"><em>automatic dirty checking</em></span>. You can also try it by modifying the name or the date property of any of your objects. As long as they are in <span class="emphasis"><em>persistent</em></span> state, that is, bound to a particular Hibernate <code class="interfacename">org.hibernate.Session</code>, Hibernate monitors any changes and executes SQL in a write-behind fashion. The process of synchronizing the memory state with the database, usually only at the end of a unit of work, is called <span class="emphasis"><em>flushing</em></span>. In our code, the unit of work ends with a commit, or rollback, of the database transaction. </p><p>You can load person and event in different units of work. Or you can modify an object outside of a <code class="interfacename">org.hibernate.Session</code>, when it is not in persistent state (if it was persistent before, this state is called <span class="emphasis"><em>detached</em></span>). You can even modify a collection when it is detached: </p><pre class="programlisting">    private void addPersonToEvent(Long personId, Long eventId) {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();

        Person aPerson = (Person) session
                .createQuery("select p from Person p left join fetch p.events where p.id = :pid")
                .setParameter("pid", personId)
                .uniqueResult(); // Eager fetch the collection so we can use it detached
        Event anEvent = (Event) session.load(Event.class, eventId);

        session.getTransaction().commit();

        // End of first unit of work

        aPerson.getEvents().add(anEvent); // aPerson (and its collection) is detached

        // Begin second unit of work

        Session session2 = HibernateUtil.getSessionFactory().getCurrentSession();
        session2.beginTransaction();
        session2.update(aPerson); // Reattachment of aPerson

        session2.getTransaction().commit();
    }</pre><p>The call to <code class="literal">update</code> makes a detached object persistent again by binding it to a new unit of work, so any modifications you made to it while detached can be saved to the database. This includes any modifications (additions/deletions) you made to a collection of that entity object. </p><p>This is not much use in our example, but it is an important concept you can incorporate into your own application. Complete this exercise by adding a new action to the main method of the <code class="literal">EventManager</code> and call it from the command line. If you need the identifiers of a person and an event - the <code class="literal">save()</code> method returns it (you might have to modify some of the previous methods to return that identifier): </p><pre class="programlisting">        else if (args[0].equals("addpersontoevent")) {
            Long eventId = mgr.createAndStoreEvent("My Event", new Date());
            Long personId = mgr.createAndStorePerson("Foo", "Bar");
            mgr.addPersonToEvent(personId, eventId);
            System.out.println("Added person " + personId + " to event " + eventId);
        }</pre><p>This is an example of an association between two equally important classes : two entities. As mentioned earlier, there are other classes and types in a typical model, usually "less important". Some you have already seen, like an <code class="literal">int</code> or a <code class="classname">java.lang.String</code>. We call these classes <span class="emphasis"><em>value types</em></span>, and their instances <span class="emphasis"><em>depend</em></span> on a particular entity. Instances of these types do not have their own identity, nor are they shared between entities. Two persons do not reference the same <code class="literal">firstname</code> object, even if they have the same first name. Value types cannot only be found in the JDK , but you can also write dependent classes yourself such as an <code class="literal">Address</code> or <code class="literal">MonetaryAmount</code> class. In fact, in a Hibernate application all JDK classes are considered value types. </p><p>You can also design a collection of value types. This is conceptually different from a collection of references to other entities, but looks almost the same in Java. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-valuecollections"/>1.2.4. Colección de valores</h3></div></div></div><p>Let's add a collection of email addresses to the <code class="literal">Person</code> entity. This will be represented as a <code class="interfacename">java.util.Set</code> of <code class="classname">java.lang.String</code> instances: </p><pre class="programlisting">    private Set emailAddresses = new HashSet();

    public Set getEmailAddresses() {
        return emailAddresses;
    }

    public void setEmailAddresses(Set emailAddresses) {
        this.emailAddresses = emailAddresses;
    }</pre><p>The mapping of this <code class="literal">Set</code> is as follows: </p><pre class="programlisting">        &lt;set name="emailAddresses" table="PERSON_EMAIL_ADDR"&gt;
            &lt;key column="PERSON_ID"/&gt;
            &lt;element type="string" column="EMAIL_ADDR"/&gt;
        &lt;/set&gt;</pre><p>The difference compared with the earlier mapping is the use of the <code class="literal">element</code> part which tells Hibernate that the collection does not contain references to another entity, but is rather a collection whose elements are values types, here specifically of type <code class="literal">string</code>. The lowercase name tells you it is a Hibernate mapping type/converter. Again the <code class="literal">table</code> attribute of the <code class="literal">set</code> element determines the table name for the collection. The <code class="literal">key</code> element defines the foreign-key column name in the collection table. The <code class="literal">column</code> attribute in the <code class="literal">element</code> element defines the column name where the email address values will actually be stored. </p><p>Here is the updated schema: </p><pre class="programlisting">
  _____________        __________________
 |             |      |                  |       _____________
 |   EVENTS    |      |   PERSON_EVENT   |      |             |       ___________________
 |_____________|      |__________________|      |    PERSON   |      |                   |
 |             |      |                  |      |_____________|      | PERSON_EMAIL_ADDR |
 | *EVENT_ID   | &lt;--&gt; | *EVENT_ID        |      |             |      |___________________|
 |  EVENT_DATE |      | *PERSON_ID       | &lt;--&gt; | *PERSON_ID  | &lt;--&gt; |  *PERSON_ID       |
 |  TITLE      |      |__________________|      |  AGE        |      |  *EMAIL_ADDR      |
 |_____________|                                |  FIRSTNAME  |      |___________________|
                                                |  LASTNAME   |
                                                |_____________|
 </pre><p>You can see that the primary key of the collection table is in fact a composite key that uses both columns. This also implies that there cannot be duplicate email addresses per person, which is exactly the semantics we need for a set in Java. </p><p>You can now try to add elements to this collection, just like we did before by linking persons and events. It is the same code in Java: </p><pre class="programlisting">    private void addEmailToPerson(Long personId, String emailAddress) {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();

        Person aPerson = (Person) session.load(Person.class, personId);
        // adding to the emailAddress collection might trigger a lazy load of the collection
        aPerson.getEmailAddresses().add(emailAddress);

        session.getTransaction().commit();
    }</pre><p>This time we did not use a <span class="emphasis"><em>fetch</em></span> query to initialize the collection. Monitor the SQL log and try to optimize this with an eager fetch. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-bidirectional"/>1.2.5. Asociaciones bidireccionales</h3></div></div></div><p>Next you will map a bi-directional association. You will make the association between person and event work from both sides in Java. The database schema does not change, so you will still have many-to-many multiplicity. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Nota</h2><p>A relational database is more flexible than a network programming language, in that it does not need a navigation direction; data can be viewed and retrieved in any possible way. </p></div><p>First, add a collection of participants to the <code class="literal">Event</code> class: </p><pre class="programlisting">    private Set participants = new HashSet();

    public Set getParticipants() {
        return participants;
    }

    public void setParticipants(Set participants) {
        this.participants = participants;
    }</pre><p>Now map this side of the association in <code class="literal">Event.hbm.xml</code>. </p><pre class="programlisting">        &lt;set name="participants" table="PERSON_EVENT" inverse="true"&gt;
            &lt;key column="EVENT_ID"/&gt;
            &lt;many-to-many column="PERSON_ID" class="events.Person"/&gt;
        &lt;/set&gt;</pre><p>These are normal <code class="literal">set</code> mappings in both mapping documents. Notice that the column names in <code class="literal">key</code> and <code class="literal">many-to-many</code> swap in both mapping documents. The most important addition here is the <code class="literal">inverse="true"</code> attribute in the <code class="literal">set</code> element of the <code class="literal">Event</code>'s collection mapping. </p><p>What this means is that Hibernate should take the other side, the <code class="literal">Person</code> class, when it needs to find out information about the link between the two. This will be a lot easier to understand once you see how the bi-directional link between our two entities is created. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-usingbidir"/>1.2.6. Trabajando enlaces bidireccionales</h3></div></div></div><p>First, keep in mind that Hibernate does not affect normal Java semantics. How did we create a link between a <code class="literal">Person</code> and an <code class="literal">Event</code> in the unidirectional example? You add an instance of <code class="literal">Event</code> to the collection of event references, of an instance of <code class="literal">Person</code>. If you want to make this link bi-directional, you have to do the same on the other side by adding a <code class="literal">Person</code> reference to the collection in an <code class="literal">Event</code>. This process of "setting the link on both sides" is absolutely necessary with bi-directional links. </p><p>Many developers program defensively and create link management methods to correctly set both sides (for example, in <code class="literal">Person</code>): </p><pre class="programlisting">    protected Set getEvents() {
        return events;
    }

    protected void setEvents(Set events) {
        this.events = events;
    }

    public void addToEvent(Event event) {
        this.getEvents().add(event);
        event.getParticipants().add(this);
    }

    public void removeFromEvent(Event event) {
        this.getEvents().remove(event);
        event.getParticipants().remove(this);
    }</pre><p>The get and set methods for the collection are now protected. This allows classes in the same package and subclasses to still access the methods, but prevents everybody else from altering the collections directly. Repeat the steps for the collection on the other side. </p><p>What about the <code class="literal">inverse</code> mapping attribute? For you, and for Java, a bi-directional link is simply a matter of setting the references on both sides correctly. Hibernate, however, does not have enough information to correctly arrange SQL <code class="literal">INSERT</code> and <code class="literal">UPDATE</code> statements (to avoid constraint violations). Making one side of the association <code class="literal">inverse</code> tells Hibernate to consider it a <span class="emphasis"><em>mirror</em></span> of the other side. That is all that is necessary for Hibernate to resolve any issues that arise when transforming a directional navigation model to a SQL database schema. The rules are straightforward: all bi-directional associations need one side as <code class="literal">inverse</code>. In a one-to-many association it has to be the many-side, and in many-to-many association you can select either side. </p></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial-webapp"/>1.3. Part 3 - The EventManager web application</h2></div></div></div><p>A Hibernate web application uses <code class="literal">Session</code> and <code class="literal">Transaction</code> almost like a standalone application. However, some common patterns are useful. You can now write an <code class="literal">EventManagerServlet</code>. This servlet can list all events stored in the database, and it provides an HTML form to enter new events. </p><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-webapp-servlet"/>1.3.1. Writing the basic servlet</h3></div></div></div><p>First we need create our basic processing servlet. Since our servlet only handles HTTP <code class="literal">GET</code> requests, we will only implement the <code class="literal">doGet()</code> method: </p><pre class="programlisting">package org.hibernate.tutorial.web;

// Imports

public class EventManagerServlet extends HttpServlet {

    protected void doGet(
            HttpServletRequest request,
            HttpServletResponse response) throws ServletException, IOException {

        SimpleDateFormat dateFormatter = new SimpleDateFormat( "dd.MM.yyyy" );

        try {
            // Begin unit of work
            HibernateUtil.getSessionFactory().getCurrentSession().beginTransaction();

            // Process request and render page...

            // End unit of work
            HibernateUtil.getSessionFactory().getCurrentSession().getTransaction().commit();
        }
        catch (Exception ex) {
            HibernateUtil.getSessionFactory().getCurrentSession().getTransaction().rollback();
            if ( ServletException.class.isInstance( ex ) ) {
                throw ( ServletException ) ex;
            }
            else {
                throw new ServletException( ex );
            }
        }
    }

}</pre><p>Save this servlet as <code class="filename">src/main/java/org/hibernate/tutorial/web/EventManagerServlet.java</code> </p><p>The pattern applied here is called <span class="emphasis"><em>session-per-request</em></span>. When a request hits the servlet, a new Hibernate <code class="literal">Session</code> is opened through the first call to <code class="literal">getCurrentSession()</code> on the <code class="literal">SessionFactory</code>. A database transaction is then started. All data access occurs inside a transaction irrespective of whether the data is read or written. Do not use the auto-commit mode in applications. </p><p>Do <span class="emphasis"><em>not</em></span> use a new Hibernate <code class="literal">Session</code> for every database operation. Use one Hibernate <code class="literal">Session</code> that is scoped to the whole request. Use <code class="literal">getCurrentSession()</code>, so that it is automatically bound to the current Java thread. </p><p>Next, the possible actions of the request are processed and the response HTML is rendered. We will get to that part soon. </p><p>Finally, the unit of work ends when processing and rendering are complete. If any problems occurred during processing or rendering, an exception will be thrown and the database transaction rolled back. This completes the <code class="literal">session-per-request</code> pattern. Instead of the transaction demarcation code in every servlet, you could also write a servlet filter. See the Hibernate website and Wiki for more information about this pattern called <span class="emphasis"><em>Open Session in View</em></span>. You will need it as soon as you consider rendering your view in JSP, not in a servlet. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-webapp-processing"/>1.3.2. Processing and rendering</h3></div></div></div><p>Now you can implement the processing of the request and the rendering of the page. </p><pre class="programlisting">        // Write HTML header
        PrintWriter out = response.getWriter();
        out.println("&lt;html&gt;&lt;head&gt;&lt;title&gt;Event Manager&lt;/title&gt;&lt;/head&gt;&lt;body&gt;");

        // Handle actions
        if ( "store".equals(request.getParameter("action")) ) {

            String eventTitle = request.getParameter("eventTitle");
            String eventDate = request.getParameter("eventDate");

            if ( "".equals(eventTitle) || "".equals(eventDate) ) {
                out.println("&lt;b&gt;&lt;i&gt;Please enter event title and date.&lt;/i&gt;&lt;/b&gt;");
            }
            else {
                createAndStoreEvent(eventTitle, dateFormatter.parse(eventDate));
                out.println("&lt;b&gt;&lt;i&gt;Added event.&lt;/i&gt;&lt;/b&gt;");
            }
        }

        // Print page
       printEventForm(out);
       listEvents(out, dateFormatter);

       // Write HTML footer
       out.println("&lt;/body&gt;&lt;/html&gt;");
       out.flush();
       out.close();</pre><p>This coding style, with a mix of Java and HTML, would not scale in a more complex application-keep in mind that we are only illustrating basic Hibernate concepts in this tutorial. The code prints an HTML header and a footer. Inside this page, an HTML form for event entry and a list of all events in the database are printed. The first method is trivial and only outputs HTML: </p><pre class="programlisting">    private void printEventForm(PrintWriter out) {
        out.println("&lt;h2&gt;Add new event:&lt;/h2&gt;");
        out.println("&lt;form&gt;");
        out.println("Title: &lt;input name='eventTitle' length='50'/&gt;&lt;br/&gt;");
        out.println("Date (e.g. 24.12.2009): &lt;input name='eventDate' length='10'/&gt;&lt;br/&gt;");
        out.println("&lt;input type='submit' name='action' value='store'/&gt;");
        out.println("&lt;/form&gt;");
    }</pre><p>The <code class="literal">listEvents()</code> method uses the Hibernate <code class="literal">Session</code> bound to the current thread to execute a query: </p><pre class="programlisting">    private void listEvents(PrintWriter out, SimpleDateFormat dateFormatter) {

        List result = HibernateUtil.getSessionFactory()
                .getCurrentSession().createCriteria(Event.class).list();
        if (result.size() &gt; 0) {
            out.println("&lt;h2&gt;Events in database:&lt;/h2&gt;");
            out.println("&lt;table border='1'&gt;");
            out.println("&lt;tr&gt;");
            out.println("&lt;th&gt;Event title&lt;/th&gt;");
            out.println("&lt;th&gt;Event date&lt;/th&gt;");
            out.println("&lt;/tr&gt;");
            Iterator it = result.iterator();
            while (it.hasNext()) {
                Event event = (Event) it.next();
                out.println("&lt;tr&gt;");
                out.println("&lt;td&gt;" + event.getTitle() + "&lt;/td&gt;");
                out.println("&lt;td&gt;" + dateFormatter.format(event.getDate()) + "&lt;/td&gt;");
                out.println("&lt;/tr&gt;");
            }
            out.println("&lt;/table&gt;");
        }
    }</pre><p>Finally, the <code class="literal">store</code> action is dispatched to the <code class="literal">createAndStoreEvent()</code> method, which also uses the <code class="literal">Session</code> of the current thread: </p><pre class="programlisting">    protected void createAndStoreEvent(String title, Date theDate) {
        Event theEvent = new Event();
        theEvent.setTitle(title);
        theEvent.setDate(theDate);

        HibernateUtil.getSessionFactory()
                .getCurrentSession().save(theEvent);
    }</pre><p>The servlet is now complete. A request to the servlet will be processed in a single <code class="literal">Session</code> and <code class="literal">Transaction</code>. As earlier in the standalone application, Hibernate can automatically bind these objects to the current thread of execution. This gives you the freedom to layer your code and access the <code class="literal">SessionFactory</code> in any way you like. Usually you would use a more sophisticated design and move the data access code into data access objects (the DAO pattern). See the Hibernate Wiki for more examples. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-webapp-deploy"/>1.3.3. Deploying and testing</h3></div></div></div><p>To deploy this application for testing we must create a Web ARchive (WAR). First we must define the WAR descriptor as <code class="filename">src/main/webapp/WEB-INF/web.xml</code> </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="2.4"
    xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;Event Manager&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.hibernate.tutorial.web.EventManagerServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Event Manager&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/eventmanager&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre><p>To build and deploy call <code class="literal">mvn package</code> in your project directory and copy the <code class="filename">hibernate-tutorial.war</code> file into your Tomcat <code class="filename">webapps</code> directory. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Nota</h2><p>If you do not have Tomcat installed, download it from <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://tomcat.apache.org/">http://tomcat.apache.org/</a> and follow the installation instructions. Our application requires no changes to the standard Tomcat configuration. </p></div><p>Once deployed and Tomcat is running, access the application at <code class="literal">http://localhost:8080/hibernate-tutorial/eventmanager</code>. Make sure you watch the Tomcat log to see Hibernate initialize when the first request hits your servlet (the static initializer in <code class="literal">HibernateUtil</code> is called) and to get the detailed output if any exceptions occurs. </p></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial-summary"/>1.4. Summary</h2></div></div></div><p>This tutorial covered the basics of writing a simple standalone Hibernate application and a small web application. More tutorials are available from the Hibernate <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://hibernate.org">website</a>. </p></div></div><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="architecture"/>Capítulo 2. Arquitectura</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#architecture-overview">2.1. Visión General</a></span></dt><dt><span class="sect1"><a href="#architecture-states">2.2. Estados de instancia</a></span></dt><dt><span class="sect1"><a href="#architecture-jmx">2.3. Integración JMX</a></span></dt><dt><span class="sect1"><a href="#architecture-jca">2.4. Soporte JCA:</a></span></dt><dt><span class="sect1"><a href="#architecture-current-session">2.5. Contextual sessions</a></span></dt></dl></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-overview"/>2.1. Visión General</h2></div></div></div><p>The diagram below provides a high-level view of the Hibernate architecture: </p><div class="mediaobject" align="center"><img src="../images/overview.png" align="middle"/></div><p>We do not have the scope in this document to provide a more detailed view of all the runtime architectures available; Hibernate is flexible and supports several different approaches. We will, however, show the two extremes: "minimal" architecture and "comprehensive" architecture. </p><p>This next diagram illustrates how Hibernate utilizes database and configuration data to provide persistence services, and persistent objects, to the application. </p><p>The "minimal" architecture has the application provide its own JDBC connections and manage its own transactions. This approach uses a minimal subset of Hibernate's APIs: </p><div class="mediaobject" align="center"><img src="../images/lite.png" align="middle"/></div><p>The "comprehensive" architecture abstracts the application away from the underlying JDBC/JTA APIs and allows Hibernate to manage the details. </p><div class="mediaobject" align="center"><img src="../images/full_cream.png" align="middle"/></div><p>Here are some definitions of the objects depicted in the diagrams: </p><div class="variablelist"><dl><dt><span class="term">SessionFactory (<code class="literal">org.hibernate.SessionFactory</code>)</span></dt><dd><p>A threadsafe, immutable cache of compiled mappings for a single database. A factory for <code class="literal">Session</code> and a client of <code class="literal">ConnectionProvider</code>, <code class="literal">SessionFactory</code> can hold an optional (second-level) cache of data that is reusable between transactions at a process, or cluster, level. </p></dd><dt><span class="term">Session (<code class="literal">org.hibernate.Session</code>)</span></dt><dd><p>A single-threaded, short-lived object representing a conversation between the application and the persistent store. It wraps a JDBC connection and is a factory for <code class="literal">Transaction</code>. <code class="literal">Session</code> holds a mandatory first-level cache of persistent objects that are used when navigating the object graph or looking up objects by identifier. </p></dd><dt><span class="term">Objetos y colecciones persistentes</span></dt><dd><p>Short-lived, single threaded objects containing persistent state and business function. These can be ordinary JavaBeans/POJOs. They are associated with exactly one <code class="literal">Session</code>. Once the <code class="literal">Session</code> is closed, they will be detached and free to use in any application layer (for example, directly as data transfer objects to and from presentation). </p></dd><dt><span class="term">Objetos y colecciones transitorios y separados</span></dt><dd><p>Instances of persistent classes that are not currently associated with a <code class="literal">Session</code>. They may have been instantiated by the application and not yet persisted, or they may have been instantiated by a closed <code class="literal">Session</code>. </p></dd><dt><span class="term">Transaction (<code class="literal">org.hibernate.Transaction</code>)</span></dt><dd><p>(Optional) A single-threaded, short-lived object used by the application to specify atomic units of work. It abstracts the application from the underlying JDBC, JTA or CORBA transaction. A <code class="literal">Session</code> might span several <code class="literal">Transaction</code>s in some cases. However, transaction demarcation, either using the underlying API or <code class="literal">Transaction</code>, is never optional. </p></dd><dt><span class="term">ConnectionProvider (<code class="literal">org.hibernate.connection.ConnectionProvider</code>)</span></dt><dd><p>(Optional) A factory for, and pool of, JDBC connections. It abstracts the application from underlying <code class="literal">Datasource</code> or <code class="literal">DriverManager</code>. It is not exposed to application, but it can be extended and/or implemented by the developer. </p></dd><dt><span class="term">TransactionFactory (<code class="literal">org.hibernate.TransactionFactory</code>)</span></dt><dd><p>(Optional) A factory for <code class="literal">Transaction</code> instances. It is not exposed to the application, but it can be extended and/or implemented by the developer. </p></dd><dt><span class="term"><span class="emphasis"><em>Interfaces de Extensión</em></span></span></dt><dd><p>Hibernate offers a range of optional extension interfaces you can implement to customize the behavior of your persistence layer. See the API documentation for details. </p></dd></dl></div><p>
        </p><p>Given a "minimal" architecture, the application bypasses the <code class="literal">Transaction</code>/<code class="literal">TransactionFactory</code> and/or <code class="literal">ConnectionProvider</code> APIs to communicate with JTA or JDBC directly. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-states"/>2.2. Estados de instancia</h2></div></div></div><p>An instance of a persistent class can be in one of three different states. These states are defined in relation to a <span class="emphasis"><em>persistence context</em></span>. The Hibernate <code class="literal">Session</code> object is the persistence context. The three different states are as follows: </p><div class="variablelist"><dl><dt><span class="term">transitorio</span></dt><dd><p>The instance is not associated with any persistence context. It has no persistent identity or primary key value. </p></dd><dt><span class="term">persistente</span></dt><dd><p>The instance is currently associated with a persistence context. It has a persistent identity (primary key value) and can have a corresponding row in the database. For a particular persistence context, Hibernate <span class="emphasis"><em>guarantees</em></span> that persistent identity is equivalent to Java identity in relation to the in-memory location of the object. </p></dd><dt><span class="term">separado</span></dt><dd><p>The instance was once associated with a persistence context, but that context was closed, or the instance was serialized to another process. It has a persistent identity and can have a corresponding row in the database. For detached instances, Hibernate does not guarantee the relationship between persistent identity and Java identity. </p></dd></dl></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-jmx"/>2.3. Integración JMX</h2></div></div></div><p>JMX is the J2EE standard for the management of Java components. Hibernate can be managed via a JMX standard service. AN MBean implementation is provided in the distribution: <code class="literal">org.hibernate.jmx.HibernateService</code>. </p><p>For an example of how to deploy Hibernate as a JMX service on the JBoss Application Server, please see the JBoss User Guide. JBoss AS also provides these benefits if you deploy using JMX: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Session Management</em></span>: the Hibernate <code class="literal">Session</code>'s life cycle can be automatically bound to the scope of a JTA transaction. This means that you no longer have to manually open and close the <code class="literal">Session</code>; this becomes the job of a JBoss EJB interceptor. You also do not have to worry about transaction demarcation in your code (if you would like to write a portable persistence layer use the optional Hibernate <code class="literal">Transaction</code> API for this). You call the <code class="literal">HibernateContext</code> to access a <code class="literal">Session</code>. </p></li><li><p><span class="emphasis"><em>HAR deployment</em></span>: the Hibernate JMX service is deployed using a JBoss service deployment descriptor in an EAR and/or SAR file, as it supports all the usual configuration options of a Hibernate <code class="literal">SessionFactory</code>. However, you still need to name all your mapping files in the deployment descriptor. If you use the optional HAR deployment, JBoss will automatically detect all mapping files in your HAR file. </p></li></ul></div><p>Para más información sobre estas opciones, consulta la Guía de Usuario del JBoss AS. </p><p>Another feature available as a JMX service is runtime Hibernate statistics. See <a href="#configuration-optional-statistics" title="3.4.6. Hibernate statistics">Sección 3.4.6, “Hibernate statistics”</a> for more information. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-jca"/>2.4. Soporte JCA:</h2></div></div></div><p>Hibernate can also be configured as a JCA connector. Please see the website for more information. Please note, however, that at this stage Hibernate JCA support is under development. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-current-session"/>2.5. Contextual sessions</h2></div></div></div><p>Most applications using Hibernate need some form of "contextual" session, where a given session is in effect throughout the scope of a given context. However, across applications the definition of what constitutes a context is typically different; different contexts define different scopes to the notion of current. Applications using Hibernate prior to version 3.0 tended to utilize either home-grown <code class="literal">ThreadLocal</code>-based contextual sessions, helper classes such as <code class="literal">HibernateUtil</code>, or utilized third-party frameworks, such as Spring or Pico, which provided proxy/interception-based contextual sessions. </p><p>Starting with version 3.0.1, Hibernate added the <code class="literal">SessionFactory.getCurrentSession()</code> method. Initially, this assumed usage of <code class="literal">JTA</code> transactions, where the <code class="literal">JTA</code> transaction defined both the scope and context of a current session. Given the maturity of the numerous stand-alone <code class="literal">JTA TransactionManager</code> implementations, most, if not all, applications should be using <code class="literal">JTA</code> transaction management, whether or not they are deployed into a <code class="literal">J2EE</code> container. Based on that, the <code class="literal">JTA</code>-based contextual sessions are all you need to use. </p><p>However, as of version 3.1, the processing behind <code class="literal">SessionFactory.getCurrentSession()</code> is now pluggable. To that end, a new extension interface, <code class="literal">org.hibernate.context.CurrentSessionContext</code>, and a new configuration parameter, <code class="literal">hibernate.current_session_context_class</code>, have been added to allow pluggability of the scope and context of defining current sessions. </p><p>See the Javadocs for the <code class="literal">org.hibernate.context.CurrentSessionContext</code> interface for a detailed discussion of its contract. It defines a single method, <code class="literal">currentSession()</code>, by which the implementation is responsible for tracking the current contextual session. Out-of-the-box, Hibernate comes with three implementations of this interface: </p><div class="itemizedlist"><ul><li><p><code class="literal">org.hibernate.context.JTASessionContext</code>: current sessions are tracked and scoped by a <code class="literal">JTA</code> transaction. The processing here is exactly the same as in the older JTA-only approach. See the Javadocs for details. </p></li><li><p><code class="literal">org.hibernate.context.ThreadLocalSessionContext</code>:current sessions are tracked by thread of execution. See the Javadocs for details. </p></li><li><p><code class="literal">org.hibernate.context.ManagedSessionContext</code>: current sessions are tracked by thread of execution. However, you are responsible to bind and unbind a <code class="literal">Session</code> instance with static methods on this class: it does not open, flush, or close a <code class="literal">Session</code>. </p></li></ul></div><p>The first two implementations provide a "one session - one database transaction" programming model. This is also also known and used as <span class="emphasis"><em>session-per-request</em></span>. The beginning and end of a Hibernate session is defined by the duration of a database transaction. If you use programmatic transaction demarcation in plain JSE without JTA, you are advised to use the Hibernate <code class="literal">Transaction</code> API to hide the underlying transaction system from your code. If you use JTA, you can utilize the JTA interfaces to demarcate transactions. If you execute in an EJB container that supports CMT, transaction boundaries are defined declaratively and you do not need any transaction or session demarcation operations in your code. Refer to <a href="#transactions" title="Capítulo 11. Transactions and Concurrency">Capítulo 11, <i xmlns:xlink="http://www.w3.org/1999/xlink">Transactions and Concurrency</i></a> for more information and code examples. </p><p>The <code class="literal">hibernate.current_session_context_class</code> configuration parameter defines which <code class="literal">org.hibernate.context.CurrentSessionContext</code> implementation should be used. For backwards compatibility, if this configuration parameter is not set but a <code class="literal">org.hibernate.transaction.TransactionManagerLookup</code> is configured, Hibernate will use the <code class="literal">org.hibernate.context.JTASessionContext</code>. Typically, the value of this parameter would just name the implementation class to use. For the three out-of-the-box implementations, however, there are three corresponding short names: "jta", "thread", and "managed". </p></div></div><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="session-configuration"/>Capítulo 3. Configuración</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#configuration-programmatic">3.1. Configuración programática</a></span></dt><dt><span class="sect1"><a href="#configuration-sessionfactory">3.2. Obteniendo una SessionFactory</a></span></dt><dt><span class="sect1"><a href="#configuration-hibernatejdbc">3.3. Conexiones JDBC</a></span></dt><dt><span class="sect1"><a href="#configuration-optional">3.4. Parámetros de configuración opcionales</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuration-optional-dialects">3.4.1. SQL Dialects</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-outerjoin">3.4.2. Recuperación por Unión Externa (Outer Join Fetching)</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-binarystreams">3.4.3. Flujos Binarios</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-cacheprovider">3.4.4. Caché de segundo nivel y de lectura</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-querysubstitution">3.4.5. Sustitución de Lenguaje de Consulta</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-statistics">3.4.6. Hibernate statistics</a></span></dt></dl></dd><dt><span class="sect1"><a href="#configuration-logging">3.5. Registros de mensajes (Logging)</a></span></dt><dt><span class="sect1"><a href="#configuration-namingstrategy">3.6. Implementando una <code class="literal">NamingStrategy</code></a></span></dt><dt><span class="sect1"><a href="#configuration-xmlconfig">3.7. Fichero de configuración XML</a></span></dt><dt><span class="sect1"><a href="#configuration-j2ee">3.8. Integració con Servidores de Aplicaciones J2EE</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuration-optional-transactionstrategy">3.8.1. Configuración de la estrategia de transacción</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-jndi">3.8.2. <code class="literal">SessionFactory</code> ligada a JNDI</a></span></dt><dt><span class="sect2"><a href="#configuration-j2ee-currentsession">3.8.3. Ligado automático de JTA y Session</a></span></dt><dt><span class="sect2"><a href="#configuration-j2ee-jmx">3.8.4. Despliegue JMX</a></span></dt></dl></dd></dl></div><p>Hibernate is designed to operate in many different environments and, as such, there is a broad range of configuration parameters. Fortunately, most have sensible default values and Hibernate is distributed with an example <code class="literal">hibernate.properties</code> file in <code class="literal">etc/</code> that displays the various options. Simply put the example file in your classpath and customize it to suit your needs. </p><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-programmatic"/>3.1. Configuración programática</h2></div></div></div><p>An instance of <code class="classname">org.hibernate.cfg.Configuration</code> represents an entire set of mappings of an application's Java types to an SQL database. The <code class="classname">org.hibernate.cfg.Configuration</code> is used to build an immutable <code class="interfacename">org.hibernate.SessionFactory</code>. The mappings are compiled from various XML mapping files. </p><p>You can obtain a <code class="classname">org.hibernate.cfg.Configuration</code> instance by instantiating it directly and specifying XML mapping documents. If the mapping files are in the classpath, use <code class="literal">addResource()</code>. For example: </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addResource("Item.hbm.xml")
    .addResource("Bid.hbm.xml");</pre><p>An alternative way is to specify the mapped class and allow Hibernate to find the mapping document for you: </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class);</pre><p>Hibernate will then search for mapping files named <code class="filename">/org/hibernate/auction/Item.hbm.xml</code> and <code class="filename">/org/hibernate/auction/Bid.hbm.xml</code> in the classpath. This approach eliminates any hardcoded filenames. </p><p>A <code class="classname">org.hibernate.cfg.Configuration</code> also allows you to specify configuration properties. For example: </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class)
    .setProperty("hibernate.dialect", "org.hibernate.dialect.MySQLInnoDBDialect")
    .setProperty("hibernate.connection.datasource", "java:comp/env/jdbc/test")
    .setProperty("hibernate.order_updates", "true");</pre><p>This is not the only way to pass configuration properties to Hibernate. Some alternative options include: </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>Pasar una instancia de <code class="literal">java.util.Properties</code> a <code class="literal">Configuration.setProperties()</code>. </p></li><li><p>Colocar <code class="literal">hibernate.properties</code> en un directorio raíz del classpath. </p></li><li><p>Establecer propiedades <code class="literal">System</code> usando <code class="literal">java -Dproperty=value</code>. </p></li><li><p>Include <code class="literal">&lt;property&gt;</code> elements in <code class="literal">hibernate.cfg.xml</code> (this is discussed later). </p></li></ol></div><p>If you want to get started quickly<code class="filename">hibernate.properties</code> is the easiest approach. </p><p>The <code class="classname">org.hibernate.cfg.Configuration</code> is intended as a startup-time object that will be discarded once a <code class="literal">SessionFactory</code> is created. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-sessionfactory"/>3.2. Obteniendo una SessionFactory</h2></div></div></div><p>Cuando todos los mapeos han sido parseados por la <code class="literal">Configuration</code>, la aplicación debe obtener una fábrica de instancias de <code class="literal">Session</code>. Esta fábrica está concebida para ser compartida por todas las hebras de aplicación: </p><pre class="programlisting">SessionFactory sessions = cfg.buildSessionFactory();</pre><p>Hibernate permite que tu aplicación instancie más de una <code class="literal">SessionFactory</code>. Esto es útil si estás usando más de una base de datos. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-hibernatejdbc"/>3.3. Conexiones JDBC</h2></div></div></div><p>It is advisable to have the <code class="interfacename">org.hibernate.SessionFactory</code> create and pool JDBC connections for you. If you take this approach, opening a <code class="interfacename">org.hibernate.Session</code> is as simple as: </p><pre class="programlisting">Session session = sessions.openSession(); // open a new Session</pre><p>Once you start a task that requires access to the database, a JDBC connection will be obtained from the pool. </p><p>Before you can do this, you first need to pass some JDBC connection properties to Hibernate. All Hibernate property names and semantics are defined on the class <code class="classname">org.hibernate.cfg.Environment</code>. The most important settings for JDBC connection configuration are outlined below. </p><p>Hibernate will obtain and pool connections using <code class="classname">java.sql.DriverManager</code> if you set the following properties: </p><div class="table"><a id="d0e1793"/><p class="title"><b>Tabla 3.1. Propiedades JDBC de Hibernate</b></p><div class="table-contents"><table summary="Propiedades JDBC de Hibernate" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Nombre de propiedad</th><th>Propósito</th></tr></thead><tbody><tr><td>
                    <span class="property">hibernate.connection.driver_class</span>
                </td><td>
                    <span class="emphasis"><em>clase del driver jdbc</em></span>
                </td></tr><tr><td>
                    <span class="property">hibernate.connection.url</span>
                </td><td>
                    <span class="emphasis"><em>URL de jdbc</em></span>
                </td></tr><tr><td>
                    <span class="property">hibernate.connection.username</span>
                </td><td>
                    <span class="emphasis"><em>usuario de base de datos</em></span>
                </td></tr><tr><td>
                    <span class="property">hibernate.connection.password</span>
                </td><td>
                    <span class="emphasis"><em>contraseña del usuario de base de datos</em></span>
                </td></tr><tr><td>
                    <span class="property">hibernate.connection.pool_size</span>
                </td><td>
                    <span class="emphasis"><em>número máximo de conexiones manejadas por pooling</em></span>
                </td></tr></tbody></table></div></div><br class="table-break"/><p>Hibernate's own connection pooling algorithm is, however, quite rudimentary. It is intended to help you get started and is <span class="emphasis"><em>not intended for use in a production system</em></span>, or even for performance testing. You should use a third party pool for best performance and stability. Just replace the <span class="property">hibernate.connection.pool_size</span> property with connection pool specific settings. This will turn off Hibernate's internal pool. For example, you might like to use c3p0. </p><p>C3P0 is an open source JDBC connection pool distributed along with Hibernate in the <code class="filename">lib</code> directory. Hibernate will use its <code class="classname">org.hibernate.connection.C3P0ConnectionProvider</code> for connection pooling if you set <span class="property">hibernate.c3p0.*</span> properties. If you would like to use Proxool, refer to the packaged <code class="filename">hibernate.properties</code> and the Hibernate web site for more information. </p><p>The following is an example <code class="filename">hibernate.properties</code> file for c3p0: </p><a id="c3p0-configuration"/><pre class="programlisting">hibernate.connection.driver_class = org.postgresql.Driver
hibernate.connection.url = jdbc:postgresql://localhost/mydatabase
hibernate.connection.username = myuser
hibernate.connection.password = secret
hibernate.c3p0.min_size=5
hibernate.c3p0.max_size=20
hibernate.c3p0.timeout=1800
hibernate.c3p0.max_statements=50
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect</pre><p>For use inside an application server, you should almost always configure Hibernate to obtain connections from an application server <code class="interfacename">javax.sql.Datasource</code> registered in JNDI. You will need to set at least one of the following properties: </p><div class="table"><a id="d0e1895"/><p class="title"><b>Tabla 3.2. Propiedades de Datasource de Hibernate</b></p><div class="table-contents"><table summary="Propiedades de Datasource de Hibernate" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Nombre de propiedad</th><th>Propósito</th></tr></thead><tbody><tr><td>
                    <span class="property">hibernate.connection.datasource</span>
                </td><td>
                    <span class="emphasis"><em>nombre del datasource JNDI</em></span>
                </td></tr><tr><td>
                    <span class="property">hibernate.jndi.url</span>
                </td><td><span class="emphasis"><em>URL del provedor JNDI</em></span> (optional) </td></tr><tr><td>
                    <span class="property">hibernate.jndi.class</span>
                </td><td><span class="emphasis"><em>clase de la <code class="literal">InitialContextFactory</code> de JNDI</em></span> (opcional) </td></tr><tr><td>
                    <span class="property">hibernate.connection.username</span>
                </td><td><span class="emphasis"><em>usuario de base de datos</em></span> (opcional) </td></tr><tr><td>
                    <span class="property">hibernate.connection.password</span>
                </td><td><span class="emphasis"><em>contraseña del usuario de base de datos</em></span> (opcional) </td></tr></tbody></table></div></div><br class="table-break"/><p>Here is an example <code class="filename">hibernate.properties</code> file for an application server provided JNDI datasource: </p><pre class="programlisting">hibernate.connection.datasource = java:/comp/env/jdbc/test
hibernate.transaction.factory_class = \
    org.hibernate.transaction.JTATransactionFactory
hibernate.transaction.manager_lookup_class = \
    org.hibernate.transaction.JBossTransactionManagerLookup
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect</pre><p>Las conexiones JDBC obtenidas de un datasource JNDI participarán automáticamente en las transacciones del servidor de aplicaciones manejadas por contenedor. </p><p>Arbitrary connection properties can be given by prepending "<code class="literal">hibernate.connection</code>" to the connection property name. For example, you can specify a <span class="property">charSet</span> connection property using <span class="property">hibernate.connection.charSet</span>. </p><p>You can define your own plugin strategy for obtaining JDBC connections by implementing the interface <code class="interfacename">org.hibernate.connection.ConnectionProvider</code>, and specifying your custom implementation via the <span class="property">hibernate.connection.provider_class</span> property. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-optional"/>3.4. Parámetros de configuración opcionales</h2></div></div></div><p>There are a number of other properties that control the behavior of Hibernate at runtime. All are optional and have reasonable default values. </p><p>
        	</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Aviso</h2><span class="emphasis"><em>Some of these properties are "system-level" only.</em></span> System-level properties can be set only via <code class="literal">java -Dproperty=value</code> or <code class="filename">hibernate.properties</code>. They <span class="emphasis"><em>cannot</em></span> be set by the other techniques described above.</div><p>
        </p><div class="table"><a id="configuration-optional-properties"/><p class="title"><b>Tabla 3.3. Propiedades de Configuración de Hibernate</b></p><div class="table-contents"><table summary="Propiedades de Configuración de Hibernate" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Nombre de propiedad</th><th>Propósito</th></tr></thead><tbody><tr><td>
                            <span class="property">hibernate.dialect</span>
                        </td><td>El nombre de clase de un <code class="literal">Dialect</code> de Hibernate que permite a Hibernate generar SQL optimizado para una base de datos relacional en particular. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">full.classname.of.Dialect</code> </p>
                            <p>In most cases Hibernate will actually be able to choose the correct <code class="classname">org.hibernate.dialect.Dialect</code> implementation based on the <code class="literal">JDBC metadata</code> returned by the JDBC driver. </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.show_sql</span>
                        </td><td>Escribe todas las sentencias SQL a la consola. This is an alternative to setting the log category <code class="literal">org.hibernate.SQL</code> to <code class="literal">debug</code>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.format_sql</span>
                        </td><td>Pretty print the SQL in the log and console. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.default_schema</span>
                        </td><td>Cualifica, en el SQL generado, los nombres de tabla sin cualificar con el esquema/tablespace dado. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">SCHEMA_NAME</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.default_catalog</span>
                        </td><td>Qualifies unqualified table names with the given catalog in generated SQL. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">CATALOG_NAME</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.session_factory_name</span>
                        </td><td>La <code class="literal">SessionFactory</code> será ligada a este nombre en JNDI automáticamente después de ser creada. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">jndi/composite/name</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.max_fetch_depth</span>
                        </td><td>Sets a maximum "depth" for the outer join fetch tree for single-ended associations (one-to-one, many-to-one). A <code class="literal">0</code> disables default outer join fetching. <p><span class="strong"><strong>e.g.</strong></span> recommended values between <code class="literal">0</code> and <code class="literal">3</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.default_batch_fetch_size</span>
                        </td><td>Sets a default size for Hibernate batch fetching of associations. <p><span class="strong"><strong>e.g.</strong></span> recommended values <code class="literal">4</code>, <code class="literal">8</code>, <code class="literal">16</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.default_entity_mode</span>
                        </td><td>Sets a default mode for entity representation for all sessions opened from this <code class="literal">SessionFactory</code> <p><code class="literal">dynamic-map</code>, <code class="literal">dom4j</code>, <code class="literal">pojo</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.order_updates</span>
                        </td><td>Forces Hibernate to order SQL updates by the primary key value of the items being updated. This will result in fewer transaction deadlocks in highly concurrent systems. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.generate_statistics</span>
                        </td><td>De habilitarse, Hibernate colectará estadísticas útiles para la afinación de rendimiento. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.use_identifer_rollback</span>
                        </td><td>De habilitarse, las propiedades identificadoras generadas serán reseteadas a valores por defecto cuando los objetos sean borrados. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.use_sql_comments</span>
                        </td><td>De activarse, Hibernate generará comentarios dentro del SQL, para una más fácil depuración, por defecto a <code class="literal">false</code>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="configuration-jdbc-properties"/><p class="title"><b>Tabla 3.4. Propiedades de JDBC y Conexiones de Hibernate</b></p><div class="table-contents"><table summary="Propiedades de JDBC y Conexiones de Hibernate" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Nombre de propiedad</th><th>Propósito</th></tr></thead><tbody><tr><td>
                            <span class="property">hibernate.jdbc.fetch_size</span>
                        </td><td>Un valor distinto de cero que determina el tamaño de recuperación de JDBC (llama a <code class="literal">Statement.setFetchSize()</code>). </td></tr><tr><td>
                            <span class="property">hibernate.jdbc.batch_size</span>
                        </td><td>Un valor distinto de cero habilita el uso de actualizaciones en lote de JDBC2 por Hibernate. <p><span class="strong"><strong>e.g.</strong></span> recommended values between <code class="literal">5</code> and <code class="literal">30</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.jdbc.batch_versioned_data</span>
                        </td><td>Set this property to <code class="literal">true</code> if your JDBC driver returns correct row counts from <code class="literal">executeBatch()</code>. Iit is usually safe to turn this option on. Hibernate will then use batched DML for automatically versioned data. Defaults to <code class="literal">false</code>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.jdbc.factory_class</span>
                        </td><td>Selecciona un <code class="literal">Batcher</code> personalizado. La mayoría de las aplicaciones no necesitarán esta propiedad de configuración. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">classname.of.BatcherFactory</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.jdbc.use_scrollable_resultset</span>
                        </td><td>Enables use of JDBC2 scrollable resultsets by Hibernate. This property is only necessary when using user-supplied JDBC connections. Hibernate uses connection metadata otherwise. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.jdbc.use_streams_for_binary</span>
                        </td><td>Usa flujos (streams) al escribir/leer tipos <code class="literal">binary</code> o <code class="literal">serializable</code> a/desde JDBC (propiedad a nivel de sistema). <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.jdbc.use_get_generated_keys</span>
                        </td><td>Enables use of JDBC3 <code class="literal">PreparedStatement.getGeneratedKeys()</code> to retrieve natively generated keys after insert. Requires JDBC3+ driver and JRE1.4+, set to false if your driver has problems with the Hibernate identifier generators. By default, it tries to determine the driver capabilities using connection metadata. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true|false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.connection.provider_class</span>
                        </td><td>EL nombre de clase de un <code class="literal">ConnectionProvider</code> personalizado que provea conexiones JDBC a Hibernate. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">classname.of.ConnectionProvider</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.connection.isolation</span>
                        </td><td>Sets the JDBC transaction isolation level. Check <code class="interfacename">java.sql.Connection</code> for meaningful values, but note that most databases do not support all isolation levels and some define additional, non-standard isolations. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">1, 2, 4, 8</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.connection.autocommit</span>
                        </td><td>Enables autocommit for JDBC pooled connections (it is not recommended). <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.connection.release_mode</span>
                        </td><td>Specifies when Hibernate should release JDBC connections. By default, a JDBC connection is held until the session is explicitly closed or disconnected. For an application server JTA datasource, use <code class="literal">after_statement</code> to aggressively release connections after every JDBC call. For a non-JTA connection, it often makes sense to release the connection at the end of each transaction, by using <code class="literal">after_transaction</code>. <code class="literal">auto</code> will choose <code class="literal">after_statement</code> for the JTA and CMT transaction strategies and <code class="literal">after_transaction</code> for the JDBC transaction strategy. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">auto</code> (default) | <code class="literal">on_close</code> | <code class="literal">after_transaction</code> | <code class="literal">after_statement</code> </p>
                            <p>This setting only affects <code class="literal">Session</code>s returned from <code class="literal">SessionFactory.openSession</code>. For <code class="literal">Session</code>s obtained through <code class="literal">SessionFactory.getCurrentSession</code>, the <code class="literal">CurrentSessionContext</code> implementation configured for use controls the connection release mode for those <code class="literal">Session</code>s. See <a href="#architecture-current-session" title="2.5. Contextual sessions">Sección 2.5, “Contextual sessions”</a> </p>
                        </td></tr><tr><td>hibernate.connection.<span class="emphasis"><em>&lt;propertyName&gt;</em></span> </td><td>Pasa la propiedad JDBC <code class="literal">propertyName</code> a <code class="literal">DriverManager.getConnection()</code>. </td></tr><tr><td>hibernate.jndi.<span class="emphasis"><em>&lt;propertyName&gt;</em></span> </td><td>Pasa la propiedad <code class="literal">propertyName</code> a <code class="literal">InitialContextFactory</code> de JNDI. </td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="configuration-cache-properties"/><p class="title"><b>Tabla 3.5. Propiedades de Caché de Hibernate</b></p><div class="table-contents"><table summary="Propiedades de Caché de Hibernate" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Nombre de propiedad</th><th>Propósito</th></tr></thead><tbody><tr><td>
                            <code class="literal">hibernate.cache.provider_class</code>
                        </td><td>El nombre de clase de un <code class="literal">CacheProvider</code> personalizado. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">classname.of.CacheProvider</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cache.use_minimal_puts</code>
                        </td><td>Optimizes second-level cache operation to minimize writes, at the cost of more frequent reads. This setting is most useful for clustered caches and, in Hibernate3, is enabled by default for clustered cache implementations. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true|false</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cache.use_query_cache</code>
                        </td><td>Enables the query cache. Individual queries still have to be set cachable. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true|false</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cache.use_second_level_cache</code>
                        </td><td>Can be used to completely disable the second level cache, which is enabled by default for classes which specify a <code class="literal">&lt;cache&gt;</code> mapping. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true|false</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cache.query_cache_factory</code>
                        </td><td>El nombre de clase de una interface <code class="literal">QueryCache</code> personalizada, por defecto al <code class="literal">StandardQueryCache</code> prefabricado. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">classname.of.QueryCache</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cache.region_prefix</code>
                        </td><td>Un prefijo a usar para los nombres de región del caché de segundo nivel. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">prefix</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cache.use_structured_entries</code>
                        </td><td>Fuerza a Hibernate a almacenar los datos en el caché de segundo nivel en un formato más amigable al humano. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true|false</code> </p>
                        </td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="configuration-transaction-properties"/><p class="title"><b>Tabla 3.6. Propiedades de Transacción de Hibernate</b></p><div class="table-contents"><table summary="Propiedades de Transacción de Hibernate" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Nombre de propiedad</th><th>Propósito</th></tr></thead><tbody><tr><td>
                            <code class="literal">hibernate.transaction.factory_class</code>
                        </td><td>El nombre de clase de un <code class="literal">TransactionFactory</code> a usar con la API de <code class="literal">Transaction</code> de Hibernate (por defectoa <code class="literal">JDBCTransactionFactory</code>). <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">classname.of.TransactionFactory</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">jta.UserTransaction</code>
                        </td><td>Un nombre JNDI usado por <code class="literal">JTATransactionFactory</code> para obtener la <code class="literal">UserTransaction</code> JTA del servidor de aplicaciones. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">jndi/composite/name</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.transaction.manager_lookup_class</code>
                        </td><td>The classname of a <code class="literal">TransactionManagerLookup</code>. It is required when JVM-level caching is enabled or when using hilo generator in a JTA environment. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">classname.of.TransactionManagerLookup</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.transaction.flush_before_completion</code>
                        </td><td>De habilitarse, la sesión se limpiará (flushed) automáticamente durante la fase previa a la compleción de la transacción. (Muy útil cuando se usa Hibernate con CMT). <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.transaction.auto_close_session</code>
                        </td><td>If enabled, the session will be automatically closed during the after completion phase of the transaction. Built-in and automatic session context management is preferred, see <a href="#architecture-current-session" title="2.5. Contextual sessions">Sección 2.5, “Contextual sessions”</a>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="configuration-misc-properties"/><p class="title"><b>Tabla 3.7. Propiedades Misceláneas</b></p><div class="table-contents"><table summary="Propiedades Misceláneas" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Nombre de propiedad</th><th>Propósito</th></tr></thead><tbody><tr><td>
                            <code class="literal">hibernate.current_session_context_class</code>
                        </td><td>Supply a custom strategy for the scoping of the "current" <code class="literal">Session</code>. See <a href="#architecture-current-session" title="2.5. Contextual sessions">Sección 2.5, “Contextual sessions”</a> for more information about the built-in strategies. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">jta</code> | <code class="literal">thread</code> | <code class="literal">managed</code> | <code class="literal">custom.Class</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.query.factory_class</code>
                        </td><td>Elige la implementación de parser HQL. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">org.hibernate.hql.ast.ASTQueryTranslatorFactory</code> or <code class="literal">org.hibernate.hql.classic.ClassicQueryTranslatorFactory</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.query.substitutions</code>
                        </td><td>Is used to map from tokens in Hibernate queries to SQL tokens (tokens might be function or literal names, for example). <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.hbm2ddl.auto</code>
                        </td><td>Automatically validates or exports schema DDL to the database when the <code class="literal">SessionFactory</code> is created. With <code class="literal">create-drop</code>, the database schema will be dropped when the <code class="literal">SessionFactory</code> is closed explicitly. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">validate</code> | <code class="literal">update</code> | <code class="literal">create</code> | <code class="literal">create-drop</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cglib.use_reflection_optimizer</code>
                        </td><td>Enables the use of CGLIB instead of runtime reflection (System-level property). Reflection can sometimes be useful when troubleshooting. Hibernate always requires CGLIB even if you turn off the optimizer. You cannot set this property in <code class="literal">hibernate.cfg.xml</code>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr></tbody></table></div></div><br class="table-break"/><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-dialects"/>3.4.1. SQL Dialects</h3></div></div></div><p>Always set the <code class="literal">hibernate.dialect</code> property to the correct <code class="literal">org.hibernate.dialect.Dialect</code> subclass for your database. If you specify a dialect, Hibernate will use sensible defaults for some of the other properties listed above. This means that you will not have to specify them manually. </p><div class="table"><a id="sql-dialects"/><p class="title"><b>Tabla 3.8. Dialectos SQL de Hibernate(<code class="literal">hibernate.dialect</code>)</b></p><div class="table-contents"><table summary="Dialectos SQL de Hibernate(hibernate.dialect)" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>RDBMS</th><th>Dialecto</th></tr></thead><tbody><tr><td>DB2</td><td><code class="literal">org.hibernate.dialect.DB2Dialect</code></td></tr><tr><td>DB2 AS/400</td><td><code class="literal">org.hibernate.dialect.DB2400Dialect</code></td></tr><tr><td>DB2 OS390</td><td><code class="literal">org.hibernate.dialect.DB2390Dialect</code></td></tr><tr><td>PostgreSQL</td><td><code class="literal">org.hibernate.dialect.PostgreSQLDialect</code></td></tr><tr><td>MySQL</td><td><code class="literal">org.hibernate.dialect.MySQLDialect</code></td></tr><tr><td>MySQL con InnoDB</td><td><code class="literal">org.hibernate.dialect.MySQLInnoDBDialect</code></td></tr><tr><td>MySQL con MyISAM</td><td><code class="literal">org.hibernate.dialect.MySQLMyISAMDialect</code></td></tr><tr><td>Oracle (cualquier versión)</td><td><code class="literal">org.hibernate.dialect.OracleDialect</code></td></tr><tr><td>Oracle 9i</td><td><code class="literal">org.hibernate.dialect.Oracle9iDialect</code></td></tr><tr><td>Oracle 10g</td><td><code class="literal">org.hibernate.dialect.Oracle10gDialect</code></td></tr><tr><td>Sybase</td><td><code class="literal">org.hibernate.dialect.SybaseDialect</code></td></tr><tr><td>Sybase Anywhere</td><td><code class="literal">org.hibernate.dialect.SybaseAnywhereDialect</code></td></tr><tr><td>Microsoft SQL Server</td><td><code class="literal">org.hibernate.dialect.SQLServerDialect</code></td></tr><tr><td>SAP DB</td><td><code class="literal">org.hibernate.dialect.SAPDBDialect</code></td></tr><tr><td>Informix</td><td><code class="literal">org.hibernate.dialect.InformixDialect</code></td></tr><tr><td>HypersonicSQL</td><td><code class="literal">org.hibernate.dialect.HSQLDialect</code></td></tr><tr><td>Ingres</td><td><code class="literal">org.hibernate.dialect.IngresDialect</code></td></tr><tr><td>Progress</td><td><code class="literal">org.hibernate.dialect.ProgressDialect</code></td></tr><tr><td>Mckoi SQL</td><td><code class="literal">org.hibernate.dialect.MckoiDialect</code></td></tr><tr><td>Interbase</td><td><code class="literal">org.hibernate.dialect.InterbaseDialect</code></td></tr><tr><td>Pointbase</td><td><code class="literal">org.hibernate.dialect.PointbaseDialect</code></td></tr><tr><td>FrontBase</td><td><code class="literal">org.hibernate.dialect.FrontbaseDialect</code></td></tr><tr><td>Firebird</td><td><code class="literal">org.hibernate.dialect.FirebirdDialect</code></td></tr></tbody></table></div></div><br class="table-break"/></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-outerjoin"/>3.4.2. Recuperación por Unión Externa (Outer Join Fetching)</h3></div></div></div><p>If your database supports ANSI, Oracle or Sybase style outer joins, <span class="emphasis"><em>outer join fetching</em></span> will often increase performance by limiting the number of round trips to and from the database. This is, however, at the cost of possibly more work performed by the database itself. Outer join fetching allows a whole graph of objects connected by many-to-one, one-to-many, many-to-many and one-to-one associations to be retrieved in a single SQL <code class="literal">SELECT</code>. </p><p>Outer join fetching can be disabled <span class="emphasis"><em>globally</em></span> by setting the property <code class="literal">hibernate.max_fetch_depth</code> to <code class="literal">0</code>. A setting of <code class="literal">1</code> or higher enables outer join fetching for one-to-one and many-to-one associations that have been mapped with <code class="literal">fetch="join"</code>. </p><p>Ver <a href="#performance-fetching" title="19.1. Estrategias de recuperación">Sección 19.1, “Estrategias de recuperación”</a> para más información. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-binarystreams"/>3.4.3. Flujos Binarios</h3></div></div></div><p>Oracle limits the size of <code class="literal">byte</code> arrays that can be passed to and/or from its JDBC driver. If you wish to use large instances of <code class="literal">binary</code> or <code class="literal">serializable</code> type, you should enable <code class="literal">hibernate.jdbc.use_streams_for_binary</code>. <span class="emphasis"><em>This is a system-level setting only.</em></span> </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-cacheprovider"/>3.4.4. Caché de segundo nivel y de lectura</h3></div></div></div><p>The properties prefixed by <code class="literal">hibernate.cache</code> allow you to use a process or cluster scoped second-level cache system with Hibernate. See the <a href="#performance-cache" title="19.2. El Caché de Segundo Nivel">Sección 19.2, “El Caché de Segundo Nivel”</a> for more information. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-querysubstitution"/>3.4.5. Sustitución de Lenguaje de Consulta</h3></div></div></div><p>You can define new Hibernate query tokens using <code class="literal">hibernate.query.substitutions</code>. For example: </p><pre class="programlisting">hibernate.query.substitutions true=1, false=0</pre><p>This would cause the tokens <code class="literal">true</code> and <code class="literal">false</code> to be translated to integer literals in the generated SQL. </p><pre class="programlisting">hibernate.query.substitutions toLowercase=LOWER</pre><p>This would allow you to rename the SQL <code class="literal">LOWER</code> function. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-statistics"/>3.4.6. Hibernate statistics</h3></div></div></div><p>If you enable <code class="literal">hibernate.generate_statistics</code>, Hibernate exposes a number of metrics that are useful when tuning a running system via <code class="literal">SessionFactory.getStatistics()</code>. Hibernate can even be configured to expose these statistics via JMX. Read the Javadoc of the interfaces in <code class="literal">org.hibernate.stats</code> for more information. </p></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-logging"/>3.5. Registros de mensajes (Logging)</h2></div></div></div><p>Hibernate utilizes <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.slf4j.org/">Simple Logging Facade for Java</a> (SLF4J) in order to log various system events. SLF4J can direct your logging output to several logging frameworks (NOP, Simple, log4j version 1.2, JDK 1.4 logging, JCL or logback) depending on your chosen binding. In order to setup logging you will need <code class="filename">slf4j-api.jar</code> in your classpath together with the jar file for your preferred binding - <code class="filename">slf4j-log4j12.jar</code> in the case of Log4J. See the SLF4J <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.slf4j.org/manual.html">documentation</a> for more detail. To use Log4j you will also need to place a <code class="filename">log4j.properties</code> file in your classpath. An example properties file is distributed with Hibernate in the <code class="literal">src/</code> directory. </p><p>It is recommended that you familiarize yourself with Hibernate's log messages. A lot of work has been put into making the Hibernate log as detailed as possible, without making it unreadable. It is an essential troubleshooting device. The most interesting log categories are the following: </p><div class="table"><a id="log-categories"/><p class="title"><b>Tabla 3.9. Categorías de Registro de Hibernate</b></p><div class="table-contents"><table summary="Categorías de Registro de Hibernate" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Categoría</th><th>Función</th></tr></thead><tbody><tr><td><code class="literal">org.hibernate.SQL</code></td><td>Registra todas las sentencias DML de SQL a medida que se ejecutan</td></tr><tr><td><code class="literal">org.hibernate.type</code></td><td>Registra todos los parámetros JDBC</td></tr><tr><td><code class="literal">org.hibernate.tool.hbm2ddl</code></td><td>Registra todas las sentencias DDL de SQL a medida que se ejecutan</td></tr><tr><td><code class="literal">org.hibernate.pretty</code></td><td>Registra el estado de todas las entidades (máximo de 20 entidades) asociadas con la sesión en tiempo de limpieza (flush) </td></tr><tr><td><code class="literal">org.hibernate.cache</code></td><td>Registra toda la actividad del caché de segundo nivel</td></tr><tr><td><code class="literal">org.hibernate.transaction</code></td><td>Registra la actividad relacionada con la transacción</td></tr><tr><td><code class="literal">org.hibernate.jdbc</code></td><td>Registra toda adquisición de recursos JDBC</td></tr><tr><td><code class="literal">org.hibernate.hql.ast</code></td><td>Regista los ASTs de HQL y SQL, así como otra información sobre análisis de consultas. </td></tr><tr><td><code class="literal">org.hibernate.secure</code></td><td>Registra todas las peticiones de autorización JAAS</td></tr><tr><td><code class="literal">org.hibernate</code></td><td>Log everything. This is a lot of information but it is useful for troubleshooting </td></tr></tbody></table></div></div><br class="table-break"/><p>Al desarrollar aplicacinoes con Hibernate, casi siempre debes trabajar con <code class="literal">debug</code> habilitado para la categoría <code class="literal">org.hibernate.SQL</code> o, alternativamente, la propiedad <code class="literal">hibernate.show_sql</code> habilitada. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-namingstrategy"/>3.6. Implementando una <code class="literal">NamingStrategy</code></h2></div></div></div><p>La interface <code class="literal">org.hibernate.cfg.NamingStrategy</code> te permite especificar un "estándar de nombrado" para objetos de la base de datos y elementos de esquema. </p><p>You can provide rules for automatically generating database identifiers from Java identifiers or for processing "logical" column and table names given in the mapping file into "physical" table and column names. This feature helps reduce the verbosity of the mapping document, eliminating repetitive noise (<code class="literal">TBL_</code> prefixes, for example). The default strategy used by Hibernate is quite minimal. </p><p>You can specify a different strategy by calling <code class="literal">Configuration.setNamingStrategy()</code> before adding mappings: </p><pre class="programlisting">SessionFactory sf = new Configuration()
    .setNamingStrategy(ImprovedNamingStrategy.INSTANCE)
    .addFile("Item.hbm.xml")
    .addFile("Bid.hbm.xml")
    .buildSessionFactory();</pre><p><code class="literal">org.hibernate.cfg.ImprovedNamingStrategy</code> es una estrategia prefabricada que puede ser un punto de partida útil para algunas aplicaciones. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-xmlconfig"/>3.7. Fichero de configuración XML</h2></div></div></div><p>Un enfoque alternativo de configuración es especificar una configuración completa en un fichero llamado <code class="literal">hibernate.cfg.xml</code>. Este fichero puede ser usado como un remplazo del fichero <code class="literal">hibernate.properties</code> o, si ambos están presentes, para sobrescribir propiedades. </p><p>The XML configuration file is by default expected to be in the root of your <code class="literal">CLASSPATH</code>. Here is an example: </p><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
    "-//Hibernate/Hibernate Configuration DTD//EN"
    "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;

&lt;hibernate-configuration&gt;

    &lt;!-- a SessionFactory instance listed as /jndi/name --&gt;
    &lt;session-factory
        name="java:hibernate/SessionFactory"&gt;

        &lt;!-- properties --&gt;
        &lt;property name="connection.datasource"
&gt;java:/comp/env/jdbc/MyDB&lt;/property&gt;
        &lt;property name="dialect"
&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;
        &lt;property name="show_sql"
&gt;false&lt;/property&gt;
        &lt;property name="transaction.factory_class"&gt;
            org.hibernate.transaction.JTATransactionFactory
        &lt;/property&gt;
        &lt;property name="jta.UserTransaction"
&gt;java:comp/UserTransaction&lt;/property&gt;

        &lt;!-- mapping files --&gt;
        &lt;mapping resource="org/hibernate/auction/Item.hbm.xml"/&gt;
        &lt;mapping resource="org/hibernate/auction/Bid.hbm.xml"/&gt;

        &lt;!-- cache settings --&gt;
        &lt;class-cache class="org.hibernate.auction.Item" usage="read-write"/&gt;
        &lt;class-cache class="org.hibernate.auction.Bid" usage="read-only"/&gt;
        &lt;collection-cache collection="org.hibernate.auction.Item.bids" usage="read-write"/&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration
&gt;</pre><p>The advantage of this approach is the externalization of the mapping file names to configuration. The <code class="literal">hibernate.cfg.xml</code> is also more convenient once you have to tune the Hibernate cache. It is your choice to use either <code class="literal">hibernate.properties</code> or <code class="literal">hibernate.cfg.xml</code>. Both are equivalent, except for the above mentioned benefits of using the XML syntax. </p><p>With the XML configuration, starting Hibernate is then as simple as: </p><pre class="programlisting">SessionFactory sf = new Configuration().configure().buildSessionFactory();</pre><p>You can select a different XML configuration file using: </p><pre class="programlisting">SessionFactory sf = new Configuration()
    .configure("catdb.cfg.xml")
    .buildSessionFactory();</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-j2ee"/>3.8. Integració con Servidores de Aplicaciones J2EE</h2></div></div></div><p>Hibernate tiene los siguientes puntos de integración con la infraestructura J2EE: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Container-managed datasources</em></span>: Hibernate can use JDBC connections managed by the container and provided through JNDI. Usually, a JTA compatible <code class="literal">TransactionManager</code> and a <code class="literal">ResourceManager</code> take care of transaction management (CMT), especially distributed transaction handling across several datasources. You can also demarcate transaction boundaries programmatically (BMT), or you might want to use the optional Hibernate <code class="literal">Transaction</code> API for this to keep your code portable. </p></li></ul></div><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Ligamento Automático JNDI</em></span>: Hibernate puede ligar sus <code class="literal">SessionFactory</code> a JNDI después del arranque. </p></li></ul></div><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>JTA Session binding:</em></span> the Hibernate <code class="literal">Session</code> can be automatically bound to the scope of JTA transactions. Simply lookup the <code class="literal">SessionFactory</code> from JNDI and get the current <code class="literal">Session</code>. Let Hibernate manage flushing and closing the <code class="literal">Session</code> when your JTA transaction completes. Transaction demarcation is either declarative (CMT) or programmatic (BMT/UserTransaction). </p></li></ul></div><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>JMX deployment:</em></span> if you have a JMX capable application server (e.g. JBoss AS), you can choose to deploy Hibernate as a managed MBean. This saves you the one line startup code to build your <code class="literal">SessionFactory</code> from a <code class="literal">Configuration</code>. The container will startup your <code class="literal">HibernateService</code> and also take care of service dependencies (datasource has to be available before Hibernate starts, etc). </p></li></ul></div><p>Dependiendo de tu entorno, podrías tener que establecer la opción de configuración <code class="literal">hibernate.connection.aggressive_release</code> a true si tu servidor de aplicaciones muestra excepciones "connection containment". </p><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-transactionstrategy"/>3.8.1. Configuración de la estrategia de transacción</h3></div></div></div><p>The Hibernate <code class="literal">Session</code> API is independent of any transaction demarcation system in your architecture. If you let Hibernate use JDBC directly through a connection pool, you can begin and end your transactions by calling the JDBC API. If you run in a J2EE application server, you might want to use bean-managed transactions and call the JTA API and <code class="literal">UserTransaction</code> when needed. </p><p>Para mantener tu código portable entre estos dos (y otros) entornos recomendamos la API de <code class="literal">Transaction</code> de Hibernate, que envuelve y oculta el sistema subyacente. Tienes que especificar una clase fábrica para las instancias de <code class="literal">Transaction</code> estableciendo la propiedad de configuración <code class="literal">hibernate.transaction.factory_class</code> de Hibernate. </p><p>There are three standard, or built-in, choices: </p><div class="variablelist"><dl><dt><span class="term"><code class="literal">org.hibernate.transaction.JDBCTransactionFactory</code></span></dt><dd><p>delega a transacciones de base de datos (JDBC) (por defecto)</p></dd><dt><span class="term"><code class="literal">org.hibernate.transaction.JTATransactionFactory</code></span></dt><dd><p>delegates to container-managed transactions if an existing transaction is underway in this context (for example, EJB session bean method). Otherwise, a new transaction is started and bean-managed transactions are used. </p></dd><dt><span class="term"><code class="literal">org.hibernate.transaction.CMTTransactionFactory</code></span></dt><dd><p>delega a transacciones JTA manejadas por contenedor</p></dd></dl></div><p>You can also define your own transaction strategies (for a CORBA transaction service, for example). </p><p>Some features in Hibernate (i.e., the second level cache, Contextual Sessions with JTA, etc.) require access to the JTA <code class="literal">TransactionManager</code> in a managed environment. In an application server, since J2EE does not standardize a single mechanism, you have to specify how Hibernate should obtain a reference to the <code class="literal">TransactionManager</code>: </p><div class="table"><a id="jtamanagerlookup"/><p class="title"><b>Tabla 3.10. TransactionManagers de JTA</b></p><div class="table-contents"><table summary="TransactionManagers de JTA" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Transaction Factory</th><th align="center">Servidor de Aplicaciones</th></tr></thead><tbody><tr><td><code class="literal">org.hibernate.transaction.JBossTransactionManagerLookup</code></td><td align="center">JBoss</td></tr><tr><td><code class="literal">org.hibernate.transaction.WeblogicTransactionManagerLookup</code></td><td align="center">Weblogic</td></tr><tr><td><code class="literal">org.hibernate.transaction.WebSphereTransactionManagerLookup</code></td><td align="center">WebSphere</td></tr><tr><td><code class="literal">org.hibernate.transaction.WebSphereExtendedJTATransactionLookup</code></td><td align="center">WebSphere 6</td></tr><tr><td><code class="literal">org.hibernate.transaction.OrionTransactionManagerLookup</code></td><td align="center">Orion</td></tr><tr><td><code class="literal">org.hibernate.transaction.ResinTransactionManagerLookup</code></td><td align="center">Resin</td></tr><tr><td><code class="literal">org.hibernate.transaction.JOTMTransactionManagerLookup</code></td><td align="center">JOTM</td></tr><tr><td><code class="literal">org.hibernate.transaction.JOnASTransactionManagerLookup</code></td><td align="center">JOnAS</td></tr><tr><td><code class="literal">org.hibernate.transaction.JRun4TransactionManagerLookup</code></td><td align="center">JRun4</td></tr><tr><td><code class="literal">org.hibernate.transaction.BESTransactionManagerLookup</code></td><td align="center">Borland ES</td></tr></tbody></table></div></div><br class="table-break"/></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-jndi"/>3.8.2. <code class="literal">SessionFactory</code> ligada a JNDI</h3></div></div></div><p>A JNDI-bound Hibernate <code class="literal">SessionFactory</code> can simplify the lookup function of the factory and create new <code class="literal">Session</code>s. This is not, however, related to a JNDI bound <code class="literal">Datasource</code>; both simply use the same registry. </p><p>If you wish to have the <code class="literal">SessionFactory</code> bound to a JNDI namespace, specify a name (e.g. <code class="literal">java:hibernate/SessionFactory</code>) using the property <code class="literal">hibernate.session_factory_name</code>. If this property is omitted, the <code class="literal">SessionFactory</code> will not be bound to JNDI. This is especially useful in environments with a read-only JNDI default implementation (in Tomcat, for example). </p><p>Al ligar la <code class="literal">SessionFactory</code> a JNDI, Hibernate usará los valores de <code class="literal">hibernate.jndi.url</code>, <code class="literal">hibernate.jndi.class</code> para instanciar un contexto inicial. Si étos no se especifican, se usará el <code class="literal">InitialContext</code> por defecto. </p><p>Hibernate will automatically place the <code class="literal">SessionFactory</code> in JNDI after you call <code class="literal">cfg.buildSessionFactory()</code>. This means you will have this call in some startup code, or utility class in your application, unless you use JMX deployment with the <code class="literal">HibernateService</code> (this is discussed later in greater detail). </p><p>If you use a JNDI <code class="literal">SessionFactory</code>, an EJB or any other class, you can obtain the <code class="literal">SessionFactory</code> using a JNDI lookup. </p><p>It is recommended that you bind the <code class="literal">SessionFactory</code> to JNDI in a managed environment and use a <code class="literal">static</code> singleton otherwise. To shield your application code from these details, we also recommend to hide the actual lookup code for a <code class="literal">SessionFactory</code> in a helper class, such as <code class="literal">HibernateUtil.getSessionFactory()</code>. Note that such a class is also a convenient way to startup Hibernatesee chapter 1. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-j2ee-currentsession"/>3.8.3. Ligado automático de JTA y Session</h3></div></div></div><p>The easiest way to handle <code class="literal">Sessions</code> and transactions is Hibernate's automatic "current" <code class="literal">Session</code> management. For a discussion of contextual sessions see <a href="#architecture-current-session" title="2.5. Contextual sessions">Sección 2.5, “Contextual sessions”</a>. Using the <code class="literal">"jta"</code> session context, if there is no Hibernate <code class="literal">Session</code> associated with the current JTA transaction, one will be started and associated with that JTA transaction the first time you call <code class="literal">sessionFactory.getCurrentSession()</code>. The <code class="literal">Session</code>s retrieved via <code class="literal">getCurrentSession()</code> in the<code class="literal">"jta"</code> context are set to automatically flush before the transaction completes, close after the transaction completes, and aggressively release JDBC connections after each statement. This allows the <code class="literal">Session</code>s to be managed by the life cycle of the JTA transaction to which it is associated, keeping user code clean of such management concerns. Your code can either use JTA programmatically through <code class="literal">UserTransaction</code>, or (recommended for portable code) use the Hibernate <code class="literal">Transaction</code> API to set transaction boundaries. If you run in an EJB container, declarative transaction demarcation with CMT is preferred. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-j2ee-jmx"/>3.8.4. Despliegue JMX</h3></div></div></div><p>The line <code class="literal">cfg.buildSessionFactory()</code> still has to be executed somewhere to get a <code class="literal">SessionFactory</code> into JNDI. You can do this either in a <code class="literal">static</code> initializer block, like the one in <code class="literal">HibernateUtil</code>, or you can deploy Hibernate as a <span class="emphasis"><em>managed service</em></span>. </p><p>Hibernate is distributed with <code class="literal">org.hibernate.jmx.HibernateService</code> for deployment on an application server with JMX capabilities, such as JBoss AS. The actual deployment and configuration is vendor-specific. Here is an example <code class="literal">jboss-service.xml</code> for JBoss 4.0.x: </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;server&gt;

&lt;mbean code="org.hibernate.jmx.HibernateService"
    name="jboss.jca:service=HibernateFactory,name=HibernateFactory"&gt;

    &lt;!-- Required services --&gt;
    &lt;depends
&gt;jboss.jca:service=RARDeployer&lt;/depends&gt;
    &lt;depends
&gt;jboss.jca:service=LocalTxCM,name=HsqlDS&lt;/depends&gt;

    &lt;!-- Bind the Hibernate service to JNDI --&gt;
    &lt;attribute name="JndiName"
&gt;java:/hibernate/SessionFactory&lt;/attribute&gt;

    &lt;!-- Datasource settings --&gt;
    &lt;attribute name="Datasource"
&gt;java:HsqlDS&lt;/attribute&gt;
    &lt;attribute name="Dialect"
&gt;org.hibernate.dialect.HSQLDialect&lt;/attribute&gt;

    &lt;!-- Transaction integration --&gt;
    &lt;attribute name="TransactionStrategy"&gt;
        org.hibernate.transaction.JTATransactionFactory&lt;/attribute&gt;
    &lt;attribute name="TransactionManagerLookupStrategy"&gt;
        org.hibernate.transaction.JBossTransactionManagerLookup&lt;/attribute&gt;
    &lt;attribute name="FlushBeforeCompletionEnabled"
&gt;true&lt;/attribute&gt;
    &lt;attribute name="AutoCloseSessionEnabled"
&gt;true&lt;/attribute&gt;

    &lt;!-- Fetching options --&gt;
    &lt;attribute name="MaximumFetchDepth"
&gt;5&lt;/attribute&gt;

    &lt;!-- Second-level caching --&gt;
    &lt;attribute name="SecondLevelCacheEnabled"
&gt;true&lt;/attribute&gt;
    &lt;attribute name="CacheProviderClass"
&gt;org.hibernate.cache.EhCacheProvider&lt;/attribute&gt;
    &lt;attribute name="QueryCacheEnabled"
&gt;true&lt;/attribute&gt;

    &lt;!-- Logging --&gt;
    &lt;attribute name="ShowSqlEnabled"
&gt;true&lt;/attribute&gt;

    &lt;!-- Mapping files --&gt;
    &lt;attribute name="MapResources"
&gt;auction/Item.hbm.xml,auction/Category.hbm.xml&lt;/attribute&gt;

&lt;/mbean&gt;

&lt;/server
&gt;</pre><p>This file is deployed in a directory called <code class="literal">META-INF</code> and packaged in a JAR file with the extension <code class="literal">.sar</code> (service archive). You also need to package Hibernate, its required third-party libraries, your compiled persistent classes, as well as your mapping files in the same archive. Your enterprise beans (usually session beans) can be kept in their own JAR file, but you can include this EJB JAR file in the main service archive to get a single (hot-)deployable unit. Consult the JBoss AS documentation for more information about JMX service and EJB deployment. </p></div></div></div><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes"/>Capítulo 4. Clases Persistentes</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#persistent-classes-pojo">4.1. Un ejemplo simple de POJO</a></span></dt><dd><dl><dt><span class="sect2"><a href="#persistent-classes-pojo-constructor">4.1.1. Implementa un constructor sin argumentos</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-identifier">4.1.2. Provee una propiedad identificadora (opcional)</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-final">4.1.3. Prefiere las clases no finales (opcional)</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-accessors">4.1.4. Declara métodos de acceso y modificación para los campos persistentes (opcional)</a></span></dt></dl></dd><dt><span class="sect1"><a href="#persistent-classes-inheritance">4.2. Implementando herencia</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-equalshashcode">4.3. Implementando <code class="literal">equals()</code> y <code class="literal">hashCode()</code></a></span></dt><dt><span class="sect1"><a href="#persistent-classes-dynamicmodels">4.4. Modelos dinámicos</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-tuplizers">4.5. UNTRANSLATED!!! Tuplizers</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-entity-name-resolver">4.6. EntityNameResolvers</a></span></dt></dl></div><p>Persistent classes are classes in an application that implement the entities of the business problem (e.g. Customer and Order in an E-commerce application). Not all instances of a persistent class are considered to be in the persistent state. For example, an instance can instead be transient or detached. </p><p>Hibernate works best if these classes follow some simple rules, also known as the Plain Old Java Object (POJO) programming model. However, none of these rules are hard requirements. Indeed, Hibernate3 assumes very little about the nature of your persistent objects. You can express a domain model in other ways (using trees of <code class="literal">Map</code> instances, for example). </p><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes-pojo"/>4.1. Un ejemplo simple de POJO</h2></div></div></div><p>Most Java applications require a persistent class representing felines. For example: </p><pre class="programlisting">package eg;
import java.util.Set;
import java.util.Date;

public class Cat {
    private Long id; // identifier

    private Date birthdate;
    private Color color;
    private char sex;
    private float weight;
    private int litterId;

    private Cat mother;
    private Set kittens = new HashSet();

    private void setId(Long id) {
        this.id=id;
    }
    public Long getId() {
        return id;
    }

    void setBirthdate(Date date) {
        birthdate = date;
    }
    public Date getBirthdate() {
        return birthdate;
    }

    void setWeight(float weight) {
        this.weight = weight;
    }
    public float getWeight() {
        return weight;
    }

    public Color getColor() {
        return color;
    }
    void setColor(Color color) {
        this.color = color;
    }

    void setSex(char sex) {
        this.sex=sex;
    }
    public char getSex() {
        return sex;
    }

    void setLitterId(int id) {
        this.litterId = id;
    }
    public int getLitterId() {
        return litterId;
    }

    void setMother(Cat mother) {
        this.mother = mother;
    }
    public Cat getMother() {
        return mother;
    }
    void setKittens(Set kittens) {
        this.kittens = kittens;
    }
    public Set getKittens() {
        return kittens;
    }
    
    // addKitten not needed by Hibernate
    public void addKitten(Cat kitten) {
            kitten.setMother(this);
        kitten.setLitterId( kittens.size() ); 
        kittens.add(kitten);
    }
}</pre><p>The four main rules of persistent classes are explored in more detail in the following sections. </p><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="persistent-classes-pojo-constructor"/>4.1.1. Implementa un constructor sin argumentos</h3></div></div></div><p><code class="literal">Cat</code> has a no-argument constructor. All persistent classes must have a default constructor (which can be non-public) so that Hibernate can instantiate them using <code class="literal">Constructor.newInstance()</code>. It is recommended that you have a default constructor with at least <span class="emphasis"><em>package</em></span> visibility for runtime proxy generation in Hibernate. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="persistent-classes-pojo-identifier"/>4.1.2. Provee una propiedad identificadora (opcional)</h3></div></div></div><p><code class="literal">Cat</code> has a property called <code class="literal">id</code>. This property maps to the primary key column of a database table. The property might have been called anything, and its type might have been any primitive type, any primitive "wrapper" type, <code class="literal">java.lang.String</code> or <code class="literal">java.util.Date</code>. If your legacy database table has composite keys, you can use a user-defined class with properties of these types (see the section on composite identifiers later in the chapter.) </p><p>La propiedad identificadora es estrictamente opcional. Puedes olvidarla y dejar que Hibernate siga internamente la pista de los identificadores del objeto. Sin embargo, no recomendamos esto. </p><p>In fact, some functionality is available only to classes that declare an identifier property: </p><div class="itemizedlist"><ul compact="compact"><li><p>Reasociación transitiva de objetos separados (actualizaciones o fusiones en cascada) - ver <a href="#objectstate-transitive" title="10.11. Persistencia transitiva">Sección 10.11, “Persistencia transitiva”</a> </p></li><li><p>
                        <code class="literal">Session.saveOrUpdate()</code>
                    </p></li><li><p>
                        <code class="literal">Session.merge()</code>
                    </p></li></ul></div><p>We recommend that you declare consistently-named identifier properties on persistent classes and that you use a nullable (i.e., non-primitive) type. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="persistent-classes-pojo-final"/>4.1.3. Prefiere las clases no finales (opcional)</h3></div></div></div><p>Un aspecto central de Hibernate, <span class="emphasis"><em>proxies</em></span>, depende de que las clases persistentes sean ya no finales, o sean ya la implementación de una interface que declare todos los métodos públicos. </p><p>You can persist <code class="literal">final</code> classes that do not implement an interface with Hibernate. You will not, however, be able to use proxies for lazy association fetching which will ultimately limit your options for performance tuning. </p><p>Debes también evitar declarar métodos <code class="literal">public final</code> en clases non-final. Si quieres usar una clase con un método <code class="literal">public final</code>, debes deshabilitar explícitamente el uso de proxies estableciendo <code class="literal">lazy="false"</code>. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="persistent-classes-pojo-accessors"/>4.1.4. Declara métodos de acceso y modificación para los campos persistentes (opcional)</h3></div></div></div><p><code class="literal">Cat</code> declares accessor methods for all its persistent fields. Many other ORM tools directly persist instance variables. It is better to provide an indirection between the relational schema and internal data structures of the class. By default, Hibernate persists JavaBeans style properties and recognizes method names of the form <code class="literal">getFoo</code>, <code class="literal">isFoo</code> and <code class="literal">setFoo</code>. If required, you can switch to direct field access for particular properties. </p><p>Las propiedades <span class="emphasis"><em>no</em></span> necesitan ser declaradas públicas. Hibernate puede persistir una propiedad con un par get / set <code class="literal">protected</code> o <code class="literal">private</code>. </p></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes-inheritance"/>4.2. Implementando herencia</h2></div></div></div><p>A subclass must also observe the first and second rules. It inherits its identifier property from the superclass, <code class="literal">Cat</code>. For example: </p><pre class="programlisting">package eg;

public class DomesticCat extends Cat {
        private String name;

        public String getName() {
                return name;
        }
        protected void setName(String name) {
                this.name=name;
        }
}</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes-equalshashcode"/>4.3. Implementando <code class="literal">equals()</code> y <code class="literal">hashCode()</code></h2></div></div></div><p>You have to override the <code class="literal">equals()</code> and <code class="literal">hashCode()</code> methods if you: </p><div class="itemizedlist"><ul compact="compact"><li><p>intend to put instances of persistent classes in a <code class="literal">Set</code> (the recommended way to represent many-valued associations); <span class="emphasis"><em>and</em></span> </p></li><li><p>piensas usar reasociación de instancias separadas. </p></li></ul></div><p>Hibernate guarantees equivalence of persistent identity (database row) and Java identity only inside a particular session scope. When you mix instances retrieved in different sessions, you must implement <code class="literal">equals()</code> and <code class="literal">hashCode()</code> if you wish to have meaningful semantics for <code class="literal">Set</code>s. </p><p>The most obvious way is to implement <code class="literal">equals()</code>/<code class="literal">hashCode()</code> by comparing the identifier value of both objects. If the value is the same, both must be the same database row, because they are equal. If both are added to a <code class="literal">Set</code>, you will only have one element in the <code class="literal">Set</code>). Unfortunately, you cannot use that approach with generated identifiers. Hibernate will only assign identifier values to objects that are persistent; a newly created instance will not have any identifier value. Furthermore, if an instance is unsaved and currently in a <code class="literal">Set</code>, saving it will assign an identifier value to the object. If <code class="literal">equals()</code> and <code class="literal">hashCode()</code> are based on the identifier value, the hash code would change, breaking the contract of the <code class="literal">Set</code>. See the Hibernate website for a full discussion of this problem. This is not a Hibernate issue, but normal Java semantics of object identity and equality. </p><p>It is recommended that you implement <code class="literal">equals()</code> and <code class="literal">hashCode()</code> using <span class="emphasis"><em>Business key equality</em></span>. Business key equality means that the <code class="literal">equals()</code> method compares only the properties that form the business key. It is a key that would identify our instance in the real world (a <span class="emphasis"><em>natural</em></span> candidate key): </p><pre class="programlisting">public class Cat {

    ...
    public boolean equals(Object other) {
        if (this == other) return true;
        if ( !(other instanceof Cat) ) return false;

        final Cat cat = (Cat) other;

        if ( !cat.getLitterId().equals( getLitterId() ) ) return false;
        if ( !cat.getMother().equals( getMother() ) ) return false;

        return true;
    }

    public int hashCode() {
        int result;
        result = getMother().hashCode();
        result = 29 * result + getLitterId();
        return result;
    }

}</pre><p>A business key does not have to be as solid as a database primary key candidate (see <a href="#transactions-basics-identity" title="11.1.3. Considerando la identidad del objeto">Sección 11.1.3, “Considerando la identidad del objeto”</a>). Immutable or unique properties are usually good candidates for a business key. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes-dynamicmodels"/>4.4. Modelos dinámicos</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
	 <span class="emphasis"><em>The following features are currently considered experimental and may change in the near future.</em></span>
	      
	</p></div><p>Persistent entities do not necessarily have to be represented as POJO classes or as JavaBean objects at runtime. Hibernate also supports dynamic models (using <code class="literal">Map</code>s of <code class="literal">Map</code>s at runtime) and the representation of entities as DOM4J trees. With this approach, you do not write persistent classes, only mapping files. </p><p>By default, Hibernate works in normal POJO mode. You can set a default entity representation mode for a particular <code class="literal">SessionFactory</code> using the <code class="literal">default_entity_mode</code> configuration option (see <a href="#configuration-optional-properties" title="Tabla 3.3. Propiedades de Configuración de Hibernate">Tabla 3.3, “Propiedades de Configuración de Hibernate”</a>). </p><p>The following examples demonstrate the representation using <code class="literal">Map</code>s. First, in the mapping file an <code class="literal">entity-name</code> has to be declared instead of, or in addition to, a class name: </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class entity-name="Customer"&gt;

        &lt;id name="id"
            type="long"
            column="ID"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;

        &lt;property name="name"
            column="NAME"
            type="string"/&gt;

        &lt;property name="address"
            column="ADDRESS"
            type="string"/&gt;

        &lt;many-to-one name="organization"
            column="ORGANIZATION_ID"
            class="Organization"/&gt;

        &lt;bag name="orders"
            inverse="true"
            lazy="false"
            cascade="all"&gt;
            &lt;key column="CUSTOMER_ID"/&gt;
            &lt;one-to-many class="Order"/&gt;
        &lt;/bag&gt;

    &lt;/class&gt;
    
&lt;/hibernate-mapping
&gt;</pre><p>Even though associations are declared using target class names, the target type of associations can also be a dynamic entity instead of a POJO. </p><p>After setting the default entity mode to <code class="literal">dynamic-map</code> for the <code class="literal">SessionFactory</code>, you can, at runtime, work with <code class="literal">Map</code>s of <code class="literal">Map</code>s: </p><pre class="programlisting">Session s = openSession();
Transaction tx = s.beginTransaction();
Session s = openSession();

// Create a customer
Map david = new HashMap();
david.put("name", "David");

// Create an organization
Map foobar = new HashMap();
foobar.put("name", "Foobar Inc.");

// Link both
david.put("organization", foobar);

// Save both
s.save("Customer", david);
s.save("Organization", foobar);

tx.commit();
s.close();</pre><p>One of the main advantages of dynamic mapping is quick turnaround time for prototyping, without the need for entity class implementation. However, you lose compile-time type checking and will likely deal with many exceptions at runtime. As a result of the Hibernate mapping, the database schema can easily be normalized and sound, allowing to add a proper domain model implementation on top later on. </p><p>Los modos de representación de entidad pueden ser establecidos por <code class="literal">Session</code>: </p><pre class="programlisting">Session dynamicSession = pojoSession.getSession(EntityMode.MAP);

// Create a customer
Map david = new HashMap();
david.put("name", "David");
dynamicSession.save("Customer", david);
...
dynamicSession.flush();
dynamicSession.close()
...
// Continue on pojoSession
</pre><p>Please note that the call to <code class="literal">getSession()</code> using an <code class="literal">EntityMode</code> is on the <code class="literal">Session</code> API, not the <code class="literal">SessionFactory</code>. That way, the new <code class="literal">Session</code> shares the underlying JDBC connection, transaction, and other context information. This means you do not have to call <code class="literal">flush()</code> and <code class="literal">close()</code> on the secondary <code class="literal">Session</code>, and also leave the transaction and connection handling to the primary unit of work. </p><p>Puede encontrarse más información sobre las capacidades de representación XML en <a href="#xml" title="Capítulo 18. Mapeo XML">Capítulo 18, <i xmlns:xlink="http://www.w3.org/1999/xlink">Mapeo XML</i></a>. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes-tuplizers"/>4.5. UNTRANSLATED!!! Tuplizers</h2></div></div></div><p><code class="literal">org.hibernate.tuple.Tuplizer</code>, and its sub-interfaces, are responsible for managing a particular representation of a piece of data given that representation's <code class="literal">org.hibernate.EntityMode</code>. If a given piece of data is thought of as a data structure, then a tuplizer is the thing that knows how to create such a data structure and how to extract values from and inject values into such a data structure. For example, for the POJO entity mode, the corresponding tuplizer knows how create the POJO through its constructor. It also knows how to access the POJO properties using the defined property accessors. </p><p>There are two high-level types of Tuplizers, represented by the <code class="literal">org.hibernate.tuple.entity.EntityTuplizer</code> and <code class="literal">org.hibernate.tuple.component.ComponentTuplizer</code> interfaces. <code class="literal">EntityTuplizer</code>s are responsible for managing the above mentioned contracts in regards to entities, while <code class="literal">ComponentTuplizer</code>s do the same for components. </p><p>Users can also plug in their own tuplizers. Perhaps you require that a <code class="literal">java.util.Map</code> implementation other than <code class="literal">java.util.HashMap</code> be used while in the dynamic-map entity-mode. Or perhaps you need to define a different proxy generation strategy than the one used by default. Both would be achieved by defining a custom tuplizer implementation. Tuplizer definitions are attached to the entity or component mapping they are meant to manage. Going back to the example of our customer entity: </p><pre class="programlisting">&lt;hibernate-mapping&gt;
                            &lt;class entity-name="Customer"&gt;
                                    &lt;!--
                                        Override the dynamic-map entity-mode
                                        tuplizer for the customer entity
                                        --&gt;
                                    &lt;tuplizer entity-mode="dynamic-map"
                                              class="CustomMapTuplizerImpl"/&gt;
                                    
                                    &lt;id name="id" type="long" column="ID"&gt;
                                            &lt;generator class="sequence"/&gt;
                                    &lt;/id&gt;
                                    
                                    &lt;!-- other properties --&gt;
                                    ...
                            &lt;/class&gt;
                    &lt;/hibernate-mapping&gt;
                    
                    
                    public class CustomMapTuplizerImpl
                    extends org.hibernate.tuple.entity.DynamicMapEntityTuplizer {
                    // override the buildInstantiator() method to plug in our custom map...
                    protected final Instantiator buildInstantiator(
                    org.hibernate.mapping.PersistentClass mappingInfo) {
                    return new CustomMapInstantiator( mappingInfo );
                    }
                    
                    private static final class CustomMapInstantiator
                    extends org.hibernate.tuple.DynamicMapInstantitor {
                    // override the generateMap() method to return our custom map...
                    protected final Map generateMap() {
                    return new CustomMap();
                    }
                    }
                    }</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes-entity-name-resolver"/>4.6. EntityNameResolvers</h2></div></div></div><p>The <code class="interfacename">org.hibernate.EntityNameResolver</code> interface is a contract for resolving the entity name of a given entity instance. The interface defines a single method <code class="methodname">resolveEntityName</code> which is passed the entity instance and is expected to return the appropriate entity name (null is allowed and would indicate that the resolver does not know how to resolve the entity name of the given entity instance). Generally speaking, an <code class="interfacename">org.hibernate.EntityNameResolver</code> is going to be most useful in the case of dynamic models. One example might be using proxied interfaces as your domain model. The hibernate test suite has an example of this exact style of usage under the <span class="package">org.hibernate.test.dynamicentity.tuplizer2</span>. Here is some of the code from that package for illustration. </p><pre class="programlisting">/**
 * A very trivial JDK Proxy InvocationHandler implementation where we proxy an interface as
 * the domain model and simply store persistent state in an internal Map.  This is an extremely
 * trivial example meant only for illustration.
 */
public final class DataProxyHandler implements InvocationHandler {
        private String entityName;
        private HashMap data = new HashMap();

        public DataProxyHandler(String entityName, Serializable id) {
                this.entityName = entityName;
                data.put( "Id", id );
        }

        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                String methodName = method.getName();
                if ( methodName.startsWith( "set" ) ) {
                        String propertyName = methodName.substring( 3 );
                        data.put( propertyName, args[0] );
                }
                else if ( methodName.startsWith( "get" ) ) {
                        String propertyName = methodName.substring( 3 );
                        return data.get( propertyName );
                }
                else if ( "toString".equals( methodName ) ) {
                        return entityName + "#" + data.get( "Id" );
                }
                else if ( "hashCode".equals( methodName ) ) {
                        return new Integer( this.hashCode() );
                }
                return null;
        }

        public String getEntityName() {
                return entityName;
        }

        public HashMap getData() {
                return data;
        }
}

/**
 *
 */
public class ProxyHelper {
    public static String extractEntityName(Object object) {
        // Our custom java.lang.reflect.Proxy instances actually bundle
        // their appropriate entity name, so we simply extract it from there
        // if this represents one of our proxies; otherwise, we return null
        if ( Proxy.isProxyClass( object.getClass() ) ) {
            InvocationHandler handler = Proxy.getInvocationHandler( object );
            if ( DataProxyHandler.class.isAssignableFrom( handler.getClass() ) ) {
                DataProxyHandler myHandler = ( DataProxyHandler ) handler;
                return myHandler.getEntityName();
            }
        }
        return null;
    }

    // various other utility methods ....

}

/**
 * The EntityNameResolver implementation.
 * IMPL NOTE : An EntityNameResolver really defines a strategy for how entity names should be
 * resolved.  Since this particular impl can handle resolution for all of our entities we want to
 * take advantage of the fact that SessionFactoryImpl keeps these in a Set so that we only ever
 * have one instance registered.  Why?  Well, when it comes time to resolve an entity name,
 * Hibernate must iterate over all the registered resolvers.  So keeping that number down
 * helps that process be as speedy as possible.  Hence the equals and hashCode impls
 */
public class MyEntityNameResolver implements EntityNameResolver {
    public static final MyEntityNameResolver INSTANCE = new MyEntityNameResolver();

    public String resolveEntityName(Object entity) {
        return ProxyHelper.extractEntityName( entity );
    }

    public boolean equals(Object obj) {
        return getClass().equals( obj.getClass() );
    }

    public int hashCode() {
        return getClass().hashCode();
    }
}

public class MyEntityTuplizer extends PojoEntityTuplizer {
        public MyEntityTuplizer(EntityMetamodel entityMetamodel, PersistentClass mappedEntity) {
                super( entityMetamodel, mappedEntity );
        }

        public EntityNameResolver[] getEntityNameResolvers() {
                return new EntityNameResolver[] { MyEntityNameResolver.INSTANCE };
        }

    public String determineConcreteSubclassEntityName(Object entityInstance, SessionFactoryImplementor factory) {
        String entityName = ProxyHelper.extractEntityName( entityInstance );
        if ( entityName == null ) {
            entityName = super.determineConcreteSubclassEntityName( entityInstance, factory );
        }
        return entityName;
    }

    ...
}
        </pre><p>In order to register an <code class="interfacename">org.hibernate.EntityNameResolver</code> users must either: </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>Implement a custom <a href="#persistent-classes-tuplizers" title="4.5. UNTRANSLATED!!! Tuplizers">Tuplizer</a>, implementing the <code class="methodname">getEntityNameResolvers</code> method. </p></li><li><p>Register it with the <code class="classname">org.hibernate.impl.SessionFactoryImpl</code> (which is the implementation class for <code class="interfacename">org.hibernate.SessionFactory</code>) using the <code class="methodname">registerEntityNameResolver</code> method. </p></li></ol></div><p>
        </p></div></div><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="mapping"/>Capítulo 5. Mapeo O/R Básico</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#mapping-declaration">5.1. Declaración de mapeo</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-declaration-doctype">5.1.1. Doctype</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-mapping">5.1.2. Hibernate-mapping</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-class">5.1.3. Class</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id">5.1.4. id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id-enhanced">5.1.5. Enhanced identifier generators</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id-enhanced-optimizers">5.1.6. Identifier generator optimization</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-compositeid">5.1.7. composite-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-discriminator">5.1.8. Discriminator</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-version">5.1.9. Version (optional)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-timestamp">5.1.10. Timestamp (optional)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-property">5.1.11. Property</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-manytoone">5.1.12. Many-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-onetoone">5.1.13. One-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-naturalid">5.1.14. Natural-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-component">5.1.15. Component and dynamic-component</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-properties">5.1.16. Properties</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-subclass">5.1.17. Subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-joinedsubclass">5.1.18. Joined-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-unionsubclass">5.1.19. Union-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-join">5.1.20. Join</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-key">5.1.21. Key</a></span></dt><dt><span class="sect2"><a href="#mapping-column">5.1.22. Column and formula elements</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-import">5.1.23. Import</a></span></dt><dt><span class="sect2"><a href="#mapping-types-anymapping">5.1.24. Any</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-types">5.2. Hibernate types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-types-entitiesvalues">5.2.1. Entidades y Valores</a></span></dt><dt><span class="sect2"><a href="#mapping-types-basictypes">5.2.2. Tipos de valores básicos</a></span></dt><dt><span class="sect2"><a href="#mapping-types-custom">5.2.3. Tipos de valor personalizados</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-entityname">5.3. Mapeando una clase más de una vez</a></span></dt><dt><span class="sect1"><a href="#mapping-quotedidentifiers">5.4. identificadores SQL encomillados</a></span></dt><dt><span class="sect1"><a href="#mapping-alternatives">5.5. Alternativas de metadatos</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-xdoclet">5.5.1. Usando marcado de XDoclet</a></span></dt><dt><span class="sect2"><a href="#mapping-annotations">5.5.2. Usando anotaciones JDK 5.0</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-generated">5.6. Generated properties</a></span></dt><dt><span class="sect1"><a href="#mapping-database-object">5.7. Auxiliary database objects</a></span></dt></dl></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-declaration"/>5.1. Declaración de mapeo</h2></div></div></div><p>Object/relational mappings are usually defined in an XML document. The mapping document is designed to be readable and hand-editable. The mapping language is Java-centric, meaning that mappings are constructed around persistent class declarations and not table declarations. </p><p>Please note that even though many Hibernate users choose to write the XML by hand, a number of tools exist to generate the mapping document. These include XDoclet, Middlegen and AndroMDA. </p><p>Here is an example mapping: </p><a id="mapping-declaration-ex1"/><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
      "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
          "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

        &lt;class name="Cat" 
            table="cats"
            discriminator-value="C"&gt;
                
                &lt;id name="id"&gt;
                        &lt;generator class="native"/&gt;
                &lt;/id&gt;

                &lt;discriminator column="subclass" 
                     type="character"/&gt;

                &lt;property name="weight"/&gt;

                &lt;property name="birthdate"
                    type="date" 
                    not-null="true" 
                    update="false"/&gt;

                &lt;property name="color"
                    type="eg.types.ColorUserType"
                    not-null="true"
                    update="false"/&gt;

                &lt;property name="sex"
                    not-null="true" 
                    update="false"/&gt;

                &lt;property name="litterId"
                    column="litterId"
                    update="false"/&gt;

                &lt;many-to-one name="mother"
                    column="mother_id"
                    update="false"/&gt;

                &lt;set name="kittens"
                    inverse="true"
                    order-by="litter_id"&gt;
                        &lt;key column="mother_id"/&gt;
                        &lt;one-to-many class="Cat"/&gt;
                &lt;/set&gt;

                &lt;subclass name="DomesticCat"
                    discriminator-value="D"&gt;

                        &lt;property name="name" 
                            type="string"/&gt;

                &lt;/subclass&gt;

        &lt;/class&gt;

        &lt;class name="Dog"&gt;
                &lt;!-- mapping for Dog could go here --&gt;
        &lt;/class&gt;

&lt;/hibernate-mapping
&gt;</pre><p>We will now discuss the content of the mapping document. We will only describe, however, the document elements and attributes that are used by Hibernate at runtime. The mapping document also contains some extra optional attributes and elements that affect the database schemas exported by the schema export tool (for example, the <code class="literal"> not-null</code> attribute). </p><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-doctype"/>5.1.1. Doctype</h3></div></div></div><p>All XML mappings should declare the doctype shown. The actual DTD can be found at the URL above, in the directory <code class="literal">hibernate-x.x.x/src/org/hibernate </code>, or in <code class="literal">hibernate3.jar</code>. Hibernate will always look for the DTD in its classpath first. If you experience lookups of the DTD using an Internet connection, check the DTD declaration against the contents of your classpath. </p><div class="sect3" lang="es-ES"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-entity-resolution"/>5.1.1.1. UNTRANSLATED! EntityResolver</h4></div></div></div><p>Hibernate will first attempt to resolve DTDs in its classpath. It does this is by registering a custom <code class="literal">org.xml.sax.EntityResolver</code> implementation with the SAXReader it uses to read in the xml files. This custom <code class="literal">EntityResolver</code> recognizes two different systemId namespaces: </p><div class="itemizedlist"><ul><li><p>a <code class="literal">hibernate namespace</code> is recognized whenever the resolver encounters a systemId starting with <code class="literal">http://hibernate.sourceforge.net/</code>. The resolver attempts to resolve these entities via the classloader which loaded the Hibernate classes. </p></li><li><p>a <code class="literal">user namespace</code> is recognized whenever the resolver encounters a systemId using a <code class="literal">classpath://</code> URL protocol. The resolver will attempt to resolve these entities via (1) the current thread context classloader and (2) the classloader which loaded the Hibernate classes. </p></li></ul></div><p>The following is an example of utilizing user namespacing: </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
                            &lt;!DOCTYPE hibernate-mapping PUBLIC
                                      "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
                                      "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd" [
                                      &lt;!ENTITY types SYSTEM "classpath://your/domain/types.xml"&gt;
                                      ]&gt;
                                      
                                      &lt;hibernate-mapping package="your.domain"&gt;
                                              &lt;class name="MyEntity"&gt;
                                                      &lt;id name="id" type="my-custom-id-type"&gt;
                                                              ...
                                                      &lt;/id&gt;
                                                      &lt;class&gt;
                                                              &amp;types;
                                                      &lt;/hibernate-mapping
&gt;</pre><p>Where <code class="literal">types.xml</code> is a resource in the <code class="literal">your.domain</code> package and contains a custom <a href="#mapping-types-custom" title="5.2.3. Tipos de valor personalizados">typedef</a>. </p></div></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-mapping"/>5.1.2. Hibernate-mapping</h3></div></div></div><p>This element has several optional attributes. The <code class="literal">schema</code> and <code class="literal">catalog</code> attributes specify that tables referred to in this mapping belong to the named schema and/or catalog. If they are specified, tablenames will be qualified by the given schema and catalog names. If they are missing, tablenames will be unqualified. The <code class="literal">default-cascade</code> attribute specifies what cascade style should be assumed for properties and collections that do not specify a <code class="literal">cascade</code> attribute. By default, the <code class="literal">auto-import</code> attribute allows you to use unqualified class names in the query language. </p><div class="programlistingco"><pre class="programlisting">&lt;hibernate-mapping
         schema="schemaName"                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
         catalog="catalogName"                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
         default-cascade="cascade_style"              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
         default-access="field|property|ClassName"    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
         default-lazy="true|false"                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
         auto-import="true|false"                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
         package="package.name"                       <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
 /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">schema</code> (optional): the name of a database schema. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">catalog</code> (optional): the name of a database catalog. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">default-cascade</code> (optional - defaults to <code class="literal">none</code>): a default cascade style. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">default-access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate should use for accessing all properties. It can be a custom implementation of <code class="literal">PropertyAccessor</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">default-lazy</code> (optional - defaults to <code class="literal">true</code>): the default value for unspecified <code class="literal">lazy</code> attributes of class and collection mappings. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">auto-import</code> (optional - defaults to <code class="literal">true</code>): specifies whether we can use unqualified class names of classes in this mapping in the query language. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">package</code> (optional): specifies a package prefix to use for unqualified class names in the mapping document. </p></td></tr></table></div></div><p>If you have two persistent classes with the same unqualified name, you should set <code class="literal">auto-import="false"</code>. An exception will result if you attempt to assign two classes to the same "imported" name. </p><p>The <code class="literal">hibernate-mapping</code> element allows you to nest several persistent <code class="literal">&lt;class&gt;</code> mappings, as shown above. It is, however, good practice (and expected by some tools) to map only a single persistent class, or a single class hierarchy, in one mapping file and name it after the persistent superclass. For example, <code class="literal">Cat.hbm.xml</code>, <code class="literal">Dog.hbm.xml</code>, or if using inheritance, <code class="literal">Animal.hbm.xml</code>. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-class"/>5.1.3. Class</h3></div></div></div><p>You can declare a persistent class using the <code class="literal">class</code> element. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;class
        name="ClassName"                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        table="tableName"                             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        discriminator-value="discriminator_value"     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        mutable="true|false"                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        schema="owner"                                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        catalog="catalog"                             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        proxy="ProxyInterface"                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        dynamic-update="true|false"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
        dynamic-insert="true|false"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/9.png" alt="(9)"/></span>
        select-before-update="true|false"             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/10.png" alt="(10)"/></span>
        polymorphism="implicit|explicit"              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/11.png" alt="(11)"/></span>
        where="arbitrary sql where condition"         <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/12.png" alt="(12)"/></span>
        persister="PersisterClass"                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/13.png" alt="(13)"/></span>
        batch-size="N"                                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/14.png" alt="(14)"/></span>
        optimistic-lock="none|version|dirty|all"      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/15.png" alt="(15)"/></span>
        lazy="true|false"                             <span xmlns="" class="co">(16)</span>
        entity-name="EntityName"                      <span xmlns="" class="co">(17)</span>
        check="arbitrary sql check condition"         <span xmlns="" class="co">(18)</span>
        rowid="rowid"                                 <span xmlns="" class="co">(19)</span>
        subselect="SQL expression"                    <span xmlns="" class="co">(20)</span>
        abstract="true|false"                         <span xmlns="" class="co">(21)</span>
        node="element-name"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code> (optional): the fully qualified Java class name of the persistent class or interface. If this attribute is missing, it is assumed that the mapping is for a non-POJO entity. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">table</code> (optional - defaults to the unqualified class name): the name of its database table. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">discriminator-value</code> (optional - defaults to the class name): a value that distinguishes individual subclasses that is used for polymorphic behavior. Acceptable values include <code class="literal">null</code> and <code class="literal">not null</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">mutable</code> (optional - defaults to <code class="literal">true</code>): specifies that instances of the class are (not) mutable. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">schema</code> (optional): overrides the schema name specified by the root <code class="literal">&lt;hibernate-mapping&gt;</code> element. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">catalog</code> (optional): overrides the catalog name specified by the root <code class="literal">&lt;hibernate-mapping&gt;</code> element. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">proxy</code> (optional): specifies an interface to use for lazy initializing proxies. You can specify the name of the class itself. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">dynamic-update</code> (optional - defaults to <code class="literal">false</code>): specifies that <code class="literal">UPDATE</code> SQL should be generated at runtime and can contain only those columns whose values have changed. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/9.png" alt="9" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">dynamic-insert</code> (optional - defaults to <code class="literal">false</code>): specifies that <code class="literal">INSERT</code> SQL should be generated at runtime and contain only the columns whose values are not null. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/10.png" alt="10" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">select-before-update</code> (optional - defaults to <code class="literal">false</code>): specifies that Hibernate should <span class="emphasis"><em>never</em></span> perform an SQL <code class="literal">UPDATE</code> unless it is certain that an object is actually modified. Only when a transient object has been associated with a new session using <code class="literal">update()</code>, will Hibernate perform an extra SQL <code class="literal">SELECT</code> to determine if an <code class="literal">UPDATE</code> is actually required. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/11.png" alt="11" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">polymorphism</code> (optional - defaults to <code class="literal">implicit</code>): determines whether implicit or explicit query polymorphism is used. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/12.png" alt="12" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">where</code> (optional): specifies an arbitrary SQL <code class="literal">WHERE</code> condition to be used when retrieving objects of this class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/13.png" alt="13" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">persister</code> (optional): specifies a custom <code class="literal">ClassPersister</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/14.png" alt="14" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">batch-size</code> (optional - defaults to <code class="literal">1</code>): specifies a "batch size" for fetching instances of this class by identifier. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/15.png" alt="15" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">version</code>): determines the optimistic locking strategy. </p></td></tr><tr><td width="5%" valign="top" align="left">(16)</td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional): lazy fetching can be disabled by setting <code class="literal">lazy="false"</code>. </p></td></tr><tr><td width="5%" valign="top" align="left">(17)</td><td valign="top" align="left"><p><code class="literal">entity-name</code> (optional - defaults to the class name): Hibernate3 allows a class to be mapped multiple times, potentially to different tables. It also allows entity mappings that are represented by Maps or XML at the Java level. In these cases, you should provide an explicit arbitrary name for the entity. See <a href="#persistent-classes-dynamicmodels" title="4.4. Modelos dinámicos">Sección 4.4, “Modelos dinámicos”</a> and <a href="#xml" title="Capítulo 18. Mapeo XML">Capítulo 18, <i xmlns:xlink="http://www.w3.org/1999/xlink">Mapeo XML</i></a> for more information. </p></td></tr><tr><td width="5%" valign="top" align="left">(18)</td><td valign="top" align="left"><p><code class="literal">check</code> (optional): an SQL expression used to generate a multi-row <span class="emphasis"><em>check</em></span> constraint for automatic schema generation. </p></td></tr><tr><td width="5%" valign="top" align="left">(19)</td><td valign="top" align="left"><p><code class="literal">rowid</code> (optional): Hibernate can use ROWIDs on databases. On Oracle, for example, Hibernate can use the <code class="literal">rowid</code> extra column for fast updates once this option has been set to <code class="literal">rowid</code>. A ROWID is an implementation detail and represents the physical location of a stored tuple. </p></td></tr><tr><td width="5%" valign="top" align="left">(20)</td><td valign="top" align="left"><p><code class="literal">subselect</code> (optional): maps an immutable and read-only entity to a database subselect. This is useful if you want to have a view instead of a base table. See below for more information. </p></td></tr><tr><td width="5%" valign="top" align="left">(21)</td><td valign="top" align="left"><p><code class="literal">abstract</code> (optional): is used to mark abstract superclasses in <code class="literal">&lt;union-subclass&gt;</code> hierarchies. </p></td></tr></table></div></div><p>It is acceptable for the named persistent class to be an interface. You can declare implementing classes of that interface using the <code class="literal">&lt;subclass&gt;</code> element. You can persist any <span class="emphasis"><em>static</em></span> inner class. Specify the class name using the standard form i.e. <code class="literal">e.g.Foo$Bar</code>. </p><p>Immutable classes, <code class="literal">mutable="false"</code>, cannot be updated or deleted by the application. This allows Hibernate to make some minor performance optimizations. </p><p>The optional <code class="literal">proxy</code> attribute enables lazy initialization of persistent instances of the class. Hibernate will initially return CGLIB proxies that implement the named interface. The persistent object will load when a method of the proxy is invoked. See "Initializing collections and proxies" below. </p><p><span class="emphasis"><em>Implicit</em></span> polymorphism means that instances of the class will be returned by a query that names any superclass or implemented interface or class, and that instances of any subclass of the class will be returned by a query that names the class itself. <span class="emphasis"><em>Explicit</em></span> polymorphism means that class instances will be returned only by queries that explicitly name that class. Queries that name the class will return only instances of subclasses mapped inside this <code class="literal">&lt;class&gt;</code> declaration as a <code class="literal">&lt;subclass&gt;</code> or <code class="literal">&lt;joined-subclass&gt;</code>. For most purposes, the default <code class="literal">polymorphism="implicit"</code> is appropriate. Explicit polymorphism is useful when two different classes are mapped to the same table This allows a "lightweight" class that contains a subset of the table columns. </p><p>The <code class="literal">persister</code> attribute lets you customize the persistence strategy used for the class. You can, for example, specify your own subclass of <code class="literal">org.hibernate.persister.EntityPersister</code>, or you can even provide a completely new implementation of the interface <code class="literal">org.hibernate.persister.ClassPersister</code> that implements, for example, persistence via stored procedure calls, serialization to flat files or LDAP. See <code class="literal">org.hibernate.test.CustomPersister</code> for a simple example of "persistence" to a <code class="literal">Hashtable</code>. </p><p>The <code class="literal">dynamic-update</code> and <code class="literal">dynamic-insert</code> settings are not inherited by subclasses, so they can also be specified on the <code class="literal">&lt;subclass&gt;</code> or <code class="literal">&lt;joined-subclass&gt;</code> elements. Although these settings can increase performance in some cases, they can actually decrease performance in others. </p><p>Use of <code class="literal">select-before-update</code> will usually decrease performance. It is useful to prevent a database update trigger being called unnecessarily if you reattach a graph of detached instances to a <code class="literal">Session</code>. </p><p>Si habilitas <code class="literal">dynamic-update</code>, tendrás opción de estrategias de bloqueo optimistas: </p><div class="itemizedlist"><ul><li><p><code class="literal">version</code>: check the version/timestamp columns </p></li><li><p><code class="literal">all</code>: check all columns </p></li><li><p><code class="literal">dirty</code>: check the changed columns, allowing some concurrent updates </p></li><li><p><code class="literal">none</code>: do not use optimistic locking </p></li></ul></div><p>It is <span class="emphasis"><em>strongly</em></span> recommended that you use version/timestamp columns for optimistic locking with Hibernate. This strategy optimizes performance and correctly handles modifications made to detached instances (i.e. when <code class="literal">Session.merge()</code> is used). </p><p>There is no difference between a view and a base table for a Hibernate mapping. This is transparent at the database level, although some DBMS do not support views properly, especially with updates. Sometimes you want to use a view, but you cannot create one in the database (i.e. with a legacy schema). In this case, you can map an immutable and read-only entity to a given SQL subselect expression: </p><pre class="programlisting">&lt;class name="Summary"&gt;
    &lt;subselect&gt;
        select item.name, max(bid.amount), count(*)
        from item
        join bid on bid.item_id = item.id
        group by item.name
    &lt;/subselect&gt;
    &lt;synchronize table="item"/&gt;
    &lt;synchronize table="bid"/&gt;
    &lt;id name="name"/&gt;
    ...
&lt;/class
&gt;</pre><p>Declare the tables to synchronize this entity with, ensuring that auto-flush happens correctly and that queries against the derived entity do not return stale data. The <code class="literal">&lt;subselect&gt;</code> is available both as an attribute and a nested mapping element. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-id"/>5.1.4. id</h3></div></div></div><p>Las clases mapeadas <span class="emphasis"><em>deben</em></span> declarar la columna de clave primaria de la tabla de la base de datos. En la mayoría de los casos tendrá también una propiedad estilo Javabeans que tenga el identificador único de una instancia. El elemento <code class="literal">&lt;id&gt;</code> define el mapeo de esa propiedad a la columna de clave primaria. </p><div class="programlistingco"><pre class="programlisting">&lt;id
        name="propertyName"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        type="typename"                                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        column="column_name"                                         <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        unsaved-value="null|any|none|undefined|id_value"             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        access="field|property|ClassName"                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        node="element-name|@attribute-name|element/@attribute|."&gt;

        &lt;generator class="generatorClass"/&gt;
&lt;/id
&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code> (optional): the name of the identifier property. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">type</code> (opcional): un nombre que indica el nobre Hibernate. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional - defaults to the property name): the name of the primary key column. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unsaved-value</code> (optional - defaults to a "sensible" value): an identifier property value that indicates an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate should use for accessing the property value. </p></td></tr></table></div></div><p>Si se omite el atributo <code class="literal">name</code>, se asume que la clase no tiene propiedad identificadora. </p><p>El atributo <code class="literal">unsaved-value</code> es importante! Si la propiedad identificadora de tu clase no tiene por defecto el valor por defecto normal de Java (null o cero), entonces debes especificar el valor por defecto real. </p><p>There is an alternative <code class="literal">&lt;composite-id&gt;</code> declaration that allows access to legacy data with composite keys. Its use is strongly discouraged for anything else. </p><div class="sect3" lang="es-ES"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-generator"/>5.1.4.1. Generator</h4></div></div></div><p>El elemento hijo opcional <code class="literal">&lt;generator&gt;</code> nombra una clase Java usada en generar identificadores únicos para instancias de la clase persistente. De requerirse algún parámetro para configurar o inicializar la instancia del generador, se pasa usando el elemento <code class="literal">&lt;param&gt;</code>. </p><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="org.hibernate.id.TableHiLoGenerator"&gt;
                &lt;param name="table"
&gt;uid_table&lt;/param&gt;
                &lt;param name="column"
&gt;next_hi_value_column&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id
&gt;</pre><p>All generators implement the interface <code class="literal">org.hibernate.id.IdentifierGenerator</code>. This is a very simple interface. Some applications can choose to provide their own specialized implementations, however, Hibernate provides a range of built-in implementations. The shortcut names for the built-in generators are as follows: </p><div class="variablelist"><dl><dt><span class="term"><code class="literal">increment</code></span></dt><dd><p>genera indentificadores de tipo <code class="literal">long</code>, <code class="literal">short</code> o <code class="literal">int</code> que sólo son únicos cuando ningún otro proceso está insertando datos en la misma tabla. <span class="emphasis"><em>No usar en un cluster.</em></span> </p></dd><dt><span class="term"><code class="literal">identity</code></span></dt><dd><p>soporta columnas de identidad en DB2, MySQL, MS SQL Server, Sybase y HypersonicSQL. El identificador devuelto es de tipo <code class="literal">long</code>, <code class="literal">short</code> o <code class="literal">int</code>. </p></dd><dt><span class="term"><code class="literal">sequence</code></span></dt><dd><p>usa una secuencia en DB2, PostgreSQL, Oracle, SAP DB, McKoi o un generador en Interbase. El identificador devuelto es de tipo <code class="literal">long</code>, <code class="literal">short</code> o <code class="literal">int</code>. </p></dd><dt><span class="term"><code class="literal">hilo</code></span></dt><dd><p><a id="mapping-declaration-id-hilodescription"/>usa un algoritmo alto/bajo para generar eficientemente identificadores de tipo <code class="literal">long</code>, <code class="literal">short</code> o <code class="literal">int</code>, dada una tabla y columna como fuente de valores altos (por defecto <code class="literal">hibernate_unique_key</code> y <code class="literal">next_hi</code> respectivamente). El algoritmo alto/bajo genera identificadores que son únicos sólo para una base de datos particular. </p></dd><dt><span class="term"><code class="literal">seqhilo</code></span></dt><dd><p>usa un algoritmo alto/bajo para generar eficientemente identificadores de tipo <code class="literal">long</code>, <code class="literal">short</code> o <code class="literal">int</code>, dada una secuencia de base de datos. </p></dd><dt><span class="term"><code class="literal">uuid</code></span></dt><dd><p>uses a 128-bit UUID algorithm to generate identifiers of type string that are unique within a network (the IP address is used). The UUID is encoded as a string of 32 hexadecimal digits in length. </p></dd><dt><span class="term"><code class="literal">guid</code></span></dt><dd><p>usa una cadena GUID generada por base de datos en MS SQL Server y MySQL. </p></dd><dt><span class="term"><code class="literal">native</code></span></dt><dd><p>selects <code class="literal">identity</code>, <code class="literal">sequence</code> or <code class="literal">hilo</code> depending upon the capabilities of the underlying database. </p></dd><dt><span class="term"><code class="literal">assigned</code></span></dt><dd><p>lets the application assign an identifier to the object before <code class="literal">save()</code> is called. This is the default strategy if no <code class="literal">&lt;generator&gt;</code> element is specified. </p></dd><dt><span class="term"><code class="literal">select</code></span></dt><dd><p>retrieves a primary key, assigned by a database trigger, by selecting the row by some unique key and retrieving the primary key value. </p></dd><dt><span class="term"><code class="literal">foreign</code></span></dt><dd><p>uses the identifier of another associated object. It is usually used in conjunction with a <code class="literal">&lt;one-to-one&gt;</code> primary key association. </p></dd><dt><span class="term"><code class="literal">UNTRANSLATED! sequence-identity</code></span></dt><dd><p>a specialized sequence generation strategy that utilizes a database sequence for the actual value generation, but combines this with JDBC3 getGeneratedKeys to return the generated identifier value as part of the insert statement execution. This strategy is only supported on Oracle 10g drivers targeted for JDK 1.4. Comments on these insert statements are disabled due to a bug in the Oracle drivers. </p></dd></dl></div><p>

                </p></div><div class="sect3" lang="es-ES"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-hilo"/>5.1.4.2. Algoritmo alto/bajo</h4></div></div></div><p>The <code class="literal">hilo</code> and <code class="literal">seqhilo</code> generators provide two alternate implementations of the hi/lo algorithm. The first implementation requires a "special" database table to hold the next available "hi" value. Where supported, the second uses an Oracle-style sequence. </p><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="hilo"&gt;
                &lt;param name="table"
&gt;hi_value&lt;/param&gt;
                &lt;param name="column"
&gt;next_value&lt;/param&gt;
                &lt;param name="max_lo"
&gt;100&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id
&gt;</pre><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="seqhilo"&gt;
                &lt;param name="sequence"
&gt;hi_value&lt;/param&gt;
                &lt;param name="max_lo"
&gt;100&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id
&gt;</pre><p>Unfortunately, you cannot use <code class="literal">hilo</code> when supplying your own <code class="literal">Connection</code> to Hibernate. When Hibernate uses an application server datasource to obtain connections enlisted with JTA, you must configure the <code class="literal">hibernate.transaction.manager_lookup_class</code>. </p></div><div class="sect3" lang="es-ES"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-uuid"/>5.1.4.3. Algoritmo UUID</h4></div></div></div><p>The UUID contains: IP address, startup time of the JVM that is accurate to a quarter second, system time and a counter value that is unique within the JVM. It is not possible to obtain a MAC address or memory address from Java code, so this is the best option without using JNI. </p></div><div class="sect3" lang="es-ES"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-sequences"/>5.1.4.4. Columnas de identidad y secuencias</h4></div></div></div><p>For databases that support identity columns (DB2, MySQL, Sybase, MS SQL), you can use <code class="literal">identity</code> key generation. For databases that support sequences (DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB) you can use <code class="literal">sequence</code> style key generation. Both of these strategies require two SQL queries to insert a new object. For example: </p><pre class="programlisting">&lt;id name="id" type="long" column="person_id"&gt;
        &lt;generator class="sequence"&gt;
                &lt;param name="sequence"
&gt;person_id_sequence&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id
&gt;</pre><pre class="programlisting">&lt;id name="id" type="long" column="person_id" unsaved-value="0"&gt;
        &lt;generator class="identity"/&gt;
&lt;/id
&gt;</pre><p>For cross-platform development, the <code class="literal">native</code> strategy will, depending on the capabilities of the underlying database, choose from the <code class="literal">identity</code>, <code class="literal">sequence</code> and <code class="literal">hilo</code> strategies. </p></div><div class="sect3" lang="es-ES"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-assigned"/>5.1.4.5. Identificadores asignados</h4></div></div></div><p>If you want the application to assign identifiers, as opposed to having Hibernate generate them, you can use the <code class="literal">assigned</code> generator. This special generator uses the identifier value already assigned to the object's identifier property. The generator is used when the primary key is a natural key instead of a surrogate key. This is the default behavior if you do not specify a <code class="literal">&lt;generator&gt;</code> element. </p><p>The <code class="literal">assigned</code> generator makes Hibernate use <code class="literal">unsaved-value="undefined"</code>. This forces Hibernate to go to the database to determine if an instance is transient or detached, unless there is a version or timestamp property, or you define <code class="literal">Interceptor.isUnsaved()</code>. </p></div><div class="sect3" lang="es-ES"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-select"/>5.1.4.6. Claves primarias asignadas por disparadores</h4></div></div></div><p>Hibernate does not generate DDL with triggers. It is for legacy schemas only. </p><pre class="programlisting">&lt;id name="id" type="long" column="person_id"&gt;
        &lt;generator class="select"&gt;
                &lt;param name="key"
&gt;socialSecurityNumber&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id
&gt;</pre><p>In the above example, there is a unique valued property named <code class="literal">socialSecurityNumber</code>. It is defined by the class, as a natural key and a surrogate key named <code class="literal">person_id</code>, whose value is generated by a trigger. </p></div></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-id-enhanced"/>5.1.5. Enhanced identifier generators</h3></div></div></div><p>Starting with release 3.2.3, there are 2 new generators which represent a re-thinking of 2 different aspects of identifier generation. The first aspect is database portability; the second is optimization Optimization means that you do not have to query the database for every request for a new identifier value. These two new generators are intended to take the place of some of the named generators described above, starting in 3.3.x. However, they are included in the current releases and can be referenced by FQN. </p><p>The first of these new generators is <code class="literal">org.hibernate.id.enhanced.SequenceStyleGenerator</code> which is intended, firstly, as a replacement for the <code class="literal">sequence</code> generator and, secondly, as a better portability generator than <code class="literal">native</code>. This is because <code class="literal">native</code> generally chooses between <code class="literal">identity</code> and <code class="literal">sequence</code> which have largely different semantics that can cause subtle issues in applications eyeing portability. <code class="literal">org.hibernate.id.enhanced.SequenceStyleGenerator</code>, however, achieves portability in a different manner. It chooses between a table or a sequence in the database to store its incrementing values, depending on the capabilities of the dialect being used. The difference between this and <code class="literal">native</code> is that table-based and sequence-based storage have the same exact semantic. In fact, sequences are exactly what Hibernate tries to emulate with its table-based generators. This generator has a number of configuration parameters: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">sequence_name</code> (optional, defaults to <code class="literal">hibernate_sequence</code>): the name of the sequence or table to be used. </p></li><li><p><code class="literal">initial_value</code> (optional, defaults to <code class="literal">1</code>): the initial value to be retrieved from the sequence/table. In sequence creation terms, this is analogous to the clause typically named "STARTS WITH". </p></li><li><p><code class="literal">increment_size</code> (optional - defaults to <code class="literal">1</code>): the value by which subsequent calls to the sequence/table should differ. In sequence creation terms, this is analogous to the clause typically named "INCREMENT BY". </p></li><li><p><code class="literal">force_table_use</code> (optional - defaults to <code class="literal">false</code>): should we force the use of a table as the backing structure even though the dialect might support sequence? </p></li><li><p><code class="literal">value_column</code> (optional - defaults to <code class="literal">next_val</code>): only relevant for table structures, it is the name of the column on the table which is used to hold the value. </p></li><li><p><code class="literal">optimizer</code> (optional - defaults to <code class="literal">none</code>): See <a href="#mapping-declaration-id-enhanced-optimizers" title="5.1.6. Identifier generator optimization">Sección 5.1.6, “Identifier generator optimization”</a> </p></li></ul></div><p>
            </p><p>The second of these new generators is <code class="literal">org.hibernate.id.enhanced.TableGenerator</code>, which is intended, firstly, as a replacement for the <code class="literal">table</code> generator, even though it actually functions much more like <code class="literal">org.hibernate.id.MultipleHiLoPerTableGenerator</code>, and secondly, as a re-implementation of <code class="literal">org.hibernate.id.MultipleHiLoPerTableGenerator</code> that utilizes the notion of pluggable optimizers. Essentially this generator defines a table capable of holding a number of different increment values simultaneously by using multiple distinctly keyed rows. This generator has a number of configuration parameters: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">table_name</code> (optional - defaults to <code class="literal">hibernate_sequences</code>): the name of the table to be used. </p></li><li><p><code class="literal">value_column_name</code> (optional - defaults to <code class="literal">next_val</code>): the name of the column on the table that is used to hold the value. </p></li><li><p><code class="literal">segment_column_name</code> (optional - defaults to <code class="literal">sequence_name</code>): the name of the column on the table that is used to hold the "segment key". This is the value which identifies which increment value to use. </p></li><li><p><code class="literal">segment_value</code> (optional - defaults to <code class="literal">default</code>): The "segment key" value for the segment from which we want to pull increment values for this generator. </p></li><li><p><code class="literal">segment_value_length</code> (optional - defaults to <code class="literal">255</code>): Used for schema generation; the column size to create this segment key column. </p></li><li><p><code class="literal">initial_value</code> (optional - defaults to <code class="literal">1</code>): The initial value to be retrieved from the table. </p></li><li><p><code class="literal">increment_size</code> (optional - defaults to <code class="literal">1</code>): The value by which subsequent calls to the table should differ. </p></li><li><p><code class="literal">optimizer</code> (optional - defaults to <code class="literal"/>): See <a href="#mapping-declaration-id-enhanced-optimizers" title="5.1.6. Identifier generator optimization">Sección 5.1.6, “Identifier generator optimization”</a> </p></li></ul></div><p>
            </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-id-enhanced-optimizers"/>5.1.6. Identifier generator optimization</h3></div></div></div><p>For identifier generators that store values in the database, it is inefficient for them to hit the database on each and every call to generate a new identifier value. Instead, you can group a bunch of them in memory and only hit the database when you have exhausted your in-memory value group. This is the role of the pluggable optimizers. Currently only the two enhanced generators (<a href="#mapping-declaration-id-enhanced" title="5.1.5. Enhanced identifier generators">Sección 5.1.5, “Enhanced identifier generators”</a> support this operation. </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">none</code> (generally this is the default if no optimizer was specified): this will not perform any optimizations and hit the database for each and every request. </p></li><li><p><code class="literal">hilo</code>: applies a hi/lo algorithm around the database retrieved values. The values from the database for this optimizer are expected to be sequential. The values retrieved from the database structure for this optimizer indicates the "group number". The <code class="literal">increment_size</code> is multiplied by that value in memory to define a group "hi value". </p></li><li><p><code class="literal">pooled</code>: as with the case of <code class="literal">hilo</code>, this optimizer attempts to minimize the number of hits to the database. Here, however, we simply store the starting value for the "next group" into the database structure rather than a sequential value in combination with an in-memory grouping algorithm. Here, <code class="literal">increment_size</code> refers to the values coming from the database. </p></li></ul></div><p>
            </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-compositeid"/>5.1.7. composite-id</h3></div></div></div><pre class="programlisting">&lt;composite-id
        name="propertyName"
        class="ClassName"
        unsaved-value="undefined|any|none"
        access="field|property|ClassName"
        node="element-name|."&gt;

        &lt;key-property name="propertyName" type="typename" column="column_name"/&gt;
        &lt;key-many-to-one name="propertyName class="ClassName" column="column_name"/&gt;
        ......
&lt;/composite-id
&gt;</pre><p>A table with a composite key can be mapped with multiple properties of the class as identifier properties. The <code class="literal">&lt;composite-id&gt;</code> element accepts <code class="literal">&lt;key-property&gt;</code> property mappings and <code class="literal">&lt;key-many-to-one&gt;</code> mappings as child elements. </p><pre class="programlisting">&lt;composite-id&gt;
        &lt;key-property name="medicareNumber"/&gt;
        &lt;key-property name="dependent"/&gt;
&lt;/composite-id
&gt;</pre><p>The persistent class <span class="emphasis"><em>must</em></span> override <code class="literal">equals()</code> and <code class="literal">hashCode()</code> to implement composite identifier equality. It must also implement <code class="literal">Serializable</code>. </p><p>Unfortunately, this approach means that a persistent object is its own identifier. There is no convenient "handle" other than the object itself. You must instantiate an instance of the persistent class itself and populate its identifier properties before you can <code class="literal">load()</code> the persistent state associated with a composite key. We call this approach an <span class="emphasis"><em>embedded</em></span> composite identifier, and discourage it for serious applications. </p><p>A second approach is what we call a <span class="emphasis"><em>mapped</em></span> composite identifier, where the identifier properties named inside the <code class="literal">&lt;composite-id&gt;</code> element are duplicated on both the persistent class and a separate identifier class. </p><pre class="programlisting">&lt;composite-id class="MedicareId" mapped="true"&gt;
                            &lt;key-property name="medicareNumber"/&gt;
                            &lt;key-property name="dependent"/&gt;
                    &lt;/composite-id
&gt;</pre><p>In this example, both the composite identifier class, <code class="literal">MedicareId</code>, and the entity class itself have properties named <code class="literal">medicareNumber</code> and <code class="literal">dependent</code>. The identifier class must override <code class="literal">equals()</code> and <code class="literal">hashCode()</code> and implement <code class="literal">Serializable</code>. The main disadvantage of this approach is code duplication. </p><p>The following attributes are used to specify a mapped composite identifier: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">mapped</code> (optional - defaults to <code class="literal">false</code>): indicates that a mapped composite identifier is used, and that the contained property mappings refer to both the entity class and the composite identifier class. </p></li><li><p><code class="literal">class</code> (optional - but required for a mapped composite identifier): the class used as a composite identifier. </p></li></ul></div><p>We will describe a third, even more convenient approach, where the composite identifier is implemented as a component class in <a href="#components-compositeid" title="8.4. Componentes como identificadores compuestos">Sección 8.4, “Componentes como identificadores compuestos”</a>. The attributes described below apply only to this alternative approach: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">name</code> (optional - required for this approach): a property of component type that holds the composite identifier. Please see chapter 9 for more information. </p></li><li><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></li><li><p><code class="literal">class</code> (optional - defaults to the property type determined by reflection): the component class used as a composite identifier. Please see the next section for more information. </p></li></ul></div><p>The third approach, an <span class="emphasis"><em>identifier component</em></span>, is recommended for almost all applications. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-discriminator"/>5.1.8. Discriminator</h3></div></div></div><p>The <code class="literal">&lt;discriminator&gt;</code> element is required for polymorphic persistence using the table-per-class-hierarchy mapping strategy. It declares a discriminator column of the table. The discriminator column contains marker values that tell the persistence layer what subclass to instantiate for a particular row. A restricted set of types can be used: <code class="literal">string</code>, <code class="literal">character</code>, <code class="literal">integer</code>, <code class="literal">byte</code>, <code class="literal">short</code>, <code class="literal">boolean</code>, <code class="literal">yes_no</code>, <code class="literal">true_false</code>. </p><div class="programlistingco"><pre class="programlisting">&lt;discriminator
        column="discriminator_column"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        type="discriminator_type"                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        force="true|false"                                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        insert="true|false"                                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        formula="arbitrary sql expression"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional - defaults to <code class="literal">class</code>): the name of the discriminator column. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">type</code> (optional - defaults to <code class="literal">string</code>): a name that indicates the Hibernate type </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">force</code> (optional - defaults to <code class="literal">false</code>): "forces" Hibernate to specify the allowed discriminator values, even when retrieving all instances of the root class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">insert</code> (optional - defaults to <code class="literal">true</code>): set this to <code class="literal">false</code> if your discriminator column is also part of a mapped composite identifier. It tells Hibernate not to include the column in SQL <code class="literal">INSERTs</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">formula</code> (optional): an arbitrary SQL expression that is executed when a type has to be evaluated. It allows content-based discrimination. </p></td></tr></table></div></div><p>Los valores reales de la columna discriminadora están especificados por el atributo <code class="literal">discriminator-value</code> de los elementos <code class="literal">&lt;class&gt;</code> y <code class="literal">&lt;subclass&gt;</code>. </p><p>The <code class="literal">force</code> attribute is only useful if the table contains rows with "extra" discriminator values that are not mapped to a persistent class. This will not usually be the case. </p><p>The <code class="literal">formula</code> attribute allows you to declare an arbitrary SQL expression that will be used to evaluate the type of a row. For example: </p><pre class="programlisting">&lt;discriminator
    formula="case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end"
    type="integer"/&gt;</pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-version"/>5.1.9. Version (optional)</h3></div></div></div><p>The <code class="literal">&lt;version&gt;</code> element is optional and indicates that the table contains versioned data. This is particularly useful if you plan to use <span class="emphasis"><em>long transactions</em></span>. See below for more information: </p><div class="programlistingco"><pre class="programlisting">&lt;version
        column="version_column"                                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        name="propertyName"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        type="typename"                                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        access="field|property|ClassName"                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        unsaved-value="null|negative|undefined"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        node="element-name|@attribute-name|element/@attribute|."     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional - defaults to the property name): the name of the column holding the version number. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the name of a property of the persistent class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">type</code> (optional - defaults to <code class="literal">integer</code>): the type of the version number. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses to access the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unsaved-value</code> (optional - defaults to <code class="literal">undefined</code>): a version property value that indicates that an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session. <code class="literal">Undefined</code> specifies that the identifier property value should be used. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">generated</code> (optional - defaults to <code class="literal">never</code>): specifies that this version property value is generated by the database. See the discussion of <a href="#mapping-generated" title="5.6. Generated properties">generated properties</a> for more information. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">insert</code> (optional - defaults to <code class="literal">true</code>): specifies whether the version column should be included in SQL insert statements. It can be set to <code class="literal">false</code> if the database column is defined with a default value of <code class="literal">0</code>. </p></td></tr></table></div></div><p>Version numbers can be of Hibernate type <code class="literal">long</code>, <code class="literal">integer</code>, <code class="literal">short</code>, <code class="literal">timestamp</code> or <code class="literal">calendar</code>. </p><p>A version or timestamp property should never be null for a detached instance. Hibernate will detect any instance with a null version or timestamp as transient, irrespective of what other <code class="literal">unsaved-value</code> strategies are specified. <span class="emphasis"><em>Declaring a nullable version or timestamp property is an easy way to avoid problems with transitive reattachment in Hibernate. It is especially useful for people using assigned identifiers or composite keys</em></span>. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-timestamp"/>5.1.10. Timestamp (optional)</h3></div></div></div><p>The optional <code class="literal">&lt;timestamp&gt;</code> element indicates that the table contains timestamped data. This provides an alternative to versioning. Timestamps are a less safe implementation of optimistic locking. However, sometimes the application might use the timestamps in other ways. </p><div class="programlistingco"><pre class="programlisting">&lt;timestamp
        column="timestamp_column"                                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        name="propertyName"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        access="field|property|ClassName"                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        unsaved-value="null|undefined"                               <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        node="element-name|@attribute-name|element/@attribute|."     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional - defaults to the property name): the name of a column holding the timestamp. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the name of a JavaBeans style property of Java type <code class="literal">Date</code> or <code class="literal">Timestamp</code> of the persistent class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unsaved-value</code> (optional - defaults to <code class="literal">null</code>): a version property value that indicates that an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session. <code class="literal">Undefined</code> specifies that the identifier property value should be used. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">source</code> (optional - defaults to <code class="literal">vm</code>): Where should Hibernate retrieve the timestamp value from? From the database, or from the current JVM? Database-based timestamps incur an overhead because Hibernate must hit the database in order to determine the "next value". It is safer to use in clustered environments. Not all <code class="literal">Dialects</code> are known to support the retrieval of the database's current timestamp. Others may also be unsafe for usage in locking due to lack of precision (Oracle 8, for example). </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">generated</code> (optional - defaults to <code class="literal">never</code>): specifies that this timestamp property value is actually generated by the database. See the discussion of <a href="#mapping-generated" title="5.6. Generated properties">generated properties</a> for more information. </p></td></tr></table></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p><code class="literal">&lt;Timestamp&gt;</code> is equivalent to <code class="literal">&lt;version type="timestamp"&gt;</code>. And <code class="literal">&lt;timestamp source="db"&gt;</code> is equivalent to <code class="literal">&lt;version type="dbtimestamp"&gt;</code> </p></div></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-property"/>5.1.11. Property</h3></div></div></div><p>The <code class="literal">&lt;property&gt;</code> element declares a persistent JavaBean style property of the class. </p><div class="programlistingco"><pre class="programlisting">&lt;property
        name="propertyName"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        column="column_name"                                         <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        type="typename"                                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        update="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        insert="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        formula="arbitrary SQL expression"                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        access="field|property|ClassName"                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        lazy="true|false"                                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        unique="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
        not-null="true|false"                                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/9.png" alt="(9)"/></span>
        optimistic-lock="true|false"                                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/10.png" alt="(10)"/></span>
        node="element-name|@attribute-name|element/@attribute|."     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/11.png" alt="(11)"/></span>
        index="index_name"
        unique_key="unique_key_id"
        length="L"
        precision="P"
        scale="S"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: el nombre de la propiedad, con la letra inicial en minúsculas. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional - defaults to the property name): the name of the mapped database table column. This can also be specified by nested <code class="literal">&lt;column&gt;</code> element(s). </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">type</code> (opcional): un nombre que indica el nobre Hibernate. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">update, insert</code> (optional - defaults to <code class="literal">true</code>): specifies that the mapped columns should be included in SQL <code class="literal">UPDATE</code> and/or <code class="literal">INSERT</code> statements. Setting both to <code class="literal">false</code> allows a pure "derived" property whose value is initialized from some other property that maps to the same column(s), or by a trigger or other application. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">formula</code> (opcional): una expresión SQL que define el valor para una propiedad <span class="emphasis"><em>computada</em></span>. Las propiedades computadas no tienen una columna mapeada propia. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional - defaults to <code class="literal">false</code>): specifies that this property should be fetched lazily when the instance variable is first accessed. It requires build-time bytecode instrumentation. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unique</code> (optional): enables the DDL generation of a unique constraint for the columns. Also, allow this to be the target of a <code class="literal">property-ref</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/9.png" alt="9" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">not-null</code> (optional): enables the DDL generation of a nullability constraint for the columns. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/10.png" alt="10" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">true</code>): specifies that updates to this property do or do not require acquisition of the optimistic lock. In other words, it determines if a version increment should occur when this property is dirty. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/11.png" alt="11" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">generated</code> (optional - defaults to <code class="literal">never</code>): specifies that this property value is actually generated by the database. See the discussion of <a href="#mapping-generated" title="5.6. Generated properties">generated properties</a> for more information. </p></td></tr></table></div></div><p><span class="emphasis"><em>typename</em></span> puede ser: </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>The name of a Hibernate basic type: <code class="literal">integer, string, character, date, timestamp, float, binary, serializable, object, blob</code> etc. </p></li><li><p>The name of a Java class with a default basic type: <code class="literal">int, float, char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</code> etc. </p></li><li><p>El nombre de una clase Java serializable. </p></li><li><p>The class name of a custom type: <code class="literal">com.illflow.type.MyCustomType</code> etc. </p></li></ol></div><p>If you do not specify a type, Hibernate will use reflection upon the named property and guess the correct Hibernate type. Hibernate will attempt to interpret the name of the return class of the property getter using, in order, rules 2, 3, and 4. In certain cases you will need the <code class="literal">type</code> attribute. For example, to distinguish between <code class="literal">Hibernate.DATE</code> and <code class="literal">Hibernate.TIMESTAMP</code>, or to specify a custom type. </p><p>The <code class="literal">access</code> attribute allows you to control how Hibernate accesses the property at runtime. By default, Hibernate will call the property get/set pair. If you specify <code class="literal">access="field"</code>, Hibernate will bypass the get/set pair and access the field directly using reflection. You can specify your own strategy for property access by naming a class that implements the interface <code class="literal">org.hibernate.property.PropertyAccessor</code>. </p><p>A powerful feature is derived properties. These properties are by definition read-only. The property value is computed at load time. You declare the computation as an SQL expression. This then translates to a <code class="literal">SELECT</code> clause subquery in the SQL query that loads an instance: </p><pre class="programlisting">
&lt;property name="totalPrice"
    formula="( SELECT SUM (li.quantity*p.price) FROM LineItem li, Product p
                WHERE li.productId = p.productId
                AND li.customerId = customerId
                AND li.orderNumber = orderNumber )"/&gt;</pre><p>You can reference the entity table by not declaring an alias on a particular column. This would be <code class="literal">customerId</code> in the given example. You can also use the nested <code class="literal">&lt;formula&gt;</code> mapping element if you do not want to use the attribute. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-manytoone"/>5.1.12. Many-to-one</h3></div></div></div><p>An ordinary association to another persistent class is declared using a <code class="literal">many-to-one</code> element. The relational model is a many-to-one association; a foreign key in one table is referencing the primary key column(s) of the target table. </p><div class="programlistingco"><pre class="programlisting">&lt;many-to-one
        name="propertyName"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        column="column_name"                                         <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        class="ClassName"                                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        cascade="cascade_style"                                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        fetch="join|select"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        update="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        insert="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        property-ref="propertyNameFromAssociatedClass"               <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        access="field|property|ClassName"                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
        unique="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/9.png" alt="(9)"/></span>
        not-null="true|false"                                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/10.png" alt="(10)"/></span>
        optimistic-lock="true|false"                                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/11.png" alt="(11)"/></span>
        lazy="true|proxy|false"                                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/12.png" alt="(12)"/></span>
        not-found="ignore|exception"                                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/13.png" alt="(13)"/></span>
        entity-name="EntityName"                                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/14.png" alt="(14)"/></span>
        formula="cualquier expresi&amp;#x00f3;n SQL"                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/15.png" alt="(15)"/></span>
        node="element-name|@attribute-name|element/@attribute|."
        embed-xml="true|false"
        index="index_name"
        unique_key="unique_key_id"
        foreign-key="foreign_key_name"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the name of the property. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional): the name of the foreign key column. This can also be specified by nested <code class="literal">&lt;column&gt;</code> element(s). </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">class</code> (optional - defaults to the property type determined by reflection): the name of the associated class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">cascade</code> (optional): specifies which operations should be cascaded from the parent object to the associated object. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">fetch</code> (optional - defaults to <code class="literal">select</code>): chooses between outer-join fetching or sequential select fetching. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">update, insert</code> (optional - defaults to <code class="literal">true</code>): specifies that the mapped columns should be included in SQL <code class="literal">UPDATE</code> and/or <code class="literal">INSERT</code> statements. Setting both to <code class="literal">false</code> allows a pure "derived" association whose value is initialized from another property that maps to the same column(s), or by a trigger or other application. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">property-ref</code> (optional): the name of a property of the associated class that is joined to this foreign key. If not specified, the primary key of the associated class is used. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/9.png" alt="9" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unique</code> (optional): enables the DDL generation of a unique constraint for the foreign-key column. By allowing this to be the target of a <code class="literal">property-ref</code>, you can make the association multiplicity one-to-one. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/10.png" alt="10" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">not-null</code> (optional): enables the DDL generation of a nullability constraint for the foreign key columns. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/11.png" alt="11" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">true</code>): specifies that updates to this property do or do not require acquisition of the optimistic lock. In other words, it determines if a version increment should occur when this property is dirty. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/12.png" alt="12" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional - defaults to <code class="literal">proxy</code>): by default, single point associations are proxied. <code class="literal">lazy="no-proxy"</code> specifies that the property should be fetched lazily when the instance variable is first accessed. This requires build-time bytecode instrumentation. <code class="literal">lazy="false"</code> specifies that the association will always be eagerly fetched. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/13.png" alt="13" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">not-found</code> (optional - defaults to <code class="literal">exception</code>): specifies how foreign keys that reference missing rows will be handled. <code class="literal">ignore</code> will treat a missing row as a null association. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/14.png" alt="14" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">entity-name</code> (optional): the entity name of the associated class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/15.png" alt="15" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">formula</code> (opcional): una expresión SQL que define el valor para una clave foránea <span class="emphasis"><em>computada</em></span>. </p></td></tr></table></div></div><p>Setting a value of the <code class="literal">cascade</code> attribute to any meaningful value other than <code class="literal">none</code> will propagate certain operations to the associated object. The meaningful values are divided into three categories. First, basic operations, which include: <code class="literal">persist, merge, delete, save-update, evict, replicate, lock and refresh</code>; second, special values: <code class="literal">delete-orphan</code>; and third,<code class="literal">all</code> comma-separated combinations of operation names: <code class="literal">cascade="persist,merge,evict"</code> or <code class="literal">cascade="all,delete-orphan"</code>. See <a href="#objectstate-transitive" title="10.11. Persistencia transitiva">Sección 10.11, “Persistencia transitiva”</a> for a full explanation. Note that single valued, many-to-one and one-to-one, associations do not support orphan delete. </p><p>Here is an example of a typical <code class="literal">many-to-one</code> declaration: </p><pre class="programlisting">&lt;many-to-one name="product" class="Product" column="PRODUCT_ID"/&gt;</pre><p>The <code class="literal">property-ref</code> attribute should only be used for mapping legacy data where a foreign key refers to a unique key of the associated table other than the primary key. This is a complicated and confusing relational model. For example, if the <code class="literal">Product</code> class had a unique serial number that is not the primary key. The <code class="literal">unique</code> attribute controls Hibernate's DDL generation with the SchemaExport tool. </p><pre class="programlisting">&lt;property name="serialNumber" unique="true" type="string" column="SERIAL_NUMBER"/&gt;</pre><p>Entonces el mapeo para <code class="literal">OrderItem</code> debería usar: </p><pre class="programlisting">&lt;many-to-one name="product" property-ref="serialNumber" column="PRODUCT_SERIAL_NUMBER"/&gt;</pre><p>This is not encouraged, however. </p><p>Si la clave única referenciada abarca múltiples propiedades de la entidad asociada, debes mapear las propiedades dentro de un elemento <code class="literal">&lt;properties&gt;</code>. </p><p>If the referenced unique key is the property of a component, you can specify a property path: </p><pre class="programlisting">&lt;many-to-one name="owner" property-ref="identity.ssn" column="OWNER_SSN"/&gt;</pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-onetoone"/>5.1.13. One-to-one</h3></div></div></div><p>Una asociación uno-a-uno a otra clase persistente se declara usando un elemento <code class="literal">one-to-one</code>. </p><div class="programlistingco"><pre class="programlisting">&lt;one-to-one
        name="propertyName"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        class="ClassName"                                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        cascade="cascade_style"                                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        constrained="true|false"                                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        fetch="join|select"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        property-ref="propertyNameFromAssociatedClass"               <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        access="field|property|ClassName"                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        formula="cualquier expresi&amp;#x00f3;n SQL"                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
        lazy="true|proxy|false"                                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/9.png" alt="(9)"/></span>
        entity-name="EntityName"                                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/10.png" alt="(10)"/></span>
        node="element-name|@attribute-name|element/@attribute|."
        embed-xml="true|false"
        foreign-key="foreign_key_name"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the name of the property. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">class</code> (optional - defaults to the property type determined by reflection): the name of the associated class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">cascade</code> (optional): specifies which operations should be cascaded from the parent object to the associated object. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">constrained</code> (optional): specifies that a foreign key constraint on the primary key of the mapped table and references the table of the associated class. This option affects the order in which <code class="literal">save()</code> and <code class="literal">delete()</code> are cascaded, and determines whether the association can be proxied. It is also used by the schema export tool. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">fetch</code> (optional - defaults to <code class="literal">select</code>): chooses between outer-join fetching or sequential select fetching. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">property-ref</code> (optional): the name of a property of the associated class that is joined to the primary key of this class. If not specified, the primary key of the associated class is used. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">formula</code> (optional): almost all one-to-one associations map to the primary key of the owning entity. If this is not the case, you can specify another column, columns or expression to join on using an SQL formula. See <code class="literal">org.hibernate.test.onetooneformula</code> for an example. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/9.png" alt="9" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional - defaults to <code class="literal">proxy</code>): by default, single point associations are proxied. <code class="literal">lazy="no-proxy"</code> specifies that the property should be fetched lazily when the instance variable is first accessed. It requires build-time bytecode instrumentation. <code class="literal">lazy="false"</code> specifies that the association will always be eagerly fetched. <span class="emphasis"><em>Note that if <code class="literal">constrained="false"</code>, proxying is impossible and Hibernate will eagerly fetch the association</em></span>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/10.png" alt="10" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">entity-name</code> (optional): the entity name of the associated class. </p></td></tr></table></div></div><p>There are two varieties of one-to-one associations: </p><div class="itemizedlist"><ul><li><p>asociaciones de clave primaria </p></li><li><p>asociaciones de clave foráneas única </p></li></ul></div><p>Primary key associations do not need an extra table column. If two rows are related by the association, then the two table rows share the same primary key value. To relate two objects by a primary key association, ensure that they are assigned the same identifier value. </p><p>For a primary key association, add the following mappings to <code class="literal">Employee</code> and <code class="literal">Person</code> respectively: </p><pre class="programlisting">&lt;one-to-one name="person" class="Person"/&gt;</pre><pre class="programlisting">&lt;one-to-one name="employee" class="Employee" constrained="true"/&gt;</pre><p>Ensure that the primary keys of the related rows in the PERSON and EMPLOYEE tables are equal. You use a special Hibernate identifier generation strategy called <code class="literal">foreign</code>: </p><pre class="programlisting">&lt;class name="person" table="PERSON"&gt;
    &lt;id name="id" column="PERSON_ID"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"
&gt;employee&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    ...
    &lt;one-to-one name="employee"
        class="Employee"
        constrained="true"/&gt;
&lt;/class
&gt;</pre><p>A newly saved instance of <code class="literal">Person</code> is assigned the same primary key value as the <code class="literal">Employee</code> instance referred with the <code class="literal">employee</code> property of that <code class="literal">Person</code>. </p><p>Alternatively, a foreign key with a unique constraint, from <code class="literal">Employee</code> to <code class="literal">Person</code>, can be expressed as: </p><pre class="programlisting">&lt;many-to-one name="person" class="Person" column="PERSON_ID" unique="true"/&gt;</pre><p>This association can be made bidirectional by adding the following to the <code class="literal">Person</code> mapping: </p><pre class="programlisting">&lt;one-to-one name="employee" class="Employee" property-ref="person"/&gt;</pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-naturalid"/>5.1.14. Natural-id</h3></div></div></div><pre class="programlisting">&lt;natural-id mutable="true|false"/&gt;
        &lt;property ... /&gt;
        &lt;many-to-one ... /&gt;
        ......
&lt;/natural-id
&gt;</pre><p>Although we recommend the use of surrogate keys as primary keys, you should try to identify natural keys for all entities. A natural key is a property or combination of properties that is unique and non-null. It is also immutable. Map the properties of the natural key inside the <code class="literal">&lt;natural-id&gt;</code> element. Hibernate will generate the necessary unique key and nullability constraints and, as a result, your mapping will be more self-documenting. </p><p>It is recommended that you implement <code class="literal">equals()</code> and <code class="literal">hashCode()</code> to compare the natural key properties of the entity. </p><p>This mapping is not intended for use with entities that have natural primary keys. </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">mutable</code> (optional - defaults to <code class="literal">false</code>): by default, natural identifier properties are assumed to be immutable (constant). </p></li></ul></div></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-component"/>5.1.15. Component and dynamic-component</h3></div></div></div><p>The <code class="literal">&lt;component&gt;</code> element maps properties of a child object to columns of the table of a parent class. Components can, in turn, declare their own properties, components or collections. See the "Component" examples below: </p><div class="programlistingco"><pre class="programlisting">&lt;component 
        name="propertyName"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        class="className"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        insert="true|false"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        update="true|false"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        access="field|property|ClassName"   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        lazy="true|false"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        optimistic-lock="true|false"        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        unique="true|false"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
        node="element-name|."
&gt;
        
        &lt;property ...../&gt;
        &lt;many-to-one .... /&gt;
        ........
&lt;/component
&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the name of the property. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">class</code> (optional - defaults to the property type determined by reflection): the name of the component (child) class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">insert</code>: do the mapped columns appear in SQL <code class="literal">INSERTs</code>? </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">update</code>: do the mapped columns appear in SQL <code class="literal">UPDATEs</code>? </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional - defaults to <code class="literal">false</code>): specifies that this component should be fetched lazily when the instance variable is first accessed. It requires build-time bytecode instrumentation. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">true</code>): specifies that updates to this component either do or do not require acquisition of the optimistic lock. It determines if a version increment should occur when this property is dirty. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unique</code> (optional - defaults to <code class="literal">false</code>): specifies that a unique constraint exists upon all mapped columns of the component. </p></td></tr></table></div></div><p>Las etiquetas hijas <code class="literal">&lt;property&gt;</code> mapean propiedades de la clase hija columnas de la tabla. </p><p>El elemento <code class="literal">&lt;component&gt;</code> permite un subelemento <code class="literal">&lt;parent&gt;</code> que mapea una propiedad de la clase del componente como una referencia de regreso a la entidad contenedora. </p><p>The <code class="literal">&lt;dynamic-component&gt;</code> element allows a <code class="literal">Map</code> to be mapped as a component, where the property names refer to keys of the map. See <a href="#components-dynamic" title="8.5. Componentes dinámicos">Sección 8.5, “Componentes dinámicos”</a> for more information. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-properties"/>5.1.16. Properties</h3></div></div></div><p>The <code class="literal">&lt;properties&gt;</code> element allows the definition of a named, logical grouping of the properties of a class. The most important use of the construct is that it allows a combination of properties to be the target of a <code class="literal">property-ref</code>. It is also a convenient way to define a multi-column unique constraint. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;properties 
        name="logicalName"                  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        insert="true|false"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        update="true|false"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        optimistic-lock="true|false"        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        unique="true|false"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
&gt;
        
        &lt;property ...../&gt;
        &lt;many-to-one .... /&gt;
        ........
&lt;/properties
&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the logical name of the grouping. It is <span class="emphasis"><em>not</em></span> an actual property name. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">insert</code>: do the mapped columns appear in SQL <code class="literal">INSERTs</code>? </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">update</code>: do the mapped columns appear in SQL <code class="literal">UPDATEs</code>? </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">true</code>): specifies that updates to these properties either do or do not require acquisition of the optimistic lock. It determines if a version increment should occur when these properties are dirty. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unique</code> (optional - defaults to <code class="literal">false</code>): specifies that a unique constraint exists upon all mapped columns of the component. </p></td></tr></table></div></div><p>Por ejemplo, si tenemos el siguiente mapeo de <code class="literal">&lt;properties&gt;</code>: </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="personNumber"/&gt;

    ...
    &lt;properties name="name"
            unique="true" update="false"&gt;
        &lt;property name="firstName"/&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="lastName"/&gt;
    &lt;/properties&gt;
&lt;/class&gt;</pre><p>You might have some legacy data association that refers to this unique key of the <code class="literal">Person</code> table, instead of to the primary key: </p><pre class="programlisting">&lt;many-to-one name="person" 
         class="Person" property-ref="name"&gt;
    &lt;column name="firstName"/&gt;
    &lt;column name="initial"/&gt;
    &lt;column name="lastName"/&gt;
&lt;/many-to-one
&gt;</pre><p>The use of this outside the context of mapping legacy data is not recommended. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-subclass"/>5.1.17. Subclass</h3></div></div></div><p>Polymorphic persistence requires the declaration of each subclass of the root persistent class. For the table-per-class-hierarchy mapping strategy, the <code class="literal">&lt;subclass&gt;</code> declaration is used. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;subclass
        name="ClassName"                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        discriminator-value="discriminator_value"     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        proxy="ProxyInterface"                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        lazy="true|false"                             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        dynamic-update="true|false"
        dynamic-insert="true|false"
        entity-name="EntityName"
        node="element-name"&gt;

        &lt;property .... /&gt;
        .....
&lt;/subclass
&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the fully qualified class name of the subclass. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">discriminator-value</code> (optional - defaults to the class name): a value that distinguishes individual subclasses. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">proxy</code> (optional): specifies a class or interface used for lazy initializing proxies. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional - defaults to <code class="literal">true</code>): setting <code class="literal">lazy="false"</code> disables the use of lazy fetching. </p></td></tr></table></div></div><p>Each subclass declares its own persistent properties and subclasses. <code class="literal">&lt;version&gt;</code> and <code class="literal">&lt;id&gt;</code> properties are assumed to be inherited from the root class. Each subclass in a hierarchy must define a unique <code class="literal">discriminator-value</code>. If this is not specified, the fully qualified Java class name is used. </p><p>For information about inheritance mappings see <a href="#inheritance" title="Capítulo 9. Inheritance mapping">Capítulo 9, <i xmlns:xlink="http://www.w3.org/1999/xlink">Inheritance mapping</i></a>. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-joinedsubclass"/>5.1.18. Joined-subclass</h3></div></div></div><p>Each subclass can also be mapped to its own table. This is called the table-per-subclass mapping strategy. An inherited state is retrieved by joining with the table of the superclass. To do this you use the <code class="literal">&lt;joined-subclass&gt;</code> element. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;joined-subclass
        name="ClassName"                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        table="tablename"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        proxy="ProxyInterface"              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        lazy="true|false"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        dynamic-update="true|false"
        dynamic-insert="true|false"
        schema="schema"
        catalog="catalog"
        extends="SuperclassName"
        persister="ClassName"
        subselect="SQL expression"
        entity-name="EntityName"
        node="element-name"&gt;

        &lt;key .... &gt;

        &lt;property .... /&gt;
        .....
&lt;/joined-subclass
&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the fully qualified class name of the subclass. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">table</code>: the name of the subclass table. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">proxy</code> (optional): specifies a class or interface to use for lazy initializing proxies. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional, defaults to <code class="literal">true</code>): setting <code class="literal">lazy="false"</code> disables the use of lazy fetching. </p></td></tr></table></div></div><p>A discriminator column is not required for this mapping strategy. Each subclass must, however, declare a table column holding the object identifier using the <code class="literal">&lt;key&gt;</code> element. The mapping at the start of the chapter would then be re-written as: </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

        &lt;class name="Cat" table="CATS"&gt;
                &lt;id name="id" column="uid" type="long"&gt;
                        &lt;generator class="hilo"/&gt;
                &lt;/id&gt;
                &lt;property name="birthdate" type="date"/&gt;
                &lt;property name="color" not-null="true"/&gt;
                &lt;property name="sex" not-null="true"/&gt;
                &lt;property name="weight"/&gt;
                &lt;many-to-one name="mate"/&gt;
                &lt;set name="kittens"&gt;
                        &lt;key column="MOTHER"/&gt;
                        &lt;one-to-many class="Cat"/&gt;
                &lt;/set&gt;
                &lt;joined-subclass name="DomesticCat" table="DOMESTIC_CATS"&gt;
                    &lt;key column="CAT"/&gt;
                    &lt;property name="name" type="string"/&gt;
                &lt;/joined-subclass&gt;
        &lt;/class&gt;

        &lt;class name="eg.Dog"&gt;
                &lt;!-- mapping for Dog could go here --&gt;
        &lt;/class&gt;

&lt;/hibernate-mapping
&gt;</pre><p>For information about inheritance mappings see <a href="#inheritance" title="Capítulo 9. Inheritance mapping">Capítulo 9, <i xmlns:xlink="http://www.w3.org/1999/xlink">Inheritance mapping</i></a>. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-unionsubclass"/>5.1.19. Union-subclass</h3></div></div></div><p>A third option is to map only the concrete classes of an inheritance hierarchy to tables. This is called the table-per-concrete-class strategy. Each table defines all persistent states of the class, including the inherited state. In Hibernate, it is not necessary to explicitly map such inheritance hierarchies. You can map each class with a separate <code class="literal">&lt;class&gt;</code> declaration. However, if you wish use polymorphic associations (e.g. an association to the superclass of your hierarchy), you need to use the <code class="literal">&lt;union-subclass&gt;</code> mapping. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;union-subclass
        name="ClassName"                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        table="tablename"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        proxy="ProxyInterface"              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        lazy="true|false"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        dynamic-update="true|false"
        dynamic-insert="true|false"
        schema="schema"
        catalog="catalog"
        extends="SuperclassName"
        abstract="true|false"
        persister="ClassName"
        subselect="SQL expression"
        entity-name="EntityName"
        node="element-name"&gt;

        &lt;property .... /&gt;
        .....
&lt;/union-subclass
&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the fully qualified class name of the subclass. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">table</code>: the name of the subclass table. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">proxy</code> (optional): specifies a class or interface to use for lazy initializing proxies. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional, defaults to <code class="literal">true</code>): setting <code class="literal">lazy="false"</code> disables the use of lazy fetching. </p></td></tr></table></div></div><p>No se requiere columna o columna clave discriminadora para esta estrategia de mapeo. </p><p>For information about inheritance mappings see <a href="#inheritance" title="Capítulo 9. Inheritance mapping">Capítulo 9, <i xmlns:xlink="http://www.w3.org/1999/xlink">Inheritance mapping</i></a>. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-join"/>5.1.20. Join</h3></div></div></div><p>Using the <code class="literal">&lt;join&gt;</code> element, it is possible to map properties of one class to several tables that have a one-to-one relationship. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;join
        table="tablename"                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        schema="owner"                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        catalog="catalog"                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        fetch="join|select"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        inverse="true|false"                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        optional="true|false"&gt;                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        
        &lt;key ... /&gt;
        
        &lt;property ... /&gt;
        ...
&lt;/join
&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">table</code>: the name of the joined table. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">schema</code> (optional): overrides the schema name specified by the root <code class="literal">&lt;hibernate-mapping&gt;</code> element. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">catalog</code> (optional): overrides the catalog name specified by the root <code class="literal">&lt;hibernate-mapping&gt;</code> element. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">fetch</code> (optional - defaults to <code class="literal">join</code>): if set to <code class="literal">join</code>, the default, Hibernate will use an inner join to retrieve a <code class="literal">&lt;join&gt;</code> defined by a class or its superclasses. It will use an outer join for a <code class="literal">&lt;join&gt;</code> defined by a subclass. If set to <code class="literal">select</code> then Hibernate will use a sequential select for a <code class="literal">&lt;join&gt;</code> defined on a subclass. This will be issued only if a row represents an instance of the subclass. Inner joins will still be used to retrieve a <code class="literal">&lt;join&gt;</code> defined by the class and its superclasses. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">inverse</code> (optional - defaults to <code class="literal">false</code>): if enabled, Hibernate will not insert or update the properties defined by this join. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optional</code> (optional - defaults to <code class="literal">false</code>): if enabled, Hibernate will insert a row only if the properties defined by this join are non-null. It will always use an outer join to retrieve the properties. </p></td></tr></table></div></div><p>For example, address information for a person can be mapped to a separate table while preserving value type semantics for all properties: </p><pre class="programlisting">&lt;class name="Person"
    table="PERSON"&gt;

    &lt;id name="id" column="PERSON_ID"
&gt;...&lt;/id&gt;

    &lt;join table="ADDRESS"&gt;
        &lt;key column="ADDRESS_ID"/&gt;
        &lt;property name="address"/&gt;
        &lt;property name="zip"/&gt;
        &lt;property name="country"/&gt;
    &lt;/join&gt;
    ...</pre><p>This feature is often only useful for legacy data models. We recommend fewer tables than classes and a fine-grained domain model. However, it is useful for switching between inheritance mapping strategies in a single hierarchy, as explained later. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-key"/>5.1.21. Key</h3></div></div></div><p>The <code class="literal">&lt;key&gt;</code> element has featured a few times within this guide. It appears anywhere the parent mapping element defines a join to a new table that references the primary key of the original table. It also defines the foreign key in the joined table: </p><div class="programlistingco"><pre class="programlisting">&lt;key
        column="columnname"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        on-delete="noaction|cascade"             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        property-ref="propertyName"              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        not-null="true|false"                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        update="true|false"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        unique="true|false"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional): the name of the foreign key column. This can also be specified by nested <code class="literal">&lt;column&gt;</code> element(s). </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">on-delete</code> (optional - defaults to <code class="literal">noaction</code>): specifies whether the foreign key constraint has database-level cascade delete enabled. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">property-ref</code> (optional): specifies that the foreign key refers to columns that are not the primary key of the original table. It is provided for legacy data. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">not-null</code> (optional): specifies that the foreign key columns are not nullable. This is implied whenever the foreign key is also part of the primary key. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">update</code> (optional): specifies that the foreign key should never be updated. This is implied whenever the foreign key is also part of the primary key. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unique</code> (optional): specifies that the foreign key should have a unique constraint. This is implied whenever the foreign key is also the primary key. </p></td></tr></table></div></div><p>For systems where delete performance is important, we recommend that all keys should be defined <code class="literal">on-delete="cascade"</code>. Hibernate uses a database-level <code class="literal">ON CASCADE DELETE</code> constraint, instead of many individual <code class="literal">DELETE</code> statements. Be aware that this feature bypasses Hibernate's usual optimistic locking strategy for versioned data. </p><p>The <code class="literal">not-null</code> and <code class="literal">update</code> attributes are useful when mapping a unidirectional one-to-many association. If you map a unidirectional one-to-many association to a non-nullable foreign key, you <span class="emphasis"><em>must</em></span> declare the key column using <code class="literal">&lt;key not-null="true"&gt;</code>. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-column"/>5.1.22. Column and formula elements</h3></div></div></div><p>Mapping elements which accept a <code class="literal">column</code> attribute will alternatively accept a <code class="literal">&lt;column&gt;</code> subelement. Likewise, <code class="literal">&lt;formula&gt;</code> is an alternative to the <code class="literal">formula</code> attribute. For example: </p><pre class="programlisting">&lt;column
        name="column_name"
        length="N"
        precision="N"
        scale="N"
        not-null="true|false"
        unique="true|false"
        unique-key="multicolumn_unique_key_name"
        index="index_name"
        sql-type="sql_type_name"
        check="SQL expression"/&gt;</pre><pre class="programlisting">&lt;formula
&gt;expresi&amp;#x00f3;n SQL&lt;/formula
&gt;</pre><p><code class="literal">column</code> and <code class="literal">formula</code> attributes can even be combined within the same property or association mapping to express, for example, exotic join conditions. </p><pre class="programlisting">&lt;many-to-one name="homeAddress" class="Address"
        insert="false" update="false"&gt;
    &lt;column name="person_id" not-null="true" length="10"/&gt;
    &lt;formula
&gt;'MAILING'&lt;/formula&gt;
&lt;/many-to-one
&gt;</pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-import"/>5.1.23. Import</h3></div></div></div><p>If your application has two persistent classes with the same name, and you do not want to specify the fully qualified package name in Hibernate queries, classes can be "imported" explicitly, rather than relying upon <code class="literal">auto-import="true"</code>. You can also import classes and interfaces that are not explicitly mapped: </p><pre class="programlisting">&lt;import class="java.lang.Object" rename="Universe"/&gt;</pre><div class="programlistingco"><pre class="programlisting">&lt;import
        class="ClassName"              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        rename="ShortName"             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">class</code>: the fully qualified class name of any Java class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">rename</code> (optional - defaults to the unqualified class name): a name that can be used in the query language. </p></td></tr></table></div></div></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-types-anymapping"/>5.1.24. Any</h3></div></div></div><p>There is one more type of property mapping. The <code class="literal">&lt;any&gt;</code> mapping element defines a polymorphic association to classes from multiple tables. This type of mapping requires more than one column. The first column contains the type of the associated entity. The remaining columns contain the identifier. It is impossible to specify a foreign key constraint for this kind of association. This is not the usual way of mapping polymorphic associations and you should use this only in special cases. For example, for audit logs, user session data, etc. </p><p>The <code class="literal">meta-type</code> attribute allows the application to specify a custom type that maps database column values to persistent classes that have identifier properties of the type specified by <code class="literal">id-type</code>. You must specify the mapping from values of the meta-type to class names. </p><pre class="programlisting">&lt;any name="being" id-type="long" meta-type="string"&gt;
    &lt;meta-value value="TBL_ANIMAL" class="Animal"/&gt;
    &lt;meta-value value="TBL_HUMAN" class="Human"/&gt;
    &lt;meta-value value="TBL_ALIEN" class="Alien"/&gt;
    &lt;column name="table_name"/&gt;
    &lt;column name="id"/&gt;
&lt;/any
&gt;</pre><div class="programlistingco"><pre class="programlisting">&lt;any
        name="propertyName"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        id-type="idtypename"                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        meta-type="metatypename"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        cascade="cascade_style"                  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        access="field|property|ClassName"        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        optimistic-lock="true|false"             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
&gt;
        &lt;meta-value ... /&gt;
        &lt;meta-value ... /&gt;
        .....
        &lt;column .... /&gt;
        &lt;column .... /&gt;
        .....
&lt;/any
&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: el nombre de la propiedad. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">id-type</code>: el tipo del identificador. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">meta-type</code> (optional - defaults to <code class="literal">string</code>): any type that is allowed for a discriminator mapping. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">cascade</code> (opcional- por defecto a <code class="literal">none</code>): el estilo de cascada. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">true</code>): specifies that updates to this property either do or do not require acquisition of the optimistic lock. It defines whether a version increment should occur if this property is dirty. </p></td></tr></table></div></div></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-types"/>5.2. Hibernate types</h2></div></div></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-types-entitiesvalues"/>5.2.1. Entidades y Valores</h3></div></div></div><p>In relation to the persistence service, Java language-level objects are classified into two groups: </p><p>An <span class="emphasis"><em>entity</em></span> exists independently of any other objects holding references to the entity. Contrast this with the usual Java model, where an unreferenced object is garbage collected. Entities must be explicitly saved and deleted. Saves and deletions, however, can be <span class="emphasis"><em>cascaded</em></span> from a parent entity to its children. This is different from the ODMG model of object persistence by reachability and corresponds more closely to how application objects are usually used in large systems. Entities support circular and shared references. They can also be versioned. </p><p>An entity's persistent state consists of references to other entities and instances of <span class="emphasis"><em>value</em></span> types. Values are primitives: collections (not what is inside a collection), components and certain immutable objects. Unlike entities, values in particular collections and components, <span class="emphasis"><em>are</em></span> persisted and deleted by reachability. Since value objects and primitives are persisted and deleted along with their containing entity, they cannot be independently versioned. Values have no independent identity, so they cannot be shared by two entities or collections. </p><p>Until now, we have been using the term "persistent class" to refer to entities. We will continue to do that. Not all user-defined classes with a persistent state, however, are entities. A <span class="emphasis"><em>component</em></span> is a user-defined class with value semantics. A Java property of type <code class="literal">java.lang.String</code> also has value semantics. Given this definition, all types (classes) provided by the JDK have value type semantics in Java, while user-defined types can be mapped with entity or value type semantics. This decision is up to the application developer. An entity class in a domain model will normally have shared references to a single instance of that class, while composition or aggregation usually translates to a value type. </p><p>We will revisit both concepts throughout this reference guide. </p><p>The challenge is to map the Java type system, and the developers' definition of entities and value types, to the SQL/database type system. The bridge between both systems is provided by Hibernate. For entities, <code class="literal">&lt;class&gt;</code>, <code class="literal">&lt;subclass&gt;</code> and so on are used. For value types we use <code class="literal">&lt;property&gt;</code>, <code class="literal">&lt;component&gt;</code>etc., that usually have a <code class="literal">type</code> attribute. The value of this attribute is the name of a Hibernate <span class="emphasis"><em>mapping type</em></span>. Hibernate provides a range of mappings for standard JDK value types out of the box. You can write your own mapping types and implement your own custom conversion strategies. </p><p>With the exception of collections, all built-in Hibernate types support null semantics. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-types-basictypes"/>5.2.2. Tipos de valores básicos</h3></div></div></div><p>The built-in <span class="emphasis"><em>basic mapping types</em></span> can be roughly categorized into the following: </p><div class="variablelist"><dl><dt><span class="term"><code class="literal">integer, long, short, float, double, character, byte, boolean, yes_no, true_false</code></span></dt><dd><p>Mapeos de tipos primitivos de Java o clases de envoltura a la tipos de columna SQL (especícifica del vendedor). <code class="literal">boolean, yes_no</code> y <code class="literal">true_false</code> son codificaciones alternativas a <code class="literal">boolean</code> de Java o <code class="literal">java.lang.Boolean</code>. </p></dd><dt><span class="term"><code class="literal">string</code></span></dt><dd><p>Un mapeo del tipo <code class="literal">java.lang.String</code> a <code class="literal">VARCHAR</code> (u Oracle <code class="literal">VAARCHAR2</code>). </p></dd><dt><span class="term"><code class="literal">date, time, timestamp</code></span></dt><dd><p>Mapeos de tipo desde <code class="literal">java.util.Date</code> y sus subclases a tipos SQL <code class="literal">DATE</code>, <code class="literal">TIME</code> y <code class="literal">TIMESTAMP</code> (o equivalente). </p></dd><dt><span class="term"><code class="literal">calendar, calendar_date</code></span></dt><dd><p>Mapeos de tipo desde <code class="literal">java.util.Date</code> y sus subclases a tipos SQL <code class="literal">TIMESTAMP</code> y <code class="literal">DATE</code> (o equivalente). </p></dd><dt><span class="term"><code class="literal">big_decimal, big_integer</code></span></dt><dd><p>Mapeos de tipo desde <code class="literal">java.math.BigDecimal</code> y <code class="literal">java.math.BigInteger</code> a <code class="literal">NUMERIC</code> (o <code class="literal">NUMBER</code> de Oracle). </p></dd><dt><span class="term"><code class="literal">locale, timezone, currency</code></span></dt><dd><p>Mapeos de tipo desde <code class="literal">java.util.Locale</code>, <code class="literal">java.util.TimeZone</code> y <code class="literal">java.util.Currency</code> a <code class="literal">VARCHAR</code> (o <code class="literal">VARCHAR2</code> de Oracle). Las instancias de <code class="literal">Locale</code> y <code class="literal">Currency</code> son mapeadas a sus códigos ISO. Las instancias de <code class="literal">TimeZone</code> son mapeadas a sus <code class="literal">ID</code>. </p></dd><dt><span class="term"><code class="literal">class</code></span></dt><dd><p>Un mapeo de tipo <code class="literal">java.lang.Class</code> a <code class="literal">VARCHAR</code> (o <code class="literal">VARCHAR2</code> de Oracle). Una <code class="literal">Class</code> es mapeara a su nombre completamente cualificado. </p></dd><dt><span class="term"><code class="literal">binary</code></span></dt><dd><p>Mapea arreglos de bytes a un tipo binario SQL apropiado. </p></dd><dt><span class="term"><code class="literal">text</code></span></dt><dd><p>Mapea cadenas largas Java al tipo SQL <code class="literal">CLOB</code> o <code class="literal">TEXT</code>. </p></dd><dt><span class="term"><code class="literal">serializable</code></span></dt><dd><p>Maps serializable Java types to an appropriate SQL binary type. You can also indicate the Hibernate type <code class="literal">serializable</code> with the name of a serializable Java class or interface that does not default to a basic type. </p></dd><dt><span class="term"><code class="literal">clob, blob</code></span></dt><dd><p>Type mappings for the JDBC classes <code class="literal">java.sql.Clob</code> and <code class="literal">java.sql.Blob</code>. These types can be inconvenient for some applications, since the blob or clob object cannot be reused outside of a transaction. Driver support is patchy and inconsistent. </p></dd><dt><span class="term">
                            <code class="literal">UNTRANSLATED! imm_date, imm_time, imm_timestamp, imm_calendar, imm_calendar_date, imm_serializable, imm_binary</code>
                        </span></dt><dd><p>Type mappings for what are considered mutable Java types. This is where Hibernate makes certain optimizations appropriate only for immutable Java types, and the application treats the object as immutable. For example, you should not call <code class="literal">Date.setTime()</code> for an instance mapped as <code class="literal">imm_timestamp</code>. To change the value of the property, and have that change made persistent, the application must assign a new, nonidentical, object to the property. </p></dd></dl></div><p>

            </p><p>Unique identifiers of entities and collections can be of any basic type except <code class="literal">binary</code>, <code class="literal">blob</code> and <code class="literal">clob</code>. Composite identifiers are also allowed. See below for more information. </p><p>Los tipos de valor básicos tienen sus constantes <code class="literal">Type</code> correspondientes definidas en <code class="literal">org.hibernate.Hibernate</code>. Por ejemplo, <code class="literal">Hibernate.STRING</code> representa el tipo <code class="literal">string</code>. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-types-custom"/>5.2.3. Tipos de valor personalizados</h3></div></div></div><p>It is relatively easy for developers to create their own value types. For example, you might want to persist properties of type <code class="literal">java.lang.BigInteger</code> to <code class="literal">VARCHAR</code> columns. Hibernate does not provide a built-in type for this. Custom types are not limited to mapping a property, or collection element, to a single table column. So, for example, you might have a Java property <code class="literal">getName()</code>/<code class="literal">setName()</code> of type <code class="literal">java.lang.String</code> that is persisted to the columns <code class="literal">FIRST_NAME</code>, <code class="literal">INITIAL</code>, <code class="literal">SURNAME</code>. </p><p>To implement a custom type, implement either <code class="literal">org.hibernate.UserType</code> or <code class="literal">org.hibernate.CompositeUserType</code> and declare properties using the fully qualified classname of the type. View <code class="literal">org.hibernate.test.DoubleStringType</code> to see the kind of things that are possible. </p><pre class="programlisting">&lt;property name="twoStrings" type="org.hibernate.test.DoubleStringType"&gt;
    &lt;column name="first_string"/&gt;
    &lt;column name="second_string"/&gt;
&lt;/property
&gt;</pre><p>Observa el uso de etiquetas <code class="literal">&lt;column&gt;</code> para mapear una propiedad a múltiples columnas. </p><p>Las interfaces <code class="literal">CompositeUserType</code>, <code class="literal">EnhancedUserType</code>, <code class="literal">UserCollectionType</code>, y <code class="literal">UserVersionType</code> proveen soporte a usos más especializados. </p><p>You can even supply parameters to a <code class="literal">UserType</code> in the mapping file. To do this, your <code class="literal">UserType</code> must implement the <code class="literal">org.hibernate.usertype.ParameterizedType</code> interface. To supply parameters to your custom type, you can use the <code class="literal">&lt;type&gt;</code> element in your mapping files. </p><pre class="programlisting">&lt;property name="priority"&gt;
    &lt;type name="com.mycompany.usertypes.DefaultValueIntegerType"&gt;
        &lt;param name="default"
&gt;0&lt;/param&gt;
    &lt;/type&gt;
&lt;/property
&gt;</pre><p>Ahora el <code class="literal">UserType</code> puede recuperar el valor del parámetro llamado <code class="literal">default</code> del objeto <code class="literal">Properties</code> que se le pasa. </p><p>If you regularly use a certain <code class="literal">UserType</code>, it is useful to define a shorter name for it. You can do this using the <code class="literal">&lt;typedef&gt;</code> element. Typedefs assign a name to a custom type, and can also contain a list of default parameter values if the type is parameterized. </p><pre class="programlisting">&lt;typedef class="com.mycompany.usertypes.DefaultValueIntegerType" name="default_zero"&gt;
    &lt;param name="default"
&gt;0&lt;/param&gt;
&lt;/typedef
&gt;</pre><pre class="programlisting">&lt;property name="priority" type="default_zero"/&gt;</pre><p>también es posible sobrescribir los parámetros provistos en un typedef sobre una base caso por caso usando parámetros de tipo en el mapeo de la propiedad. </p><p>Even though Hibernate's rich range of built-in types and support for components means you will rarely need to use a custom type, it is considered good practice to use custom types for non-entity classes that occur frequently in your application. For example, a <code class="literal">MonetaryAmount</code> class is a good candidate for a <code class="literal">CompositeUserType</code>, even though it could be mapped as a component. One reason for this is abstraction. With a custom type, your mapping documents would be protected against changes to the way monetary values are represented. </p></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-entityname"/>5.3. Mapeando una clase más de una vez</h2></div></div></div><p>It is possible to provide more than one mapping for a particular persistent class. In this case, you must specify an <span class="emphasis"><em>entity name</em></span> to disambiguate between instances of the two mapped entities. By default, the entity name is the same as the class name. Hibernate lets you specify the entity name when working with persistent objects, when writing queries, or when mapping associations to the named entity. </p><pre class="programlisting">&lt;class name="Contract" table="Contracts" 
        entity-name="CurrentContract"&gt;
    ...
    &lt;set name="history" inverse="true" 
            order-by="effectiveEndDate desc"&gt;
        &lt;key column="currentContractId"/&gt;
        &lt;one-to-many entity-name="HistoricalContract"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Contract" table="ContractHistory" 
        entity-name="HistoricalContract"&gt;
    ...
    &lt;many-to-one name="currentContract" 
            column="currentContractId" 
            entity-name="CurrentContract"/&gt;
&lt;/class
&gt;</pre><p>Associations are now specified using <code class="literal">entity-name</code> instead of <code class="literal">class</code>. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-quotedidentifiers"/>5.4. identificadores SQL encomillados</h2></div></div></div><p>You can force Hibernate to quote an identifier in the generated SQL by enclosing the table or column name in backticks in the mapping document. Hibernate will use the correct quotation style for the SQL <code class="literal">Dialect</code>. This is usually double quotes, but the SQL Server uses brackets and MySQL uses backticks. </p><pre class="programlisting">&lt;class name="LineItem" table="`Line Item`"&gt;
    &lt;id name="id" column="`Item Id`"/&gt;&lt;generator class="assigned"/&gt;&lt;/id&gt;
    &lt;property name="itemNumber" column="`Item #`"/&gt;
    ...
&lt;/class
&gt;</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-alternatives"/>5.5. Alternativas de metadatos</h2></div></div></div><p>XML does not suit all users so there are some alternative ways to define O/R mapping metadata in Hibernate. </p><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-xdoclet"/>5.5.1. Usando marcado de XDoclet</h3></div></div></div><p>Many Hibernate users prefer to embed mapping information directly in sourcecode using XDoclet <code class="literal">@hibernate.tags</code>. We do not cover this approach in this reference guide since it is considered part of XDoclet. However, we include the following example of the <code class="literal">Cat</code> class with XDoclet mappings: </p><pre class="programlisting">package eg;
import java.util.Set;
import java.util.Date;

/**
 * @hibernate.class
 *  table="CATS"
 */
public class Cat {
    private Long id; // identifier
    private Date birthdate;
    private Cat mother;
    private Set kittens
    private Color color;
    private char sex;
    private float weight;

    /*
     * @hibernate.id
     *  generator-class="native"
     *  column="CAT_ID"
     */
    public Long getId() {
        return id;
    }
    private void setId(Long id) {
        this.id=id;
    }

    /**
     * @hibernate.many-to-one
     *  column="PARENT_ID"
     */
    public Cat getMother() {
        return mother;
    }
    void setMother(Cat mother) {
        this.mother = mother;
    }

    /**
     * @hibernate.property
     *  column="BIRTH_DATE"
     */
    public Date getBirthdate() {
        return birthdate;
    }
    void setBirthdate(Date date) {
        birthdate = date;
    }
    /**
     * @hibernate.property
     *  column="WEIGHT"
     */
    public float getWeight() {
        return weight;
    }
    void setWeight(float weight) {
        this.weight = weight;
    }

    /**
     * @hibernate.property
     *  column="COLOR"
     *  not-null="true"
     */
    public Color getColor() {
        return color;
    }
    void setColor(Color color) {
        this.color = color;
    }
    /**
     * @hibernate.set
     *  inverse="true"
     *  order-by="BIRTH_DATE"
     * @hibernate.collection-key
     *  column="PARENT_ID"
     * @hibernate.collection-one-to-many
     */
    public Set getKittens() {
        return kittens;
    }
    void setKittens(Set kittens) {
        this.kittens = kittens;
    }
    // addKitten not needed by Hibernate
    public void addKitten(Cat kitten) {
        kittens.add(kitten);
    }

    /**
     * @hibernate.property
     *  column="SEX"
     *  not-null="true"
     *  update="false"
     */
    public char getSex() {
        return sex;
    }
    void setSex(char sex) {
        this.sex=sex;
    }
}</pre><p>See the Hibernate website for more examples of XDoclet and Hibernate. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-annotations"/>5.5.2. Usando anotaciones JDK 5.0</h3></div></div></div><p>JDK 5.0 introduced XDoclet-style annotations at the language level that are type-safe and checked at compile time. This mechanism is more powerful than XDoclet annotations and better supported by tools and IDEs. IntelliJ IDEA, for example, supports auto-completion and syntax highlighting of JDK 5.0 annotations. The new revision of the EJB specification (JSR-220) uses JDK 5.0 annotations as the primary metadata mechanism for entity beans. Hibernate3 implements the <code class="literal">EntityManager</code> of JSR-220 (the persistence API). Support for mapping metadata is available via the <span class="emphasis"><em>Hibernate Annotations</em></span> package as a separate download. Both EJB3 (JSR-220) and Hibernate3 metadata is supported. </p><p>Este es un ejemplo de una clase POJO anotada como un bean de entidad EJB: </p><pre class="programlisting">@Entity(access = AccessType.FIELD)
public class Customer implements Serializable {

    @Id;
    Long id;

    String firstName;
    String lastName;
    Date birthday;

    @Transient
    Integer age;

    @Embedded
    private Address homeAddress;

    @OneToMany(cascade=CascadeType.ALL)

    @JoinColumn(name="CUSTOMER_ID")
    Set&lt;Order
&gt; orders;

    // Getter/setter and business methods
}</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Support for JDK 5.0 Annotations (and JSR-220) is currently under development. Please refer to the Hibernate Annotations module for more details. </p></div></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-generated"/>5.6. Generated properties</h2></div></div></div><p>Generated properties are properties that have their values generated by the database. Typically, Hibernate applications needed to <code class="literal">refresh</code> objects that contain any properties for which the database was generating values. Marking properties as generated, however, lets the application delegate this responsibility to Hibernate. When Hibernate issues an SQL INSERT or UPDATE for an entity that has defined generated properties, it immediately issues a select afterwards to retrieve the generated values. </p><p>Properties marked as generated must additionally be non-insertable and non-updateable. Only <a href="#mapping-declaration-version" title="5.1.9. Version (optional)">versions</a>, <a href="#mapping-declaration-timestamp" title="5.1.10. Timestamp (optional)">timestamps</a>, and <a href="#mapping-declaration-property" title="5.1.11. Property">simple properties</a>, can be marked as generated. </p><p><code class="literal">never</code> (the default): the given property value is not generated within the database. </p><p><code class="literal">insert</code>: the given property value is generated on insert, but is not regenerated on subsequent updates. Properties like created-date fall into this category. Even though <a href="#mapping-declaration-version" title="5.1.9. Version (optional)">version</a> and <a href="#mapping-declaration-timestamp" title="5.1.10. Timestamp (optional)">timestamp</a> properties can be marked as generated, this option is not available. </p><p><code class="literal">always</code>: the property value is generated both on insert and on update. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-database-object"/>5.7. Auxiliary database objects</h2></div></div></div><p>Auxiliary database objects allow for the CREATE and DROP of arbitrary database objects. In conjunction with Hibernate's schema evolution tools, they have the ability to fully define a user schema within the Hibernate mapping files. Although designed specifically for creating and dropping things like triggers or stored procedures, any SQL command that can be run via a <code class="literal">java.sql.Statement.execute()</code> method is valid (for example, ALTERs, INSERTS, etc.). There are essentially two modes for defining auxiliary database objects: </p><p>The first mode is to explicitly list the CREATE and DROP commands in the mapping file: </p><pre class="programlisting">&lt;hibernate-mapping&gt;
                            ...
                            &lt;database-object&gt;
                                    &lt;create
&gt;CREATE TRIGGER my_trigger ...&lt;/create&gt;
                                    &lt;drop
&gt;DROP TRIGGER my_trigger&lt;/drop&gt;
                            &lt;/database-object&gt;
                    &lt;/hibernate-mapping
&gt;</pre><p>The second mode is to supply a custom class that constructs the CREATE and DROP commands. This custom class must implement the <code class="literal">org.hibernate.mapping.AuxiliaryDatabaseObject</code> interface. </p><pre class="programlisting">&lt;hibernate-mapping&gt;
                            ...
                            &lt;database-object&gt;
                                    &lt;definition class="MyTriggerDefinition"/&gt;
                            &lt;/database-object&gt;
                    &lt;/hibernate-mapping
&gt;</pre><p>Additionally, these database objects can be optionally scoped so that they only apply when certain dialects are used. </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    ...
    &lt;database-object&gt;
        &lt;definition class="MyTriggerDefinition"/&gt;
        &lt;dialect-scope name="org.hibernate.dialect.Oracle9iDialect"/&gt;
        &lt;dialect-scope name="org.hibernate.dialect.Oracle10gDialect"/&gt;
    &lt;/database-object&gt;
&lt;/hibernate-mapping&gt;</pre></div></div><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="collections"/>Capítulo 6. Collection mapping</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#collections-persistent">6.1. Colecciones persistentes</a></span></dt><dt><span class="sect1"><a href="#collections-mapping">6.2. Mapeos de colección</a></span></dt><dd><dl><dt><span class="sect2"><a href="#collections-foreignkeys">6.2.1. Claves foráneas de collección</a></span></dt><dt><span class="sect2"><a href="#collections-elements">6.2.2. Elementos de collección</a></span></dt><dt><span class="sect2"><a href="#collections-indexed">6.2.3. Colecciones indexadas</a></span></dt><dt><span class="sect2"><a href="#collections-ofvalues">6.2.4. Colecciones de valores y asociaciones muchos-a-muchos</a></span></dt><dt><span class="sect2"><a href="#collections-onetomany">6.2.5. Asociaciones uno-a-muchos</a></span></dt></dl></dd><dt><span class="sect1"><a href="#collections-advancedmappings">6.3. Mapeos de colección avanzados</a></span></dt><dd><dl><dt><span class="sect2"><a href="#collections-sorted">6.3.1. Colecciones ordenadas</a></span></dt><dt><span class="sect2"><a href="#collections-bidirectional">6.3.2. Asociaciones bidireccionales</a></span></dt><dt><span class="sect2"><a href="#collections-indexedbidirectional">6.3.3. Asociaciones bidireccionales con colecciones indexadas</a></span></dt><dt><span class="sect2"><a href="#collections-ternary">6.3.4. Asociaciones ternarias</a></span></dt><dt><span class="sect2"><a href="#collections-idbag">6.3.5. <code class="literal">Usando un &lt;idbag&gt;</code></a></span></dt></dl></dd><dt><span class="sect1"><a href="#collections-example">6.4. Ejemplos de colección</a></span></dt></dl></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="collections-persistent"/>6.1. Colecciones persistentes</h2></div></div></div><p>Hibernate requires that persistent collection-valued fields be declared as an interface type. For example: </p><pre class="programlisting">public class Product {
    private String serialNumber;
    private Set parts = new HashSet();
    
    public Set getParts() { return parts; }
    void setParts(Set parts) { this.parts = parts; }
    public String getSerialNumber() { return serialNumber; }
    void setSerialNumber(String sn) { serialNumber = sn; }
}</pre><p>The actual interface might be <code class="literal">java.util.Set</code>, <code class="literal">java.util.Collection</code>, <code class="literal">java.util.List</code>, <code class="literal">java.util.Map</code>, <code class="literal">java.util.SortedSet</code>, <code class="literal">java.util.SortedMap</code> or anything you like ("anything you like" means you will have to write an implementation of <code class="literal">org.hibernate.usertype.UserCollectionType</code>.) </p><p>Notice how the instance variable was initialized with an instance of <code class="literal">HashSet</code>. This is the best way to initialize collection valued properties of newly instantiated (non-persistent) instances. When you make the instance persistent, by calling <code class="literal">persist()</code> for example, Hibernate will actually replace the <code class="literal">HashSet</code> with an instance of Hibernate's own implementation of <code class="literal">Set</code>. Be aware of the following errors: </p><pre class="programlisting">Cat cat = new DomesticCat();
Cat kitten = new DomesticCat();
....
Set kittens = new HashSet();
kittens.add(kitten);
cat.setKittens(kittens);
session.persist(cat);
kittens = cat.getKittens(); // Okay, kittens collection is a Set
(HashSet) cat.getKittens(); // Error!</pre><p>The persistent collections injected by Hibernate behave like <code class="literal">HashMap</code>, <code class="literal">HashSet</code>, <code class="literal">TreeMap</code>, <code class="literal">TreeSet</code> or <code class="literal">ArrayList</code>, depending on the interface type. </p><p>Collections instances have the usual behavior of value types. They are automatically persisted when referenced by a persistent object and are automatically deleted when unreferenced. If a collection is passed from one persistent object to another, its elements might be moved from one table to another. Two entities cannot share a reference to the same collection instance. Due to the underlying relational model, collection-valued properties do not support null value semantics. Hibernate does not distinguish between a null collection reference and an empty collection. </p><p>Use persistent collections the same way you use ordinary Java collections. However, please ensure you understand the semantics of bidirectional associations (these are discussed later). </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="collections-mapping"/>6.2. Mapeos de colección</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Sugerencia</h2><p>There are quite a range of mappings that can be generated for collections that cover many common relational models. We suggest you experiment with the schema generation tool so that you understand how various mapping declarations translate to database tables. </p></div><p>The Hibernate mapping element used for mapping a collection depends upon the type of interface. For example, a <code class="literal">&lt;set&gt;</code> element is used for mapping properties of type <code class="literal">Set</code>. </p><pre class="programlisting">&lt;class name="Product"&gt;
    &lt;id name="serialNumber" column="productSerialNumber"/&gt;
    &lt;set name="parts"&gt;
        &lt;key column="productSerialNumber" not-null="true"/&gt;
        &lt;one-to-many class="Part"/&gt;
    &lt;/set&gt;
&lt;/class
&gt;</pre><p>Aparte de <code class="literal">&lt;set&gt;</code>, existen además los elementos de mapeo <code class="literal">&lt;list&gt;</code>, <code class="literal">&lt;map&gt;</code>, <code class="literal">&lt;bag&gt;</code>, <code class="literal">&lt;array&gt;</code> y <code class="literal">&lt;primitive-array&gt;</code>. El elemento <code class="literal">&lt;map&gt;</code> es representativo: </p><div class="programlistingco"><pre class="programlisting">&lt;map
    name="propertyName"                                         <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
    table="table_name"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
    schema="schema_name"                                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
    lazy="true|false"                                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
    inverse="true|false"                                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
    cascade="all|none|save-update|delete|all-delete-orphan"     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
    sort="unsorted|natural|comparatorClass"                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
    order-by="column_name asc|desc"                             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
    where="arbitrary sql where condition"                       <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/9.png" alt="(9)"/></span>
    fetch="join|select|subselect"                               <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/10.png" alt="(10)"/></span>
    batch-size="N"                                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/11.png" alt="(11)"/></span>
    access="field|property|ClassName"                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/12.png" alt="(12)"/></span>
    optimistic-lock="true|false"                                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/13.png" alt="(13)"/></span>
    node="element-name|."                                       <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/14.png" alt="(14)"/></span>
    embed-xml="true|false"
&gt;

    &lt;key .... /&gt;
    &lt;map-key .... /&gt;
    &lt;element .... /&gt;
&lt;/map
&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the collection property name </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">table</code> (optional - defaults to property name): the name of the collection table. It is not used for one-to-many associations. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">schema</code> (optional): the name of a table schema to override the schema declared on the root element </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional - defaults to <code class="literal">true</code>): disables lazy fetching and specifies that the association is always eagerly fetched. It can also be used to enable "extra-lazy" fetching where most operations do not initialize the collection. This is suitable for large collections. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">inverse</code> (optional - defaults to <code class="literal">false</code>): marks this collection as the "inverse" end of a bidirectional association. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">cascade</code> (optional - defaults to <code class="literal">none</code>): enables operations to cascade to child entities. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">sort</code> (optional): specifies a sorted collection with <code class="literal">natural</code> sort order or a given comparator class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">order-by</code> (optional, JDK1.4 only): specifies a table column or columns that define the iteration order of the <code class="literal">Map</code>, <code class="literal">Set</code> or bag, together with an optional <code class="literal">asc</code> or <code class="literal">desc</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/9.png" alt="9" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">where</code> (optional): specifies an arbitrary SQL <code class="literal">WHERE</code> condition that is used when retrieving or removing the collection. This is useful if the collection needs to contain only a subset of the available data. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/10.png" alt="10" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">fetch</code> (optional, defaults to <code class="literal">select</code>): chooses between outer-join fetching, fetching by sequential select, and fetching by sequential subselect. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/11.png" alt="11" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">batch-size</code> (optional, defaults to <code class="literal">1</code>): specifies a "batch size" for lazily fetching instances of this collection. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/12.png" alt="12" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the collection property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/13.png" alt="13" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">true</code>): specifies that changes to the state of the collection results in increments of the owning entity's version. For one-to-many associations you may want to disable this setting. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/14.png" alt="14" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">mutable</code> (optional - defaults to <code class="literal">true</code>): a value of <code class="literal">false</code> specifies that the elements of the collection never change. This allows for minor performance optimization in some cases. </p></td></tr></table></div></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="collections-foreignkeys"/>6.2.1. Claves foráneas de collección</h3></div></div></div><p>Collection instances are distinguished in the database by the foreign key of the entity that owns the collection. This foreign key is referred to as the <span class="emphasis"><em>collection key column</em></span>, or columns, of the collection table. The collection key column is mapped by the <code class="literal">&lt;key&gt;</code> element. </p><p>There can be a nullability constraint on the foreign key column. For most collections, this is implied. For unidirectional one-to-many associations, the foreign key column is nullable by default, so you may need to specify <code class="literal">not-null="true"</code>. </p><pre class="programlisting">&lt;key column="productSerialNumber" not-null="true"/&gt;</pre><p>The foreign key constraint can use <code class="literal">ON DELETE CASCADE</code>. </p><pre class="programlisting">&lt;key column="productSerialNumber" on-delete="cascade"/&gt;</pre><p>Mira el capítulo anterior por una definición completa del elemento <code class="literal">&lt;key&gt;</code>. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="collections-elements"/>6.2.2. Elementos de collección</h3></div></div></div><p>Collections can contain almost any other Hibernate type, including: basic types, custom types, components and references to other entities. This is an important distinction. An object in a collection might be handled with "value" semantics (its life cycle fully depends on the collection owner), or it might be a reference to another entity with its own life cycle. In the latter case, only the "link" between the two objects is considered to be a state held by the collection. </p><p>Se hace referencia al tipo contenido como el <span class="emphasis"><em>tipo de elemento de la colección</em></span>. Los elementos de colección son mapeados por <code class="literal">&lt;element&gt;</code> o <code class="literal">&lt;composite-element&gt;</code>, o en el caso de referencias de entidades, con <code class="literal">&lt;one-to-many&gt;</code> o <code class="literal">&lt;many-to-many&gt;</code>. Las dos primeras mapean elementos con semántica de valor, los dos siguientes son usados para mapear asociaciones de entidades. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="collections-indexed"/>6.2.3. Colecciones indexadas</h3></div></div></div><p>All collection mappings, except those with set and bag semantics, need an <span class="emphasis"><em>index column</em></span> in the collection table. An index column is a column that maps to an array index, or <code class="literal">List</code> index, or <code class="literal">Map</code> key. The index of a <code class="literal">Map</code> may be of any basic type, mapped with <code class="literal">&lt;map-key&gt;</code>. It can be an entity reference mapped with <code class="literal">&lt;map-key-many-to-many&gt;</code>, or it can be a composite type mapped with <code class="literal">&lt;composite-map-key&gt;</code>. The index of an array or list is always of type <code class="literal">integer</code> and is mapped using the <code class="literal">&lt;list-index&gt;</code> element. The mapped column contains sequential integers that are numbered from zero by default. </p><div class="programlistingco"><pre class="programlisting">&lt;list-index 
        column="column_name"                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        base="0|1|..."/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">column_name</code> (required): the name of the column holding the collection index values. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">base</code> (optional - defaults to <code class="literal">0</code>): the value of the index column that corresponds to the first element of the list or array. </p></td></tr></table></div></div><div class="programlistingco"><pre class="programlisting">&lt;map-key 
        column="column_name"                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        formula="any SQL expression"        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        type="type_name"                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        node="@attribute-name"
        length="N"/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">column</code> (optional): the name of the column holding the collection index values. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">formula</code> (optional): a SQL formula used to evaluate the key of the map. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">type</code> (required): the type of the map keys. </p></td></tr></table></div></div><div class="programlistingco"><pre class="programlisting">&lt;map-key-many-to-many
        column="column_name"                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        formula="any SQL expression"        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span><span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        class="ClassName"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">column</code> (optional): the name of the foreign key column for the collection index values. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">formula</code> (optional): a SQ formula used to evaluate the foreign key of the map key. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">class</code> (required): the entity class used as the map key. </p></td></tr></table></div></div><p>If your table does not have an index column, and you still wish to use <code class="literal">List</code> as the property type, you can map the property as a Hibernate <span class="emphasis"><em>&lt;bag&gt;</em></span>. A bag does not retain its order when it is retrieved from the database, but it can be optionally sorted or ordered. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="collections-ofvalues"/>6.2.4. Colecciones de valores y asociaciones muchos-a-muchos</h3></div></div></div><p>Any collection of values or many-to-many associations requires a dedicated <span class="emphasis"><em>collection table</em></span> with a foreign key column or columns, <span class="emphasis"><em>collection element column</em></span> or columns, and possibly an index column or columns. </p><p>For a collection of values use the <code class="literal">&lt;element&gt;</code> tag. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;element
        column="column_name"                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        formula="any SQL expression"             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        type="typename"                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        length="L"
        precision="P"
        scale="S"
        not-null="true|false"
        unique="true|false"
        node="element-name"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">column</code> (optional): the name of the column holding the collection element values. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">formula</code> (optional): an SQL formula used to evaluate the element. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">type</code> (required): the type of the collection element. </p></td></tr></table></div></div><p> A <span class="emphasis"><em>many-to-many association</em></span> is specified using the <code class="literal">&lt;many-to-many&gt;</code> element. </p><div class="programlistingco"><pre class="programlisting">&lt;many-to-many
        column="column_name"                               <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        formula="any SQL expression"                       <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        class="ClassName"                                  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        fetch="select|join"                                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        unique="true|false"                                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        not-found="ignore|exception"                       <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        entity-name="EntityName"                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        property-ref="propertyNameFromAssociatedClass"     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
        node="element-name"
        embed-xml="true|false"
    /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">column</code> (optional): the name of the element foreign key column. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">formula</code> (optional): an SQL formula used to evaluate the element foreign key value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">class</code> (required): the name of the associated class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">fetch</code> (optional - defaults to <code class="literal">join</code>): enables outer-join or sequential select fetching for this association. This is a special case; for full eager fetching in a single <code class="literal">SELECT</code> of an entity and its many-to-many relationships to other entities, you would enable <code class="literal">join</code> fetching,not only of the collection itself, but also with this attribute on the <code class="literal">&lt;many-to-many&gt;</code> nested element. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">unique</code> (optional): enables the DDL generation of a unique constraint for the foreign-key column. This makes the association multiplicity effectively one-to-many. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">not-found</code> (optional - defaults to <code class="literal">exception</code>): specifies how foreign keys that reference missing rows will be handled: <code class="literal">ignore</code> will treat a missing row as a null association. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">entity-name</code> (optional): the entity name of the associated class, as an alternative to <code class="literal">class</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">property-ref</code> (optional): the name of a property of the associated class that is joined to this foreign key. If not specified, the primary key of the associated class is used. </p></td></tr></table></div></div><p>Here are some examples. </p><p>A set of strings: </p><pre class="programlisting">&lt;set name="names" table="person_names"&gt;
    &lt;key column="person_id"/&gt;
    &lt;element column="person_name" type="string"/&gt;
&lt;/set
&gt;</pre><p>A bag containing integers with an iteration order determined by the <code class="literal">order-by</code> attribute: </p><pre class="programlisting">&lt;bag name="sizes" 
        table="item_sizes" 
        order-by="size asc"&gt;
    &lt;key column="item_id"/&gt;
    &lt;element column="size" type="integer"/&gt;
&lt;/bag
&gt;</pre><p>An array of entities, in this case, a many-to-many association: </p><pre class="programlisting">&lt;array name="addresses" 
        table="PersonAddress" 
        cascade="persist"&gt;
    &lt;key column="personId"/&gt;
    &lt;list-index column="sortOrder"/&gt;
    &lt;many-to-many column="addressId" class="Address"/&gt;
&lt;/array
&gt;</pre><p>Un mapa de índices de cadenas a fechas: </p><pre class="programlisting">&lt;map name="holidays" 
        table="holidays" 
        schema="dbo" 
        order-by="hol_name asc"&gt;
    &lt;key column="id"/&gt;
    &lt;map-key column="hol_name" type="string"/&gt;
    &lt;element column="hol_date" type="date"/&gt;
&lt;/map
&gt;</pre><p>A list of components (this is discussed in the next chapter): </p><pre class="programlisting">&lt;list name="carComponents" 
        table="CarComponents"&gt;
    &lt;key column="carId"/&gt;
    &lt;list-index column="sortOrder"/&gt;
    &lt;composite-element class="CarComponent"&gt;
        &lt;property name="price"/&gt;
        &lt;property name="type"/&gt;
        &lt;property name="serialNumber" column="serialNum"/&gt;
    &lt;/composite-element&gt;
&lt;/list
&gt;</pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="collections-onetomany"/>6.2.5. Asociaciones uno-a-muchos</h3></div></div></div><p>A <span class="emphasis"><em>one-to-many association</em></span> links the tables of two classes via a foreign key with no intervening collection table. This mapping loses certain semantics of normal Java collections: </p><div class="itemizedlist"><ul compact="compact"><li><p>An instance of the contained entity class cannot belong to more than one instance of the collection. </p></li><li><p>An instance of the contained entity class cannot appear at more than one value of the collection index. </p></li></ul></div><p>An association from <code class="literal">Product</code> to <code class="literal">Part</code> requires the existence of a foreign key column and possibly an index column to the <code class="literal">Part</code> table. A <code class="literal">&lt;one-to-many&gt;</code> tag indicates that this is a one-to-many association. </p><div class="programlistingco"><pre class="programlisting">&lt;one-to-many 
        class="ClassName"                                  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        not-found="ignore|exception"                       <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        entity-name="EntityName"                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        node="element-name"
        embed-xml="true|false"
    /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">class</code> (required): the name of the associated class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">not-found</code> (optional - defaults to <code class="literal">exception</code>): specifies how cached identifiers that reference missing rows will be handled. <code class="literal">ignore</code> will treat a missing row as a null association. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">entity-name</code> (optional): the entity name of the associated class, as an alternative to <code class="literal">class</code>. </p></td></tr></table></div></div><p>The <code class="literal">&lt;one-to-many&gt;</code> element does not need to declare any columns. Nor is it necessary to specify the <code class="literal">table</code> name anywhere. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Aviso</h2><p>If the foreign key column of a <code class="literal">&lt;one-to-many&gt;</code> association is declared <code class="literal">NOT NULL</code>, you must declare the <code class="literal">&lt;key&gt;</code> mapping <code class="literal">not-null="true"</code> or <span class="emphasis"><em>use a bidirectional association</em></span> with the collection mapping marked <code class="literal">inverse="true"</code>. See the discussion of bidirectional associations later in this chapter for more information. </p></div><p>The following example shows a map of <code class="literal">Part</code> entities by name, where <code class="literal">partName</code> is a persistent property of <code class="literal">Part</code>. Notice the use of a formula-based index: </p><pre class="programlisting">&lt;map name="parts"
        cascade="all"&gt;
    &lt;key column="productId" not-null="true"/&gt;
    &lt;map-key formula="partName"/&gt;
    &lt;one-to-many class="Part"/&gt;
&lt;/map
&gt;</pre></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="collections-advancedmappings"/>6.3. Mapeos de colección avanzados</h2></div></div></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="collections-sorted"/>6.3.1. Colecciones ordenadas</h3></div></div></div><p>Hibernate soporta colecciones implementando <code class="literal">java.util.SortedMap</code> y <code class="literal">java.util.SortedSet</code>. Debes especificar un comparador en el fichero de mapeo: </p><pre class="programlisting">&lt;set name="aliases" 
            table="person_aliases" 
            sort="natural"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="string"/&gt;
&lt;/set&gt;

&lt;map name="holidays" sort="my.custom.HolidayComparator"&gt;
    &lt;key column="year_id"/&gt;
    &lt;map-key column="hol_name" type="string"/&gt;
    &lt;element column="hol_date" type="date"/&gt;
&lt;/map
&gt;</pre><p>Los valores permitidos del atributo <code class="literal">sort</code> son <code class="literal">unsorted</code>, <code class="literal">natural</code> y el nombre de una clase que implemente <code class="literal">java.util.Comparator</code>. </p><p>Las colecciones ordenadas realmente se comportan como <code class="literal">java.util.TreeSet</code> o <code class="literal">java.util.TreeMap</code>. </p><p>If you want the database itself to order the collection elements, use the <code class="literal">order-by</code> attribute of <code class="literal">set</code>, <code class="literal">bag</code> or <code class="literal">map</code> mappings. This solution is only available under JDK 1.4 or higher and is implemented using <code class="literal">LinkedHashSet</code> or <code class="literal">LinkedHashMap</code>. This performs the ordering in the SQL query and not in the memory. </p><pre class="programlisting">&lt;set name="aliases" table="person_aliases" order-by="lower(name) asc"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="string"/&gt;
&lt;/set&gt;

&lt;map name="holidays" order-by="hol_date, hol_name"&gt;
    &lt;key column="year_id"/&gt;
    &lt;map-key column="hol_name" type="string"/&gt;
    &lt;element column="hol_date type="date"/&gt;
&lt;/map
&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The value of the <code class="literal">order-by</code> attribute is an SQL ordering, not an HQL ordering. </p></div><p>Associations can even be sorted by arbitrary criteria at runtime using a collection <code class="literal">filter()</code>: </p><pre class="programlisting">sortedUsers = s.createFilter( group.getUsers(), "order by this.name" ).list();</pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="collections-bidirectional"/>6.3.2. Asociaciones bidireccionales</h3></div></div></div><p>Una <span class="emphasis"><em>asociación bidireccional</em></span> permite la nevegación desde ambos "extremos" de la asociación. Son soportados dos tipos de asociación bidireccional: </p><div class="variablelist"><dl><dt><span class="term">uno-a-muchos</span></dt><dd><p>set or bag valued at one end and single-valued at the other </p></dd><dt><span class="term">muchos-a-muchos</span></dt><dd><p>set o bag valorados a ambos extremos </p></dd></dl></div><p>

        </p><p>You can specify a bidirectional many-to-many association by mapping two many-to-many associations to the same database table and declaring one end as <span class="emphasis"><em>inverse</em></span>. You cannot select an indexed collection. </p><p>Here is an example of a bidirectional many-to-many association that illustrates how each category can have many items and each item can be in many categories: </p><pre class="programlisting">&lt;class name="Category"&gt;
    &lt;id name="id" column="CATEGORY_ID"/&gt;
    ...
    &lt;bag name="items" table="CATEGORY_ITEM"&gt;
        &lt;key column="CATEGORY_ID"/&gt;
        &lt;many-to-many class="Item" column="ITEM_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;

&lt;class name="Item"&gt;
    &lt;id name="id" column="ITEM_ID"/&gt;
    ...

    &lt;!-- inverse end --&gt;
    &lt;bag name="categories" table="CATEGORY_ITEM" inverse="true"&gt;
        &lt;key column="ITEM_ID"/&gt;
        &lt;many-to-many class="Category" column="CATEGORY_ID"/&gt;
    &lt;/bag&gt;
&lt;/class
&gt;</pre><p>Changes made only to the inverse end of the association are <span class="emphasis"><em>not</em></span> persisted. This means that Hibernate has two representations in memory for every bidirectional association: one link from A to B and another link from B to A. This is easier to understand if you think about the Java object model and how a many-to-many relationship in Javais created: </p><pre class="programlisting">
category.getItems().add(item);          // The category now "knows" about the relationship
item.getCategories().add(category);     // The item now "knows" about the relationship

session.persist(item);                   // The relationship won't be saved!
session.persist(category);               // The relationship will be saved</pre><p>El lado no-inverso se usa para salvar la representación en memoria a la base de datos. </p><p>You can define a bidirectional one-to-many association by mapping a one-to-many association to the same table column(s) as a many-to-one association and declaring the many-valued end <code class="literal">inverse="true"</code>. </p><pre class="programlisting">&lt;class name="Parent"&gt;
    &lt;id name="id" column="parent_id"/&gt;
    ....
    &lt;set name="children" inverse="true"&gt;
        &lt;key column="parent_id"/&gt;
        &lt;one-to-many class="Child"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="eg.Child"&gt;
    &lt;id name="id" column="id"/&gt;
    ....
    &lt;many-to-one name="parent" 
        class="Parent" 
        column="parent_id"
        not-null="true"/&gt;
&lt;/class
&gt;</pre><p>Mapping one end of an association with <code class="literal">inverse="true"</code> does not affect the operation of cascades as these are orthogonal concepts. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="collections-indexedbidirectional"/>6.3.3. Asociaciones bidireccionales con colecciones indexadas</h3></div></div></div><p>A bidirectional association where one end is represented as a <code class="literal">&lt;list&gt;</code> or <code class="literal">&lt;map&gt;</code>, requires special consideration. If there is a property of the child class that maps to the index column you can use <code class="literal">inverse="true"</code> on the collection mapping: </p><pre class="programlisting">&lt;class name="Parent"&gt;
    &lt;id name="id" column="parent_id"/&gt;
    ....
    &lt;map name="children" inverse="true"&gt;
        &lt;key column="parent_id"/&gt;
        &lt;map-key column="name" 
            type="string"/&gt;
        &lt;one-to-many class="Child"/&gt;
    &lt;/map&gt;
&lt;/class&gt;

&lt;class name="Child"&gt;
    &lt;id name="id" column="child_id"/&gt;
    ....
    &lt;property name="name" 
        not-null="true"/&gt;
    &lt;many-to-one name="parent" 
        class="Parent" 
        column="parent_id"
        not-null="true"/&gt;
&lt;/class
&gt;</pre><p>If there is no such property on the child class, the association cannot be considered truly bidirectional. That is, there is information available at one end of the association that is not available at the other end. In this case, you cannot map the collection <code class="literal">inverse="true"</code>. Instead, you could use the following mapping: </p><pre class="programlisting">&lt;class name="Parent"&gt;
    &lt;id name="id" column="parent_id"/&gt;
    ....
    &lt;map name="children"&gt;
        &lt;key column="parent_id"
            not-null="true"/&gt;
        &lt;map-key column="name" 
            type="string"/&gt;
        &lt;one-to-many class="Child"/&gt;
    &lt;/map&gt;
&lt;/class&gt;

&lt;class name="Child"&gt;
    &lt;id name="id" column="child_id"/&gt;
    ....
    &lt;many-to-one name="parent" 
        class="Parent" 
        column="parent_id"
        insert="false"
        update="false"
        not-null="true"/&gt;
&lt;/class
&gt;</pre><p>Note that in this mapping, the collection-valued end of the association is responsible for updates to the foreign key. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="collections-ternary"/>6.3.4. Asociaciones ternarias</h3></div></div></div><p>There are three possible approaches to mapping a ternary association. One approach is to use a <code class="literal">Map</code> with an association as its index: </p><pre class="programlisting">&lt;map name="contracts"&gt;
    &lt;key column="employer_id" not-null="true"/&gt;
    &lt;map-key-many-to-many column="employee_id" class="Employee"/&gt;
    &lt;one-to-many class="Contract"/&gt;
&lt;/map
&gt;</pre><pre class="programlisting">&lt;map name="connections"&gt;
    &lt;key column="incoming_node_id"/&gt;
    &lt;map-key-many-to-many column="outgoing_node_id" class="Node"/&gt;
    &lt;many-to-many column="connection_id" class="Connection"/&gt;
&lt;/map
&gt;</pre><p>A second approach is to remodel the association as an entity class. This is the most common approach. </p><p>A final alternative is to use composite elements, which will be discussed later. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="collections-idbag"/>6.3.5. <code class="literal">Usando un &lt;idbag&gt;</code></h3></div></div></div><p>The majority of the many-to-many associations and collections of values shown previously all map to tables with composite keys, even though it has been have suggested that entities should have synthetic identifiers (surrogate keys). A pure association table does not seem to benefit much from a surrogate key, although a collection of composite values <span class="emphasis"><em>might</em></span>. It is for this reason that Hibernate provides a feature that allows you to map many-to-many associations and collections of values to a table with a surrogate key. </p><p>The <code class="literal">&lt;idbag&gt;</code> element lets you map a <code class="literal">List</code> (or <code class="literal">Collection</code>) with bag semantics. For example: </p><pre class="programlisting">&lt;idbag name="lovers" table="LOVERS"&gt;
    &lt;collection-id column="ID" type="long"&gt;
        &lt;generator class="sequence"/&gt;
    &lt;/collection-id&gt;
    &lt;key column="PERSON1"/&gt;
    &lt;many-to-many column="PERSON2" class="Person" fetch="join"/&gt;
&lt;/idbag
&gt;</pre><p>An <code class="literal">&lt;idbag&gt;</code> has a synthetic id generator, just like an entity class. A different surrogate key is assigned to each collection row. Hibernate does not, however, provide any mechanism for discovering the surrogate key value of a particular row. </p><p>The update performance of an <code class="literal">&lt;idbag&gt;</code> supersedes a regular <code class="literal">&lt;bag&gt;</code>. Hibernate can locate individual rows efficiently and update or delete them individually, similar to a list, map or set. </p><p>En la implementación actual, la estrategia de generación de identificador <code class="literal">native</code> no está soportada para identificadores de colecciones <code class="literal">&lt;idbag&gt;</code>. </p></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="collections-example"/>6.4. Ejemplos de colección</h2></div></div></div><p>This section covers collection examples. </p><p>The following class has a collection of <code class="literal">Child</code> instances: </p><pre class="programlisting">package eg;
import java.util.Set;

public class Parent {
    private long id;
    private Set children;

    public long getId() { return id; }
    private void setId(long id) { this.id=id; }

    private Set getChildren() { return children; }
    private void setChildren(Set children) { this.children=children; }

    ....
    ....
}</pre><p>If each child has, at most, one parent, the most natural mapping is a one-to-many association: </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping
&gt;</pre><p>Esto mapea a las siguientes definiciones de tablas: </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null primary key, name varchar(255), parent_id bigint )
alter table child add constraint childfk0 (parent_id) references parent</pre><p>Si el padre es <span class="emphasis"><em>requerido</em></span>, usa una asociación bidireccional uno-a-muchos: </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" inverse="true"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
        &lt;many-to-one name="parent" class="Parent" column="parent_id" not-null="true"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping
&gt;</pre><p>Observa la restricción <code class="literal">NOT NULL</code>: </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null
                     primary key,
                     name varchar(255),
                     parent_id bigint not null )
alter table child add constraint childfk0 (parent_id) references parent</pre><p>Alternatively, if this association must be unidirectional you can declare the <code class="literal">NOT NULL</code> constraint on the <code class="literal">&lt;key&gt;</code> mapping: </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children"&gt;
            &lt;key column="parent_id" not-null="true"/&gt;
            &lt;one-to-many class="Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping
&gt;</pre><p>On the other hand, if a child has multiple parents, a many-to-many association is appropriate: </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" table="childset"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;many-to-many class="Child" column="child_id"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping
&gt;</pre><p>Definiciones de tabla: </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null primary key, name varchar(255) )
create table childset ( parent_id bigint not null,
                        child_id bigint not null,
                        primary key ( parent_id, child_id ) )
alter table childset add constraint childsetfk0 (parent_id) references parent
alter table childset add constraint childsetfk1 (child_id) references child</pre><p>For more examples and a complete explanation of a parent/child relationship mapping, see <a href="#example-parentchild" title="Capítulo 21. Ejemplo: Padre/Hijo">Capítulo 21, <i xmlns:xlink="http://www.w3.org/1999/xlink">Ejemplo: Padre/Hijo</i></a> for more information. </p><p>Even more complex association mappings are covered in the next chapter. </p></div></div><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="associations"/>Capítulo 7. Mapeos de Asociación</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#assoc-intro">7.1. Introducción</a></span></dt><dt><span class="sect1"><a href="#assoc-unidirectional">7.2. Asociaciones Unidireccionales</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-unidirectional-m21">7.2.1. Many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-121">7.2.2. One-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-12m">7.2.3. One-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-unidirectional-join">7.3. Asociaciones unidireccionales con tablas de unión</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-unidirectional-join-12m">7.3.1. One-to-many</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-m21">7.3.2. Many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-121">7.3.3. One-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-m2m">7.3.4. Many-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-bidirectional">7.4. Asociaciones Bidireccionales</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-bidirectional-m21">7.4.1. one-to-many / many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-121">7.4.2. One-to-one</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-bidirectional-join">7.5. Asociaciones bidireccionales con tablas de unión</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-bidirectional-join-12m">7.5.1. one-to-many / many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-join-121">7.5.2. uno a uno</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-join-m2m">7.5.3. Many-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-complex">7.6. UNTRANSLATED! More complex association mappings</a></span></dt></dl></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="assoc-intro"/>7.1. Introducción</h2></div></div></div><p>Association mappings are often the most difficult thing to implement correctly. In this section we examine some canonical cases one by one, starting with unidirectional mappings and then bidirectional cases. We will use <code class="literal">Person</code> and <code class="literal">Address</code> in all the examples. </p><p>Associations will be classified by multiplicity and whether or not they map to an intervening join table. </p><p>Nullable foreign keys are not considered to be good practice in traditional data modelling, so our examples do not use nullable foreign keys. This is not a requirement of Hibernate, and the mappings will work if you drop the nullability constraints. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="assoc-unidirectional"/>7.2. Asociaciones Unidireccionales</h2></div></div></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-m21"/>7.2.1. Many-to-one</h3></div></div></div><p>Una <span class="emphasis"><em>asociación unidireccional muchos-a-uno</em></span> es el tipo más común de asociaciones unidireccionales. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class
&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-121"/>7.2.2. One-to-one</h3></div></div></div><p>Una <span class="emphasis"><em>asociación unidireccional uno-a-uno en una clave primaria</em></span> es casi idéntica. La única diferencia es la restricción de unicidad de la columna. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId" 
        unique="true"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class
&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre><p>A <span class="emphasis"><em>unidirectional one-to-one association on a primary key</em></span> usually uses a special id generator In this example, however, we have reversed the direction of the association: </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"
&gt;person&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    &lt;one-to-one name="person" constrained="true"/&gt;
&lt;/class
&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table Address ( personId bigint not null primary key )
        </pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-12m"/>7.2.3. One-to-many</h3></div></div></div><p>A <span class="emphasis"><em>unidirectional one-to-many association on a foreign key</em></span> is an unusual case, and is not recommended. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses"&gt;
        &lt;key column="personId" 
            not-null="true"/&gt;
        &lt;one-to-many class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class
&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table Address ( addressId bigint not null primary key, personId bigint not null )
        </pre><p>You should instead use a join table for this kind of association. </p></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="assoc-unidirectional-join"/>7.3. Asociaciones unidireccionales con tablas de unión</h2></div></div></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-join-12m"/>7.3.1. One-to-many</h3></div></div></div><p>A <span class="emphasis"><em>unidirectional one-to-many association on a join table</em></span> is the preferred option. Specifying <code class="literal">unique="true"</code>, changes the multiplicity from many-to-many to one-to-many. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses" table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            unique="true"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class
&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId not null, addressId bigint not null primary key )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-join-m21"/>7.3.2. Many-to-one</h3></div></div></div><p>A <span class="emphasis"><em>unidirectional many-to-one association on a join table</em></span> is common when the association is optional. For example: </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"&gt;
        &lt;key column="personId" unique="true"/&gt;
        &lt;many-to-one name="address"
            column="addressId" 
            not-null="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class
&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null primary key, addressId bigint not null )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-join-121"/>7.3.3. One-to-one</h3></div></div></div><p>A <span class="emphasis"><em>unidirectional one-to-one association on a join table</em></span> is possible, but extremely unusual. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"&gt;
        &lt;key column="personId" 
            unique="true"/&gt;
        &lt;many-to-one name="address"
            column="addressId" 
            not-null="true"
            unique="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class
&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-join-m2m"/>7.3.4. Many-to-many</h3></div></div></div><p>Finally, here is an example of a <span class="emphasis"><em>unidirectional many-to-many association</em></span>. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses" table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class
&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null, addressId bigint not null, primary key (personId, addressId) )
create table Address ( addressId bigint not null primary key )
        </pre></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="assoc-bidirectional"/>7.4. Asociaciones Bidireccionales</h2></div></div></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-bidirectional-m21"/>7.4.1. one-to-many / many-to-one</h3></div></div></div><p>A <span class="emphasis"><em>bidirectional many-to-one association</em></span> is the most common kind of association. The following example illustrates the standard parent/child relationship. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="people" inverse="true"&gt;
        &lt;key column="addressId"/&gt;
        &lt;one-to-many class="Person"/&gt;
    &lt;/set&gt;
&lt;/class
&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null )
create table Address ( addressId bigint not null primary key )
        </pre><p>If you use a <code class="literal">List</code>, or other indexed collection, set the <code class="literal">key</code> column of the foreign key to <code class="literal">not null</code>. Hibernate will manage the association from the collections side to maintain the index of each element, making the other side virtually inverse by setting <code class="literal">update="false"</code> and <code class="literal">insert="false"</code>: </p><pre class="programlisting">&lt;class name="Person"&gt;
                        &lt;id name="id"/&gt;
                        ...
                        &lt;many-to-one name="address"
                                     column="addressId"
                                     not-null="true"
                                     insert="false"
                                     update="false"/&gt;
                &lt;/class&gt;
                
                &lt;class name="Address"&gt;
                        &lt;id name="id"/&gt;
                        ...
                        &lt;list name="people"&gt;
                                &lt;key column="addressId" not-null="true"/&gt;
                                &lt;list-index column="peopleIdx"/&gt;
                                &lt;one-to-many class="Person"/&gt;
                        &lt;/list&gt;
                &lt;/class
&gt;</pre><p>If the underlying foreign key column is <code class="literal">NOT NULL</code>, it is important that you define <code class="literal">not-null="true"</code> on the <code class="literal">&lt;key&gt;</code> element of the collection mapping. Do not only declare <code class="literal">not-null="true"</code> on a possible nested <code class="literal">&lt;column&gt;</code> element, but on the <code class="literal">&lt;key&gt;</code> element. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-bidirectional-121"/>7.4.2. One-to-one</h3></div></div></div><p>A <span class="emphasis"><em>bidirectional one-to-one association on a foreign key</em></span> is common: </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId" 
        unique="true"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
   &lt;one-to-one name="person" 
        property-ref="address"/&gt;
&lt;/class
&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre><p>A <span class="emphasis"><em>bidirectional one-to-one association on a primary key</em></span> uses the special id generator: </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;one-to-one name="address"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"
&gt;person&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    &lt;one-to-one name="person" 
        constrained="true"/&gt;
&lt;/class
&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table Address ( personId bigint not null primary key )
        </pre></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="assoc-bidirectional-join"/>7.5. Asociaciones bidireccionales con tablas de unión</h2></div></div></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-bidirectional-join-12m"/>7.5.1. one-to-many / many-to-one</h3></div></div></div><p>The following is an example of a <span class="emphasis"><em>bidirectional one-to-many association on a join table</em></span>. The <code class="literal">inverse="true"</code> can go on either end of the association, on the collection, or on the join. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses" 
        table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            unique="true"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        inverse="true" 
        optional="true"&gt;
        &lt;key column="addressId"/&gt;
        &lt;many-to-one name="person"
            column="personId"
            not-null="true"/&gt;
    &lt;/join&gt;
&lt;/class
&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null, addressId bigint not null primary key )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-bidirectional-join-121"/>7.5.2. uno a uno</h3></div></div></div><p>A <span class="emphasis"><em>bidirectional one-to-one association on a join table</em></span> is possible, but extremely unusual. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"&gt;
        &lt;key column="personId" 
            unique="true"/&gt;
        &lt;many-to-one name="address"
            column="addressId" 
            not-null="true"
            unique="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"
        inverse="true"&gt;
        &lt;key column="addressId" 
            unique="true"/&gt;
        &lt;many-to-one name="address"
            column="personId" 
            not-null="true"
            unique="true"/&gt;
    &lt;/join&gt;
&lt;/class
&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-bidirectional-join-m2m"/>7.5.3. Many-to-many</h3></div></div></div><p>Here is an example of a <span class="emphasis"><em>bidirectional many-to-many association</em></span>. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="people" inverse="true"&gt;
        &lt;key column="addressId"/&gt;
        &lt;many-to-many column="personId"
            class="Person"/&gt;
    &lt;/set&gt;
&lt;/class
&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null, addressId bigint not null, primary key (personId, addressId) )
create table Address ( addressId bigint not null primary key )
        </pre></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="assoc-complex"/>7.6. UNTRANSLATED! More complex association mappings</h2></div></div></div><p>More complex association joins are <span class="emphasis"><em>extremely</em></span> rare. Hibernate handles more complex situations by using SQL fragments embedded in the mapping document. For example, if a table with historical account information data defines <code class="literal">accountNumber</code>, <code class="literal">effectiveEndDate</code> and <code class="literal">effectiveStartDate</code>columns, it would be mapped as follows: </p><pre class="programlisting">&lt;properties name="currentAccountKey"&gt;
                            &lt;property name="accountNumber" type="string" not-null="true"/&gt;
                            &lt;property name="currentAccount" type="boolean"&gt;
                                    &lt;formula
&gt;case when effectiveEndDate is null then 1 else 0 end&lt;/formula&gt;
                            &lt;/property&gt;
                    &lt;/properties&gt;
                    &lt;property name="effectiveEndDate" type="date"/&gt;
                    &lt;property name="effectiveStateDate" type="date" not-null="true"/&gt;</pre><p>You can then map an association to the <span class="emphasis"><em>current</em></span> instance, the one with null <code class="literal">effectiveEndDate</code>, by using: </p><pre class="programlisting">&lt;many-to-one name="currentAccountInfo" 
                                                  property-ref="currentAccountKey"
                                                  class="AccountInfo"&gt;
                            &lt;column name="accountNumber"/&gt;
                            &lt;formula
&gt;'1'&lt;/formula&gt;
                    &lt;/many-to-one
&gt;</pre><p>In a more complex example, imagine that the association between <code class="literal">Employee</code> and <code class="literal">Organization</code> is maintained in an <code class="literal">Employment</code> table full of historical employment data. An association to the employee's <span class="emphasis"><em>most recent</em></span> employer, the one with the most recent <code class="literal">startDate</code>, could be mapped in the following way: </p><pre class="programlisting">&lt;join&gt;
                            &lt;key column="employeeId"/&gt;
                            &lt;subselect&gt;
                                    select employeeId, orgId 
                                    from Employments 
                                    group by orgId 
                                    having startDate = max(startDate)
                            &lt;/subselect&gt;
                            &lt;many-to-one name="mostRecentEmployer" 
                                         class="Organization" 
                                         column="orgId"/&gt;
                    &lt;/join
&gt;</pre><p>This functionality allows a degree of creativity and flexibility, but it is more practical to handle these kinds of cases using HQL or a criteria query. </p></div></div><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="components"/>Capítulo 8. Mapeo de Componentes</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#components-dependentobjects">8.1. Objetos dependientes</a></span></dt><dt><span class="sect1"><a href="#components-incollections">8.2. Colecciones de objetos dependientes</a></span></dt><dt><span class="sect1"><a href="#components-asmapindex">8.3. Componentes como índices de Map</a></span></dt><dt><span class="sect1"><a href="#components-compositeid">8.4. Componentes como identificadores compuestos</a></span></dt><dt><span class="sect1"><a href="#components-dynamic">8.5. Componentes dinámicos</a></span></dt></dl></div><p>The notion of a <span class="emphasis"><em>component</em></span> is re-used in several different contexts and purposes throughout Hibernate. </p><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="components-dependentobjects"/>8.1. Objetos dependientes</h2></div></div></div><p>A component is a contained object that is persisted as a value type and not an entity reference. The term "component" refers to the object-oriented notion of composition and not to architecture-level components. For example, you can model a person like this: </p><pre class="programlisting">public class Person {
    private java.util.Date birthday;
    private Name name;
    private String key;
    public String getKey() {
        return key;
    }
    private void setKey(String key) {
        this.key=key;
    }
    public java.util.Date getBirthday() {
        return birthday;
    }
    public void setBirthday(java.util.Date birthday) {
        this.birthday = birthday;
    }
    public Name getName() {
        return name;
    }
    public void setName(Name name) {
        this.name = name;
    }
    ......
    ......
}</pre><pre class="programlisting">public class Name {
    char initial;
    String first;
    String last;
    public String getFirst() {
        return first;
    }
    void setFirst(String first) {
        this.first = first;
    }
    public String getLast() {
        return last;
    }
    void setLast(String last) {
        this.last = last;
    }
    public char getInitial() {
        return initial;
    }
    void setInitial(char initial) {
        this.initial = initial;
    }
}</pre><p>Now <code class="literal">Name</code> can be persisted as a component of <code class="literal">Person</code>. <code class="literal">Name</code> defines getter and setter methods for its persistent properties, but it does not need to declare any interfaces or identifier properties. </p><p>Our Hibernate mapping would look like this: </p><pre class="programlisting">&lt;class name="eg.Person" table="person"&gt;
    &lt;id name="Key" column="pid" type="string"&gt;
        &lt;generator class="uuid.hex"/&gt;
    &lt;/id&gt;
    &lt;property name="birthday" type="date"/&gt;
    &lt;component name="Name" class="eg.Name"
&gt; &lt;!-- class attribute optional --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/component&gt;
&lt;/class
&gt;</pre><p>La tabla person tendría las columnas <code class="literal">pid</code>, <code class="literal">birthday</code>, <code class="literal">initial</code>, <code class="literal">first</code> y <code class="literal">last</code>. </p><p>Like value types, components do not support shared references. In other words, two persons could have the same name, but the two person objects would contain two independent name objects that were only "the same" by value. The null value semantics of a component are <span class="emphasis"><em>ad hoc</em></span>. When reloading the containing object, Hibernate will assume that if all component columns are null, then the entire component is null. This is suitable for most purposes. </p><p>The properties of a component can be of any Hibernate type (collections, many-to-one associations, other components, etc). Nested components should <span class="emphasis"><em>not</em></span> be considered an exotic usage. Hibernate is intended to support a fine-grained object model. </p><p>El elemento <code class="literal">&lt;component&gt;</code> permite un subelemento <code class="literal">&lt;parent&gt;</code> que mapee una propiedad de la clase del componente como una referencia de regreso a la entidad contenedora. </p><pre class="programlisting">&lt;class name="eg.Person" table="person"&gt;
    &lt;id name="Key" column="pid" type="string"&gt;
        &lt;generator class="uuid.hex"/&gt;
    &lt;/id&gt;
    &lt;property name="birthday" type="date"/&gt;
    &lt;component name="Name" class="eg.Name" unique="true"&gt;
        &lt;parent name="namedPerson"/&gt; &lt;!-- reference back to the Person --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/component&gt;
&lt;/class
&gt;</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="components-incollections"/>8.2. Colecciones de objetos dependientes</h2></div></div></div><p>Collections of components are supported (e.g. an array of type <code class="literal">Name</code>). Declare your component collection by replacing the <code class="literal">&lt;element&gt;</code> tag with a <code class="literal">&lt;composite-element&gt;</code> tag: </p><pre class="programlisting">&lt;set name="someNames" table="some_names" lazy="true"&gt;
    &lt;key column="id"/&gt;
    &lt;composite-element class="eg.Name"
&gt; &lt;!-- class attribute required --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/composite-element&gt;
&lt;/set
&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Importante</h2><p>If you define a <code class="literal">Set</code> of composite elements, it is important to implement <code class="literal">equals()</code> and <code class="literal">hashCode()</code> correctly. </p></div><p>Composite elements can contain components but not collections. If your composite element contains components, use the <code class="literal">&lt;nested-composite-element&gt;</code> tag. This case is a collection of components which themselves have components. You may want to consider if a one-to-many association is more appropriate. Remodel the composite element as an entity, but be aware that even though the Java model is the same, the relational model and persistence semantics are still slightly different. </p><p>A composite element mapping does not support null-able properties if you are using a <code class="literal">&lt;set&gt;</code>. There is no separate primary key column in the composite element table. Hibernate uses each column's value to identify a record when deleting objects, which is not possible with null values. You have to either use only not-null properties in a composite-element or choose a <code class="literal">&lt;list&gt;</code>, <code class="literal">&lt;map&gt;</code>, <code class="literal">&lt;bag&gt;</code> or <code class="literal">&lt;idbag&gt;</code>. </p><p>A special case of a composite element is a composite element with a nested <code class="literal">&lt;many-to-one&gt;</code> element. This mapping allows you to map extra columns of a many-to-many association table to the composite element class. The following is a many-to-many association from <code class="literal">Order</code> to <code class="literal">Item</code>, where <code class="literal">purchaseDate</code>, <code class="literal">price</code> and <code class="literal">quantity</code> are properties of the association: </p><pre class="programlisting">&lt;class name="eg.Order" .... &gt;
    ....
    &lt;set name="purchasedItems" table="purchase_items" lazy="true"&gt;
        &lt;key column="order_id"&gt;
        &lt;composite-element class="eg.Purchase"&gt;
            &lt;property name="purchaseDate"/&gt;
            &lt;property name="price"/&gt;
            &lt;property name="quantity"/&gt;
            &lt;many-to-one name="item" class="eg.Item"/&gt; &lt;!-- class attribute is optional --&gt;
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class
&gt;</pre><p>There cannot be a reference to the purchase on the other side for bidirectional association navigation. Components are value types and do not allow shared references. A single <code class="literal">Purchase</code> can be in the set of an <code class="literal">Order</code>, but it cannot be referenced by the <code class="literal">Item</code> at the same time. </p><p>Incluso son posibles las asociaciones ternarias (o cuaternarias, etc):</p><pre class="programlisting">&lt;class name="eg.Order" .... &gt;
    ....
    &lt;set name="purchasedItems" table="purchase_items" lazy="true"&gt;
        &lt;key column="order_id"&gt;
        &lt;composite-element class="eg.OrderLine"&gt;
            &lt;many-to-one name="purchaseDetails class="eg.Purchase"/&gt;
            &lt;many-to-one name="item" class="eg.Item"/&gt;
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class
&gt;</pre><p>Composite elements can appear in queries using the same syntax as associations to other entities. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="components-asmapindex"/>8.3. Componentes como índices de Map</h2></div></div></div><p>The <code class="literal">&lt;composite-map-key&gt;</code> element allows you to map a component class as the key of a <code class="literal">Map</code>. Ensure that you override <code class="literal">hashCode()</code> and <code class="literal">equals()</code> correctly on the component class. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="components-compositeid"/>8.4. Componentes como identificadores compuestos</h2></div></div></div><p>You can use a component as an identifier of an entity class. Your component class must satisfy certain requirements: </p><div class="itemizedlist"><ul compact="compact"><li><p>Debe implementar <code class="literal">java.io.Serializable</code>. </p></li><li><p>It must re-implement <code class="literal">equals()</code> and <code class="literal">hashCode()</code> consistently with the database's notion of composite key equality. </p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>In Hibernate3, although the second requirement is not an absolutely hard requirement of Hibernate, it is recommended. </p></div><p>You cannot use an <code class="literal">IdentifierGenerator</code> to generate composite keys. Instead the application must assign its own identifiers. </p><p>Use the <code class="literal">&lt;composite-id&gt;</code> tag, with nested <code class="literal">&lt;key-property&gt;</code> elements, in place of the usual <code class="literal">&lt;id&gt;</code> declaration. For example, the <code class="literal">OrderLine</code> class has a primary key that depends upon the (composite) primary key of <code class="literal">Order</code>. </p><pre class="programlisting">&lt;class name="OrderLine"&gt;
    
    &lt;composite-id name="id" class="OrderLineId"&gt;
        &lt;key-property name="lineId"/&gt;
        &lt;key-property name="orderId"/&gt;
        &lt;key-property name="customerId"/&gt;
    &lt;/composite-id&gt;
    
    &lt;property name="name"/&gt;
    
    &lt;many-to-one name="order" class="Order"
            insert="false" update="false"&gt;
        &lt;column name="orderId"/&gt;
        &lt;column name="customerId"/&gt;
    &lt;/many-to-one&gt;
    ....
    
&lt;/class
&gt;</pre><p>Any foreign keys referencing the <code class="literal">OrderLine</code> table are now composite. Declare this in your mappings for other classes. An association to <code class="literal">OrderLine</code> is mapped like this: </p><pre class="programlisting">&lt;many-to-one name="orderLine" class="OrderLine"&gt;
&lt;!-- the "class" attribute is optional, as usual --&gt;
    &lt;column name="lineId"/&gt;
    &lt;column name="orderId"/&gt;
    &lt;column name="customerId"/&gt;
&lt;/many-to-one
&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Sugerencia</h2><p>The <code class="literal">column</code> element is an alternative to the <code class="literal">column</code> attribute everywhere. Using the <code class="literal">column</code> element just gives more declaration options, which are mostly useful when utilizing <code class="literal">hbm2ddl</code> </p></div><p>Una asociación <code class="literal">muchos-a-muchos</code> a <code class="literal">OrderLine</code> también usa la clave foránea compuesta: </p><pre class="programlisting">&lt;set name="undeliveredOrderLines"&gt;
    &lt;key column name="warehouseId"/&gt;
    &lt;many-to-many class="OrderLine"&gt;
        &lt;column name="lineId"/&gt;
        &lt;column name="orderId"/&gt;
        &lt;column name="customerId"/&gt;
    &lt;/many-to-many&gt;
&lt;/set
&gt;</pre><p>La colección de <code class="literal">OrderLine</code>s en <code class="literal">Order</code> usaría: </p><pre class="programlisting">&lt;set name="orderLines" inverse="true"&gt;
    &lt;key&gt;
        &lt;column name="orderId"/&gt;
        &lt;column name="customerId"/&gt;
    &lt;/key&gt;
    &lt;one-to-many class="OrderLine"/&gt;
&lt;/set
&gt;</pre><p>The <code class="literal">&lt;one-to-many&gt;</code> element declares no columns. </p><p>Si <code class="literal">OrderLine</code> posee una colección por sí misma, tiene también una clave foránea compuesta. </p><pre class="programlisting">&lt;class name="OrderLine"&gt;
    ....
    ....
    &lt;list name="deliveryAttempts"&gt;
        &lt;key
&gt;   &lt;!-- a collection inherits the composite key type --&gt;
            &lt;column name="lineId"/&gt;
            &lt;column name="orderId"/&gt;
            &lt;column name="customerId"/&gt;
        &lt;/key&gt;
        &lt;list-index column="attemptId" base="1"/&gt;
        &lt;composite-element class="DeliveryAttempt"&gt;
            ...
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class
&gt;</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="components-dynamic"/>8.5. Componentes dinámicos</h2></div></div></div><p>You can also map a property of type <code class="literal">Map</code>: </p><pre class="programlisting">&lt;dynamic-component name="userAttributes"&gt;
    &lt;property name="foo" column="FOO" type="string"/&gt;
    &lt;property name="bar" column="BAR" type="integer"/&gt;
    &lt;many-to-one name="baz" class="Baz" column="BAZ_ID"/&gt;
&lt;/dynamic-component
&gt;</pre><p>The semantics of a <code class="literal">&lt;dynamic-component&gt;</code> mapping are identical to <code class="literal">&lt;component&gt;</code>. The advantage of this kind of mapping is the ability to determine the actual properties of the bean at deployment time just by editing the mapping document. Runtime manipulation of the mapping document is also possible, using a DOM parser. You can also access, and change, Hibernate's configuration-time metamodel via the <code class="literal">Configuration</code> object. </p></div></div><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="inheritance"/>Capítulo 9. Inheritance mapping</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#inheritance-strategies">9.1. The three strategies</a></span></dt><dd><dl><dt><span class="sect2"><a href="#inheritance-tableperclass">9.1.1. Tabla por jerarquía de clases</a></span></dt><dt><span class="sect2"><a href="#inheritance-tablepersubclass">9.1.2. Tabla por subclase</a></span></dt><dt><span class="sect2"><a href="#inheritance-tablepersubclass-discriminator">9.1.3. Table per subclass: using a discriminator</a></span></dt><dt><span class="sect2"><a href="#inheritance-mixing-tableperclass-tablepersubclass">9.1.4. Mezclando tabla por jerarquía de clases con tabla por subclase</a></span></dt><dt><span class="sect2"><a href="#inheritance-tableperconcrete">9.1.5. Tabla por clase concreta</a></span></dt><dt><span class="sect2"><a href="#inheritance-tableperconcreate-polymorphism">9.1.6. Table per concrete class using implicit polymorphism</a></span></dt><dt><span class="sect2"><a href="#inheritance-mixingpolymorphism">9.1.7. Mezclando polimorfismo implícito con otros mapeos de herencia</a></span></dt></dl></dd><dt><span class="sect1"><a href="#inheritance-limitations">9.2. Limitaciones</a></span></dt></dl></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="inheritance-strategies"/>9.1. The three strategies</h2></div></div></div><p>Hibernate soporta las tres estrategias básicas de mapeo de herencia: </p><div class="itemizedlist"><ul><li><p>tabla por jerarquía de clases</p><p> </p></li><li><p>tabla por subclase </p></li><li><p>tabla por clase concreta </p></li></ul></div><p>En adición, Hibernate soporta un cuarto, ligeramente diferente tipo de polimorfismo: </p><div class="itemizedlist"><ul><li><p>polimorfismo implícito </p></li></ul></div><p>It is possible to use different mapping strategies for different branches of the same inheritance hierarchy. You can then make use of implicit polymorphism to achieve polymorphism across the whole hierarchy. However, Hibernate does not support mixing <code class="literal">&lt;subclass&gt;</code>, <code class="literal">&lt;joined-subclass&gt;</code> and <code class="literal">&lt;union-subclass&gt;</code> mappings under the same root <code class="literal">&lt;class&gt;</code> element. It is possible to mix together the table per hierarchy and table per subclass strategies under the the same <code class="literal">&lt;class&gt;</code> element, by combining the <code class="literal">&lt;subclass&gt;</code> and <code class="literal">&lt;join&gt;</code> elements (see below for an example). </p><p>It is possible to define <code class="literal">subclass</code>, <code class="literal">union-subclass</code>, and <code class="literal">joined-subclass</code> mappings in separate mapping documents directly beneath <code class="literal">hibernate-mapping</code>. This allows you to extend a class hierarchy by adding a new mapping file. You must specify an <code class="literal">extends</code> attribute in the subclass mapping, naming a previously mapped superclass. Previously this feature made the ordering of the mapping documents important. Since Hibernate3, the ordering of mapping files is irrelevant when using the extends keyword. The ordering inside a single mapping file still needs to be defined as superclasses before subclasses. </p><pre class="programlisting">Es posible usar estrategias de mapeo diferentes para diferentes ramificaciones de la misma jerarquía de herencia, y entonces usar polimorfismo implícito para conseguir polimorfismo a través de toda la jerarquía. Sin embargo, Hibernate no soporta la mezcla de mapeos <code class="literal">&lt;subclass&gt;</code>, y <code class="literal">&lt;joined-subclass&gt;</code> y <code class="literal">&lt;union-subclass&gt;</code> bajo el mismo elemento <code class="literal">&lt;class&gt;</code> raíz. Es posible mezclar juntas las estrategias de tabla por jerarquía y tabla por subclase, bajo el mismo elemento <code class="literal">&lt;class&gt;</code>, combinando los elementos <code class="literal">&lt;subclass&gt;</code> y <code class="literal">&lt;join&gt;</code> (ver debajo).</pre><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-tableperclass"/>9.1.1. Tabla por jerarquía de clases</h3></div></div></div><p>Suppose we have an interface <code class="literal">Payment</code> with the implementors <code class="literal">CreditCardPayment</code>, <code class="literal">CashPayment</code>, and <code class="literal">ChequePayment</code>. The table per hierarchy mapping would display in the following way: </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        &lt;property name="creditCardType" column="CCTYPE"/&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        ...
    &lt;/subclass&gt;
&lt;/class
&gt;</pre><p>Exactly one table is required. There is a limitation of this mapping strategy: columns declared by the subclasses, such as <code class="literal">CCTYPE</code>, cannot have <code class="literal">NOT NULL</code> constraints. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-tablepersubclass"/>9.1.2. Tabla por subclase</h3></div></div></div><p>A table per subclass mapping looks like this: </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;joined-subclass name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="creditCardType" column="CCTYPE"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
&lt;/class
&gt;</pre><p>Four tables are required. The three subclass tables have primary key associations to the superclass table so the relational model is actually a one-to-one association. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-tablepersubclass-discriminator"/>9.1.3. Table per subclass: using a discriminator</h3></div></div></div><p>Hibernate's implementation of table per subclass does not require a discriminator column. Other object/relational mappers use a different implementation of table per subclass that requires a type discriminator column in the superclass table. The approach taken by Hibernate is much more difficult to implement, but arguably more correct from a relational point of view. If you want to use a discriminator column with the table per subclass strategy, you can combine the use of <code class="literal">&lt;subclass&gt;</code> and <code class="literal">&lt;join&gt;</code>, as follows: </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        &lt;join table="CREDIT_PAYMENT"&gt;
            &lt;key column="PAYMENT_ID"/&gt;
            &lt;property name="creditCardType" column="CCTYPE"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        &lt;join table="CASH_PAYMENT"&gt;
            &lt;key column="PAYMENT_ID"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        &lt;join table="CHEQUE_PAYMENT" fetch="select"&gt;
            &lt;key column="PAYMENT_ID"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
&lt;/class
&gt;</pre><p>la declaración opcional <code class="literal">fetch="select"</code> dice a Hibernate que no recupere los datos de la subclase <code class="literal">ChequePayment</code> usando una unión externa (outer join) al consultar la superclase. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-mixing-tableperclass-tablepersubclass"/>9.1.4. Mezclando tabla por jerarquía de clases con tabla por subclase</h3></div></div></div><p>You can even mix the table per hierarchy and table per subclass strategies using the following approach: </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        &lt;join table="CREDIT_PAYMENT"&gt;
            &lt;property name="creditCardType" column="CCTYPE"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        ...
    &lt;/subclass&gt;
&lt;/class
&gt;</pre><p>Para cualquiera de estas estrategias de mapeo, una asociación polimórfica a la clase raíz <code class="literal">Payment</code> es mapeada usando <code class="literal">&lt;many-to-one&gt;</code>. </p><pre class="programlisting">&lt;many-to-one name="payment" column="PAYMENT_ID" class="Payment"/&gt;</pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-tableperconcrete"/>9.1.5. Tabla por clase concreta</h3></div></div></div><p>There are two ways we can map the table per concrete class strategy. First, you can use <code class="literal">&lt;union-subclass&gt;</code>. </p><pre class="programlisting">&lt;class name="Payment"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="sequence"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;union-subclass name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
        &lt;property name="creditCardType" column="CCTYPE"/&gt;
        ...
    &lt;/union-subclass&gt;
    &lt;union-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        ...
    &lt;/union-subclass&gt;
    &lt;union-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        ...
    &lt;/union-subclass&gt;
&lt;/class
&gt;</pre><p>Están implicadas tres tablas. Cada tabla define columnas para todas las propiedades de la clase, inccluyendo las propiedades heredadas. </p><p>The limitation of this approach is that if a property is mapped on the superclass, the column name must be the same on all subclass tables. The identity generator strategy is not allowed in union subclass inheritance. The primary key seed has to be shared across all unioned subclasses of a hierarchy. </p><p>If your superclass is abstract, map it with <code class="literal">abstract="true"</code>. If it is not abstract, an additional table (it defaults to <code class="literal">PAYMENT</code> in the example above), is needed to hold instances of the superclass. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-tableperconcreate-polymorphism"/>9.1.6. Table per concrete class using implicit polymorphism</h3></div></div></div><p>Un enfoque alternativo es hacer uso de polimorfismo implícito: </p><pre class="programlisting">&lt;class name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CREDIT_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CREDIT_AMOUNT"/&gt;
    ...
&lt;/class&gt;

&lt;class name="CashPayment" table="CASH_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CASH_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CASH_AMOUNT"/&gt;
    ...
&lt;/class&gt;

&lt;class name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CHEQUE_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CHEQUE_AMOUNT"/&gt;
    ...
&lt;/class
&gt;</pre><p>Notice that the <code class="literal">Payment</code> interface is not mentioned explicitly. Also notice that properties of <code class="literal">Payment</code> are mapped in each of the subclasses. If you want to avoid duplication, consider using XML entities (for example, <code class="literal">[ &lt;!ENTITY allproperties SYSTEM "allproperties.xml"&gt; ]</code> in the <code class="literal">DOCTYPE</code> declaration and <code class="literal">&amp;allproperties;</code> in the mapping). </p><p>La desventaja de este enfoque es que Hibernate no genera <code class="literal">UNION</code>s de SQL al realizar consultas polimórficas. </p><p>Para esta estrategia de mapeo, una asociación polimórfica a <code class="literal">Payment</code> es mapeada generalmente usando <code class="literal">&lt;any&gt;</code>. </p><pre class="programlisting">&lt;any name="payment" meta-type="string" id-type="long"&gt;
    &lt;meta-value value="CREDIT" class="CreditCardPayment"/&gt;
    &lt;meta-value value="CASH" class="CashPayment"/&gt;
    &lt;meta-value value="CHEQUE" class="ChequePayment"/&gt;
    &lt;column name="PAYMENT_CLASS"/&gt;
    &lt;column name="PAYMENT_ID"/&gt;
&lt;/any
&gt;</pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-mixingpolymorphism"/>9.1.7. Mezclando polimorfismo implícito con otros mapeos de herencia</h3></div></div></div><p>Since the subclasses are each mapped in their own <code class="literal">&lt;class&gt;</code> element, and since <code class="literal">Payment</code> is just an interface), each of the subclasses could easily be part of another inheritance hierarchy. You can still use polymorphic queries against the <code class="literal">Payment</code> interface. </p><pre class="programlisting">&lt;class name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CREDIT_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="CREDIT_CARD" type="string"/&gt;
    &lt;property name="amount" column="CREDIT_AMOUNT"/&gt;
    ...
    &lt;subclass name="MasterCardPayment" discriminator-value="MDC"/&gt;
    &lt;subclass name="VisaPayment" discriminator-value="VISA"/&gt;
&lt;/class&gt;

&lt;class name="NonelectronicTransaction" table="NONELECTRONIC_TXN"&gt;
    &lt;id name="id" type="long" column="TXN_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    ...
    &lt;joined-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="amount" column="CASH_AMOUNT"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="amount" column="CHEQUE_AMOUNT"/&gt;
        ...
    &lt;/joined-subclass&gt;
&lt;/class
&gt;</pre><p>Once again, <code class="literal">Payment</code> is not mentioned explicitly. If we execute a query against the <code class="literal">Payment</code> interface, for example <code class="literal">from Payment</code>, Hibernate automatically returns instances of <code class="literal">CreditCardPayment</code> (and its subclasses, since they also implement <code class="literal">Payment</code>), <code class="literal">CashPayment</code> and <code class="literal">ChequePayment</code>, but not instances of <code class="literal">NonelectronicTransaction</code>. </p></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="inheritance-limitations"/>9.2. Limitaciones</h2></div></div></div><p>There are limitations to the "implicit polymorphism" approach to the table per concrete-class mapping strategy. There are somewhat less restrictive limitations to <code class="literal">&lt;union-subclass&gt;</code> mappings. </p><p>La siguiente tabla muestra las limitaciones de mapeos de tabla por clase concreta, y de polmorfismo implícito, en Hibernate. </p><div class="table"><a id="d0e9220"/><p class="title"><b>Tabla 9.1. Funcionalidades de mapeo de herencia</b></p><div class="table-contents"><table summary="Funcionalidades de mapeo de herencia" border="1"><colgroup><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/></colgroup><thead><tr><th align="left">Estrategia de herencia</th><th align="left">muchos-a-uno polimórfica</th><th align="left">uno-a-uno polimórfica</th><th align="left">uno-a-muchos polimórfica</th><th align="left">mushos-a-muchos polimórfica</th><th align="left"><code class="literal">load()/get()</code> polimórficos</th><th align="left">Consultas polimórficas</th><th align="left">Uniones polimórficas</th><th align="left">Recuperación por unión externa (outer join)</th></tr></thead><tbody><tr><td align="left">tabla por jerarquía de clases</td><td align="left"><code class="literal">&lt;many-to-one&gt;</code></td><td align="left"><code class="literal">&lt;one-to-one&gt;</code></td><td align="left"><code class="literal">&lt;one-to-many&gt;</code></td><td align="left"><code class="literal">&lt;many-to-many&gt;</code></td><td align="left"><code class="literal">s.get(Payment.class, id)</code></td><td align="left"><code class="literal">from Payment p</code></td><td align="left"><code class="literal">from Order o join o.payment p</code></td><td align="left"><span class="emphasis"><em>soportada</em></span></td></tr><tr><td align="left">tabla por subclase</td><td align="left"><code class="literal">&lt;many-to-one&gt;</code></td><td align="left"><code class="literal">&lt;one-to-one&gt;</code></td><td align="left"><code class="literal">&lt;one-to-many&gt;</code></td><td align="left"><code class="literal">&lt;many-to-many&gt;</code></td><td align="left"><code class="literal">s.get(Payment.class, id)</code></td><td align="left"><code class="literal">from Payment p</code></td><td align="left"><code class="literal">from Order o join o.payment p</code></td><td align="left"><span class="emphasis"><em>soportada</em></span></td></tr><tr><td align="left">tabla por clase concreta (union-subclass)</td><td align="left"><code class="literal">&lt;many-to-one&gt;</code></td><td align="left"><code class="literal">&lt;one-to-one&gt;</code></td><td align="left"><code class="literal">&lt;one-to-many&gt;</code> (para <code class="literal">inverse="true"</code> solamente)</td><td align="left"><code class="literal">&lt;many-to-many&gt;</code></td><td align="left"><code class="literal">s.get(Payment.class, id)</code></td><td align="left"><code class="literal">from Payment p</code></td><td align="left"><code class="literal">from Order o join o.payment p</code></td><td align="left"><span class="emphasis"><em>soportada</em></span></td></tr><tr><td align="left">tabla por clase concreta (polimorfismo implícito)</td><td align="left"><code class="literal">&lt;any&gt;</code></td><td align="left"><span class="emphasis"><em>no soportada</em></span></td><td align="left"><span class="emphasis"><em>no soportada</em></span></td><td align="left"><code class="literal">&lt;many-to-any&gt;</code></td><td align="left"><code class="literal">s.createCriteria(Payment.class).add( Restrictions.idEq(id) ).uniqueResult()</code></td><td align="left"><code class="literal">from Payment p</code></td><td align="left"><span class="emphasis"><em>no soportada</em></span></td><td align="left"><span class="emphasis"><em>no soportada</em></span></td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate"/>Capítulo 10. Trabajando con objetos</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#objectstate-overview">10.1. Estados de objeto de Hibernate</a></span></dt><dt><span class="sect1"><a href="#objectstate-makingpersistent">10.2. Haciendo los objetos persistentes</a></span></dt><dt><span class="sect1"><a href="#objectstate-loading">10.3. Cargando un objeto</a></span></dt><dt><span class="sect1"><a href="#objectstate-querying">10.4. Consultando</a></span></dt><dd><dl><dt><span class="sect2"><a href="#objectstate-querying-executing">10.4.1. Ejecutando consultas</a></span></dt><dt><span class="sect2"><a href="#objectstate-filtering">10.4.2. Filtrando colecciones</a></span></dt><dt><span class="sect2"><a href="#objecstate-querying-criteria">10.4.3. Consultas de criterios</a></span></dt><dt><span class="sect2"><a href="#objectstate-querying-nativesql">10.4.4. Consultas en SQL nativo</a></span></dt></dl></dd><dt><span class="sect1"><a href="#objectstate-modifying">10.5. Modificando objetos persistentes</a></span></dt><dt><span class="sect1"><a href="#objectstate-detached">10.6. Modificando objetos separados</a></span></dt><dt><span class="sect1"><a href="#objectstate-saveorupdate">10.7. Detección automática de estado</a></span></dt><dt><span class="sect1"><a href="#objectstate-deleting">10.8. Borrando objetos persistentes</a></span></dt><dt><span class="sect1"><a href="#objectstate-replicating">10.9. Replicando objetos entre dos almacénes de datos diferentes</a></span></dt><dt><span class="sect1"><a href="#objectstate-flushing">10.10. Limpiando (flushing) la sesión</a></span></dt><dt><span class="sect1"><a href="#objectstate-transitive">10.11. Persistencia transitiva</a></span></dt><dt><span class="sect1"><a href="#objectstate-metadata">10.12. Usando metadatos</a></span></dt></dl></div><p>Hibernate is a full object/relational mapping solution that not only shields the developer from the details of the underlying database management system, but also offers <span class="emphasis"><em>state management</em></span> of objects. This is, contrary to the management of SQL <code class="literal">statements</code> in common JDBC/SQL persistence layers, a natural object-oriented view of persistence in Java applications. </p><p>En otras palabras, los desarroladores de aplicaciones Hibernate deben siempre pensar en el <span class="emphasis"><em>estado</em></span> de sus objetos, y no necesariamente en la ejecución de sentencias SQL. Esta parte es cuidada por Hibernate y es sólo relevante para el desarrollador de la aplicación al afinar el rendimiento del sistema. </p><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-overview"/>10.1. Estados de objeto de Hibernate</h2></div></div></div><p>Hibernate define y soporta los siguientes estados de objeto: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Transient</em></span> - an object is transient if it has just been instantiated using the <code class="literal">new</code> operator, and it is not associated with a Hibernate <code class="literal">Session</code>. It has no persistent representation in the database and no identifier value has been assigned. Transient instances will be destroyed by the garbage collector if the application does not hold a reference anymore. Use the Hibernate <code class="literal">Session</code> to make an object persistent (and let Hibernate take care of the SQL statements that need to be executed for this transition). </p></li><li><p><span class="emphasis"><em>Persistent</em></span> - a persistent instance has a representation in the database and an identifier value. It might just have been saved or loaded, however, it is by definition in the scope of a <code class="literal">Session</code>. Hibernate will detect any changes made to an object in persistent state and synchronize the state with the database when the unit of work completes. Developers do not execute manual <code class="literal">UPDATE</code> statements, or <code class="literal">DELETE</code> statements when an object should be made transient. </p></li><li><p><span class="emphasis"><em>Detached</em></span> - a detached instance is an object that has been persistent, but its <code class="literal">Session</code> has been closed. The reference to the object is still valid, of course, and the detached instance might even be modified in this state. A detached instance can be reattached to a new <code class="literal">Session</code> at a later point in time, making it (and all the modifications) persistent again. This feature enables a programming model for long running units of work that require user think-time. We call them <span class="emphasis"><em>application transactions</em></span>, i.e., a unit of work from the point of view of the user. </p></li></ul></div><p>We will now discuss the states and state transitions (and the Hibernate methods that trigger a transition) in more detail. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-makingpersistent"/>10.2. Haciendo los objetos persistentes</h2></div></div></div><p>Las instancias recién instanciadas de una clase persistente son consideradas <span class="emphasis"><em>transitorias</em></span> por Hibernate. Podemos hacer una instancia transitoria <span class="emphasis"><em>persistente</em></span> asociándola con una sesión: </p><pre class="programlisting">DomesticCat fritz = new DomesticCat();
fritz.setColor(Color.GINGER);
fritz.setSex('M');
fritz.setName("Fritz");
Long generatedId = (Long) sess.save(fritz);</pre><p>If <code class="literal">Cat</code> has a generated identifier, the identifier is generated and assigned to the <code class="literal">cat</code> when <code class="literal">save()</code> is called. If <code class="literal">Cat</code> has an <code class="literal">assigned</code> identifier, or a composite key, the identifier should be assigned to the <code class="literal">cat</code> instance before calling <code class="literal">save()</code>. You can also use <code class="literal">persist()</code> instead of <code class="literal">save()</code>, with the semantics defined in the EJB3 early draft. </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">persist()</code> makes a transient instance persistent. However, it does not guarantee that the identifier value will be assigned to the persistent instance immediately, the assignment might happen at flush time. <code class="literal">persist()</code> also guarantees that it will not execute an <code class="literal">INSERT</code> statement if it is called outside of transaction boundaries. This is useful in long-running conversations with an extended Session/persistence context. </p></li><li><p><code class="literal">save()</code> does guarantee to return an identifier. If an INSERT has to be executed to get the identifier ( e.g. "identity" generator, not "sequence"), this INSERT happens immediately, no matter if you are inside or outside of a transaction. This is problematic in a long-running conversation with an extended Session/persistence context. </p></li></ul></div><p>Alternatively, you can assign the identifier using an overloaded version of <code class="literal">save()</code>. </p><pre class="programlisting">DomesticCat pk = new DomesticCat();
pk.setColor(Color.TABBY);
pk.setSex('F');
pk.setName("PK");
pk.setKittens( new HashSet() );
pk.addKitten(fritz);
sess.save( pk, new Long(1234) );</pre><p>If the object you make persistent has associated objects (e.g. the <code class="literal">kittens</code> collection in the previous example), these objects can be made persistent in any order you like unless you have a <code class="literal">NOT NULL</code> constraint upon a foreign key column. There is never a risk of violating foreign key constraints. However, you might violate a <code class="literal">NOT NULL</code> constraint if you <code class="literal">save()</code> the objects in the wrong order. </p><p>Usually you do not bother with this detail, as you will normally use Hibernate's <span class="emphasis"><em>transitive persistence</em></span> feature to save the associated objects automatically. Then, even <code class="literal">NOT NULL</code> constraint violations do not occur - Hibernate will take care of everything. Transitive persistence is discussed later in this chapter. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-loading"/>10.3. Cargando un objeto</h2></div></div></div><p>The <code class="literal">load()</code> methods of <code class="literal">Session</code> provide a way of retrieving a persistent instance if you know its identifier. <code class="literal">load()</code> takes a class object and loads the state into a newly instantiated instance of that class in a persistent state. </p><pre class="programlisting">Cat fritz = (Cat) sess.load(Cat.class, generatedId);</pre><pre class="programlisting">// you need to wrap primitive identifiers
long id = 1234;
DomesticCat pk = (DomesticCat) sess.load( DomesticCat.class, new Long(id) );</pre><p>Alternativamente, puedes cargar estado dentro de una instancia dada: </p><pre class="programlisting">Cat cat = new DomesticCat();
// load pk's state into cat
sess.load( cat, new Long(pkId) );
Set kittens = cat.getKittens();</pre><p>Be aware that <code class="literal">load()</code> will throw an unrecoverable exception if there is no matching database row. If the class is mapped with a proxy, <code class="literal">load()</code> just returns an uninitialized proxy and does not actually hit the database until you invoke a method of the proxy. This is useful if you wish to create an association to an object without actually loading it from the database. It also allows multiple instances to be loaded as a batch if <code class="literal">batch-size</code> is defined for the class mapping. </p><p>If you are not certain that a matching row exists, you should use the <code class="literal">get()</code> method which hits the database immediately and returns null if there is no matching row. </p><pre class="programlisting">Cat cat = (Cat) sess.get(Cat.class, id);
if (cat==null) {
    cat = new Cat();
    sess.save(cat, id);
}
return cat;</pre><p>You can even load an object using an SQL <code class="literal">SELECT ... FOR UPDATE</code>, using a <code class="literal">LockMode</code>. See the API documentation for more information. </p><pre class="programlisting">Cat cat = (Cat) sess.get(Cat.class, id, LockMode.UPGRADE);</pre><p>Any associated instances or contained collections will <span class="emphasis"><em>not</em></span> be selected <code class="literal">FOR UPDATE</code>, unless you decide to specify <code class="literal">lock</code> or <code class="literal">all</code> as a cascade style for the association. </p><p>Es posible volver a cargar un objeto y todas sus colecciones en cualquier momento, usando el método <code class="literal">refresh()</code>. Esto es útil cuando se usan disparadores de base de datos para inicializar algunas de las propiedades del objeto. </p><pre class="programlisting">sess.save(cat);
sess.flush(); //force the SQL INSERT
sess.refresh(cat); //re-read the state (after the trigger executes)</pre><p>How much does Hibernate load from the database and how many SQL <code class="literal">SELECT</code>s will it use? This depends on the <span class="emphasis"><em>fetching strategy</em></span>. This is explained in <a href="#performance-fetching" title="19.1. Estrategias de recuperación">Sección 19.1, “Estrategias de recuperación”</a>. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-querying"/>10.4. Consultando</h2></div></div></div><p>If you do not know the identifiers of the objects you are looking for, you need a query. Hibernate supports an easy-to-use but powerful object oriented query language (HQL). For programmatic query creation, Hibernate supports a sophisticated Criteria and Example query feature (QBC and QBE). You can also express your query in the native SQL of your database, with optional support from Hibernate for result set conversion into objects. </p><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="objectstate-querying-executing"/>10.4.1. Ejecutando consultas</h3></div></div></div><p>Las consultas HQL y SQL nativas son representadas con una instancia de <code class="literal">org.hibernate.Query</code>. Esta interface ofrece métodos para la ligación de parámetros, manejo del conjunto resultado, y para la ejecución de la consulta real. Siempre obtienes una <code class="literal">Query</code> usando la <code class="literal">Session</code> actual: </p><pre class="programlisting">List cats = session.createQuery(
    "from Cat as cat where cat.birthdate &lt; ?")
    .setDate(0, date)
    .list();

List mothers = session.createQuery(
    "select mother from Cat as cat join cat.mother as mother where cat.name = ?")
    .setString(0, name)
    .list();

List kittens = session.createQuery(
    "from Cat as cat where cat.mother = ?")
    .setEntity(0, pk)
    .list();

Cat mother = (Cat) session.createQuery(
    "select cat.mother from Cat as cat where cat = ?")
    .setEntity(0, izi)
    .uniqueResult();</pre><p>A query is usually executed by invoking <code class="literal">list()</code>. The result of the query will be loaded completely into a collection in memory. Entity instances retrieved by a query are in a persistent state. The <code class="literal">uniqueResult()</code> method offers a shortcut if you know your query will only return a single object. Queries that make use of eager fetching of collections usually return duplicates of the root objects, but with their collections initialized. You can filter these duplicates through a <code class="literal">Set</code>. </p><div class="sect3" lang="es-ES"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-iterate"/>10.4.1.1. Iterando los resultados</h4></div></div></div><p>Occasionally, you might be able to achieve better performance by executing the query using the <code class="literal">iterate()</code> method. This will usually be the case if you expect that the actual entity instances returned by the query will already be in the session or second-level cache. If they are not already cached, <code class="literal">iterate()</code> will be slower than <code class="literal">list()</code> and might require many database hits for a simple query, usually <span class="emphasis"><em>1</em></span> for the initial select which only returns identifiers, and <span class="emphasis"><em>n</em></span> additional selects to initialize the actual instances. </p><pre class="programlisting">// fetch ids
Iterator iter = sess.createQuery("from eg.Qux q order by q.likeliness").iterate();
while ( iter.hasNext() ) {
    Qux qux = (Qux) iter.next();  // fetch the object
    // something we couldnt express in the query
    if ( qux.calculateComplicatedAlgorithm() ) {
        // delete the current instance
        iter.remove();
        // dont need to process the rest
        break;
    }
}</pre></div><div class="sect3" lang="es-ES"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-tuples"/>10.4.1.2. Consultas que devuelven tuplas</h4></div></div></div><p>Hibernate queries sometimes return tuples of objects. Each tuple is returned as an array: </p><pre class="programlisting">Iterator kittensAndMothers = sess.createQuery(
            "select kitten, mother from Cat kitten join kitten.mother mother")
            .list()
            .iterator();

while ( kittensAndMothers.hasNext() ) {
    Object[] tuple = (Object[]) kittensAndMothers.next();
    Cat kitten = (Cat) tuple[0];
    Cat mother = (Cat) tuple[1];
    ....
}</pre></div><div class="sect3" lang="es-ES"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-scalar"/>10.4.1.3. Resultados escalares</h4></div></div></div><p>Queries can specify a property of a class in the <code class="literal">select</code> clause. They can even call SQL aggregate functions. Properties or aggregates are considered "scalar" results and not entities in persistent state. </p><pre class="programlisting">Iterator results = sess.createQuery(
        "select cat.color, min(cat.birthdate), count(cat) from Cat cat " +
        "group by cat.color")
        .list()
        .iterator();

while ( results.hasNext() ) {
    Object[] row = results.next();
    Color type = (Color) row[0];
    Date oldest = (Date) row[1];
    Integer count = (Integer) row[2];
    .....
}</pre></div><div class="sect3" lang="es-ES"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-parameters"/>10.4.1.4. Ligación de parámetros</h4></div></div></div><p>Methods on <code class="literal">Query</code> are provided for binding values to named parameters or JDBC-style <code class="literal">?</code> parameters. <span class="emphasis"><em>Contrary to JDBC, Hibernate numbers parameters from zero.</em></span> Named parameters are identifiers of the form <code class="literal">:name</code> in the query string. The advantages of named parameters are as follows: </p><div class="itemizedlist"><ul compact="compact"><li><p>los parámetros con nombre son insensibles al orden en que aparecen en la cadena de consulta </p></li><li><p>they can occur multiple times in the same query </p></li><li><p>son auto-documentados </p></li></ul></div><pre class="programlisting">//named parameter (preferred)
Query q = sess.createQuery("from DomesticCat cat where cat.name = :name");
q.setString("name", "Fritz");
Iterator cats = q.iterate();</pre><pre class="programlisting">//positional parameter
Query q = sess.createQuery("from DomesticCat cat where cat.name = ?");
q.setString(0, "Izi");
Iterator cats = q.iterate();</pre><pre class="programlisting">//named parameter list
List names = new ArrayList();
names.add("Izi");
names.add("Fritz");
Query q = sess.createQuery("from DomesticCat cat where cat.name in (:namesList)");
q.setParameterList("namesList", names);
List cats = q.list();</pre></div><div class="sect3" lang="es-ES"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-pagination"/>10.4.1.5. Paginación</h4></div></div></div><p>If you need to specify bounds upon your result set, that is, the maximum number of rows you want to retrieve and/or the first row you want to retrieve, you can use methods of the <code class="literal">Query</code> interface: </p><pre class="programlisting">Query q = sess.createQuery("from DomesticCat cat");
q.setFirstResult(20);
q.setMaxResults(10);
List cats = q.list();</pre><p>Hibernate sabe cómo traducir este límite de consulta al SQL nativo de tu DBMS. </p></div><div class="sect3" lang="es-ES"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-scrolling"/>10.4.1.6. Iteración scrollable</h4></div></div></div><p>If your JDBC driver supports scrollable <code class="literal">ResultSet</code>s, the <code class="literal">Query</code> interface can be used to obtain a <code class="literal">ScrollableResults</code> object that allows flexible navigation of the query results. </p><pre class="programlisting">Query q = sess.createQuery("select cat.name, cat from DomesticCat cat " +
                            "order by cat.name");
ScrollableResults cats = q.scroll();
if ( cats.first() ) {

    // find the first name on each page of an alphabetical list of cats by name
    firstNamesOfPages = new ArrayList();
    do {
        String name = cats.getString(0);
        firstNamesOfPages.add(name);
    }
    while ( cats.scroll(PAGE_SIZE) );

    // Now get the first page of cats
    pageOfCats = new ArrayList();
    cats.beforeFirst();
    int i=0;
    while( ( PAGE_SIZE 
&gt; i++ ) &amp;&amp; cats.next() ) pageOfCats.add( cats.get(1) );

}
cats.close()</pre><p>Note that an open database connection and cursor is required for this functionality. Use <code class="literal">setMaxResult()</code>/<code class="literal">setFirstResult()</code> if you need offline pagination functionality. </p></div><div class="sect3" lang="es-ES"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-named"/>10.4.1.7. Externalizando consultas con nombre</h4></div></div></div><p>You can also define named queries in the mapping document. Remember to use a <code class="literal">CDATA</code> section if your query contains characters that could be interpreted as markup. </p><pre class="programlisting">&lt;query name="eg.DomesticCat.by.name.and.minimum.weight"
&gt;&lt;![CDATA[
    from eg.DomesticCat as cat
        where cat.name = ?
        and cat.weight 
&gt; ?
] ]&gt;&lt;/query
&gt;</pre><p>La ligación de parámetros y ejecución se hace programáticamente: </p><pre class="programlisting">Query q = sess.getNamedQuery("eg.DomesticCat.by.name.and.minimum.weight");
q.setString(0, name);
q.setInt(1, minWeight);
List cats = q.list();</pre><p>The actual program code is independent of the query language that is used. You can also define native SQL queries in metadata, or migrate existing queries to Hibernate by placing them in mapping files. </p><p>Also note that a query declaration inside a <code class="literal">&lt;hibernate-mapping&gt;</code> element requires a global unique name for the query, while a query declaration inside a <code class="literal">&lt;class&gt;</code> element is made unique automatically by prepending the fully qualified name of the class. For example <code class="literal">eg.Cat.ByNameAndMaximumWeight</code>. </p></div></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="objectstate-filtering"/>10.4.2. Filtrando colecciones</h3></div></div></div><p>A collection <span class="emphasis"><em>filter</em></span> is a special type of query that can be applied to a persistent collection or array. The query string can refer to <code class="literal">this</code>, meaning the current collection element. </p><pre class="programlisting">Collection blackKittens = session.createFilter(
    pk.getKittens(), 
    "where this.color = ?")
    .setParameter( Color.BLACK, Hibernate.custom(ColorUserType.class) )
    .list()
);</pre><p>The returned collection is considered a bag that is a copy of the given collection. The original collection is not modified. This is contrary to the implication of the name "filter", but consistent with expected behavior. </p><p>Observe that filters do not require a <code class="literal">from</code> clause, although they can have one if required. Filters are not limited to returning the collection elements themselves. </p><pre class="programlisting">Collection blackKittenMates = session.createFilter(
    pk.getKittens(), 
    "select this.mate where this.color = eg.Color.BLACK.intValue")
    .list();</pre><p>Even an empty filter query is useful, e.g. to load a subset of elements in a large collection: </p><pre class="programlisting">Collection tenKittens = session.createFilter(
    mother.getKittens(), "")
    .setFirstResult(0).setMaxResults(10)
    .list();</pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="objecstate-querying-criteria"/>10.4.3. Consultas de criterios</h3></div></div></div><p>HQL is extremely powerful, but some developers prefer to build queries dynamically using an object-oriented API, rather than building query strings. Hibernate provides an intuitive <code class="literal">Criteria</code> query API for these cases: </p><pre class="programlisting">Criteria crit = session.createCriteria(Cat.class);
crit.add( Restrictions.eq( "color", eg.Color.BLACK ) );
crit.setMaxResults(10);
List cats = crit.list();</pre><p>Las APIs de <code class="literal">Criteria</code> y la asociada <code class="literal">Example</code> son discutidas en más detalle en <a href="#querycriteria" title="Capítulo 15. Consultas por Criterios">Capítulo 15, <i xmlns:xlink="http://www.w3.org/1999/xlink">Consultas por Criterios</i></a>. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="objectstate-querying-nativesql"/>10.4.4. Consultas en SQL nativo</h3></div></div></div><p>You can express a query in SQL, using <code class="literal">createSQLQuery()</code> and let Hibernate manage the mapping from result sets to objects. You can at any time call <code class="literal">session.connection()</code> and use the JDBC <code class="literal">Connection</code> directly. If you choose to use the Hibernate API, you must enclose SQL aliases in braces: </p><pre class="programlisting">List cats = session.createSQLQuery("SELECT {cat.*} FROM CAT {cat} WHERE ROWNUM&lt;10")
    .addEntity("cat", Cat.class)
.list();</pre><pre class="programlisting">List cats = session.createSQLQuery(
    "SELECT {cat}.ID AS {cat.id}, {cat}.SEX AS {cat.sex}, " +
           "{cat}.MATE AS {cat.mate}, {cat}.SUBCLASS AS {cat.class}, ... " +
    "FROM CAT {cat} WHERE ROWNUM&lt;10")
    .addEntity("cat", Cat.class)
.list()</pre><p>SQL queries can contain named and positional parameters, just like Hibernate queries. More information about native SQL queries in Hibernate can be found in <a href="#querysql" title="Capítulo 16. SQL Nativo">Capítulo 16, <i xmlns:xlink="http://www.w3.org/1999/xlink">SQL Nativo</i></a>. </p></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-modifying"/>10.5. Modificando objetos persistentes</h2></div></div></div><p><span class="emphasis"><em>Transactional persistent instances</em></span> (i.e. objects loaded, saved, created or queried by the <code class="literal">Session</code>) can be manipulated by the application, and any changes to persistent state will be persisted when the <code class="literal">Session</code> is <span class="emphasis"><em>flushed</em></span>. This is discussed later in this chapter. There is no need to call a particular method (like <code class="literal">update()</code>, which has a different purpose) to make your modifications persistent. The most straightforward way to update the state of an object is to <code class="literal">load()</code> it and then manipulate it directly while the <code class="literal">Session</code> is open: </p><pre class="programlisting">DomesticCat cat = (DomesticCat) sess.load( Cat.class, new Long(69) );
cat.setName("PK");
sess.flush();  // changes to cat are automatically detected and persisted</pre><p>Sometimes this programming model is inefficient, as it requires in the same session both an SQL <code class="literal">SELECT</code> to load an object and an SQL <code class="literal">UPDATE</code> to persist its updated state. Hibernate offers an alternate approach by using detached instances. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Importante</h2><p>Hibernate does not offer its own API for direct execution of <code class="literal">UPDATE</code> or <code class="literal">DELETE</code> statements. Hibernate is a <span class="emphasis"><em>state management</em></span> service, you do not have to think in <span class="emphasis"><em>statements</em></span> to use it. JDBC is a perfect API for executing SQL statements, you can get a JDBC <code class="literal">Connection</code> at any time by calling <code class="literal">session.connection()</code>. Furthermore, the notion of mass operations conflicts with object/relational mapping for online transaction processing-oriented applications. Future versions of Hibernate can, however, provide special mass operation functions. See <a href="#batch" title="Capítulo 13. Procesamiento por lotes">Capítulo 13, <i xmlns:xlink="http://www.w3.org/1999/xlink">Procesamiento por lotes</i></a> for some possible batch operation tricks. </p></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-detached"/>10.6. Modificando objetos separados</h2></div></div></div><p>Muchas aplicaciones necesitan recuperar un objeto en una transacción, enviarla a la capa de UI para su manipulación, y entonces salvar los cambios en una nueva transacción. Las aplicaciones que usan este tipo de enfoque en un entorno de alta concurrencia usualmente usan datos versionados para asegurar el aislamiento de la unidad de trabajo "larga". </p><p>Hibernate soporta este modelo al proveer re-unión de instancias separadas usando los métodos <code class="literal">Session.update()</code> o <code class="literal">Session.merge()</code>: </p><pre class="programlisting">// in the first session
Cat cat = (Cat) firstSession.load(Cat.class, catId);
Cat potentialMate = new Cat();
firstSession.save(potentialMate);

// in a higher layer of the application
cat.setMate(potentialMate);

// later, in a new session
secondSession.update(cat);  // update cat
secondSession.update(mate); // update mate</pre><p>Si el <code class="literal">Cat</code> con identificador <code class="literal">catId</code> ya hubiera sido cargado por <code class="literal">secondSession</code> cuando la aplicación intentó volver a unirlo, se habría lanzado una excepción. </p><p>Use <code class="literal">update()</code> if you are certain that the session does not contain an already persistent instance with the same identifier. Use <code class="literal">merge()</code> if you want to merge your modifications at any time without consideration of the state of the session. In other words, <code class="literal">update()</code> is usually the first method you would call in a fresh session, ensuring that the reattachment of your detached instances is the first operation that is executed. </p><p>The application should individually <code class="literal">update()</code> detached instances that are reachable from the given detached instance <span class="emphasis"><em>only</em></span> if it wants their state to be updated. This can be automated using <span class="emphasis"><em>transitive persistence</em></span>. See <a href="#objectstate-transitive" title="10.11. Persistencia transitiva">Sección 10.11, “Persistencia transitiva”</a> for more information. </p><p>The <code class="literal">lock()</code> method also allows an application to reassociate an object with a new session. However, the detached instance has to be unmodified. </p><pre class="programlisting">//just reassociate:
sess.lock(fritz, LockMode.NONE);
//do a version check, then reassociate:
sess.lock(izi, LockMode.READ);
//do a version check, using SELECT ... FOR UPDATE, then reassociate:
sess.lock(pk, LockMode.UPGRADE);</pre><p>Note that <code class="literal">lock()</code> can be used with various <code class="literal">LockMode</code>s. See the API documentation and the chapter on transaction handling for more information. Reattachment is not the only usecase for <code class="literal">lock()</code>. </p><p>Se discuten otros modelos para unidades de trabajo largas en <a href="#transactions-optimistic" title="11.3. Control optimista de concurrencia">Sección 11.3, “Control optimista de concurrencia”</a>. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-saveorupdate"/>10.7. Detección automática de estado</h2></div></div></div><p>Los usuarios de Hibernate han pedido un método de propósito general que bien salve una instancia transitoria generando un identificador nuevo, o bien actualice/reúna las instancias separadas asociadas con su identificador actual. El método <code class="literal">saveOrUpdate()</code> implementa esta funcionalidad. </p><pre class="programlisting">// in the first session
Cat cat = (Cat) firstSession.load(Cat.class, catID);

// in a higher tier of the application
Cat mate = new Cat();
cat.setMate(mate);

// later, in a new session
secondSession.saveOrUpdate(cat);   // update existing state (cat has a non-null id)
secondSession.saveOrUpdate(mate);  // save the new instance (mate has a null id)</pre><p>El uso y semántica de <code class="literal">saveOrUpdate()</code> parece ser confuso para usuarios nuevos. Primeramente, en tanto no estés intentando usar instancias de una sesión en otra sesión nueva, no debes necesitar usar <code class="literal">update()</code>, <code class="literal">saveOrUpdate()</code>, o <code class="literal">merge()</code>. Algunas aplicaciones enteras nunca usarán ninguno de estos métodos. </p><p>Usualmente <code class="literal">update()</code> o <code class="literal">saveOrUpdate()</code> se usan en el siguiente escenario: </p><div class="itemizedlist"><ul compact="compact"><li><p>la aplicación carga un objeto en la primera sesión </p></li><li><p>el objeto es pasado a la capa de UI </p></li><li><p>se hacen algunas modificaciones al objeto </p></li><li><p>el objeto se pasa abajo de regreso a la capa de negocio </p></li><li><p>la aplicación hace estas modificaciones persistentes llamando a <code class="literal">update()</code> en una segunda sesión </p></li></ul></div><p><code class="literal">saveOrUpdate()</code> hace lo siguiente: </p><div class="itemizedlist"><ul compact="compact"><li><p>si el objeto ya es persistente en esta sesión, no hace nada </p></li><li><p>si otro objeto asociado con la sesión tiene el mismo identificador, lanza una excepción </p></li><li><p>si el objeto no tiene ninguna propiedad identificadora, lo salva llamando a <code class="literal">save()</code> </p></li><li><p>si el identificador del objeto tiene el valor asignado a un objeto recién instanciado, lo salva llamando a <code class="literal">save()</code> </p></li><li><p>if the object is versioned by a <code class="literal">&lt;version&gt;</code> or <code class="literal">&lt;timestamp&gt;</code>, and the version property value is the same value assigned to a newly instantiated object, <code class="literal">save()</code> it </p></li><li><p>en cualquier otro caso se actualiza el objeto llamando a <code class="literal">update()</code> </p></li></ul></div><p>y <code class="literal">merge()</code> es muy diferente: </p><div class="itemizedlist"><ul compact="compact"><li><p>si existe una instancia persistente con el mismo identificador asignado actualmente con la sesión, copia el estado del objeto dado en la instancia persistente </p></li><li><p>si no existe ninguna instancia persistente actualmente asociada a la sesión, intente cargarla de la base de datos, o crear una nueva instancia persistente </p></li><li><p>la instancia persistente es devuelta </p></li><li><p>la instancia dada no resulta ser asociada a la sesión, permanece separada </p></li></ul></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-deleting"/>10.8. Borrando objetos persistentes</h2></div></div></div><p><code class="literal">Session.delete()</code> will remove an object's state from the database. Your application, however, can still hold a reference to a deleted object. It is best to think of <code class="literal">delete()</code> as making a persistent instance, transient. </p><pre class="programlisting">sess.delete(cat);</pre><p>You can delete objects in any order, without risk of foreign key constraint violations. It is still possible to violate a <code class="literal">NOT NULL</code> constraint on a foreign key column by deleting objects in the wrong order, e.g. if you delete the parent, but forget to delete the children. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-replicating"/>10.9. Replicando objetos entre dos almacénes de datos diferentes</h2></div></div></div><p>It is sometimes useful to be able to take a graph of persistent instances and make them persistent in a different datastore, without regenerating identifier values. </p><pre class="programlisting">//retrieve a cat from one database
Session session1 = factory1.openSession();
Transaction tx1 = session1.beginTransaction();
Cat cat = session1.get(Cat.class, catId);
tx1.commit();
session1.close();

//reconcile with a second database
Session session2 = factory2.openSession();
Transaction tx2 = session2.beginTransaction();
session2.replicate(cat, ReplicationMode.LATEST_VERSION);
tx2.commit();
session2.close();</pre><p>The <code class="literal">ReplicationMode</code> determines how <code class="literal">replicate()</code> will deal with conflicts with existing rows in the database: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">ReplicationMode.IGNORE</code>: ignores the object when there is an existing database row with the same identifier </p></li><li><p><code class="literal">ReplicationMode.OVERWRITE</code>: overwrites any existing database row with the same identifier </p></li><li><p><code class="literal">ReplicationMode.EXCEPTION</code>: throws an exception if there is an existing database row with the same identifier </p></li><li><p><code class="literal">ReplicationMode.LATEST_VERSION</code>: overwrites the row if its version number is earlier than the version number of the object, or ignore the object otherwise </p></li></ul></div><p>Los casos de uso para esta funcionalidad incluyen reconciliar datos ingresados en instancias diferentes de bases de datos, actualizar información de configuración de sistema durante actualizaciones de producto, deshacer cambios producidos durante transacciones no-ACID y más. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-flushing"/>10.10. Limpiando (flushing) la sesión</h2></div></div></div><p>Sometimes the <code class="literal">Session</code> will execute the SQL statements needed to synchronize the JDBC connection's state with the state of objects held in memory. This process, called <span class="emphasis"><em>flush</em></span>, occurs by default at the following points: </p><div class="itemizedlist"><ul compact="compact"><li><p>antes de algunas ejecuciones de consulta </p></li><li><p>desde <code class="literal">org.hibernate.Transaction.commit()</code> </p></li><li><p>desde <code class="literal">Session.flush()</code> </p></li></ul></div><p>The SQL statements are issued in the following order: </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>all entity insertions in the same order the corresponding objects were saved using <code class="literal">Session.save()</code> </p></li><li><p>todas las actualizaciones de entidades </p></li><li><p>todas los borrados de colecciones </p></li><li><p>todos los borrados, actualizaciones e inserciones de elementos de colección </p></li><li><p>todas las inserciones de colecciones </p></li><li><p>all entity deletions in the same order the corresponding objects were deleted using <code class="literal">Session.delete()</code> </p></li></ol></div><p>An exception is that objects using <code class="literal">native</code> ID generation are inserted when they are saved. </p><p>Except when you explicitly <code class="literal">flush()</code>, there are absolutely no guarantees about <span class="emphasis"><em>when</em></span> the <code class="literal">Session</code> executes the JDBC calls, only the <span class="emphasis"><em>order</em></span> in which they are executed. However, Hibernate does guarantee that the <code class="literal">Query.list(..)</code> will never return stale or incorrect data. </p><p>It is possible to change the default behavior so that flush occurs less frequently. The <code class="literal">FlushMode</code> class defines three different modes: only flush at commit time when the Hibernate <code class="literal">Transaction</code> API is used, flush automatically using the explained routine, or never flush unless <code class="literal">flush()</code> is called explicitly. The last mode is useful for long running units of work, where a <code class="literal">Session</code> is kept open and disconnected for a long time (see <a href="#transactions-optimistic-longsession" title="11.3.2. Sesión larga y versionado automático">Sección 11.3.2, “Sesión larga y versionado automático”</a>). </p><pre class="programlisting">sess = sf.openSession();
Transaction tx = sess.beginTransaction();
sess.setFlushMode(FlushMode.COMMIT); // allow queries to return stale state

Cat izi = (Cat) sess.load(Cat.class, id);
izi.setName(iznizi);

// might return stale data
sess.find("from Cat as cat left outer join cat.kittens kitten");

// change to izi is not flushed!
...
tx.commit(); // flush occurs</pre><p>Durante la limpieza, puede ocurrir una excepción (por ejemplo, si una operación DML violase una restricción). Ya que el manejo de excepciones implica alguna comprensión del comportamiento transaccional de Hibernate, lo discutimos en <a href="#transactions" title="Capítulo 11. Transactions and Concurrency">Capítulo 11, <i xmlns:xlink="http://www.w3.org/1999/xlink">Transactions and Concurrency</i></a>. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-transitive"/>10.11. Persistencia transitiva</h2></div></div></div><p>Es absolutamente incómodo dalvar, borrar, o reunir objetos individuales, especialmente si tratas con un grafo de objetos asociados. Un caso común es una relación padre/hijo. Considera el siguiente ejemplo: </p><p>If the children in a parent/child relationship would be value typed (e.g. a collection of addresses or strings), their life cycle would depend on the parent and no further action would be required for convenient "cascading" of state changes. When the parent is saved, the value-typed child objects are saved and when the parent is deleted, the children will be deleted, etc. This works for operations such as the removal of a child from the collection. Since value-typed objects cannot have shared references, Hibernate will detect this and delete the child from the database. </p><p>Now consider the same scenario with parent and child objects being entities, not value-types (e.g. categories and items, or parent and child cats). Entities have their own life cycle and support shared references. Removing an entity from the collection does not mean it can be deleted), and there is by default no cascading of state from one entity to any other associated entities. Hibernate does not implement <span class="emphasis"><em>persistence by reachability</em></span> by default. </p><p>Para cada operación básica de la sesión de Hibernate - incluyendo <code class="literal">persist(), merge(), saveOrUpdate(), delete(), lock(), refresh(), evict(), replicate()</code> - hay un estilo de cascada correspondiente. Respectivamente, los estilos de cascada se llaman <code class="literal">create, merge, save-update, delete, lock, refresh, evict, replicate</code>. Si quieres que una operación sea tratada en cascada a lo largo de una asociación, debes indicar eso en el documento de mapeo. Por ejemplo: </p><pre class="programlisting">&lt;one-to-one name="person" cascade="persist"/&gt;</pre><p>Los estilos de cascada pueden combinarse: </p><pre class="programlisting">&lt;one-to-one name="person" cascade="persist,delete,lock"/&gt;</pre><p>You can even use <code class="literal">cascade="all"</code> to specify that <span class="emphasis"><em>all</em></span> operations should be cascaded along the association. The default <code class="literal">cascade="none"</code> specifies that no operations are to be cascaded. </p><p>Un estilo de cascada especial, <code class="literal">delete-orphan</code>, se aplica sólo a asociaciones uno-a-muchos, e indica que la operación <code class="literal">delete()</code> debe aplicarse a cualquier objeto hijo que sea quitado de la asociación. </p><p>Recomendaciones: </p><div class="itemizedlist"><ul compact="compact"><li><p>It does not usually make sense to enable cascade on a <code class="literal">&lt;many-to-one&gt;</code> or <code class="literal">&lt;many-to-many&gt;</code> association. Cascade is often useful for <code class="literal">&lt;one-to-one&gt;</code> and <code class="literal">&lt;one-to-many&gt;</code> associations. </p></li><li><p>Si la esperanza de vida de los objetos hijos está ligada a la eesperanza de vida del objeto padre, házlo un <span class="emphasis"><em>objeto de ciclo de vida</em></span> especificando <code class="literal">cascade="all,delete-orphan"</code>. </p></li><li><p>En otro caso, puede que no necesites tratamiento en cascada en absoluto. Pero si piensas que estarás trabajando frecuentemente con padre e hijos juntos en la misma transacción, y quieres ahorrarte algo de tipeo, considera usar <code class="literal">cascade="persist,merge,save-update"</code>. </p></li></ul></div><p>Mapear una asociación (ya sea una asociación monovaluada, o una colección) con <code class="literal">cascade="all"</code> marca la asociación como una relación del estilo <span class="emphasis"><em>padre/hijo</em></span> donde save/update/delete en el padre resulta en save/update/delete del hijo o hijos. </p><p>Furthermore, a mere reference to a child from a persistent parent will result in save/update of the child. This metaphor is incomplete, however. A child which becomes unreferenced by its parent is <span class="emphasis"><em>not</em></span> automatically deleted, except in the case of a <code class="literal">&lt;one-to-many&gt;</code> association mapped with <code class="literal">cascade="delete-orphan"</code>. The precise semantics of cascading operations for a parent/child relationship are as follows: </p><div class="itemizedlist"><ul compact="compact"><li><p>Si un padre le es pasado a <code class="literal">persist()</code>, todos los hijos le son pasados a <code class="literal">persist()</code> </p></li><li><p>Si un padre le es pasado a <code class="literal">merge()</code>, todos los hijos le son pasados a <code class="literal">merge()</code> </p></li><li><p>Si un padre le es pasado a <code class="literal">save()</code>, <code class="literal">update()</code> o <code class="literal">saveOrUpdate()</code>, todos los hijos le son pasados a <code class="literal">saveOrUpdate()</code> </p></li><li><p>Si un hijo transitorio o separado se vuelve referenciado por un padre persistente, le es pasado a <code class="literal">saveOrUpdate()</code> </p></li><li><p>Si un padre es borrado, todos los hijos le son pasados a <code class="literal">delete()</code> </p></li><li><p>Si un hijo deja de ser referenciado por un padre persistente, <span class="emphasis"><em>no ocurre nada especial</em></span> - la aplicación debe borrar explícitamente el hijo de ser necesario - a menos que <code class="literal">cascade="delete-orphan"</code>, en cuyo caso el hijo "huérfano" es borrado. </p></li></ul></div><p>Finally, note that cascading of operations can be applied to an object graph at <span class="emphasis"><em>call time</em></span> or at <span class="emphasis"><em>flush time</em></span>. All operations, if enabled, are cascaded to associated entities reachable when the operation is executed. However, <code class="literal">save-update</code> and <code class="literal">delete-orphan</code> are transitive for all associated entities reachable during flush of the <code class="literal">Session</code>. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-metadata"/>10.12. Usando metadatos</h2></div></div></div><p>Hibernate requires a rich meta-level model of all entity and value types. This model can be useful to the application itself. For example, the application might use Hibernate's metadata to implement a "smart" deep-copy algorithm that understands which objects should be copied (eg. mutable value types) and which objects that should not (e.g. immutable value types and, possibly, associated entities). </p><p>Hibernate exposes metadata via the <code class="literal">ClassMetadata</code> and <code class="literal">CollectionMetadata</code> interfaces and the <code class="literal">Type</code> hierarchy. Instances of the metadata interfaces can be obtained from the <code class="literal">SessionFactory</code>. </p><pre class="programlisting">Cat fritz = ......;
ClassMetadata catMeta = sessionfactory.getClassMetadata(Cat.class);

Object[] propertyValues = catMeta.getPropertyValues(fritz);
String[] propertyNames = catMeta.getPropertyNames();
Type[] propertyTypes = catMeta.getPropertyTypes();

// get a Map of all properties which are not collections or associations
Map namedValues = new HashMap();
for ( int i=0; i&lt;propertyNames.length; i++ ) {
    if ( !propertyTypes[i].isEntityType() &amp;&amp; !propertyTypes[i].isCollectionType() ) {
        namedValues.put( propertyNames[i], propertyValues[i] );
    }
}</pre></div></div><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="transactions"/>Capítulo 11. Transactions and Concurrency</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#transactions-basics">11.1. Ámbitos de sesión y de transacción</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-basics-uow">11.1.1. Unidad de trabajo</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-apptx">11.1.2. Transacciones de aplicación</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-identity">11.1.3. Considerando la identidad del objeto</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-issues">11.1.4. Temas comunes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-demarcation">11.2. Demarcación de la transacción de base de datos</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-demarcation-nonmanaged">11.2.1. Entorno no manejado</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-jta">11.2.2. Usando JTA</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-exceptions">11.2.3. Manejo de excepciones</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-timeout">11.2.4. Transaction timeout</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-optimistic">11.3. Control optimista de concurrencia</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-optimistic-manual">11.3.1. Chequeo de versiones de aplicación</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-longsession">11.3.2. Sesión larga y versionado automático</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-detached">11.3.3. Objetos separados y versionado automático</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-customizing">11.3.4. Personalizando el versionado automático</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-locking">11.4. Pessimistic locking</a></span></dt><dt><span class="sect1"><a href="#transactions-connection-release">11.5. Connection release modes</a></span></dt></dl></div><p>The most important point about Hibernate and concurrency control is that it is easy to understand. Hibernate directly uses JDBC connections and JTA resources without adding any additional locking behavior. It is recommended that you spend some time with the JDBC, ANSI, and transaction isolation specification of your database management system. </p><p>Hibernate does not lock objects in memory. Your application can expect the behavior as defined by the isolation level of your database transactions. Through <code class="literal">Session</code>, which is also a transaction-scoped cache, Hibernate provides repeatable reads for lookup by identifier and entity queries and not reporting queries that return scalar values. </p><p>In addition to versioning for automatic optimistic concurrency control, Hibernate also offers, using the <code class="literal">SELECT FOR UPDATE</code> syntax, a (minor) API for pessimistic locking of rows. Optimistic concurrency control and this API are discussed later in this chapter. </p><p>The discussion of concurrency control in Hibernate begins with the granularity of <code class="literal">Configuration</code>, <code class="literal">SessionFactory</code>, and <code class="literal">Session</code>, as well as database transactions and long conversations. </p><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-basics"/>11.1. Ámbitos de sesión y de transacción</h2></div></div></div><p>A <code class="literal">SessionFactory</code> is an expensive-to-create, threadsafe object, intended to be shared by all application threads. It is created once, usually on application startup, from a <code class="literal">Configuration</code> instance. </p><p>A <code class="literal">Session</code> is an inexpensive, non-threadsafe object that should be used once and then discarded for: a single request, a conversation or a single unit of work. A <code class="literal">Session</code> will not obtain a JDBC <code class="literal">Connection</code>, or a <code class="literal">Datasource</code>, unless it is needed. It will not consume any resources until used. </p><p>In order to reduce lock contention in the database, a database transaction has to be as short as possible. Long database transactions will prevent your application from scaling to a highly concurrent load. It is not recommended that you hold a database transaction open during user think time until the unit of work is complete. </p><p>What is the scope of a unit of work? Can a single Hibernate <code class="literal">Session</code> span several database transactions, or is this a one-to-one relationship of scopes? When should you open and close a <code class="literal">Session</code> and how do you demarcate the database transaction boundaries? These questions are addressed in the following sections. </p><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-uow"/>11.1.1. Unidad de trabajo</h3></div></div></div><p>First, let's define a unit of work. A unit of work is a design pattern described by Martin Fowler as “<span class="quote"> [maintaining] a list of objects affected by a business transaction and coordinates the writing out of changes and the resolution of concurrency problems. </span>”[<a href="#biblio-PoEAA"><span class="citation">PoEAA</span></a>] In other words, its a series of operations we wish to carry out against the database together. Basically, it is a transaction, though fulfilling a unit of work will often span multiple physical database transactions (see <a href="#transactions-basics-apptx" title="11.1.2. Transacciones de aplicación">Sección 11.1.2, “Transacciones de aplicación”</a>). So really we are talking about a more abstract notion of a transaction. The term "business transaction" is also sometimes used in lieu of unit of work. </p><p>Do not use the <span class="emphasis"><em>session-per-operation</em></span> antipattern: do not open and close a <code class="literal">Session</code> for every simple database call in a single thread. The same is true for database transactions. Database calls in an application are made using a planned sequence; they are grouped into atomic units of work. This also means that auto-commit after every single SQL statement is useless in an application as this mode is intended for ad-hoc SQL console work. Hibernate disables, or expects the application server to disable, auto-commit mode immediately. Database transactions are never optional. All communication with a database has to occur inside a transaction. Auto-commit behavior for reading data should be avoided, as many small transactions are unlikely to perform better than one clearly defined unit of work. The latter is also more maintainable and extensible. </p><p>The most common pattern in a multi-user client/server application is <span class="emphasis"><em>session-per-request</em></span>. In this model, a request from the client is sent to the server, where the Hibernate persistence layer runs. A new Hibernate <code class="literal">Session</code> is opened, and all database operations are executed in this unit of work. On completion of the work, and once the response for the client has been prepared, the session is flushed and closed. Use a single database transaction to serve the clients request, starting and committing it when you open and close the <code class="literal">Session</code>. The relationship between the two is one-to-one and this model is a perfect fit for many applications. </p><p>The challenge lies in the implementation. Hibernate provides built-in management of the "current session" to simplify this pattern. Start a transaction when a server request has to be processed, and end the transaction before the response is sent to the client. Common solutions are <code class="literal">ServletFilter</code>, AOP interceptor with a pointcut on the service methods, or a proxy/interception container. An EJB container is a standardized way to implement cross-cutting aspects such as transaction demarcation on EJB session beans, declaratively with CMT. If you use programmatic transaction demarcation, for ease of use and code portability use the Hibernate <code class="literal">Transaction</code> API shown later in this chapter. </p><p>Your application code can access a "current session" to process the request by calling <code class="literal">sessionFactory.getCurrentSession()</code>. You will always get a <code class="literal">Session</code> scoped to the current database transaction. This has to be configured for either resource-local or JTA environments, see <a href="#architecture-current-session" title="2.5. Contextual sessions">Sección 2.5, “Contextual sessions”</a>. </p><p>You can extend the scope of a <code class="literal">Session</code> and database transaction until the "view has been rendered". This is especially useful in servlet applications that utilize a separate rendering phase after the request has been processed. Extending the database transaction until view rendering, is achieved by implementing your own interceptor. However, this will be difficult if you rely on EJBs with container-managed transactions. A transaction will be completed when an EJB method returns, before rendering of any view can start. See the Hibernate website and forum for tips and examples relating to this <span class="emphasis"><em>Open Session in View</em></span> pattern. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-apptx"/>11.1.2. Transacciones de aplicación</h3></div></div></div><p>The session-per-request pattern is not the only way of designing units of work. Many business processes require a whole series of interactions with the user that are interleaved with database accesses. In web and enterprise applications, it is not acceptable for a database transaction to span a user interaction. Consider the following example: </p><div class="itemizedlist"><ul><li><p>The first screen of a dialog opens. The data seen by the user has been loaded in a particular <code class="literal">Session</code> and database transaction. The user is free to modify the objects. </p></li><li><p>The user clicks "Save" after 5 minutes and expects their modifications to be made persistent. The user also expects that they were the only person editing this information and that no conflicting modification has occurred. </p></li></ul></div><p>From the point of view of the user, we call this unit of work a long-running <span class="emphasis"><em>conversation</em></span> or <span class="emphasis"><em>application transaction</em></span>. There are many ways to implement this in your application. </p><p>A first naive implementation might keep the <code class="literal">Session</code> and database transaction open during user think time, with locks held in the database to prevent concurrent modification and to guarantee isolation and atomicity. This is an anti-pattern, since lock contention would not allow the application to scale with the number of concurrent users. </p><p>You have to use several database transactions to implement the conversation. In this case, maintaining isolation of business processes becomes the partial responsibility of the application tier. A single conversation usually spans several database transactions. It will be atomic if only one of these database transactions (the last one) stores the updated data. All others simply read data (for example, in a wizard-style dialog spanning several request/response cycles). This is easier to implement than it might sound, especially if you utilize some of Hibernate's features: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Automatic Versioning</em></span>: Hibernate can perform automatic optimistic concurrency control for you. It can automatically detect if a concurrent modification occurred during user think time. Check for this at the end of the conversation. </p></li><li><p><span class="emphasis"><em>Detached Objects</em></span>: if you decide to use the <span class="emphasis"><em>session-per-request</em></span> pattern, all loaded instances will be in the detached state during user think time. Hibernate allows you to reattach the objects and persist the modifications. The pattern is called <span class="emphasis"><em>session-per-request-with-detached-objects</em></span>. Automatic versioning is used to isolate concurrent modifications. </p></li><li><p><span class="emphasis"><em>Extended (or Long) Session</em></span>: the Hibernate <code class="literal">Session</code> can be disconnected from the underlying JDBC connection after the database transaction has been committed and reconnected when a new client request occurs. This pattern is known as <span class="emphasis"><em>session-per-conversation</em></span> and makes even reattachment unnecessary. Automatic versioning is used to isolate concurrent modifications and the <code class="literal">Session</code> will not be allowed to be flushed automatically, but explicitly. </p></li></ul></div><p>Both <span class="emphasis"><em>session-per-request-with-detached-objects</em></span> and <span class="emphasis"><em>session-per-conversation</em></span> have advantages and disadvantages. These disadvantages are discussed later in this chapter in the context of optimistic concurrency control. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-identity"/>11.1.3. Considerando la identidad del objeto</h3></div></div></div><p>An application can concurrently access the same persistent state in two different <code class="literal">Session</code>s. However, an instance of a persistent class is never shared between two <code class="literal">Session</code> instances. It is for this reason that there are two different notions of identity: </p><div class="variablelist"><dl><dt><span class="term">Identidad de Base de Datos</span></dt><dd><p>
                            <code class="literal">foo.getId().equals( bar.getId() )</code>
                        </p></dd><dt><span class="term">Identidad JVM</span></dt><dd><p>
                            <code class="literal">foo==bar</code>
                        </p></dd></dl></div><p>For objects attached to a <span class="emphasis"><em>particular</em></span> <code class="literal">Session</code> (i.e., in the scope of a <code class="literal">Session</code>), the two notions are equivalent and JVM identity for database identity is guaranteed by Hibernate. While the application might concurrently access the "same" (persistent identity) business object in two different sessions, the two instances will actually be "different" (JVM identity). Conflicts are resolved using an optimistic approach and automatic versioning at flush/commit time. </p><p>This approach leaves Hibernate and the database to worry about concurrency. It also provides the best scalability, since guaranteeing identity in single-threaded units of work means that it does not need expensive locking or other means of synchronization. The application does not need to synchronize on any business object, as long as it maintains a single thread per <code class="literal">Session</code>. Within a <code class="literal">Session</code> the application can safely use <code class="literal">==</code> to compare objects. </p><p>However, an application that uses <code class="literal">==</code> outside of a <code class="literal">Session</code> might produce unexpected results. This might occur even in some unexpected places. For example, if you put two detached instances into the same <code class="literal">Set</code>, both might have the same database identity (i.e., they represent the same row). JVM identity, however, is by definition not guaranteed for instances in a detached state. The developer has to override the <code class="literal">equals()</code> and <code class="literal">hashCode()</code> methods in persistent classes and implement their own notion of object equality. There is one caveat: never use the database identifier to implement equality. Use a business key that is a combination of unique, usually immutable, attributes. The database identifier will change if a transient object is made persistent. If the transient instance (usually together with detached instances) is held in a <code class="literal">Set</code>, changing the hashcode breaks the contract of the <code class="literal">Set</code>. Attributes for business keys do not have to be as stable as database primary keys; you only have to guarantee stability as long as the objects are in the same <code class="literal">Set</code>. See the Hibernate website for a more thorough discussion of this issue. Please note that this is not a Hibernate issue, but simply how Java object identity and equality has to be implemented. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-issues"/>11.1.4. Temas comunes</h3></div></div></div><p>Do not use the anti-patterns <span class="emphasis"><em>session-per-user-session</em></span> or <span class="emphasis"><em>session-per-application</em></span> (there are, however, rare exceptions to this rule). Some of the following issues might also arise within the recommended patterns, so ensure that you understand the implications before making a design decision: </p><div class="itemizedlist"><ul><li><p>A <code class="literal">Session</code> is not thread-safe. Things that work concurrently, like HTTP requests, session beans, or Swing workers, will cause race conditions if a <code class="literal">Session</code> instance is shared. If you keep your Hibernate <code class="literal">Session</code> in your <code class="literal">HttpSession</code> (this is discussed later in the chapter), you should consider synchronizing access to your Http session. Otherwise, a user that clicks reload fast enough can use the same <code class="literal">Session</code> in two concurrently running threads. </p></li><li><p>An exception thrown by Hibernate means you have to rollback your database transaction and close the <code class="literal">Session</code> immediately (this is discussed in more detail later in the chapter). If your <code class="literal">Session</code> is bound to the application, you have to stop the application. Rolling back the database transaction does not put your business objects back into the state they were at the start of the transaction. This means that the database state and the business objects will be out of sync. Usually this is not a problem, because exceptions are not recoverable and you will have to start over after rollback anyway. </p></li><li><p>The <code class="literal">Session</code> caches every object that is in a persistent state (watched and checked for dirty state by Hibernate). If you keep it open for a long time or simply load too much data, it will grow endlessly until you get an OutOfMemoryException. One solution is to call <code class="literal">clear()</code> and <code class="literal">evict()</code> to manage the <code class="literal">Session</code> cache, but you should consider a Stored Procedure if you need mass data operations. Some solutions are shown in <a href="#batch" title="Capítulo 13. Procesamiento por lotes">Capítulo 13, <i xmlns:xlink="http://www.w3.org/1999/xlink">Procesamiento por lotes</i></a>. Keeping a <code class="literal">Session</code> open for the duration of a user session also means a higher probability of stale data. </p></li></ul></div></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-demarcation"/>11.2. Demarcación de la transacción de base de datos</h2></div></div></div><p>Database, or system, transaction boundaries are always necessary. No communication with the database can occur outside of a database transaction (this seems to confuse many developers who are used to the auto-commit mode). Always use clear transaction boundaries, even for read-only operations. Depending on your isolation level and database capabilities this might not be required, but there is no downside if you always demarcate transactions explicitly. Certainly, a single database transaction is going to perform better than many small transactions, even for reading data. </p><p>A Hibernate application can run in non-managed (i.e., standalone, simple Web- or Swing applications) and managed J2EE environments. In a non-managed environment, Hibernate is usually responsible for its own database connection pool. The application developer has to manually set transaction boundaries (begin, commit, or rollback database transactions) themselves. A managed environment usually provides container-managed transactions (CMT), with the transaction assembly defined declaratively (in deployment descriptors of EJB session beans, for example). Programmatic transaction demarcation is then no longer necessary. </p><p>However, it is often desirable to keep your persistence layer portable between non-managed resource-local environments, and systems that can rely on JTA but use BMT instead of CMT. In both cases use programmatic transaction demarcation. Hibernate offers a wrapper API called <code class="literal">Transaction</code> that translates into the native transaction system of your deployment environment. This API is actually optional, but we strongly encourage its use unless you are in a CMT session bean. </p><p>Ending a <code class="literal">Session</code> usually involves four distinct phases: </p><div class="itemizedlist"><ul compact="compact"><li><p>limpiar (flush) la sesión </p></li><li><p>comprometer la transacción </p></li><li><p>cerrar la sesión </p></li><li><p>manejar excepciones </p></li></ul></div><p>We discussed Flushing the session earlier, so we will now have a closer look at transaction demarcation and exception handling in both managed and non-managed environments. </p><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-nonmanaged"/>11.2.1. Entorno no manejado</h3></div></div></div><p>If a Hibernate persistence layer runs in a non-managed environment, database connections are usually handled by simple (i.e., non-DataSource) connection pools from which Hibernate obtains connections as needed. The session/transaction handling idiom looks like this: </p><pre class="programlisting">// Non-managed environment idiom
Session sess = factory.openSession();
Transaction tx = null;
try {
    tx = sess.beginTransaction();

    // do some work
    ...

    tx.commit();
}
catch (RuntimeException e) {
    if (tx != null) tx.rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}</pre><p>You do not have to <code class="literal">flush()</code> the <code class="literal">Session</code> explicitly: the call to <code class="literal">commit()</code> automatically triggers the synchronization depending on the <a href="#objectstate-flushing" title="10.10. Limpiando (flushing) la sesión">FlushMode</a> for the session. A call to <code class="literal">close()</code> marks the end of a session. The main implication of <code class="literal">close()</code> is that the JDBC connection will be relinquished by the session. This Java code is portable and runs in both non-managed and JTA environments. </p><p>As outlined earlier, a much more flexible solution is Hibernate's built-in "current session" context management: </p><pre class="programlisting">// Non-managed environment idiom with getCurrentSession()
try {
    factory.getCurrentSession().beginTransaction();

    // do some work
    ...

    factory.getCurrentSession().getTransaction().commit();
}
catch (RuntimeException e) {
    factory.getCurrentSession().getTransaction().rollback();
    throw e; // or display error message
}</pre><p>You will not see these code snippets in a regular application; fatal (system) exceptions should always be caught at the "top". In other words, the code that executes Hibernate calls in the persistence layer, and the code that handles <code class="literal">RuntimeException</code> (and usually can only clean up and exit), are in different layers. The current context management by Hibernate can significantly simplify this design by accessing a <code class="literal">SessionFactory</code>. Exception handling is discussed later in this chapter. </p><p>You should select <code class="literal">org.hibernate.transaction.JDBCTransactionFactory</code>, which is the default, and for the second example select <code class="literal">"thread"</code> as your <code class="literal">hibernate.current_session_context_class</code>. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-jta"/>11.2.2. Usando JTA</h3></div></div></div><p>If your persistence layer runs in an application server (for example, behind EJB session beans), every datasource connection obtained by Hibernate will automatically be part of the global JTA transaction. You can also install a standalone JTA implementation and use it without EJB. Hibernate offers two strategies for JTA integration. </p><p>If you use bean-managed transactions (BMT), Hibernate will tell the application server to start and end a BMT transaction if you use the <code class="literal">Transaction</code> API. The transaction management code is identical to the non-managed environment. </p><pre class="programlisting">// BMT idiom
Session sess = factory.openSession();
Transaction tx = null;
try {
    tx = sess.beginTransaction();

    // do some work
    ...

    tx.commit();
}
catch (RuntimeException e) {
    if (tx != null) tx.rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}</pre><p>If you want to use a transaction-bound <code class="literal">Session</code>, that is, the <code class="literal">getCurrentSession()</code> functionality for easy context propagation, use the JTA <code class="literal">UserTransaction</code> API directly: </p><pre class="programlisting">// BMT idiom with getCurrentSession()
try {
    UserTransaction tx = (UserTransaction)new InitialContext()
                            .lookup("java:comp/UserTransaction");

    tx.begin();

    // Do some work on Session bound to transaction
    factory.getCurrentSession().load(...);
    factory.getCurrentSession().persist(...);

    tx.commit();
}
catch (RuntimeException e) {
    tx.rollback();
    throw e; // or display error message
}</pre><p>With CMT, transaction demarcation is completed in session bean deployment descriptors, not programmatically. The code is reduced to: </p><pre class="programlisting">// CMT idiom
 Session sess = factory.getCurrentSession();

 // do some work
 ...
</pre><p>In a CMT/EJB, even rollback happens automatically. An unhandled <code class="literal">RuntimeException</code> thrown by a session bean method tells the container to set the global transaction to rollback. <span class="emphasis"><em>You do not need to use the Hibernate <code class="literal">Transaction</code> API at all with BMT or CMT, and you get automatic propagation of the "current" Session bound to the transaction.</em></span> </p><p>When configuring Hibernate's transaction factory, choose <code class="literal">org.hibernate.transaction.JTATransactionFactory</code> if you use JTA directly (BMT), and <code class="literal">org.hibernate.transaction.CMTTransactionFactory</code> in a CMT session bean. Remember to also set <code class="literal">hibernate.transaction.manager_lookup_class</code>. Ensure that your <code class="literal">hibernate.current_session_context_class</code> is either unset (backwards compatibility), or is set to <code class="literal">"jta"</code>. </p><p>The <code class="literal">getCurrentSession()</code> operation has one downside in a JTA environment. There is one caveat to the use of <code class="literal">after_statement</code> connection release mode, which is then used by default. Due to a limitation of the JTA spec, it is not possible for Hibernate to automatically clean up any unclosed <code class="literal">ScrollableResults</code> or <code class="literal">Iterator</code> instances returned by <code class="literal">scroll()</code> or <code class="literal">iterate()</code>. You <span class="emphasis"><em>must</em></span> release the underlying database cursor by calling <code class="literal">ScrollableResults.close()</code> or <code class="literal">Hibernate.close(Iterator)</code> explicitly from a <code class="literal">finally</code> block. Most applications can easily avoid using <code class="literal">scroll()</code> or <code class="literal">iterate()</code> from the JTA or CMT code.) </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-exceptions"/>11.2.3. Manejo de excepciones</h3></div></div></div><p>If the <code class="literal">Session</code> throws an exception, including any <code class="literal">SQLException</code>, immediately rollback the database transaction, call <code class="literal">Session.close()</code> and discard the <code class="literal">Session</code> instance. Certain methods of <code class="literal">Session</code> will <span class="emphasis"><em>not</em></span> leave the session in a consistent state. No exception thrown by Hibernate can be treated as recoverable. Ensure that the <code class="literal">Session</code> will be closed by calling <code class="literal">close()</code> in a <code class="literal">finally</code> block. </p><p>The <code class="literal">HibernateException</code>, which wraps most of the errors that can occur in a Hibernate persistence layer, is an unchecked exception. It was not in older versions of Hibernate. In our opinion, we should not force the application developer to catch an unrecoverable exception at a low layer. In most systems, unchecked and fatal exceptions are handled in one of the first frames of the method call stack (i.e., in higher layers) and either an error message is presented to the application user or some other appropriate action is taken. Note that Hibernate might also throw other unchecked exceptions that are not a <code class="literal">HibernateException</code>. These are not recoverable and appropriate action should be taken. </p><p>Hibernate wraps <code class="literal">SQLException</code>s thrown while interacting with the database in a <code class="literal">JDBCException</code>. In fact, Hibernate will attempt to convert the exception into a more meaningful subclass of <code class="literal">JDBCException</code>. The underlying <code class="literal">SQLException</code> is always available via <code class="literal">JDBCException.getCause()</code>. Hibernate converts the <code class="literal">SQLException</code> into an appropriate <code class="literal">JDBCException</code> subclass using the <code class="literal">SQLExceptionConverter</code> attached to the <code class="literal">SessionFactory</code>. By default, the <code class="literal">SQLExceptionConverter</code> is defined by the configured dialect. However, it is also possible to plug in a custom implementation. See the javadocs for the <code class="literal">SQLExceptionConverterFactory</code> class for details. The standard <code class="literal">JDBCException</code> subtypes are: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">JDBCConnectionException</code>: indicates an error with the underlying JDBC communication. </p></li><li><p><code class="literal">SQLGrammarException</code>: indicates a grammar or syntax problem with the issued SQL. </p></li><li><p><code class="literal">ConstraintViolationException</code>: indicates some form of integrity constraint violation. </p></li><li><p><code class="literal">LockAcquisitionException</code>: indicates an error acquiring a lock level necessary to perform the requested operation. </p></li><li><p><code class="literal">GenericJDBCException</code>: a generic exception which did not fall into any of the other categories. </p></li></ul></div></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-timeout"/>11.2.4. Transaction timeout</h3></div></div></div><p>An important feature provided by a managed environment like EJB, that is never provided for non-managed code, is transaction timeout. Transaction timeouts ensure that no misbehaving transaction can indefinitely tie up resources while returning no response to the user. Outside a managed (JTA) environment, Hibernate cannot fully provide this functionality. However, Hibernate can at least control data access operations, ensuring that database level deadlocks and queries with huge result sets are limited by a defined timeout. In a managed environment, Hibernate can delegate transaction timeout to JTA. This functionality is abstracted by the Hibernate <code class="literal">Transaction</code> object. </p><pre class="programlisting">
Session sess = factory.openSession();
try {
    //set transaction timeout to 3 seconds
    sess.getTransaction().setTimeout(3);
    sess.getTransaction().begin();

    // do some work
    ...

    sess.getTransaction().commit()
}
catch (RuntimeException e) {
    sess.getTransaction().rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}</pre><p><code class="literal">setTimeout()</code> cannot be called in a CMT bean, where transaction timeouts must be defined declaratively. </p></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-optimistic"/>11.3. Control optimista de concurrencia</h2></div></div></div><p>The only approach that is consistent with high concurrency and high scalability, is optimistic concurrency control with versioning. Version checking uses version numbers, or timestamps, to detect conflicting updates and to prevent lost updates. Hibernate provides three possible approaches to writing application code that uses optimistic concurrency. The use cases we discuss are in the context of long conversations, but version checking also has the benefit of preventing lost updates in single database transactions. </p><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-manual"/>11.3.1. Chequeo de versiones de aplicación</h3></div></div></div><p>In an implementation without much help from Hibernate, each interaction with the database occurs in a new <code class="literal">Session</code> and the developer is responsible for reloading all persistent instances from the database before manipulating them. The application is forced to carry out its own version checking to ensure conversation transaction isolation. This approach is the least efficient in terms of database access. It is the approach most similar to entity EJBs. </p><pre class="programlisting">// foo is an instance loaded by a previous Session
session = factory.openSession();
Transaction t = session.beginTransaction();

int oldVersion = foo.getVersion();
session.load( foo, foo.getKey() ); // load the current state
if ( oldVersion != foo.getVersion() ) throw new StaleObjectStateException();
foo.setProperty("bar");

t.commit();
session.close();</pre><p>La propiedad <code class="literal">version</code> se mapea usando <code class="literal">&lt;version&gt;</code>, e Hibernate la incrementará automáticamente durante la limpieza si la entidad está sucia. </p><p>If you are operating in a low-data-concurrency environment, and do not require version checking, you can use this approach and skip the version check. In this case, <span class="emphasis"><em>last commit wins</em></span> is the default strategy for long conversations. Be aware that this might confuse the users of the application, as they might experience lost updates without error messages or a chance to merge conflicting changes. </p><p>Manual version checking is only feasible in trivial circumstances and not practical for most applications. Often not only single instances, but complete graphs of modified objects, have to be checked. Hibernate offers automatic version checking with either an extended <code class="literal">Session</code> or detached instances as the design paradigm. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-longsession"/>11.3.2. Sesión larga y versionado automático</h3></div></div></div><p>A single <code class="literal">Session</code> instance and its persistent instances that are used for the whole conversation are known as <span class="emphasis"><em>session-per-conversation</em></span>. Hibernate checks instance versions at flush time, throwing an exception if concurrent modification is detected. It is up to the developer to catch and handle this exception. Common options are the opportunity for the user to merge changes or to restart the business conversation with non-stale data. </p><p>The <code class="literal">Session</code> is disconnected from any underlying JDBC connection when waiting for user interaction. This approach is the most efficient in terms of database access. The application does not version check or reattach detached instances, nor does it have to reload instances in every database transaction. </p><pre class="programlisting">// foo is an instance loaded earlier by the old session
Transaction t = session.beginTransaction(); // Obtain a new JDBC connection, start transaction

foo.setProperty("bar");

session.flush();    // Only for last transaction in conversation
t.commit();         // Also return JDBC connection
session.close();    // Only for last transaction in conversation</pre><p>The <code class="literal">foo</code> object knows which <code class="literal">Session</code> it was loaded in. Beginning a new database transaction on an old session obtains a new connection and resumes the session. Committing a database transaction disconnects a session from the JDBC connection and returns the connection to the pool. After reconnection, to force a version check on data you are not updating, you can call <code class="literal">Session.lock()</code> with <code class="literal">LockMode.READ</code> on any objects that might have been updated by another transaction. You do not need to lock any data that you <span class="emphasis"><em>are</em></span> updating. Usually you would set <code class="literal">FlushMode.MANUAL</code> on an extended <code class="literal">Session</code>, so that only the last database transaction cycle is allowed to actually persist all modifications made in this conversation. Only this last database transaction will include the <code class="literal">flush()</code> operation, and then <code class="literal">close()</code> the session to end the conversation. </p><p>This pattern is problematic if the <code class="literal">Session</code> is too big to be stored during user think time (for example, an <code class="literal">HttpSession</code> should be kept as small as possible). As the <code class="literal">Session</code> is also the first-level cache and contains all loaded objects, we can probably use this strategy only for a few request/response cycles. Use a <code class="literal">Session</code> only for a single conversation as it will soon have stale data. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Earlier versions of Hibernate required explicit disconnection and reconnection of a <code class="literal">Session</code>. These methods are deprecated, as beginning and ending a transaction has the same effect. </p></div><p>Keep the disconnected <code class="literal">Session</code> close to the persistence layer. Use an EJB stateful session bean to hold the <code class="literal">Session</code> in a three-tier environment. Do not transfer it to the web layer, or even serialize it to a separate tier, to store it in the <code class="literal">HttpSession</code>. </p><p>The extended session pattern, or <span class="emphasis"><em>session-per-conversation</em></span>, is more difficult to implement with automatic current session context management. You need to supply your own implementation of the <code class="literal">CurrentSessionContext</code> for this. See the Hibernate Wiki for examples. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-detached"/>11.3.3. Objetos separados y versionado automático</h3></div></div></div><p>Cada interacción con el almacén persistente ocurre en una nueva <code class="literal">Session</code>. Sin embargo, las mismas instancias persistentes son reusadas para cada interacción con la base de datos. La aplicación manipula el estado de las instancias separadas originalmente cargadas en otra <code class="literal">Session</code> y luego las readjunta usando <code class="literal">Session.update()</code>, <code class="literal">Session.saveOrUpdate()</code>, o <code class="literal">Session.merge()</code>. </p><pre class="programlisting">// foo is an instance loaded by a previous Session
foo.setProperty("bar");
session = factory.openSession();
Transaction t = session.beginTransaction();
session.saveOrUpdate(foo); // Use merge() if "foo" might have been loaded already
t.commit();
session.close();</pre><p>Again, Hibernate will check instance versions during flush, throwing an exception if conflicting updates occurred. </p><p>You can also call <code class="literal">lock()</code> instead of <code class="literal">update()</code>, and use <code class="literal">LockMode.READ</code> (performing a version check and bypassing all caches) if you are sure that the object has not been modified. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-customizing"/>11.3.4. Personalizando el versionado automático</h3></div></div></div><p>You can disable Hibernate's automatic version increment for particular properties and collections by setting the <code class="literal">optimistic-lock</code> mapping attribute to <code class="literal">false</code>. Hibernate will then no longer increment versions if the property is dirty. </p><p>Legacy database schemas are often static and cannot be modified. Or, other applications might access the same database and will not know how to handle version numbers or even timestamps. In both cases, versioning cannot rely on a particular column in a table. To force a version check with a comparison of the state of all fields in a row but without a version or timestamp property mapping, turn on <code class="literal">optimistic-lock="all"</code> in the <code class="literal">&lt;class&gt;</code> mapping. This conceptually only works if Hibernate can compare the old and the new state (i.e., if you use a single long <code class="literal">Session</code> and not session-per-request-with-detached-objects). </p><p>Concurrent modification can be permitted in instances where the changes that have been made do not overlap. If you set <code class="literal">optimistic-lock="dirty"</code> when mapping the <code class="literal">&lt;class&gt;</code>, Hibernate will only compare dirty fields during flush. </p><p>In both cases, with dedicated version/timestamp columns or with a full/dirty field comparison, Hibernate uses a single <code class="literal">UPDATE</code> statement, with an appropriate <code class="literal">WHERE</code> clause, per entity to execute the version check and update the information. If you use transitive persistence to cascade reattachment to associated entities, Hibernate may execute unnecessary updates. This is usually not a problem, but <span class="emphasis"><em>on update</em></span> triggers in the database might be executed even when no changes have been made to detached instances. You can customize this behavior by setting <code class="literal">select-before-update="true"</code> in the <code class="literal">&lt;class&gt;</code> mapping, forcing Hibernate to <code class="literal">SELECT</code> the instance to ensure that changes did occur before updating the row. </p></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-locking"/>11.4. Pessimistic locking</h2></div></div></div><p>It is not intended that users spend much time worrying about locking strategies. It is usually enough to specify an isolation level for the JDBC connections and then simply let the database do all the work. However, advanced users may wish to obtain exclusive pessimistic locks or re-obtain locks at the start of a new transaction. </p><p>Hibernate will always use the locking mechanism of the database; it never lock objects in memory. </p><p>The <code class="literal">LockMode</code> class defines the different lock levels that can be acquired by Hibernate. A lock is obtained by the following mechanisms: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">LockMode.WRITE</code> se adquiere automáticamente cuando Hibernate actualiza o inserta una fila. </p></li><li><p><code class="literal">LockMode.UPGRADE</code> can be acquired upon explicit user request using <code class="literal">SELECT ... FOR UPDATE</code> on databases which support that syntax. </p></li><li><p><code class="literal">LockMode.UPGRADE_NOWAIT</code> can be acquired upon explicit user request using a <code class="literal">SELECT ... FOR UPDATE NOWAIT</code> under Oracle. </p></li><li><p><code class="literal">LockMode.READ</code> is acquired automatically when Hibernate reads data under Repeatable Read or Serializable isolation level. It can be re-acquired by explicit user request. </p></li><li><p><code class="literal">LockMode.NONE</code> representa la ausencia de un bloqueo. Todos los objetos se pasan a este modo de bloqueo al final de una <code class="literal">Transaction</code>. Los objetos asociados con una sesión vía una llamada a <code class="literal">update()</code> o <code class="literal">saveOrUpdate()</code> también comienzan en este modo de bloqueo. </p></li></ul></div><p>La "petición explícita del usuario" se expresa en una de las siguientes formas: </p><div class="itemizedlist"><ul compact="compact"><li><p>Una llamada a <code class="literal">Session.load()</code>, especificando un <code class="literal">LockMode</code>. </p></li><li><p>Una llamada a <code class="literal">Session.lock()</code>. </p></li><li><p>Una llamada a <code class="literal">Query.setLockMode()</code>. </p></li></ul></div><p>Si se llama a <code class="literal">Session.load()</code> con <code class="literal">UPGRADE</code> o <code class="literal">UPGRADE_NOWAIT</code>, y el objeto pedido no ha sido aún cargado por la sesión, el objeto es cargado usando <code class="literal">SELECT ... FOR UPDATE</code>. Si se llama a <code class="literal">load()</code> para un objeto que ya esté cargado con un bloqueo menos restrictivo que el pedido, Hibernate llama a <code class="literal">lock()</code> para ese objeto. </p><p><code class="literal">Session.lock()</code> performs a version number check if the specified lock mode is <code class="literal">READ</code>, <code class="literal">UPGRADE</code> or <code class="literal">UPGRADE_NOWAIT</code>. In the case of <code class="literal">UPGRADE</code> or <code class="literal">UPGRADE_NOWAIT</code>, <code class="literal">SELECT ... FOR UPDATE</code> is used. </p><p>If the requested lock mode is not supported by the database, Hibernate uses an appropriate alternate mode instead of throwing an exception. This ensures that applications are portable. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-connection-release"/>11.5. Connection release modes</h2></div></div></div><p>One of the legacies of Hibernate 2.x JDBC connection management meant that a <code class="literal">Session</code> would obtain a connection when it was first required and then maintain that connection until the session was closed. Hibernate 3.x introduced the notion of connection release modes that would instruct a session how to handle its JDBC connections. The following discussion is pertinent only to connections provided through a configured <code class="literal">ConnectionProvider</code>. User-supplied connections are outside the breadth of this discussion. The different release modes are identified by the enumerated values of <code class="literal">org.hibernate.ConnectionReleaseMode</code>: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">ON_CLOSE</code>: is the legacy behavior described above. The Hibernate session obtains a connection when it first needs to perform some JDBC access and maintains that connection until the session is closed. </p></li><li><p><code class="literal">AFTER_TRANSACTION</code>: releases connections after a <code class="literal">org.hibernate.Transaction</code> has been completed. </p></li><li><p><code class="literal">AFTER_STATEMENT</code> (also referred to as aggressive release): releases connections after every statement execution. This aggressive releasing is skipped if that statement leaves open resources associated with the given session. Currently the only situation where this occurs is through the use of <code class="literal">org.hibernate.ScrollableResults</code>. </p></li></ul></div><p>The configuration parameter <code class="literal">hibernate.connection.release_mode</code> is used to specify which release mode to use. The possible values are as follows: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">auto</code> (the default): this choice delegates to the release mode returned by the <code class="literal">org.hibernate.transaction.TransactionFactory.getDefaultReleaseMode()</code> method. For JTATransactionFactory, this returns ConnectionReleaseMode.AFTER_STATEMENT; for JDBCTransactionFactory, this returns ConnectionReleaseMode.AFTER_TRANSACTION. Do not change this default behavior as failures due to the value of this setting tend to indicate bugs and/or invalid assumptions in user code. </p></li><li><p><code class="literal">on_close</code>: uses ConnectionReleaseMode.ON_CLOSE. This setting is left for backwards compatibility, but its use is discouraged. </p></li><li><p><code class="literal">after_transaction</code>: uses ConnectionReleaseMode.AFTER_TRANSACTION. This setting should not be used in JTA environments. Also note that with ConnectionReleaseMode.AFTER_TRANSACTION, if a session is considered to be in auto-commit mode, connections will be released as if the release mode were AFTER_STATEMENT. </p></li><li><p><code class="literal">after_statement</code>: uses ConnectionReleaseMode.AFTER_STATEMENT. Additionally, the configured <code class="literal">ConnectionProvider</code> is consulted to see if it supports this setting (<code class="literal">supportsAggressiveRelease()</code>). If not, the release mode is reset to ConnectionReleaseMode.AFTER_TRANSACTION. This setting is only safe in environments where we can either re-acquire the same underlying JDBC connection each time you make a call into <code class="literal">ConnectionProvider.getConnection()</code> or in auto-commit environments where it does not matter if we re-establish the same connection. </p></li></ul></div></div></div><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="events"/>Capítulo 12. Interceptores y eventos</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#objectstate-interceptors">12.1. Interceptores</a></span></dt><dt><span class="sect1"><a href="#objectstate-events">12.2. Sistema de eventos</a></span></dt><dt><span class="sect1"><a href="#objectstate-decl-security">12.3. Seguridad declarativa de Hibernate</a></span></dt></dl></div><p>It is useful for the application to react to certain events that occur inside Hibernate. This allows for the implementation of generic functionality and the extension of Hibernate functionality. </p><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-interceptors"/>12.1. Interceptores</h2></div></div></div><p>The <code class="literal">Interceptor</code> interface provides callbacks from the session to the application, allowing the application to inspect and/or manipulate properties of a persistent object before it is saved, updated, deleted or loaded. One possible use for this is to track auditing information. For example, the following <code class="literal">Interceptor</code> automatically sets the <code class="literal">createTimestamp</code> when an <code class="literal">Auditable</code> is created and updates the <code class="literal">lastUpdateTimestamp</code> property when an <code class="literal">Auditable</code> is updated. </p><p>You can either implement <code class="literal">Interceptor</code> directly or extend <code class="literal">EmptyInterceptor</code>. </p><pre class="programlisting">package org.hibernate.test;

import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;

import org.hibernate.Interceptor;
import org.hibernate.type.Type;

public class AuditInterceptor implements Interceptor, Serializable {

    private int updates;
    private int creates;

    public void onDelete(Object entity,
                         Serializable id,
                         Object[] state,
                         String[] propertyNames,
                         Type[] types) {
        // do nothing
    }

    public boolean onFlushDirty(Object entity,
                                Serializable id,
                                Object[] currentState,
                                Object[] previousState,
                                String[] propertyNames,
                                Type[] types) {

        if ( entity instanceof Auditable ) {
            updates++;
            for ( int i=0; i &lt; propertyNames.length; i++ ) {
                if ( "lastUpdateTimestamp".equals( propertyNames[i] ) ) {
                    currentState[i] = new Date();
                    return true;
                }
            }
        }
        return false;
    }

    public boolean onLoad(Object entity,
                          Serializable id,
                          Object[] state,
                          String[] propertyNames,
                          Type[] types) {
        return false;
    }

    public boolean onSave(Object entity,
                          Serializable id,
                          Object[] state,
                          String[] propertyNames,
                          Type[] types) {

        if ( entity instanceof Auditable ) {
            creates++;
            for ( int i=0; i&lt;propertyNames.length; i++ ) {
                if ( "createTimestamp".equals( propertyNames[i] ) ) {
                    state[i] = new Date();
                    return true;
                }
            }
        }
        return false;
    }

    public void postFlush(Iterator entities) {
        System.out.println("Creations: " + creates + ", Updates: " + updates);
    }

    public void preFlush(Iterator entities) {
        updates=0;
        creates=0;
    }

    ...

}</pre><p>There are two kinds of inteceptors: <code class="literal">Session</code>-scoped and <code class="literal">SessionFactory</code>-scoped. </p><p>UNTRANSLATED! A <code class="literal">Session</code>-scoped interceptor is specified when a session is opened using one of the overloaded SessionFactory.openSession() methods accepting an <code class="literal">Interceptor</code>. </p><pre class="programlisting">Session session = sf.openSession( new AuditInterceptor() );</pre><p>A <code class="literal">SessionFactory</code>-scoped interceptor is registered with the <code class="literal">Configuration</code> object prior to building the <code class="literal">SessionFactory</code>. Unless a session is opened explicitly specifying the interceptor to use, the supplied interceptor will be applied to all sessions opened from that <code class="literal">SessionFactory</code>. <code class="literal">SessionFactory</code>-scoped interceptors must be thread safe. Ensure that you do not store session-specific states, since multiple sessions will use this interceptor potentially concurrently. </p><pre class="programlisting">new Configuration().setInterceptor( new AuditInterceptor() );</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-events"/>12.2. Sistema de eventos</h2></div></div></div><p>If you have to react to particular events in your persistence layer, you can also use the Hibernate3 <span class="emphasis"><em>event</em></span> architecture. The event system can be used in addition, or as a replacement, for interceptors. </p><p>All the methods of the <code class="literal">Session</code> interface correlate to an event. You have a <code class="literal">LoadEvent</code>, a <code class="literal">FlushEvent</code>, etc. Consult the XML configuration-file DTD or the <code class="literal">org.hibernate.event</code> package for the full list of defined event types. When a request is made of one of these methods, the Hibernate <code class="literal">Session</code> generates an appropriate event and passes it to the configured event listeners for that type. Out-of-the-box, these listeners implement the same processing in which those methods always resulted. However, you are free to implement a customization of one of the listener interfaces (i.e., the <code class="literal">LoadEvent</code> is processed by the registered implementation of the <code class="literal">LoadEventListener</code> interface), in which case their implementation would be responsible for processing any <code class="literal">load()</code> requests made of the <code class="literal">Session</code>. </p><p>The listeners should be considered singletons. This means they are shared between requests, and should not save any state as instance variables. </p><p>A custom listener implements the appropriate interface for the event it wants to process and/or extend one of the convenience base classes (or even the default event listeners used by Hibernate out-of-the-box as these are declared non-final for this purpose). Custom listeners can either be registered programmatically through the <code class="literal">Configuration</code> object, or specified in the Hibernate configuration XML. Declarative configuration through the properties file is not supported. Here is an example of a custom load event listener: </p><pre class="programlisting">public class MyLoadListener extends DefaultLoadEventListener {
    // this is the single method defined by the LoadEventListener interface
    public Object onLoad(LoadEvent event, LoadEventListener.LoadType loadType)
            throws HibernateException {
        if ( !MySecurity.isAuthorized( event.getEntityClassName(), event.getEntityId() ) ) {
            throw MySecurityException("Unauthorized access");
        }
        return super.onLoad(event, loadType);
    }
}</pre><p>Necesitas además una entrada de configuración diciéndole a Hibernate que use el oyente en vez del oyente por defecto: </p><pre class="programlisting">&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
        ...
        &lt;listener type="load" class="MyLoadListener"/&gt;
    &lt;/session-factory&gt;
&lt;/hibernate-configuration
&gt;</pre><p>Instead, you can register it programmatically: </p><pre class="programlisting">Configuration cfg = new Configuration();
cfg.getSessionEventListenerConfig().setLoadEventListener( new MyLoadListener() );</pre><p>Listeners registered declaratively cannot share instances. If the same class name is used in multiple <code class="literal">&lt;listener/&gt;</code> elements, each reference will result in a separate instance of that class. If you need to share listener instances between listener types you must use the programmatic registration approach. </p><p>Why implement an interface and define the specific type during configuration? A listener implementation could implement multiple event listener interfaces. Having the type additionally defined during registration makes it easier to turn custom listeners on or off during configuration. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-decl-security"/>12.3. Seguridad declarativa de Hibernate</h2></div></div></div><p>Usually, declarative security in Hibernate applications is managed in a session facade layer. Hibernate3 allows certain actions to be permissioned via JACC, and authorized via JAAS. This is an optional functionality that is built on top of the event architecture. </p><p>Primero, debes configurar los oyentes de eventos apropiados, para habilitar el uso de autorización JAAS. </p><pre class="programlisting">&lt;listener type="pre-delete" class="org.hibernate.secure.JACCPreDeleteEventListener"/&gt;
&lt;listener type="pre-update" class="org.hibernate.secure.JACCPreUpdateEventListener"/&gt;
&lt;listener type="pre-insert" class="org.hibernate.secure.JACCPreInsertEventListener"/&gt;
&lt;listener type="pre-load" class="org.hibernate.secure.JACCPreLoadEventListener"/&gt;</pre><p>Note that <code class="literal">&lt;listener type="..." class="..."/&gt;</code> is shorthand for <code class="literal">&lt;event type="..."&gt;&lt;listener class="..."/&gt;&lt;/event&gt;</code> when there is exactly one listener for a particular event type. </p><p>Next, while still in <code class="literal">hibernate.cfg.xml</code>, bind the permissions to roles: </p><pre class="programlisting">&lt;grant role="admin" entity-name="User" actions="insert,update,read"/&gt;
&lt;grant role="su" entity-name="User" actions="*"/&gt;</pre><p>Los nombres de role son los roles entendidos por tu proveedor de JACC. </p></div></div><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="batch"/>Capítulo 13. Procesamiento por lotes</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#batch-inserts">13.1. Inserciones en lote</a></span></dt><dt><span class="sect1"><a href="#batch-update">13.2. Actualizaciones en lote</a></span></dt><dt><span class="sect1"><a href="#batch-statelesssession">13.3. UNTRANSLATED! The StatelessSession interface</a></span></dt><dt><span class="sect1"><a href="#batch-direct">13.4. update/delete en masa</a></span></dt></dl></div><p>A naive approach to inserting 100,000 rows in the database using Hibernate might look like this: </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
for ( int i=0; i&lt;100000; i++ ) {
    Customer customer = new Customer(.....);
    session.save(customer);
}
tx.commit();
session.close();</pre><p>This would fall over with an <code class="literal">OutOfMemoryException</code> somewhere around the 50,000th row. That is because Hibernate caches all the newly inserted <code class="literal">Customer</code> instances in the session-level cache. In this chapter we will show you how to avoid this problem. </p><p>If you are undertaking batch processing you will need to enable the use of JDBC batching. This is absolutely essential if you want to achieve optimal performance. Set the JDBC batch size to a reasonable number (10-50, for example): </p><pre class="programlisting">hibernate.jdbc.batch_size 20</pre><p><a id="disablebatching"/>Hibernate disables insert batching at the JDBC level transparently if you use an <code class="literal">identity</code> identifier generator. </p><p>You can also do this kind of work in a process where interaction with the second-level cache is completely disabled: </p><pre class="programlisting">hibernate.cache.use_second_level_cache false</pre><p>UNTRANSLATED! However, this is not absolutely necessary, since we can explicitly set the <code class="literal">CacheMode</code> to disable interaction with the second-level cache. </p><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="batch-inserts"/>13.1. Inserciones en lote</h2></div></div></div><p>When making new objects persistent <code class="literal">flush()</code> and then <code class="literal">clear()</code> the session regularly in order to control the size of the first-level cache. </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
   
for ( int i=0; i&lt;100000; i++ ) {
    Customer customer = new Customer(.....);
    session.save(customer);
    if ( i % 20 == 0 ) { //20, same as the JDBC batch size
        //flush a batch of inserts and release memory:
        session.flush();
        session.clear();
    }
}
   
tx.commit();
session.close();</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="batch-update"/>13.2. Actualizaciones en lote</h2></div></div></div><p>For retrieving and updating data, the same ideas apply. In addition, you need to use <code class="literal">scroll()</code> to take advantage of server-side cursors for queries that return many rows of data. </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
   
ScrollableResults customers = session.getNamedQuery("GetCustomers")
    .setCacheMode(CacheMode.IGNORE)
    .scroll(ScrollMode.FORWARD_ONLY);
int count=0;
while ( customers.next() ) {
    Customer customer = (Customer) customers.get(0);
    customer.updateStuff(...);
    if ( ++count % 20 == 0 ) {
        //flush a batch of updates and release memory:
        session.flush();
        session.clear();
    }
}
   
tx.commit();
session.close();</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="batch-statelesssession"/>13.3. UNTRANSLATED! The StatelessSession interface</h2></div></div></div><p>Alternatively, Hibernate provides a command-oriented API that can be used for streaming data to and from the database in the form of detached objects. A <code class="literal">StatelessSession</code> has no persistence context associated with it and does not provide many of the higher-level life cycle semantics. In particular, a stateless session does not implement a first-level cache nor interact with any second-level or query cache. It does not implement transactional write-behind or automatic dirty checking. Operations performed using a stateless session never cascade to associated instances. Collections are ignored by a stateless session. Operations performed via a stateless session bypass Hibernate's event model and interceptors. Due to the lack of a first-level cache, Stateless sessions are vulnerable to data aliasing effects. A stateless session is a lower-level abstraction that is much closer to the underlying JDBC. </p><pre class="programlisting">StatelessSession session = sessionFactory.openStatelessSession();
                                                      Transaction tx = session.beginTransaction();
                                                      
                                                      ScrollableResults customers = session.getNamedQuery("GetCustomers")
                                                      .scroll(ScrollMode.FORWARD_ONLY);
                                                      while ( customers.next() ) {
                                                      Customer customer = (Customer) customers.get(0);
                                                      customer.updateStuff(...);
                                                      session.update(customer);
                                                      }
                                                      
                                                      tx.commit();
                                                      session.close();</pre><p>In this code example, the <code class="literal">Customer</code> instances returned by the query are immediately detached. They are never associated with any persistence context. </p><p>The <code class="literal">insert(), update()</code> and <code class="literal">delete()</code> operations defined by the <code class="literal">StatelessSession</code> interface are considered to be direct database row-level operations. They result in the immediate execution of a SQL <code class="literal">INSERT, UPDATE</code> or <code class="literal">DELETE</code> respectively. They have different semantics to the <code class="literal">save(), saveOrUpdate()</code> and <code class="literal">delete()</code> operations defined by the <code class="literal">Session</code> interface. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="batch-direct"/>13.4. update/delete en masa</h2></div></div></div><p>As already discussed, automatic and transparent object/relational mapping is concerned with the management of the object state. The object state is available in memory. This means that manipulating data directly in the database (using the SQL <code class="literal">Data Manipulation Language</code> (DML) the statements: <code class="literal">INSERT</code>, <code class="literal">UPDATE</code>, <code class="literal">DELETE</code>) will not affect in-memory state. However, Hibernate provides methods for bulk SQL-style DML statement execution that is performed through the Hibernate Query Language (<a href="#queryhql" title="Capítulo 14. HQL: El Lenguaje de Consulta de Hibernate">HQL</a>). </p><p>The pseudo-syntax for <code class="literal">UPDATE</code> and <code class="literal">DELETE</code> statements is: <code class="literal">( UPDATE | DELETE ) FROM? EntityName (WHERE where_conditions)?</code>. </p><p>Some points to note: </p><div class="itemizedlist"><ul compact="compact"><li><p>En la clÃ¡usula-from, la palabra clave FROM es opcional </p></li><li><p>There can only be a single entity named in the from-clause. It can, however, be aliased. If the entity name is aliased, then any property references must be qualified using that alias. If the entity name is not aliased, then it is illegal for any property references to be qualified. </p></li><li><p>No <a href="#queryhql-joins-forms" title="14.4. UNTRANSLATED!!! Forms of join syntax">joins</a>, either implicit or explicit, can be specified in a bulk HQL query. Sub-queries can be used in the where-clause, where the subqueries themselves may contain joins. </p></li><li><p>La clÃ¡usula-where es tambiÃ©n opcional. </p></li></ul></div><p>As an example, to execute an HQL <code class="literal">UPDATE</code>, use the <code class="literal">Query.executeUpdate()</code> method. The method is named for those familiar with JDBC's <code class="literal">PreparedStatement.executeUpdate()</code>: </p><pre class="programlisting">Session session = sessionFactory.openSession();
                                         Transaction tx = session.beginTransaction();
                                         
                                         String hqlUpdate = "update Customer c set c.name = :newName where c.name = :oldName";
                                         // or String hqlUpdate = "update Customer set name = :newName where name = :oldName";
                                         int updatedEntities = s.createQuery( hqlUpdate )
                                         .setString( "newName", newName )
                                         .setString( "oldName", oldName )
                                         .executeUpdate();
                                         tx.commit();
                                         session.close();</pre><p>In keeping with the EJB3 specification, HQL <code class="literal">UPDATE</code> statements, by default, do not effect the <a href="#mapping-declaration-version" title="5.1.9. Version (optional)">version</a> or the <a href="#mapping-declaration-timestamp" title="5.1.10. Timestamp (optional)">timestamp</a> property values for the affected entities. However, you can force Hibernate to reset the <code class="literal">version</code> or <code class="literal">timestamp</code> property values through the use of a <code class="literal">versioned update</code>. This is achieved by adding the <code class="literal">VERSIONED</code> keyword after the <code class="literal">UPDATE</code> keyword. </p><pre class="programlisting">Session session = sessionFactory.openSession();
                                         Transaction tx = session.beginTransaction();
                                         String hqlVersionedUpdate = "update versioned Customer set name = :newName where name = :oldName";
                                         int updatedEntities = s.createQuery( hqlUpdate )
                                         .setString( "newName", newName )
                                         .setString( "oldName", oldName )
                                         .executeUpdate();
                                         tx.commit();
                                         session.close();</pre><p>Custom version types, <code class="literal">org.hibernate.usertype.UserVersionType</code>, are not allowed in conjunction with a <code class="literal">update versioned</code> statement. </p><p>Para ejecutar un <code class="literal">DELETE</code> HQL, usa el mismo mÃ©todo <code class="literal">Query.executeUpdate()</code>: </p><pre class="programlisting">Session session = sessionFactory.openSession();
        Transaction tx = session.beginTransaction();

        String hqlDelete = "delete Customer where name = :oldName";
        int deletedEntities = s.createQuery( hqlDelete )
                            .setString( "oldName", oldName )
                            .executeUpdate();
        tx.commit();
        session.close();</pre><p>The <code class="literal">int</code> value returned by the <code class="literal">Query.executeUpdate()</code> method indicates the number of entities effected by the operation. This may or may not correlate to the number of rows effected in the database. An HQL bulk operation might result in multiple actual SQL statements being executed (for joined-subclass, for example). The returned number indicates the number of actual entities affected by the statement. Going back to the example of joined-subclass, a delete against one of the subclasses may actually result in deletes against not just the table to which that subclass is mapped, but also the "root" table and potentially joined-subclass tables further down the inheritance hierarchy. </p><p>Ten en cuenta que existen actualmente unas pocas limitaciones con las operaciones HQL masivas, que serÃ¡n atendidas en lanzamientos futuros; consulta la hoja de ruta de JIRA para mÃ¡s detalles. </p><div class="itemizedlist"><ul compact="compact"><li><p>Only the INSERT INTO ... SELECT ... form is supported; not the INSERT INTO ... VALUES ... form. </p><p>The properties_list is analogous to the <code class="literal">column specification</code> in the SQL <code class="literal">INSERT</code> statement. For entities involved in mapped inheritance, only properties directly defined on that given class-level can be used in the properties_list. Superclass properties are not allowed and subclass properties do not make sense. In other words, <code class="literal">INSERT</code> statements are inherently non-polymorphic. </p></li><li><p>select_statement can be any valid HQL select query, with the caveat that the return types must match the types expected by the insert. Currently, this is checked during query compilation rather than allowing the check to relegate to the database. This might, however, cause problems between Hibernate <code class="literal">Type</code>s which are <span class="emphasis"><em>equivalent</em></span> as opposed to <span class="emphasis"><em>equal</em></span>. This might cause issues with mismatches between a property defined as a <code class="literal">org.hibernate.type.DateType</code> and a property defined as a <code class="literal">org.hibernate.type.TimestampType</code>, even though the database might not make a distinction or might be able to handle the conversion. </p></li><li><p>For the id property, the insert statement gives you two options. You can either explicitly specify the id property in the properties_list, in which case its value is taken from the corresponding select expression, or omit it from the properties_list, in which case a generated value is used. This latter option is only available when using id generators that operate in the database; attempting to use this option with any "in memory" type generators will cause an exception during parsing. For the purposes of this discussion, in-database generators are considered to be <code class="literal">org.hibernate.id.SequenceGenerator</code> (and its subclasses) and any implementers of <code class="literal">org.hibernate.id.PostInsertIdentifierGenerator</code>. The most notable exception here is <code class="literal">org.hibernate.id.TableHiLoGenerator</code>, which cannot be used because it does not expose a selectable way to get its values. </p></li><li><p>For properties mapped as either <code class="literal">version</code> or <code class="literal">timestamp</code>, the insert statement gives you two options. You can either specify the property in the properties_list, in which case its value is taken from the corresponding select expressions, or omit it from the properties_list, in which case the <code class="literal">seed value</code> defined by the <code class="literal">org.hibernate.type.VersionType</code> is used. </p></li></ul></div><p>The following is an example of an HQL <code class="literal">INSERT</code> statement execution: </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

String hqlInsert = "insert into DelinquentAccount (id, name) select c.id, c.name from Customer c where ...";
int createdEntities = s.createQuery( hqlInsert )
        .executeUpdate();
tx.commit();
session.close();</pre></div></div><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql"/>Capítulo 14. HQL: El Lenguaje de Consulta de Hibernate</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#queryhql-casesensitivity">14.1. Sensibilidad a Mayúsculas</a></span></dt><dt><span class="sect1"><a href="#queryhql-from">14.2. La cláusula from</a></span></dt><dt><span class="sect1"><a href="#queryhql-joins">14.3. Asociaciones y uniones (joins)</a></span></dt><dt><span class="sect1"><a href="#queryhql-joins-forms">14.4. UNTRANSLATED!!! Forms of join syntax</a></span></dt><dt><span class="sect1"><a href="#queryhql-identifier-property">14.5. Referring to identifier property</a></span></dt><dt><span class="sect1"><a href="#queryhql-select">14.6. La cláusula select</a></span></dt><dt><span class="sect1"><a href="#queryhql-aggregation">14.7. Funciones de agregación</a></span></dt><dt><span class="sect1"><a href="#queryhql-polymorphism">14.8. Consultas polimórficas</a></span></dt><dt><span class="sect1"><a href="#queryhql-where">14.9. La cláusula where</a></span></dt><dt><span class="sect1"><a href="#queryhql-expressions">14.10. Expresiones</a></span></dt><dt><span class="sect1"><a href="#queryhql-ordering">14.11. La cláusula order by</a></span></dt><dt><span class="sect1"><a href="#queryhql-grouping">14.12. La cláusula group by</a></span></dt><dt><span class="sect1"><a href="#queryhql-subqueries">14.13. Subconsultas</a></span></dt><dt><span class="sect1"><a href="#queryhql-examples">14.14. Ejemplos de HQL</a></span></dt><dt><span class="sect1"><a href="#queryhql-bulk">14.15. Sentencias UPDATE y DELETE masivas</a></span></dt><dt><span class="sect1"><a href="#queryhql-tipstricks">14.16. Consejos y Trucos</a></span></dt><dt><span class="sect1"><a href="#queryhql-components">14.17. UNTRANSLATED! Components</a></span></dt><dt><span class="sect1"><a href="#queryhql-tuple">14.18. Row value constructor syntax</a></span></dt></dl></div><p>Hibernate uses a powerful query language (HQL) that is similar in appearance to SQL. Compared with SQL, however, HQL is fully object-oriented and understands notions like inheritance, polymorphism and association. </p><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-casesensitivity"/>14.1. Sensibilidad a Mayúsculas</h2></div></div></div><p>With the exception of names of Java classes and properties, queries are case-insensitive. So <code class="literal">SeLeCT</code> is the same as <code class="literal">sELEct</code> is the same as <code class="literal">SELECT</code>, but <code class="literal">org.hibernate.eg.FOO</code> is not <code class="literal">org.hibernate.eg.Foo</code>, and <code class="literal">foo.barSet</code> is not <code class="literal">foo.BARSET</code>. </p><p>This manual uses lowercase HQL keywords. Some users find queries with uppercase keywords more readable, but this convention is unsuitable for queries embedded in Java code. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-from"/>14.2. La cláusula from</h2></div></div></div><p>La consulta más simple posible de Hibernate es de la forma: </p><pre class="programlisting">from eg.Cat</pre><p>This returns all instances of the class <code class="literal">eg.Cat</code>. You do not usually need to qualify the class name, since <code class="literal">auto-import</code> is the default. For example: </p><pre class="programlisting">from Cat</pre><p>In order to refer to the <code class="literal">Cat</code> in other parts of the query, you will need to assign an <span class="emphasis"><em>alias</em></span>. For example: </p><pre class="programlisting">from Cat as cat</pre><p>This query assigns the alias <code class="literal">cat</code> to <code class="literal">Cat</code> instances, so you can use that alias later in the query. The <code class="literal">as</code> keyword is optional. You could also write: </p><pre class="programlisting">from Cat cat</pre><p>Multiple classes can appear, resulting in a cartesian product or "cross" join. </p><pre class="programlisting">from Formula, Parameter</pre><pre class="programlisting">from Formula as form, Parameter as param</pre><p>It is good practice to name query aliases using an initial lowercase as this is consistent with Java naming standards for local variables (e.g. <code class="literal">domesticCat</code>). </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-joins"/>14.3. Asociaciones y uniones (joins)</h2></div></div></div><p>You can also assign aliases to associated entities or to elements of a collection of values using a <code class="literal">join</code>. For example: </p><pre class="programlisting">from Cat as cat 
    inner join cat.mate as mate
    left outer join cat.kittens as kitten</pre><pre class="programlisting">from Cat as cat left join cat.mate.kittens as kittens</pre><pre class="programlisting">from Formula form full join form.parameter param</pre><p>The supported join types are borrowed from ANSI SQL: </p><div class="itemizedlist"><ul compact="compact"><li><p>
                    <code class="literal">inner join</code>
                </p></li><li><p>
                    <code class="literal">left outer join</code>
                </p></li><li><p>
                    <code class="literal">right outer join</code>
                </p></li><li><p><code class="literal">full join</code> (no útil usualmente) </p></li></ul></div><p>Las construcciones <code class="literal">inner join</code>, <code class="literal">left outer join</code> y <code class="literal">right outer join</code> pueden ser abreviadas. </p><pre class="programlisting">from Cat as cat 
    join cat.mate as mate
    left join cat.kittens as kitten</pre><p>Puedes proveer condiciones de unión extra usando la palabra clave <code class="literal">with</code> de HQL. </p><pre class="programlisting">from Cat as cat 
    left join cat.kittens as kitten 
        with kitten.bodyWeight 
&gt; 10.0</pre><p>A "fetch" join allows associations or collections of values to be initialized along with their parent objects using a single select. This is particularly useful in the case of a collection. It effectively overrides the outer join and lazy declarations of the mapping file for associations and collections. See <a href="#performance-fetching" title="19.1. Estrategias de recuperación">Sección 19.1, “Estrategias de recuperación”</a> for more information. </p><pre class="programlisting">from Cat as cat 
    inner join fetch cat.mate
    left join fetch cat.kittens</pre><p>A fetch join does not usually need to assign an alias, because the associated objects should not be used in the <code class="literal">where</code> clause (or any other clause). The associated objects are also not returned directly in the query results. Instead, they may be accessed via the parent object. The only reason you might need an alias is if you are recursively join fetching a further collection: </p><pre class="programlisting">from Cat as cat 
    inner join fetch cat.mate
    left join fetch cat.kittens child
    left join fetch child.kittens</pre><p>The <code class="literal">fetch</code> construct cannot be used in queries called using <code class="literal">iterate()</code> (though <code class="literal">scroll()</code> can be used). <code class="literal">Fetch</code> should be used together with <code class="literal">setMaxResults()</code> or <code class="literal">setFirstResult()</code>, as these operations are based on the result rows which usually contain duplicates for eager collection fetching, hence, the number of rows is not what you would expect. <code class="literal">Fetch</code> should also not be used together with impromptu <code class="literal">with</code> condition. It is possible to create a cartesian product by join fetching more than one collection in a query, so take care in this case. Join fetching multiple collection roles can produce unexpected results for bag mappings, so user discretion is advised when formulating queries in this case. Finally, note that <code class="literal">full join fetch</code> and <code class="literal">right join fetch</code> are not meaningful. </p><p>If you are using property-level lazy fetching (with bytecode instrumentation), it is possible to force Hibernate to fetch the lazy properties in the first query immediately using <code class="literal">fetch all properties</code>. </p><pre class="programlisting">from Document fetch all properties order by name</pre><pre class="programlisting">from Document doc fetch all properties where lower(doc.name) like '%cats%'</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-joins-forms"/>14.4. UNTRANSLATED!!! Forms of join syntax</h2></div></div></div><p>HQL supports two forms of association joining: <code class="literal">implicit</code> and <code class="literal">explicit</code>. </p><p>The queries shown in the previous section all use the <code class="literal">explicit</code> form, that is, where the join keyword is explicitly used in the from clause. This is the recommended form. </p><p>The <code class="literal">implicit</code> form does not use the join keyword. Instead, the associations are "dereferenced" using dot-notation. <code class="literal">implicit</code> joins can appear in any of the HQL clauses. <code class="literal">implicit</code> join result in inner joins in the resulting SQL statement. </p><pre class="programlisting">from Cat as cat where cat.mate.name like '%s%'</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-identifier-property"/>14.5. Referring to identifier property</h2></div></div></div><p>There are 2 ways to refer to an entity's identifier property: </p><div class="itemizedlist"><ul compact="compact"><li><p>The special property (lowercase) <code class="literal">id</code> may be used to reference the identifier property of an entity <span class="emphasis"><em>provided that the entity does not define a non-identifier property named id</em></span>. </p></li><li><p>If the entity defines a named identifier property, you can use that property name. </p></li></ul></div><p>References to composite identifier properties follow the same naming rules. If the entity has a non-identifier property named id, the composite identifier property can only be referenced by its defined named. Otherwise, the special <code class="literal">id</code> property can be used to reference the identifier property. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Importante</h2><p>Please note that, starting in version 3.2.2, this has changed significantly. In previous versions, <code class="literal">id</code> <span class="emphasis"><em>always</em></span> referred to the identifier property regardless of its actual name. A ramification of that decision was that non-identifier properties named <code class="literal">id</code> could never be referenced in Hibernate queries. </p></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-select"/>14.6. La cláusula select</h2></div></div></div><p>The <code class="literal">select</code> clause picks which objects and properties to return in the query result set. Consider the following: </p><pre class="programlisting">select mate 
from Cat as cat 
    inner join cat.mate as mate</pre><p>The query will select <code class="literal">mate</code>s of other <code class="literal">Cat</code>s. You can express this query more compactly as: </p><pre class="programlisting">select cat.mate from Cat cat</pre><p>Queries can return properties of any value type including properties of component type: </p><pre class="programlisting">select cat.name from DomesticCat cat
where cat.name like 'fri%'</pre><pre class="programlisting">select cust.name.firstName from Customer as cust</pre><p>Queries can return multiple objects and/or properties as an array of type <code class="literal">Object[]</code>: </p><pre class="programlisting">select mother, offspr, mate.name 
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>Or as a <code class="literal">List</code>: </p><pre class="programlisting">select new list(mother, offspr, mate.name)
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>Or - assuming that the class <code class="literal">Family</code> has an appropriate constructor - as an actual typesafe Java object: </p><pre class="programlisting">select new Family(mother, mate, offspr)
from DomesticCat as mother
    join mother.mate as mate
    left join mother.kittens as offspr</pre><p>You can assign aliases to selected expressions using <code class="literal">as</code>: </p><pre class="programlisting">select max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n
from Cat cat</pre><p>Esto es lo más útil cuando se usa junto con <code class="literal">select new map</code>: </p><pre class="programlisting">select new map( max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n )
from Cat cat</pre><p>Esta consulta devuelve un <code class="literal">Map</code> de aliases a valores seleccionados. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-aggregation"/>14.7. Funciones de agregación</h2></div></div></div><p>HQL queries can even return the results of aggregate functions on properties: </p><pre class="programlisting">select avg(cat.weight), sum(cat.weight), max(cat.weight), count(cat)
from Cat cat</pre><p>The supported aggregate functions are: </p><div class="itemizedlist"><ul compact="compact"><li><p>
                    <code class="literal">avg(...), sum(...), min(...), max(...)</code>
                </p></li><li><p>
                    <code class="literal">count(*)</code>
                </p></li><li><p>
                    <code class="literal">count(...), count(distinct ...), count(all...)</code>
                </p></li></ul></div><p>You can use arithmetic operators, concatenation, and recognized SQL functions in the select clause: </p><pre class="programlisting">select cat.weight + sum(kitten.weight) 
from Cat cat 
    join cat.kittens kitten
group by cat.id, cat.weight</pre><pre class="programlisting">select firstName||' '||initial||' '||upper(lastName) from Person</pre><p>The <code class="literal">distinct</code> and <code class="literal">all</code> keywords can be used and have the same semantics as in SQL. </p><pre class="programlisting">select distinct cat.name from Cat cat

select count(distinct cat.name), count(cat) from Cat cat</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-polymorphism"/>14.8. Consultas polimórficas</h2></div></div></div><p>Una consulta como: </p><pre class="programlisting">from Cat as cat</pre><p>returns instances not only of <code class="literal">Cat</code>, but also of subclasses like <code class="literal">DomesticCat</code>. Hibernate queries can name <span class="emphasis"><em>any</em></span> Java class or interface in the <code class="literal">from</code> clause. The query will return instances of all persistent classes that extend that class or implement the interface. The following query would return all persistent objects: </p><pre class="programlisting">from java.lang.Object o</pre><p>La interface <code class="literal">Named</code> podría ser implementada por varias clases persistentes: </p><pre class="programlisting">from Named n, Named m where n.name = m.name</pre><p>These last two queries will require more than one SQL <code class="literal">SELECT</code>. This means that the <code class="literal">order by</code> clause does not correctly order the whole result set. It also means you cannot call these queries using <code class="literal">Query.scroll()</code>. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-where"/>14.9. La cláusula where</h2></div></div></div><p>The <code class="literal">where</code> clause allows you to refine the list of instances returned. If no alias exists, you can refer to properties by name: </p><pre class="programlisting">from Cat where name='Fritz'</pre><p>Si existe un alias, usan un nombre cualificado de propiedad: </p><pre class="programlisting">from Cat as cat where cat.name='Fritz'</pre><p>This returns instances of <code class="literal">Cat</code> named 'Fritz'. </p><p>The following query: </p><pre class="programlisting">select foo
from Foo foo, Bar bar
where foo.startDate = bar.date</pre><p> returns all instances of <code class="literal">Foo</code> with an instance of <code class="literal">bar</code> with a <code class="literal">date</code> property equal to the <code class="literal">startDate</code> property of the <code class="literal">Foo</code>. Compound path expressions make the <code class="literal">where</code> clause extremely powerful. Consider the following: </p><pre class="programlisting">from Cat cat where cat.mate.name is not null</pre><p>This query translates to an SQL query with a table (inner) join. For example: </p><pre class="programlisting">from Foo foo  
where foo.bar.baz.customer.address.city is not null</pre><p>would result in a query that would require four table joins in SQL. </p><p>The <code class="literal">=</code> operator can be used to compare not only properties, but also instances: </p><pre class="programlisting">from Cat cat, Cat rival where cat.mate = rival.mate</pre><pre class="programlisting">select cat, mate 
from Cat cat, Cat mate
where cat.mate = mate</pre><p>The special property (lowercase) <code class="literal">id</code> can be used to reference the unique identifier of an object. See <a href="#queryhql-identifier-property" title="14.5. Referring to identifier property">Sección 14.5, “Referring to identifier property”</a> for more information. </p><pre class="programlisting">from Cat as cat where cat.id = 123

from Cat as cat where cat.mate.id = 69</pre><p>The second query is efficient and does not require a table join. </p><p>Properties of composite identifiers can also be used. Consider the following example where <code class="literal">Person</code> has composite identifiers consisting of <code class="literal">country</code> and <code class="literal">medicareNumber</code>: </p><pre class="programlisting">from bank.Person person
where person.id.country = 'AU' 
    and person.id.medicareNumber = 123456</pre><pre class="programlisting">from bank.Account account
where account.owner.id.country = 'AU' 
    and account.owner.id.medicareNumber = 123456</pre><p>Once again, the second query does not require a table join. </p><p>See <a href="#queryhql-identifier-property" title="14.5. Referring to identifier property">Sección 14.5, “Referring to identifier property”</a> for more information regarding referencing identifier properties) </p><p>The special property <code class="literal">class</code> accesses the discriminator value of an instance in the case of polymorphic persistence. A Java class name embedded in the where clause will be translated to its discriminator value. </p><pre class="programlisting">from Cat cat where cat.class = DomesticCat</pre><p>You can also use components or composite user types, or properties of said component types. See <a href="#queryhql-components" title="14.17. UNTRANSLATED! Components">Sección 14.17, “UNTRANSLATED! Components”</a> for more information. </p><p>An "any" type has the special properties <code class="literal">id</code> and <code class="literal">class</code> that allows you to express a join in the following way (where <code class="literal">AuditLog.item</code> is a property mapped with <code class="literal">&lt;any&gt;</code>): </p><pre class="programlisting">from AuditLog log, Payment payment 
where log.item.class = 'Payment' and log.item.id = payment.id</pre><p>The <code class="literal">log.item.class</code> and <code class="literal">payment.class</code> would refer to the values of completely different database columns in the above query. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-expressions"/>14.10. Expresiones</h2></div></div></div><p>Expressions used in the <code class="literal">where</code> clause include the following: </p><div class="itemizedlist"><ul compact="compact"><li><p>mathematical operators: <code class="literal">+, -, *, /</code> </p></li><li><p>binary comparison operators: <code class="literal">=, &gt;=, &lt;=, &lt;&gt;, !=, like</code> </p></li><li><p>operadores lógicos <code class="literal">and, or, not</code> </p></li><li><p>Parentheses <code class="literal">( )</code> that indicates grouping </p></li><li><p><code class="literal">in</code>, <code class="literal">not in</code>, <code class="literal">between</code>, <code class="literal">is null</code>, <code class="literal">is not null</code>, <code class="literal">is empty</code>, <code class="literal">is not empty</code>, <code class="literal">member of</code> y <code class="literal">not member of</code> </p></li><li><p>Caso "simple", <code class="literal">case ... when ... then ... else ... end</code>, y caso "buscado", <code class="literal">case when ... then ... else ... end</code> </p></li><li><p>concatenación de cadenas <code class="literal">...||...</code> o <code class="literal">concat(...,...)</code> </p></li><li><p><code class="literal">current_date()</code>, <code class="literal">current_time()</code>, and <code class="literal">current_timestamp()</code> </p></li><li><p><code class="literal">second(...)</code>, <code class="literal">minute(...)</code>, <code class="literal">hour(...)</code>, <code class="literal">day(...)</code>, <code class="literal">month(...)</code>, and <code class="literal">year(...)</code> </p></li><li><p>Cualquier función u operador definido por EJB-QL 3.0: <code class="literal">substring(), trim(), lower(), upper(), length(), locate(), abs(), sqrt(), bit_length(), mod()</code> </p></li><li><p><code class="literal">coalesce()</code> y <code class="literal">nullif()</code> </p></li><li><p><code class="literal">str()</code> para convertir valores numéricos o temporales a una cadena legible. </p></li><li><p><code class="literal">cast(... as ...)</code>, donde el segundo argumento es el nombre de un tipo Hibernate , y <code class="literal">extract(... from ...)</code> si <code class="literal">cast()</code> y <code class="literal">extract()</code> fuesen soportados por la base de datos subyacente. </p></li><li><p>la función <code class="literal">index()</code> de HQL, que se aplica a alias de una colección indexada unida. </p></li><li><p>HQL functions that take collection-valued path expressions: <code class="literal">size(), minelement(), maxelement(), minindex(), maxindex()</code>, along with the special <code class="literal">elements()</code> and <code class="literal">indices</code> functions that can be quantified using <code class="literal">some, all, exists, any, in</code>. </p></li><li><p>Any database-supported SQL scalar function like <code class="literal">sign()</code>, <code class="literal">trunc()</code>, <code class="literal">rtrim()</code>, and <code class="literal">sin()</code> </p></li><li><p>parámetros posicionales JDBC <code class="literal">?</code> </p></li><li><p>named parameters <code class="literal">:name</code>, <code class="literal">:start_date</code>, and <code class="literal">:x1</code> </p></li><li><p>literales SQL <code class="literal">'foo'</code>, <code class="literal">69</code>, <code class="literal">6.66E+2</code>, <code class="literal">'1970-01-01 10:00:01.0'</code> </p></li><li><p>constantes Java <code class="literal">public static final</code> <code class="literal">eg.Color.TABBY</code> </p></li></ul></div><p><code class="literal">in</code> and <code class="literal">between</code> can be used as follows: </p><pre class="programlisting">from DomesticCat cat where cat.name between 'A' and 'B'</pre><pre class="programlisting">from DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )</pre><p>The negated forms can be written as follows: </p><pre class="programlisting">from DomesticCat cat where cat.name not between 'A' and 'B'</pre><pre class="programlisting">from DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )</pre><p>Similarly, <code class="literal">is null</code> and <code class="literal">is not null</code> can be used to test for null values. </p><p>Booleans can be easily used in expressions by declaring HQL query substitutions in Hibernate configuration: </p><pre class="programlisting">&lt;property name="hibernate.query.substitutions"
&gt;true 1, false 0&lt;/property
&gt;</pre><p>Esto remplazará las palabras clave <code class="literal">true</code> y <code class="literal">false</code> con los literales <code class="literal">1</code> y <code class="literal">0</code> en el SQL traducido de este HQL: </p><pre class="programlisting">from Cat cat where cat.alive = true</pre><p>You can test the size of a collection with the special property <code class="literal">size</code> or the special <code class="literal">size()</code> function. </p><pre class="programlisting">from Cat cat where cat.kittens.size 
&gt; 0</pre><pre class="programlisting">from Cat cat where size(cat.kittens) 
&gt; 0</pre><p>For indexed collections, you can refer to the minimum and maximum indices using <code class="literal">minindex</code> and <code class="literal">maxindex</code> functions. Similarly, you can refer to the minimum and maximum elements of a collection of basic type using the <code class="literal">minelement</code> and <code class="literal">maxelement</code> functions. For example: </p><pre class="programlisting">from Calendar cal where maxelement(cal.holidays) 
&gt; current_date</pre><pre class="programlisting">from Order order where maxindex(order.items) 
&gt; 100</pre><pre class="programlisting">from Order order where minelement(order.items) 
&gt; 10000</pre><p>The SQL functions <code class="literal">any, some, all, exists, in</code> are supported when passed the element or index set of a collection (<code class="literal">elements</code> and <code class="literal">indices</code> functions) or the result of a subquery (see below): </p><pre class="programlisting">select mother from Cat as mother, Cat as kit
where kit in elements(foo.kittens)</pre><pre class="programlisting">select p from NameList list, Person p
where p.name = some elements(list.names)</pre><pre class="programlisting">from Cat cat where exists elements(cat.kittens)</pre><pre class="programlisting">from Player p where 3 
&gt; all elements(p.scores)</pre><pre class="programlisting">from Show show where 'fizard' in indices(show.acts)</pre><p>Note that these constructs - <code class="literal">size</code>, <code class="literal">elements</code>, <code class="literal">indices</code>, <code class="literal">minindex</code>, <code class="literal">maxindex</code>, <code class="literal">minelement</code>, <code class="literal">maxelement</code> - can only be used in the where clause in Hibernate3. </p><p>Elements of indexed collections (arrays, lists, and maps) can be referred to by index in a where clause only: </p><pre class="programlisting">from Order order where order.items[0].id = 1234</pre><pre class="programlisting">select person from Person person, Calendar calendar
where calendar.holidays['national day'] = person.birthDay
    and person.nationality.calendar = calendar</pre><pre class="programlisting">select item from Item item, Order order
where order.items[ order.deliveredItemIndices[0] ] = item and order.id = 11</pre><pre class="programlisting">select item from Item item, Order order
where order.items[ maxindex(order.items) ] = item and order.id = 11</pre><p>The expression inside <code class="literal">[]</code> can even be an arithmetic expression: </p><pre class="programlisting">select item from Item item, Order order
where order.items[ size(order.items) - 1 ] = item</pre><p>HQL also provides the built-in <code class="literal">index()</code> function for elements of a one-to-many association or collection of values. </p><pre class="programlisting">select item, index(item) from Order order 
    join order.items item
where index(item) &lt; 5</pre><p>Scalar SQL functions supported by the underlying database can be used: </p><pre class="programlisting">from DomesticCat cat where upper(cat.name) like 'FRI%'</pre><p>Consider how much longer and less readable the following query would be in SQL: </p><pre class="programlisting">select cust
from Product prod,
    Store store
    inner join store.customers cust
where prod.name = 'widget'
    and store.location.name in ( 'Melbourne', 'Sydney' )
    and prod = all elements(cust.currentOrder.lineItems)</pre><p><span class="emphasis"><em>Ayuda:</em></span> algo como </p><pre class="programlisting">SELECT cust.name, cust.address, cust.phone, cust.id, cust.current_order
FROM customers cust,
    stores store,
    locations loc,
    store_customers sc,
    product prod
WHERE prod.name = 'widget'
    AND store.loc_id = loc.id
    AND loc.name IN ( 'Melbourne', 'Sydney' )
    AND sc.store_id = store.id
    AND sc.cust_id = cust.id
    AND prod.id = ALL(
        SELECT item.prod_id
        FROM line_items item, orders o
        WHERE item.order_id = o.id
            AND cust.current_order = o.id
    )</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-ordering"/>14.11. La cláusula order by</h2></div></div></div><p>The list returned by a query can be ordered by any property of a returned class or components: </p><pre class="programlisting">from DomesticCat cat
order by cat.name asc, cat.weight desc, cat.birthdate</pre><p>Los <code class="literal">asc</code> o <code class="literal">desc</code> opcionales indican ordenamiento ascendente o descendente respectivamente. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-grouping"/>14.12. La cláusula group by</h2></div></div></div><p>A query that returns aggregate values can be grouped by any property of a returned class or components: </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat) 
from Cat cat
group by cat.color</pre><pre class="programlisting">select foo.id, avg(name), max(name) 
from Foo foo join foo.names name
group by foo.id</pre><p>Se permite también una cláusula <code class="literal">having</code>. </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat) 
from Cat cat
group by cat.color 
having cat.color in (eg.Color.TABBY, eg.Color.BLACK)</pre><p>SQL functions and aggregate functions are allowed in the <code class="literal">having</code> and <code class="literal">order by</code> clauses if they are supported by the underlying database (i.e., not in MySQL). </p><pre class="programlisting">select cat
from Cat cat
    join cat.kittens kitten
group by cat
having avg(kitten.weight) 
&gt; 100
order by count(kitten) asc, sum(kitten.weight) desc</pre><p>Neither the <code class="literal">group by</code> clause nor the <code class="literal">order by</code> clause can contain arithmetic expressions. Hibernate also does not currently expand a grouped entity, so you cannot write <code class="literal">group by cat</code> if all properties of <code class="literal">cat</code> are non-aggregated. You have to list all non-aggregated properties explicitly. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-subqueries"/>14.13. Subconsultas</h2></div></div></div><p>Para bases de datos que soportan subconsultas, Hibernate soporta subconsultas dentro de consultas. Una subconsulta debe ser encerrada entre paréntesis (frecuentemente por una llamada a una función de agregación SQL). Incluso se permiten subconsultas correlacionadas (subconsultas que hacen referencia a un alias en la consulta exterior). </p><pre class="programlisting">from Cat as fatcat
                                      where fatcat.weight 
&gt; (
                select avg(cat.weight) from DomesticCat cat
                )</pre><pre class="programlisting">from DomesticCat as cat
                                      where cat.name = some (
                                      select name.nickName from Name as name
                                      )</pre><pre class="programlisting">from Cat as cat
                                      where not exists (
                                      from Cat as mate where mate.mate = cat
                                      )</pre><pre class="programlisting">from DomesticCat as cat
                                      where cat.name not in (
                                      select name.nickName from Name as name
                                      )</pre><pre class="programlisting">select cat.id, (select max(kit.weight) from cat.kitten kit)
                                        from Cat as cat</pre><p>Note that HQL subqueries can occur only in the select or where clauses. </p><p>Note that subqueries can also utilize <code class="literal">row value constructor</code> syntax. See <a href="#queryhql-tuple" title="14.18. Row value constructor syntax">Sección 14.18, “Row value constructor syntax”</a> for more information. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-examples"/>14.14. Ejemplos de HQL</h2></div></div></div><p>Hibernate queries can be quite powerful and complex. In fact, the power of the query language is one of Hibernate's main strengths. The following example queries are similar to queries that have been used on recent projects. Please note that most queries you will write will be much simpler than the following examples. </p><p>The following query returns the order id, number of items, the given minimum total value and the total value of the order for all unpaid orders for a particular customer. The results are ordered by total value. In determining the prices, it uses the current catalog. The resulting SQL query, against the <code class="literal">ORDER</code>, <code class="literal">ORDER_LINE</code>, <code class="literal">PRODUCT</code>, <code class="literal">CATALOG</code> and <code class="literal">PRICE</code> tables has four inner joins and an (uncorrelated) subselect. </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog.effectiveDate &lt; sysdate
    and catalog.effectiveDate 
&gt;= all (
        select cat.effectiveDate 
        from Catalog as cat
        where cat.effectiveDate &lt; sysdate
    )
group by order
having sum(price.amount) 
&gt; :minAmount
order by sum(price.amount) desc</pre><p>¡Qué monstruo! Realmente, en la vida real, no estoy muy afilado en subconsultas, de modo que mi consulta fue realmente algo como esto: </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog = :currentCatalog
group by order
having sum(price.amount) 
&gt; :minAmount
order by sum(price.amount) desc</pre><p>La próxima consulta cuenta el número de pagos en cada estado, excluyendo todos los pagos en el estado <code class="literal">AWAITING_APPROVAL</code> donde el estado más reciente fue hecho por el usuario actual. Se traduce en una consulta SQL con dos joins interiores y una subselect correlacionada contra las tablas <code class="literal">PAYMENT</code>, <code class="literal">PAYMENT_STATUS</code> y <code class="literal">PAYMENT_STATUS_CHANGE</code>. </p><pre class="programlisting">select count(payment), status.name 
from Payment as payment 
    join payment.currentStatus as status
    join payment.statusChanges as statusChange
where payment.status.name &lt;
&gt; PaymentStatus.AWAITING_APPROVAL
    or (
        statusChange.timeStamp = ( 
            select max(change.timeStamp) 
            from PaymentStatusChange change 
            where change.payment = payment
        )
        and statusChange.user &lt;
&gt; :currentUser
    )
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>If the <code class="literal">statusChanges</code> collection was mapped as a list, instead of a set, the query would have been much simpler to write. </p><pre class="programlisting">select count(payment), status.name 
from Payment as payment
    join payment.currentStatus as status
where payment.status.name &lt;
&gt; PaymentStatus.AWAITING_APPROVAL
    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user &lt;
&gt; :currentUser
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>La próxima consulta usa la función <code class="literal">isNull()</code> de MS SQL Server para devolver todas las cuentas y pagos inpagos de la organización a la que pertenece el usuario actual. Se traduce en una consulta SQL con tres joins interiores, un join exterior y una subconsulta contra las tablas <code class="literal">ACCOUNT</code>, <code class="literal">PAYMENT</code>, <code class="literal">PAYMENT_STATUS</code>, <code class="literal">ACCOUNT_TYPE</code>, <code class="literal">ORGANIZATION</code> y <code class="literal">ORG_USER</code>. </p><pre class="programlisting">select account, payment
from Account as account
    left outer join account.payments as payment
where :currentUser in elements(account.holder.users)
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre><p>Para algunas bases de datos, necesitaríamos eliminar la subselect (correlacionada). </p><pre class="programlisting">select account, payment
from Account as account
    join account.holder.users as user
    left outer join account.payments as payment
where :currentUser = user
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-bulk"/>14.15. Sentencias UPDATE y DELETE masivas</h2></div></div></div><p>HQL now supports <code class="literal">update</code>, <code class="literal">delete</code> and <code class="literal">insert ... select ...</code> statements. See <a href="#batch-direct" title="13.4. update/delete en masa">Sección 13.4, “update/delete en masa”</a> for more information. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-tipstricks"/>14.16. Consejos y Trucos</h2></div></div></div><p>You can count the number of query results without returning them: </p><pre class="programlisting">( (Integer) session.createQuery("select count(*) from ....").iterate().next() ).intValue()</pre><p>Para ordenar un resultado por el tamaño de una colección, usa la siguiente consulta: </p><pre class="programlisting">select usr.id, usr.name
from User as usr 
    left join usr.messages as msg
group by usr.id, usr.name
order by count(msg)</pre><p>Si tu base de datos soporta subselects, puedes colocar una condición sobre el tamaño de selección en la cláusula where de tu consulta: </p><pre class="programlisting">from User usr where size(usr.messages) 
&gt;= 1</pre><p>If your database does not support subselects, use the following query: </p><pre class="programlisting">select usr.id, usr.name
from User usr.name
    join usr.messages msg
group by usr.id, usr.name
having count(msg) 
&gt;= 1</pre><p>As this solution cannot return a <code class="literal">User</code> with zero messages because of the inner join, the following form is also useful: </p><pre class="programlisting">select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
having count(msg) = 0</pre><p>Las propiedades de un JavaBean pueden ser ligadas al parámetros de consulta con nombre: </p><pre class="programlisting">Query q = s.createQuery("from foo Foo as foo where foo.name=:name and foo.size=:size");
q.setProperties(fooBean); // fooBean has getName() and getSize()
List foos = q.list();</pre><p>Las colecciones son paginables usando la interface <code class="literal">Query</code> con un filtro: </p><pre class="programlisting">Query q = s.createFilter( collection, "" ); // the trivial filter
q.setMaxResults(PAGE_SIZE);
q.setFirstResult(PAGE_SIZE * pageNumber);
List page = q.list();</pre><p>Collection elements can be ordered or grouped using a query filter: </p><pre class="programlisting">Collection orderedCollection = s.filter( collection, "order by this.amount" );
Collection counts = s.filter( collection, "select this.type, count(this) group by this.type" );</pre><p>Puedes hallar el tamaño de una colección sin inicializarla: </p><pre class="programlisting">( (Integer) session.createQuery("select count(*) from ....").iterate().next() ).intValue();</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-components"/>14.17. UNTRANSLATED! Components</h2></div></div></div><p>Components can be used similarly to the simple value types that are used in HQL queries. They can appear in the <code class="literal">select</code> clause as follows: </p><pre class="programlisting">select p.name from Person p</pre><pre class="programlisting">select p.name.first from Person p</pre><p>where the Person's name property is a component. Components can also be used in the <code class="literal">where</code> clause: </p><pre class="programlisting">from Person p where p.name = :name</pre><pre class="programlisting">from Person p where p.name.first = :firstName</pre><p>Components can also be used in the <code class="literal">order by</code> clause: </p><pre class="programlisting">from Person p order by p.name</pre><pre class="programlisting">from Person p order by p.name.first</pre><p>Another common use of components is in <a href="#queryhql-tuple" title="14.18. Row value constructor syntax">row value constructors</a>. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-tuple"/>14.18. Row value constructor syntax</h2></div></div></div><p>HQL supports the use of ANSI SQL <code class="literal">row value constructor</code> syntax, sometimes referred to AS <code class="literal">tuple</code> syntax, even though the underlying database may not support that notion. Here, we are generally referring to multi-valued comparisons, typically associated with components. Consider an entity Person which defines a name component: </p><pre class="programlisting">from Person p where p.name.first='John' and p.name.last='Jingleheimer-Schmidt'</pre><p>That is valid syntax although it is a little verbose. You can make this more concise by using <code class="literal">row value constructor</code> syntax: </p><pre class="programlisting">from Person p where p.name=('John', 'Jingleheimer-Schmidt')</pre><p>It can also be useful to specify this in the <code class="literal">select</code> clause: </p><pre class="programlisting">select p.name from Person p</pre><p>Using <code class="literal">row value constructor</code> syntax can also be beneficial when using subqueries that need to compare against multiple values: </p><pre class="programlisting">from Cat as cat
                                          where not ( cat.name, cat.color ) in (
                                          select cat.name, cat.color from DomesticCat cat
                                          )</pre><p>One thing to consider when deciding if you want to use this syntax, is that the query will be dependent upon the ordering of the component sub-properties in the metadata. </p></div></div><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria"/>Capítulo 15. Consultas por Criterios</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#querycriteria-creating">15.1. Creando una instancia de <code class="literal">Criteria</code></a></span></dt><dt><span class="sect1"><a href="#querycriteria-narrowing">15.2. Estrechando el conjunto resultado</a></span></dt><dt><span class="sect1"><a href="#querycriteria-ordering">15.3. Ordenando los resultados</a></span></dt><dt><span class="sect1"><a href="#querycriteria-associations">15.4. Asociaciones</a></span></dt><dt><span class="sect1"><a href="#querycriteria-dynamicfetching">15.5. Recuperación dinámica de asociaciones</a></span></dt><dt><span class="sect1"><a href="#querycriteria-examples">15.6. Consultas por ejemplos</a></span></dt><dt><span class="sect1"><a href="#querycriteria-projection">15.7. Proyecciones, agregación y agrupamiento</a></span></dt><dt><span class="sect1"><a href="#querycriteria-detachedqueries">15.8. Consultas y subconsultas separadas</a></span></dt><dt><span class="sect1"><a href="#query-criteria-naturalid">15.9. Consultas por identificador natural</a></span></dt></dl></div><p>Acompaña a Hibernate una API de consultas por criterios intuitiva y extensible. </p><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-creating"/>15.1. Creando una instancia de <code class="literal">Criteria</code></h2></div></div></div><p>La interface <code class="literal">org.hibernate.Criteria</code> representa una consulta contra una clase persistente en particular. La <code class="literal">Session</code> es una fábrica de instancias de <code class="literal">Criteria</code>. </p><pre class="programlisting">Criteria crit = sess.createCriteria(Cat.class);
crit.setMaxResults(50);
List cats = crit.list();</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-narrowing"/>15.2. Estrechando el conjunto resultado</h2></div></div></div><p>Un criterio individual de consulta es una instancia de la interface <code class="literal">org.hibernate.criterion.Criterion</code>. La clase <code class="literal">org.hibernate.criterion.Restrictions</code> define métodos de fábrica para obtener ciertos tipos prefabricados de <code class="literal">Criterion</code>. </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "Fritz%") )
    .add( Restrictions.between("weight", minWeight, maxWeight) )
    .list();</pre><p>Restrictions can be grouped logically. </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "Fritz%") )
    .add( Restrictions.or(
        Restrictions.eq( "age", new Integer(0) ),
        Restrictions.isNull("age")
    ) )
    .list();</pre><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.in( "name", new String[] { "Fritz", "Izi", "Pk" } ) )
    .add( Restrictions.disjunction()
        .add( Restrictions.isNull("age") )
        .add( Restrictions.eq("age", new Integer(0) ) )
        .add( Restrictions.eq("age", new Integer(1) ) )
        .add( Restrictions.eq("age", new Integer(2) ) )
    ) )
    .list();</pre><p>There are a range of built-in criterion types (<code class="literal">Restrictions</code> subclasses). One of the most useful allows you to specify SQL directly. </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.sql("lower({alias}.name) like lower(?)", "Fritz%", Hibernate.STRING) )
    .list();</pre><p>El sitio <code class="literal">{alias}</code> será remplazado por el alias de fila de la entidad consultada. </p><p>You can also obtain a criterion from a <code class="literal">Property</code> instance. You can create a <code class="literal">Property</code> by calling <code class="literal">Property.forName()</code>: </p><pre class="programlisting">
Property age = Property.forName("age");
List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.disjunction()
        .add( age.isNull() )
        .add( age.eq( new Integer(0) ) )
        .add( age.eq( new Integer(1) ) )
        .add( age.eq( new Integer(2) ) )
    ) )
    .add( Property.forName("name").in( new String[] { "Fritz", "Izi", "Pk" } ) )
    .list();</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-ordering"/>15.3. Ordenando los resultados</h2></div></div></div><p>You can order the results using <code class="literal">org.hibernate.criterion.Order</code>. </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "F%")
    .addOrder( Order.asc("name") )
    .addOrder( Order.desc("age") )
    .setMaxResults(50)
    .list();</pre><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Property.forName("name").like("F%") )
    .addOrder( Property.forName("name").asc() )
    .addOrder( Property.forName("age").desc() )
    .setMaxResults(50)
    .list();</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-associations"/>15.4. Asociaciones</h2></div></div></div><p>By navigating associations using <code class="literal">createCriteria()</code> you can specify constraints upon related entities: </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "F%")
    .createCriteria("kittens")
        .add( Restrictions.like("name", "F%")
    .list();</pre><p>The second <code class="literal">createCriteria()</code> returns a new instance of <code class="literal">Criteria</code> that refers to the elements of the <code class="literal">kittens</code> collection. </p><p>There is also an alternate form that is useful in certain circumstances: </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .createAlias("kittens", "kt")
    .createAlias("mate", "mt")
    .add( Restrictions.eqProperty("kt.name", "mt.name") )
    .list();</pre><p>(<code class="literal">createAlias()</code> no crea una nueva instancia de <code class="literal">Criteria</code>.) </p><p>The kittens collections held by the <code class="literal">Cat</code> instances returned by the previous two queries are <span class="emphasis"><em>not</em></span> pre-filtered by the criteria. If you want to retrieve just the kittens that match the criteria, you must use a <code class="literal">ResultTransformer</code>. </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .createCriteria("kittens", "kt")
        .add( Restrictions.eq("name", "F%") )
    .returnMaps()
    .list();
Iterator iter = cats.iterator();
while ( iter.hasNext() ) {
    Map map = (Map) iter.next();
    Cat cat = (Cat) map.get(Criteria.ROOT_ALIAS);
    Cat kitten = (Cat) map.get("kt");
}</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-dynamicfetching"/>15.5. Recuperación dinámica de asociaciones</h2></div></div></div><p>You can specify association fetching semantics at runtime using <code class="literal">setFetchMode()</code>. </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "Fritz%") )
    .setFetchMode("mate", FetchMode.EAGER)
    .setFetchMode("kittens", FetchMode.EAGER)
    .list();</pre><p>Esta consulta recuperará tanto <code class="literal">mate</code> como <code class="literal">kittens</code> por unión exterior (outer join). Ver <a href="#performance-fetching" title="19.1. Estrategias de recuperación">Sección 19.1, “Estrategias de recuperación”</a> para más información. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-examples"/>15.6. Consultas por ejemplos</h2></div></div></div><p>La clase <code class="literal">org.hibernate.criterion.Example</code> te permite construir un criterio de consulta a partir de una instancia dada. </p><pre class="programlisting">Cat cat = new Cat();
cat.setSex('F');
cat.setColor(Color.BLACK);
List results = session.createCriteria(Cat.class)
    .add( Example.create(cat) )
    .list();</pre><p>Las propiedades de versión, los identificadores y las asociaciones son ignorados. Por defecto, las propiedades valuadas a nulo son excluídas. </p><p>Puedes ajustar cómo se aplica el <code class="literal">Example</code>. </p><pre class="programlisting">Example example = Example.create(cat)
    .excludeZeroes()           //exclude zero valued properties
    .excludeProperty("color")  //exclude the property named "color"
    .ignoreCase()              //perform case insensitive string comparisons
    .enableLike();             //use like for string comparisons
List results = session.createCriteria(Cat.class)
    .add(example)
    .list();</pre><p>Puedes incluso usar ejemplos para colocar criterios sobre objetos asociados. </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .add( Example.create(cat) )
    .createCriteria("mate")
        .add( Example.create( cat.getMate() ) )
    .list();</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-projection"/>15.7. Proyecciones, agregación y agrupamiento</h2></div></div></div><p>The class <code class="literal">org.hibernate.criterion.Projections</code> is a factory for <code class="literal">Projection</code> instances. You can apply a projection to a query by calling <code class="literal">setProjection()</code>. </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.rowCount() )
    .add( Restrictions.eq("color", Color.BLACK) )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.projectionList()
        .add( Projections.rowCount() )
        .add( Projections.avg("weight") )
        .add( Projections.max("weight") )
        .add( Projections.groupProperty("color") )
    )
    .list();</pre><p>No es necesario ningún "group by" explícito en una consulta por criterios. Ciertos tipos de proyecciones son definidos para ser <span class="emphasis"><em>proyecciones agrupadas</em></span>, que además aparecen en la cláusula SQL <code class="literal">group by</code>. </p><p>An alias can be assigned to a projection so that the projected value can be referred to in restrictions or orderings. Here are two different ways to do this: </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.alias( Projections.groupProperty("color"), "colr" ) )
    .addOrder( Order.asc("colr") )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.groupProperty("color").as("colr") )
    .addOrder( Order.asc("colr") )
    .list();</pre><p>Los métodos <code class="literal">alias()</code> y <code class="literal">as()</code> simplemente envuelven una instancia de proyección en otra instancia de <code class="literal">Projection</code> con alias. Como un atajo, puedes asignar un alias cuando agregas la proyección a una lista de proyecciones: </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.projectionList()
        .add( Projections.rowCount(), "catCountByColor" )
        .add( Projections.avg("weight"), "avgWeight" )
        .add( Projections.max("weight"), "maxWeight" )
        .add( Projections.groupProperty("color"), "color" )
    )
    .addOrder( Order.desc("catCountByColor") )
    .addOrder( Order.desc("avgWeight") )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Domestic.class, "cat")
    .createAlias("kittens", "kit")
    .setProjection( Projections.projectionList()
        .add( Projections.property("cat.name"), "catName" )
        .add( Projections.property("kit.name"), "kitName" )
    )
    .addOrder( Order.asc("catName") )
    .addOrder( Order.asc("kitName") )
    .list();</pre><p>Puedes también usar <code class="literal">Property.forName()</code> para expresar proyecciones: </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Property.forName("name") )
    .add( Property.forName("color").eq(Color.BLACK) )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.projectionList()
        .add( Projections.rowCount().as("catCountByColor") )
        .add( Property.forName("weight").avg().as("avgWeight") )
        .add( Property.forName("weight").max().as("maxWeight") )
        .add( Property.forName("color").group().as("color" )
    )
    .addOrder( Order.desc("catCountByColor") )
    .addOrder( Order.desc("avgWeight") )
    .list();</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-detachedqueries"/>15.8. Consultas y subconsultas separadas</h2></div></div></div><p>The <code class="literal">DetachedCriteria</code> class allows you to create a query outside the scope of a session and then execute it using an arbitrary <code class="literal">Session</code>. </p><pre class="programlisting">DetachedCriteria query = DetachedCriteria.forClass(Cat.class)
    .add( Property.forName("sex").eq('F') );
    
Session session = ....;
Transaction txn = session.beginTransaction();
List results = query.getExecutableCriteria(session).setMaxResults(100).list();
txn.commit();
session.close();</pre><p>A <code class="literal">DetachedCriteria</code> can also be used to express a subquery. Criterion instances involving subqueries can be obtained via <code class="literal">Subqueries</code> or <code class="literal">Property</code>. </p><pre class="programlisting">DetachedCriteria avgWeight = DetachedCriteria.forClass(Cat.class)
    .setProjection( Property.forName("weight").avg() );
session.createCriteria(Cat.class)
    .add( Property.forName("weight").gt(avgWeight) )
    .list();</pre><pre class="programlisting">DetachedCriteria weights = DetachedCriteria.forClass(Cat.class)
    .setProjection( Property.forName("weight") );
session.createCriteria(Cat.class)
    .add( Subqueries.geAll("weight", weights) )
    .list();</pre><p>Correlated subqueries are also possible: </p><pre class="programlisting">DetachedCriteria avgWeightForSex = DetachedCriteria.forClass(Cat.class, "cat2")
    .setProjection( Property.forName("weight").avg() )
    .add( Property.forName("cat2.sex").eqProperty("cat.sex") );
session.createCriteria(Cat.class, "cat")
    .add( Property.forName("weight").gt(avgWeightForSex) )
    .list();</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="query-criteria-naturalid"/>15.9. Consultas por identificador natural</h2></div></div></div><p>For most queries, including criteria queries, the query cache is not efficient because query cache invalidation occurs too frequently. However, there is a special kind of query where you can optimize the cache invalidation algorithm: lookups by a constant natural key. In some applications, this kind of query occurs frequently. The criteria API provides special provision for this use case. </p><p>First, map the natural key of your entity using <code class="literal">&lt;natural-id&gt;</code> and enable use of the second-level cache. </p><pre class="programlisting">&lt;class name="User"&gt;
    &lt;cache usage="read-write"/&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;natural-id&gt;
        &lt;property name="name"/&gt;
        &lt;property name="org"/&gt;
    &lt;/natural-id&gt;
    &lt;property name="password"/&gt;
&lt;/class
&gt;</pre><p>This functionality is not intended for use with entities with <span class="emphasis"><em>mutable</em></span> natural keys. </p><p>Once you have enabled the Hibernate query cache, the <code class="literal">Restrictions.naturalId()</code> allows you to make use of the more efficient cache algorithm. </p><pre class="programlisting">session.createCriteria(User.class)
    .add( Restrictions.naturalId()
        .set("name", "gavin")
        .set("org", "hb") 
    ).setCacheable(true)
    .uniqueResult();</pre></div></div><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="querysql"/>Capítulo 16. SQL Nativo</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#querysql-creating">16.1. Using a <code class="literal">SQLQuery</code></a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e13411">16.1.1. Scalar queries</a></span></dt><dt><span class="sect2"><a href="#d0e13461">16.1.2. Entity queries</a></span></dt><dt><span class="sect2"><a href="#d0e13497">16.1.3. Handling associations and collections</a></span></dt><dt><span class="sect2"><a href="#d0e13528">16.1.4. Returning multiple entities</a></span></dt><dt><span class="sect2"><a href="#d0e13669">16.1.5. Returning non-managed entities</a></span></dt><dt><span class="sect2"><a href="#d0e13690">16.1.6. Handling inheritance</a></span></dt><dt><span class="sect2"><a href="#d0e13695">16.1.7. Parameters</a></span></dt></dl></dd><dt><span class="sect1"><a href="#querysql-namedqueries">16.2. Consultas SQL con nombre</a></span></dt><dd><dl><dt><span class="sect2"><a href="#propertyresults">16.2.1. Usando return-property para especificar explícitamente nombres de columna/alias</a></span></dt><dt><span class="sect2"><a href="#sp_query">16.2.2. Usando procedimientos almacenados para consultar</a></span></dt></dl></dd><dt><span class="sect1"><a href="#querysql-cud">16.3. SQL personalizado para crear, actualizar y borrar</a></span></dt><dt><span class="sect1"><a href="#querysql-load">16.4. SQL personalizado para carga</a></span></dt></dl></div><p>You can also express queries in the native SQL dialect of your database. This is useful if you want to utilize database-specific features such as query hints or the <code class="literal">CONNECT</code> keyword in Oracle. It also provides a clean migration path from a direct SQL/JDBC based application to Hibernate.</p><p>Hibernate3 allows you to specify handwritten SQL, including stored procedures, for all create, update, delete, and load operations.</p><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="querysql-creating"/>16.1. Using a <code class="literal">SQLQuery</code></h2></div></div></div><p>Execution of native SQL queries is controlled via the <code class="literal">SQLQuery</code> interface, which is obtained by calling <code class="literal">Session.createSQLQuery()</code>. The following sections describe how to use this API for querying.</p><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13411"/>16.1.1. Scalar queries</h3></div></div></div><p>The most basic SQL query is to get a list of scalars (values).</p><pre class="programlisting">sess.createSQLQuery("SELECT * FROM CATS").list();
                                                                         sess.createSQLQuery("SELECT ID, NAME, BIRTHDATE FROM CATS").list();
                                                                         </pre><p>These will return a List of Object arrays (Object[]) with scalar values for each column in the CATS table. Hibernate will use ResultSetMetadata to deduce the actual order and types of the returned scalar values.</p><p>To avoid the overhead of using <code class="literal">ResultSetMetadata</code>, or simply to be more explicit in what is returned, one can use <code class="literal">addScalar()</code>:</p><pre class="programlisting">sess.createSQLQuery("SELECT * FROM CATS")
                                                                         .addScalar("ID", Hibernate.LONG)
                                                                         .addScalar("NAME", Hibernate.STRING)
                                                                         .addScalar("BIRTHDATE", Hibernate.DATE)
                                                                         </pre><p>This query specified:</p><div class="itemizedlist"><ul><li><p>the SQL query string</p></li><li><p>the columns and types to return</p></li></ul></div><p>This will return Object arrays, but now it will not use <code class="literal">ResultSetMetadata</code> but will instead explicitly get the ID, NAME and BIRTHDATE column as respectively a Long, String and a Short from the underlying resultset. This also means that only these three columns will be returned, even though the query is using <code class="literal">*</code> and could return more than the three listed columns.</p><p>It is possible to leave out the type information for all or some of the scalars.</p><pre class="programlisting">sess.createSQLQuery("SELECT * FROM CATS")
                                                                         .addScalar("ID", Hibernate.LONG)
                                                                         .addScalar("NAME")
                                                                         .addScalar("BIRTHDATE")
                                                                         </pre><p>This is essentially the same query as before, but now <code class="literal">ResultSetMetaData</code> is used to determine the type of NAME and BIRTHDATE, where as the type of ID is explicitly specified.</p><p>How the java.sql.Types returned from ResultSetMetaData is mapped to Hibernate types is controlled by the Dialect. If a specific type is not mapped, or does not result in the expected type, it is possible to customize it via calls to <code class="literal">registerHibernateType</code> in the Dialect.</p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13461"/>16.1.2. Entity queries</h3></div></div></div><p>The above queries were all about returning scalar values, basically returning the "raw" values from the resultset. The following shows how to get entity objects from a native sql query via <code class="literal">addEntity()</code>.</p><pre class="programlisting">sess.createSQLQuery("SELECT * FROM CATS").addEntity(Cat.class);
                                                                         sess.createSQLQuery("SELECT ID, NAME, BIRTHDATE FROM CATS").addEntity(Cat.class);
                                                                         </pre><p>This query specified:</p><div class="itemizedlist"><ul><li><p>the SQL query string</p></li><li><p>the entity returned by the query</p></li></ul></div><p>Assuming that Cat is mapped as a class with the columns ID, NAME and BIRTHDATE the above queries will both return a List where each element is a Cat entity.</p><p>If the entity is mapped with a <code class="literal">many-to-one</code> to another entity it is required to also return this when performing the native query, otherwise a database specific "column not found" error will occur. The additional columns will automatically be returned when using the * notation, but we prefer to be explicit as in the following example for a <code class="literal">many-to-one</code> to a <code class="literal">Dog</code>:</p><pre class="programlisting">sess.createSQLQuery("SELECT ID, NAME, BIRTHDATE, DOG_ID FROM CATS").addEntity(Cat.class);
                                                                         </pre><p>This will allow cat.getDog() to function properly.</p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13497"/>16.1.3. Handling associations and collections</h3></div></div></div><p>It is possible to eagerly join in the <code class="literal">Dog</code> to avoid the possible extra roundtrip for initializing the proxy. This is done via the <code class="literal">addJoin()</code> method, which allows you to join in an association or collection.</p><pre class="programlisting">sess.createSQLQuery("SELECT c.ID, NAME, BIRTHDATE, DOG_ID, D_ID, D_NAME FROM CATS c, DOGS d WHERE c.DOG_ID = d.D_ID")
                                                                         .addEntity("cat", Cat.class)
                                                                         .addJoin("cat.dog");
                                                                         </pre><p>In this example, the returned <code class="literal">Cat</code>'s will have their <code class="literal">dog</code> property fully initialized without any extra roundtrip to the database. Notice that you added an alias name ("cat") to be able to specify the target property path of the join. It is possible to do the same eager joining for collections, e.g. if the <code class="literal">Cat</code> had a one-to-many to <code class="literal">Dog</code> instead.</p><pre class="programlisting">sess.createSQLQuery("SELECT ID, NAME, BIRTHDATE, D_ID, D_NAME, CAT_ID FROM CATS c, DOGS d WHERE c.ID = d.CAT_ID")
                                                                         .addEntity("cat", Cat.class)
                                                                         .addJoin("cat.dogs");
                                                                         </pre><p>At this stage you are reaching the limits of what is possible with native queries, without starting to enhance the sql queries to make them usable in Hibernate. Problems can arise when returning multiple entities of the same type or when the default alias/column names are not enough. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13528"/>16.1.4. Returning multiple entities</h3></div></div></div><p>Until now, the result set column names are assumed to be the same as the column names specified in the mapping document. This can be problematic for SQL queries that join multiple tables, since the same column names can appear in more than one table.</p><p>Column alias injection is needed in the following query (which most likely will fail):</p><pre class="programlisting">sess.createSQLQuery("SELECT c.*, m.*  FROM CATS c, CATS m WHERE c.MOTHER_ID = c.ID")
                                                                         .addEntity("cat", Cat.class)
                                                                         .addEntity("mother", Cat.class)
                                                                         </pre><p>The query was intended to return two Cat instances per row: a cat and its mother. The query will, however, fail because there is a conflict of names; the instances are mapped to the same column names. Also, on some databases the returned column aliases will most likely be on the form "c.ID", "c.NAME", etc. which are not equal to the columns specified in the mappings ("ID" and "NAME"). </p><p>The following form is not vulnerable to column name duplication:</p><pre class="programlisting">sess.createSQLQuery("SELECT {cat.*}, {mother.*}  FROM CATS c, CATS m WHERE c.MOTHER_ID = c.ID")
                                                                         .addEntity("cat", Cat.class)
                                                                         .addEntity("mother", Cat.class)
                                                                         </pre><p>This query specified:</p><div class="itemizedlist"><ul><li><p>the SQL query string, with placeholders for Hibernate to inject column aliases</p></li><li><p>the entities returned by the query</p></li></ul></div><p>The {cat.*} and {mother.*} notation used above is a shorthand for "all properties". Alternatively, you can list the columns explicitly, but even in this case Hibernate injects the SQL column aliases for each property. The placeholder for a column alias is just the property name qualified by the table alias. In the following example, you retrieve Cats and their mothers from a different table (cat_log) to the one declared in the mapping metadata. You can even use the property aliases in the where clause.</p><pre class="programlisting">String sql = "SELECT ID as {c.id}, NAME as {c.name}, " + 
                                                    "BIRTHDATE as {c.birthDate}, MOTHER_ID as {c.mother}, {mother.*} " +
                                                    "FROM CAT_LOG c, CAT_LOG m WHERE {c.mother} = c.ID";
                                                    
                                                    List loggedCats = sess.createSQLQuery(sql)
                                                    .addEntity("cat", Cat.class)
                                                    .addEntity("mother", Cat.class).list()
                                                    </pre><div class="sect3" lang="es-ES"><div class="titlepage"><div><div><h4 class="title"><a id="querysql-aliasreferences"/>16.1.4.1. Alias and property references</h4></div></div></div><p>In most cases the above alias injection is needed. For queries relating to more complex mappings, like composite properties, inheritance discriminators, collections etc., you can use specific aliases that allow Hibernate to inject the proper aliases.</p><p>The following table shows the different ways you can use the alias injection. Please note that the alias names in the result are simply examples; each alias will have a unique and probably different name when used.</p><div class="table"><a id="aliasinjection-summary"/><p class="title"><b>Tabla 16.1. Alias injection names</b></p><div class="table-contents"><table summary="Alias injection names" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Description</th><th>Syntax</th><th>Example</th></tr></thead><tbody><tr><td>A simple property</td><td><code class="literal">{[aliasname].[propertyname]</code></td><td><code class="literal">A_NAME as {item.name}</code></td></tr><tr><td>A composite property</td><td><code class="literal">{[aliasname].[componentname].[propertyname]}</code></td><td><code class="literal">CURRENCY as {item.amount.currency}, VALUE as {item.amount.value}</code></td></tr><tr><td>Discriminator of an entity</td><td><code class="literal">{[aliasname].class}</code></td><td><code class="literal">DISC as {item.class}</code></td></tr><tr><td>All properties of an entity</td><td><code class="literal">{[aliasname].*}</code></td><td><code class="literal">{item.*}</code></td></tr><tr><td>A collection key</td><td><code class="literal">{[aliasname].key}</code></td><td><code class="literal">ORGID as {coll.key}</code></td></tr><tr><td>The id of an collection</td><td><code class="literal">{[aliasname].id}</code></td><td><code class="literal">EMPID as {coll.id}</code></td></tr><tr><td>The element of an collection</td><td><code class="literal">{[aliasname].element}</code></td><td><code class="literal">XID as {coll.element}</code></td></tr><tr><td>property of the element in the collection</td><td><code class="literal">{[aliasname].element.[propertyname]}</code></td><td><code class="literal">NAME as {coll.element.name}</code></td></tr><tr><td>All properties of the element in the collection</td><td><code class="literal">{[aliasname].element.*}</code></td><td><code class="literal">{coll.element.*}</code></td></tr><tr><td>All properties of the the collection</td><td><code class="literal">{[aliasname].*}</code></td><td><code class="literal">{coll.*}</code></td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13669"/>16.1.5. Returning non-managed entities</h3></div></div></div><p>It is possible to apply a ResultTransformer to native SQL queries, allowing it to return non-managed entities.</p><pre class="programlisting">sess.createSQLQuery("SELECT NAME, BIRTHDATE FROM CATS")
                                                                         .setResultTransformer(Transformers.aliasToBean(CatDTO.class))</pre><p>This query specified:</p><div class="itemizedlist"><ul><li><p>the SQL query string</p></li><li><p>a result transformer</p></li></ul></div><p>The above query will return a list of <code class="literal">CatDTO</code> which has been instantiated and injected the values of NAME and BIRTHNAME into its corresponding properties or fields. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13690"/>16.1.6. Handling inheritance</h3></div></div></div><p>Native SQL queries which query for entities that are mapped as part of an inheritance must include all properties for the baseclass and all its subclasses.</p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13695"/>16.1.7. Parameters</h3></div></div></div><p>Native SQL queries support positional as well as named parameters:</p><pre class="programlisting">Query query = sess.createSQLQuery("SELECT * FROM CATS WHERE NAME like ?").addEntity(Cat.class);
                                                   List pusList = query.setString(0, "Pus%").list();
                                                   
                                                   query = sess.createSQLQuery("SELECT * FROM CATS WHERE NAME like :name").addEntity(Cat.class);
                                                   List pusList = query.setString("name", "Pus%").list();          </pre></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="querysql-namedqueries"/>16.2. Consultas SQL con nombre</h2></div></div></div><p>Named SQL queries can be defined in the mapping document and called in exactly the same way as a named HQL query. In this case, you do <span class="emphasis"><em>not</em></span> need to call <code class="literal">addEntity()</code>.</p><pre class="programlisting">&lt;sql-query name="persons"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex}
    FROM PERSON person 
    WHERE person.NAME LIKE :namePattern
&lt;/sql-query
&gt;</pre><pre class="programlisting">List people = sess.getNamedQuery("persons")
    .setString("namePattern", namePattern)
    .setMaxResults(50)
    .list();</pre><p>The <code class="literal">&lt;return-join&gt;</code> element is use to join associations and the <code class="literal">&lt;load-collection&gt;</code> element is used to define queries which initialize collections, </p><pre class="programlisting">&lt;sql-query name="personsWith"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    &lt;return-join alias="address" property="person.mailingAddress"/&gt;
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex},
           address.STREET AS {address.street},
           address.CITY AS {address.city},
           address.STATE AS {address.state},
           address.ZIP AS {address.zip}
    FROM PERSON person 
    JOIN ADDRESS address
            ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'
    WHERE person.NAME LIKE :namePattern
&lt;/sql-query
&gt;</pre><p>Una consulta SQL con nombre puede devolver un valor escalar. Debes especificar el alias de columna y tipo Hibernate usando el elementp <code class="literal">&lt;return-scalar&gt;</code>:</p><pre class="programlisting">&lt;sql-query name="mySqlQuery"&gt;
    &lt;return-scalar column="name" type="string"/&gt;
    &lt;return-scalar column="age" type="long"/&gt;
    SELECT p.NAME AS name,
           p.AGE AS age,
    FROM PERSON p WHERE p.NAME LIKE 'Hiber%'
&lt;/sql-query
&gt;</pre><p>You can externalize the resultset mapping information in a <code class="literal">&lt;resultset&gt;</code> element which will allow you to either reuse them across several named queries or through the <code class="literal">setResultSetMapping()</code> API.</p><pre class="programlisting">&lt;resultset name="personAddress"&gt;
                &lt;return alias="person" class="eg.Person"/&gt;
                &lt;return-join alias="address" property="person.mailingAddress"/&gt;
        &lt;/resultset&gt;
        
        &lt;sql-query name="personsWith" resultset-ref="personAddress"&gt;
                SELECT person.NAME AS {person.name},
                person.AGE AS {person.age},
                person.SEX AS {person.sex},
                address.STREET AS {address.street},
                address.CITY AS {address.city},
                address.STATE AS {address.state},
                address.ZIP AS {address.zip}
                FROM PERSON person
                JOIN ADDRESS address
                ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'
                WHERE person.NAME LIKE :namePattern
        &lt;/sql-query
&gt;</pre><p>You can, alternatively, use the resultset mapping information in your hbm files directly in java code.</p><pre class="programlisting">List cats = sess.createSQLQuery(
                              "select {cat.*}, {kitten.*} from cats cat, cats kitten where kitten.mother = cat.id"
                              )
                              .setResultSetMapping("catAndKitten")
    .list();</pre><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="propertyresults"/>16.2.1. Usando return-property para especificar explícitamente nombres de columna/alias</h3></div></div></div><p>You can explicitly tell Hibernate what column aliases to use with <code class="literal">&lt;return-property&gt;</code>, instead of using the <code class="literal">{}</code>-syntax to let Hibernate inject its own aliases.For example:</p><pre class="programlisting">&lt;sql-query name="mySqlQuery"&gt;
    &lt;return alias="person" class="eg.Person"&gt;
        &lt;return-property name="name" column="myName"/&gt;
        &lt;return-property name="age" column="myAge"/&gt;
        &lt;return-property name="sex" column="mySex"/&gt;
    &lt;/return&gt;
    SELECT person.NAME AS myName,
           person.AGE AS myAge,
           person.SEX AS mySex,
    FROM PERSON person WHERE person.NAME LIKE :name
&lt;/sql-query&gt;
</pre><p><code class="literal">&lt;return-property&gt;</code> also works with multiple columns. This solves a limitation with the <code class="literal">{}</code>-syntax which cannot allow fine grained control of multi-column properties.</p><pre class="programlisting">&lt;sql-query name="organizationCurrentEmployments"&gt;
    &lt;return alias="emp" class="Employment"
&gt;            
        &lt;return-property name="salary"
&gt; 
            &lt;return-column name="VALUE"/&gt;
            &lt;return-column name="CURRENCY"/&gt;            
        &lt;/return-property&gt;
        &lt;return-property name="endDate" column="myEndDate"/&gt;
    &lt;/return&gt;
        SELECT EMPLOYEE AS {emp.employee}, EMPLOYER AS {emp.employer}, 
        STARTDATE AS {emp.startDate}, ENDDATE AS {emp.endDate},
        REGIONCODE as {emp.regionCode}, EID AS {emp.id}, VALUE, CURRENCY
        FROM EMPLOYMENT
        WHERE EMPLOYER = :id AND ENDDATE IS NULL
        ORDER BY STARTDATE ASC
&lt;/sql-query
&gt;</pre><p>In this example <code class="literal">&lt;return-property&gt;</code> was used in combination with the <code class="literal">{}</code>-syntax for injection. This allows users to choose how they want to refer column and properties.</p><p>Si tu mapeo tiene un discriminador debes usar <code class="literal">&lt;return-discriminator&gt;</code> para especificar la columna discriminadora.</p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="sp_query"/>16.2.2. Usando procedimientos almacenados para consultar</h3></div></div></div><p>Hibernate3 provides support for queries via stored procedures and functions. Most of the following documentation is equivalent for both. The stored procedure/function must return a resultset as the first out-parameter to be able to work with Hibernate. An example of such a stored function in Oracle 9 and higher is as follows:</p><pre class="programlisting">CREATE OR REPLACE FUNCTION selectAllEmployments 
    RETURN SYS_REFCURSOR 
AS 
    st_cursor SYS_REFCURSOR; 
BEGIN 
    OPEN st_cursor FOR 
 SELECT EMPLOYEE, EMPLOYER, 
 STARTDATE, ENDDATE, 
 REGIONCODE, EID, VALUE, CURRENCY 
 FROM EMPLOYMENT; 
      RETURN  st_cursor; 
 END;</pre><p>Para usar esta consulta en Hibernate necesitas mapearla por medio de una consulta con nombre.</p><pre class="programlisting">&lt;sql-query name="selectAllEmployees_SP" callable="true"&gt;
    &lt;return alias="emp" class="Employment"&gt;
        &lt;return-property name="employee" column="EMPLOYEE"/&gt;
        &lt;return-property name="employer" column="EMPLOYER"/&gt;            
        &lt;return-property name="startDate" column="STARTDATE"/&gt;
        &lt;return-property name="endDate" column="ENDDATE"/&gt;            
        &lt;return-property name="regionCode" column="REGIONCODE"/&gt;            
        &lt;return-property name="id" column="EID"/&gt;                        
        &lt;return-property name="salary"
&gt; 
            &lt;return-column name="VALUE"/&gt;
            &lt;return-column name="CURRENCY"/&gt;            
        &lt;/return-property&gt;
    &lt;/return&gt;
    { ? = call selectAllEmployments() }
&lt;/sql-query
&gt;</pre><p>Stored procedures currently only return scalars and entities. <code class="literal">&lt;return-join&gt;</code> and <code class="literal">&lt;load-collection&gt;</code> are not supported.</p><div class="sect3" lang="es-ES"><div class="titlepage"><div><div><h4 class="title"><a id="querysql-limits-storedprocedures"/>16.2.2.1. Reglas/limitaciones para usar procedimientos almacenados</h4></div></div></div><p>You cannot use stored procedures with Hibernate unless you follow some procedure/function rules. If they do not follow those rules they are not usable with Hibernate. If you still want to use these procedures you have to execute them via <code class="literal">session.connection()</code>. The rules are different for each database, since database vendors have different stored procedure semantics/syntax.</p><p>Stored procedure queries cannot be paged with <code class="literal">setFirstResult()/setMaxResults()</code>.</p><p>The recommended call form is standard SQL92: <code class="literal">{ ? = call functionName(&lt;parameters&gt;) }</code> or <code class="literal">{ ? = call procedureName(&lt;parameters&gt;}</code>. Native call syntax is not supported.</p><p>El procedimiento debe devolver un conjunto resultado. Esto se hace devolviendo un <code class="literal">SYS_REFCURSOR</code> en Oracle 9 o 10. En Oracle necesitas definir un tipo <code class="literal">REF CURSOR</code>.</p><div class="itemizedlist"><ul compact="compact"><li><p>A function must return a result set. The first parameter of a procedure must be an <code class="literal">OUT</code> that returns a result set. This is done by using a <code class="literal">SYS_REFCURSOR</code> type in Oracle 9 or 10. In Oracle you need to define a <code class="literal">REF CURSOR</code> type. See Oracle literature for further information.</p></li></ul></div><p>Para Sybase o MS SQL server se aplican las siguientes reglas:</p><div class="itemizedlist"><ul compact="compact"><li><p>The procedure must return a result set. Note that since these servers can return multiple result sets and update counts, Hibernate will iterate the results and take the first result that is a result set as its return value. Everything else will be discarded.</p></li><li><p>Si habilitas <code class="literal">SET NOCOUNT ON</code> en tu procedimiento será probablemente más eficiente, pero esto no es un requerimiento.</p></li></ul></div></div></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="querysql-cud"/>16.3. SQL personalizado para crear, actualizar y borrar</h2></div></div></div><p>Hibernate3 puede usar sentencias SQL personalizadas para las operaciones de crear, actualizar y borrar. Los persistidores de clases y colecciones en Hibernate ya contienen un conjunto de cadenas generadas en tiempo de configuración (insertsql, deletesql, updatesql, etc.). Las etiquetas de mapeo <code class="literal">&lt;sql-insert&gt;</code>, <code class="literal">&lt;sql-delete&gt;</code>, y <code class="literal">&lt;sql-update&gt;</code> sobrescriben estas cadenas:</p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true"/&gt;
    &lt;sql-insert
&gt;INSERT INTO PERSON (NAME, ID) VALUES ( UPPER(?), ? )&lt;/sql-insert&gt;
    &lt;sql-update
&gt;UPDATE PERSON SET NAME=UPPER(?) WHERE ID=?&lt;/sql-update&gt;
    &lt;sql-delete
&gt;DELETE FROM PERSON WHERE ID=?&lt;/sql-delete&gt;
&lt;/class
&gt;</pre><p>The SQL is directly executed in your database, so you can use any dialect you like. This will reduce the portability of your mapping if you use database specific SQL.</p><p>Los procedimientos almacenados son soportados si está establecido el atributo <code class="literal">callable</code>:</p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true"/&gt;
    &lt;sql-insert callable="true"
&gt;{call createPerson (?, ?)}&lt;/sql-insert&gt;
    &lt;sql-delete callable="true"
&gt;{? = call deletePerson (?)}&lt;/sql-delete&gt;
    &lt;sql-update callable="true"
&gt;{? = call updatePerson (?, ?)}&lt;/sql-update&gt;
&lt;/class
&gt;</pre><p>The order of the positional parameters is vital, as they must be in the same sequence as Hibernate expects them.</p><p>You can view the expected order by enabling debug logging for the <code class="literal">org.hibernate.persister.entity</code> level. With this level enabled, Hibernate will print out the static SQL that is used to create, update, delete etc. entities. To view the expected sequence, do not include your custom SQL in the mapping files, as this will override the Hibernate generated static SQL.</p><p>The stored procedures are in most cases required to return the number of rows inserted, updated and deleted, as Hibernate has some runtime checks for the success of the statement. Hibernate always registers the first statement parameter as a numeric output parameter for the CUD operations:</p><pre class="programlisting">CREATE OR REPLACE FUNCTION updatePerson (uid IN NUMBER, uname IN VARCHAR2)
    RETURN NUMBER IS
BEGIN

    update PERSON
    set
        NAME = uname,
    where
        ID = uid;

    return SQL%ROWCOUNT;

END updatePerson;</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="querysql-load"/>16.4. SQL personalizado para carga</h2></div></div></div><p>You can also declare your own SQL (or HQL) queries for entity loading:</p><pre class="programlisting">&lt;sql-query name="person"&gt;
    &lt;return alias="pers" class="Person" lock-mode="upgrade"/&gt;
    SELECT NAME AS {pers.name}, ID AS {pers.id} 
    FROM PERSON 
    WHERE ID=? 
    FOR UPDATE
&lt;/sql-query
&gt;</pre><p>This is just a named query declaration, as discussed earlier. You can reference this named query in a class mapping:</p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true"/&gt;
    &lt;loader query-ref="person"/&gt;
&lt;/class
&gt;</pre><p>Esto incluso funciona con procedimientos almacenados.</p><p>You can even define a query for collection loading:</p><pre class="programlisting">&lt;set name="employments" inverse="true"&gt;
    &lt;key/&gt;
    &lt;one-to-many class="Employment"/&gt;
    &lt;loader query-ref="employments"/&gt;
&lt;/set
&gt;</pre><pre class="programlisting">&lt;sql-query name="employments"&gt;
    &lt;load-collection alias="emp" role="Person.employments"/&gt;
    SELECT {emp.*}
    FROM EMPLOYMENT emp
    WHERE EMPLOYER = :id
    ORDER BY STARTDATE ASC, EMPLOYEE ASC
&lt;/sql-query
&gt;</pre><p>You can also define an entity loader that loads a collection by join fetching:</p><pre class="programlisting">&lt;sql-query name="person"&gt;
    &lt;return alias="pers" class="Person"/&gt;
    &lt;return-join alias="emp" property="pers.employments"/&gt; 
    SELECT NAME AS {pers.*}, {emp.*}
    FROM PERSON pers
    LEFT OUTER JOIN EMPLOYMENT emp 
        ON pers.ID = emp.PERSON_ID
    WHERE ID=?
&lt;/sql-query
&gt;</pre></div></div><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="filters"/>Capítulo 17. Filtrando datos</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#objectstate-filters">17.1. Filtros de Hibernate</a></span></dt></dl></div><p>Hibernate3 provides an innovative new approach to handling data with "visibility" rules. A <span class="emphasis"><em>Hibernate filter</em></span> is a global, named, parameterized filter that can be enabled or disabled for a particular Hibernate session. </p><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-filters"/>17.1. Filtros de Hibernate</h2></div></div></div><p>Hibernate3 has the ability to pre-define filter criteria and attach those filters at both a class level and a collection level. A filter criteria allows you to define a restriction clause similar to the existing "where" attribute available on the class and various collection elements. These filter conditions, however, can be parameterized. The application can then decide at runtime whether certain filters should be enabled and what their parameter values should be. Filters can be used like database views, but they are parameterized inside the application. </p><p>Para usar los filtros, éstos deben primero ser definidos y luego unidos a los elementos de mapeo apropiados. Para definir un filtro, usa el elemento <code class="literal">&lt;filter-def/&gt;</code> dentro de un elemento <code class="literal">&lt;hibernate-mapping/&gt;</code>: </p><pre class="programlisting">&lt;filter-def name="myFilter"&gt;
    &lt;filter-param name="myFilterParam" type="string"/&gt;
&lt;/filter-def
&gt;</pre><p>This filter can then be attached to a class: </p><pre class="programlisting">&lt;class name="myClass" ...&gt;
    ...
    &lt;filter name="myFilter" condition=":myFilterParam = MY_FILTERED_COLUMN"/&gt;
&lt;/class
&gt;</pre><p>Or, to a collection: </p><pre class="programlisting">&lt;set ...&gt;
    &lt;filter name="myFilter" condition=":myFilterParam = MY_FILTERED_COLUMN"/&gt;
&lt;/set
&gt;</pre><p>Or, to both or multiples of each at the same time. </p><p>The methods on <code class="literal">Session</code> are: <code class="literal">enableFilter(String filterName)</code>, <code class="literal">getEnabledFilter(String filterName)</code>, and <code class="literal">disableFilter(String filterName)</code>. By default, filters are <span class="emphasis"><em>not</em></span> enabled for a given session. Filters must be enabled through use of the <code class="literal">Session.enableFilter()</code> method, which returns an instance of the <code class="literal">Filter</code> interface. If you used the simple filter defined above, it would look like this: </p><pre class="programlisting">session.enableFilter("myFilter").setParameter("myFilterParam", "some-value");</pre><p>Methods on the org.hibernate.Filter interface do allow the method-chaining common to much of Hibernate. </p><p>The following is a full example, using temporal data with an effective record date pattern: </p><pre class="programlisting">&lt;filter-def name="effectiveDate"&gt;
    &lt;filter-param name="asOfDate" type="date"/&gt;
&lt;/filter-def&gt;

&lt;class name="Employee" ...&gt;
...
    &lt;many-to-one name="department" column="dept_id" class="Department"/&gt;
    &lt;property name="effectiveStartDate" type="date" column="eff_start_dt"/&gt;
    &lt;property name="effectiveEndDate" type="date" column="eff_end_dt"/&gt;
...
    &lt;!--
        Note that this assumes non-terminal records have an eff_end_dt set to
        a max db date for simplicity-sake
    --&gt;
    &lt;filter name="effectiveDate"
            condition=":asOfDate BETWEEN eff_start_dt and eff_end_dt"/&gt;
&lt;/class&gt;

&lt;class name="Department" ...&gt;
...
    &lt;set name="employees" lazy="true"&gt;
        &lt;key column="dept_id"/&gt;
        &lt;one-to-many class="Employee"/&gt;
        &lt;filter name="effectiveDate"
                condition=":asOfDate BETWEEN eff_start_dt and eff_end_dt"/&gt;
    &lt;/set&gt;
&lt;/class
&gt;</pre><p>In order to ensure that you are provided with currently effective records, enable the filter on the session prior to retrieving employee data: </p><pre class="programlisting">Session session = ...;
session.enableFilter("effectiveDate").setParameter("asOfDate", new Date());
List results = session.createQuery("from Employee as e where e.salary 
&gt; :targetSalary")
         .setLong("targetSalary", new Long(1000000))
         .list();
</pre><p>Even though a salary constraint was mentioned explicitly on the results in the above HQL, because of the enabled filter, the query will return only currently active employees who have a salary greater than one million dollars. </p><p>If you want to use filters with outer joining, either through HQL or load fetching, be careful of the direction of the condition expression. It is safest to set this up for left outer joining. Place the parameter first followed by the column name(s) after the operator. </p><p>After being defined, a filter might be attached to multiple entities and/or collections each with its own condition. This can be problematic when the conditions are the same each time. Using <code class="literal">&lt;filter-def/&gt;</code> allows you to definine a default condition, either as an attribute or CDATA: </p><pre class="programlisting">&lt;filter-def name="myFilter" condition="abc &gt; xyz"&gt;...&lt;/filter-def&gt;
&lt;filter-def name="myOtherFilter"&gt;abc=xyz&lt;/filter-def&gt;</pre><p>This default condition will be used whenever the filter is attached to something without specifying a condition. This means you can give a specific condition as part of the attachment of the filter that overrides the default condition in that particular case. </p></div></div><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="xml"/>Capítulo 18. Mapeo XML</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#xml-intro">18.1. Trabajando con datos XML</a></span></dt><dd><dl><dt><span class="sect2"><a href="#xml-intro-mapping">18.1.1. Especificando los mapeos de XML y de clase juntos</a></span></dt><dt><span class="sect2"><a href="#xml-onlyxml">18.1.2. Especificando sólo un mapeo XML</a></span></dt></dl></dd><dt><span class="sect1"><a href="#xml-mapping">18.2. Mapeo de metadatos XML</a></span></dt><dt><span class="sect1"><a href="#xml-manipulation">18.3. Manipulando datos XML</a></span></dt></dl></div><p><span class="emphasis"><em>XML Mapping is an experimental feature in Hibernate 3.0 and is currently under active development. </em></span></p><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="xml-intro"/>18.1. Trabajando con datos XML</h2></div></div></div><p>Hibernate allows you to work with persistent XML data in much the same way you work with persistent POJOs. A parsed XML tree can be thought of as another way of representing the relational data at the object level, instead of POJOs. </p><p>Hibernate soporta dom4j como API para manipular árboles XML. Puedes escribir consultas que traigan árboles dom4j de la base de datos y tener cualquier modificación que hagas al árbol sincronizada automáticamente a la base de datos. Puedes incluso tomar un documento XML, analizarlo usando dom4j, y escribirlo a la base de datos con cualquiera de las operaciones básicas de Hibernate: <code class="literal">persist(), saveOrUpdate(), merge(), delete(), replicate()</code> (la fusión no está aún soportada). </p><p>Esta funcionalidad tiene muchas aplicaciones incluyendo la importación/exportación de datos, externalización de datos de entidad vía JMS o SOAP y reportes basados en XSLT. </p><p>A single mapping can be used to simultaneously map properties of a class and nodes of an XML document to the database, or, if there is no class to map, it can be used to map just the XML. </p><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="xml-intro-mapping"/>18.1.1. Especificando los mapeos de XML y de clase juntos</h3></div></div></div><p>He aquí un ejemplo de mapear un POJO y XML simultáneamente: </p><pre class="programlisting">&lt;class name="Account" 
        table="ACCOUNTS" 
        node="account"&gt;
        
    &lt;id name="accountId" 
            column="ACCOUNT_ID" 
            node="@id"/&gt;
            
    &lt;many-to-one name="customer" 
            column="CUSTOMER_ID" 
            node="customer/@id" 
            embed-xml="false"/&gt;
            
    &lt;property name="balance" 
            column="BALANCE" 
            node="balance"/&gt;
            
    ...
    
&lt;/class
&gt;</pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="xml-onlyxml"/>18.1.2. Especificando sólo un mapeo XML</h3></div></div></div><p>He aquí un ejemplo donde no hay ninguna clase POJO: </p><pre class="programlisting">&lt;class entity-name="Account" 
        table="ACCOUNTS" 
        node="account"&gt;
        
    &lt;id name="id" 
            column="ACCOUNT_ID" 
            node="@id" 
            type="string"/&gt;
            
    &lt;many-to-one name="customerId" 
            column="CUSTOMER_ID" 
            node="customer/@id" 
            embed-xml="false" 
            entity-name="Customer"/&gt;
            
    &lt;property name="balance" 
            column="BALANCE" 
            node="balance" 
            type="big_decimal"/&gt;
            
    ...
    
&lt;/class
&gt;</pre><p>This mapping allows you to access the data as a dom4j tree, or as a graph of property name/value pairs or java <code class="literal">Map</code>s. The property names are purely logical constructs that can be referred to in HQL queries. </p></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="xml-mapping"/>18.2. Mapeo de metadatos XML</h2></div></div></div><p>A range of Hibernate mapping elements accept the <code class="literal">node</code> attribute. This lets you specify the name of an XML attribute or element that holds the property or entity data. The format of the <code class="literal">node</code> attribute must be one of the following: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">"element-name"</code>: map to the named XML element</p></li><li><p><code class="literal">"@attribute-name"</code>: map to the named XML attribute</p></li><li><p><code class="literal">"."</code>: map to the parent element</p></li><li><p><code class="literal">"element-name/@attribute-name"</code>: map to the named attribute of the named element </p></li></ul></div><p>For collections and single valued associations, there is an additional <code class="literal">embed-xml</code> attribute. If <code class="literal">embed-xml="true"</code>, the default, the XML tree for the associated entity (or collection of value type) will be embedded directly in the XML tree for the entity that owns the association. Otherwise, if <code class="literal">embed-xml="false"</code>, then only the referenced identifier value will appear in the XML for single point associations and collections will not appear at all. </p><p>Do not leave <code class="literal">embed-xml="true"</code> for too many associations, since XML does not deal well with circularity. </p><pre class="programlisting">&lt;class name="Customer" 
        table="CUSTOMER" 
        node="customer"&gt;
        
    &lt;id name="id" 
            column="CUST_ID" 
            node="@id"/&gt;
            
    &lt;map name="accounts" 
            node="." 
            embed-xml="true"&gt;
        &lt;key column="CUSTOMER_ID" 
                not-null="true"/&gt;
        &lt;map-key column="SHORT_DESC" 
                node="@short-desc" 
                type="string"/&gt;
        &lt;one-to-many entity-name="Account"
                embed-xml="false" 
                node="account"/&gt;
    &lt;/map&gt;
    
    &lt;component name="name" 
            node="name"&gt;
        &lt;property name="firstName" 
                node="first-name"/&gt;
        &lt;property name="initial" 
                node="initial"/&gt;
        &lt;property name="lastName" 
                node="last-name"/&gt;
    &lt;/component&gt;
    
    ...
    
&lt;/class
&gt;</pre><p>In this case, the collection of account ids is embedded, but not the actual account data. The following HQL query: </p><pre class="programlisting">from Customer c left join fetch c.accounts where c.lastName like :lastName</pre><p>would return datasets such as this: </p><pre class="programlisting">&lt;customer id="123456789"&gt;
    &lt;account short-desc="Savings"
&gt;987632567&lt;/account&gt;
    &lt;account short-desc="Credit Card"
&gt;985612323&lt;/account&gt;
    &lt;name&gt;
        &lt;first-name
&gt;Gavin&lt;/first-name&gt;
        &lt;initial
&gt;A&lt;/initial&gt;
        &lt;last-name
&gt;King&lt;/last-name&gt;
    &lt;/name&gt;
    ...
&lt;/customer
&gt;</pre><p>Si estableces <code class="literal">embed-xml="true"</code> en el mapeo <code class="literal">&lt;one-to-many&gt;</code>, los datos podrían verse así: </p><pre class="programlisting">&lt;customer id="123456789"&gt;
    &lt;account id="987632567" short-desc="Savings"&gt;
        &lt;customer id="123456789"/&gt;
        &lt;balance
&gt;100.29&lt;/balance&gt;
    &lt;/account&gt;
    &lt;account id="985612323" short-desc="Credit Card"&gt;
        &lt;customer id="123456789"/&gt;
        &lt;balance
&gt;-2370.34&lt;/balance&gt;
    &lt;/account&gt;
    &lt;name&gt;
        &lt;first-name
&gt;Gavin&lt;/first-name&gt;
        &lt;initial
&gt;A&lt;/initial&gt;
        &lt;last-name
&gt;King&lt;/last-name&gt;
    &lt;/name&gt;
    ...
&lt;/customer
&gt;</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="xml-manipulation"/>18.3. Manipulando datos XML</h2></div></div></div><p>You can also re-read and update XML documents in the application. You can do this by obtaining a dom4j session: </p><pre class="programlisting">Document doc = ....;
       
Session session = factory.openSession();
Session dom4jSession = session.getSession(EntityMode.DOM4J);
Transaction tx = session.beginTransaction();

List results = dom4jSession
    .createQuery("from Customer c left join fetch c.accounts where c.lastName like :lastName")
    .list();
for ( int i=0; i&lt;results.size(); i++ ) {
    //add the customer data to the XML document
    Element customer = (Element) results.get(i);
    doc.add(customer);
}

tx.commit();
session.close();</pre><pre class="programlisting">Session session = factory.openSession();
Session dom4jSession = session.getSession(EntityMode.DOM4J);
Transaction tx = session.beginTransaction();

Element cust = (Element) dom4jSession.get("Customer", customerId);
for ( int i=0; i&lt;results.size(); i++ ) {
    Element customer = (Element) results.get(i);
    //change the customer name in the XML and database
    Element name = customer.element("name");
    name.element("first-name").setText(firstName);
    name.element("initial").setText(initial);
    name.element("last-name").setText(lastName);
}

tx.commit();
session.close();</pre><p>When implementing XML-based data import/export, it is useful to combine this feature with Hibernate's <code class="literal">replicate()</code> operation. </p></div></div><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="performance"/>Capítulo 19. Mejorando el rendimiento</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#performance-fetching">19.1. Estrategias de recuperación</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-fetching-lazy">19.1.1. Trabajando con asociaciones perezosas</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-custom">19.1.2. Afinando las estrategias de recuperación</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-proxies">19.1.3. Proxies de asociaciones de un solo extremo</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-initialization">19.1.4. Inicializando colecciones y proxies</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-batch">19.1.5. Usando recuperación en lotes</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-subselect">19.1.6. Usando recuperación por subselección</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-lazyproperties">19.1.7. Usando recuperación perezosa de propiedades</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-cache">19.2. El Caché de Segundo Nivel</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-cache-mapping">19.2.1. Mapeos de caché</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readonly">19.2.2. Estrategia: sólo lectura (read only)</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readwrite">19.2.3. Estrategia: lectura/escritura (read/write)</a></span></dt><dt><span class="sect2"><a href="#performance-cache-nonstrict">19.2.4. Estrategia: lectura/escritura no estricta (nonstrict read/write)</a></span></dt><dt><span class="sect2"><a href="#performance-cache-transactional">19.2.5. Estrategia: transaccional</a></span></dt><dt><span class="sect2"><a href="#performance-cache-compat-matrix">19.2.6. Cache-provider/concurrency-strategy compatibility</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-sessioncache">19.3. Gestionando los cachés</a></span></dt><dt><span class="sect1"><a href="#performance-querycache">19.4. El Caché de Consultas</a></span></dt><dt><span class="sect1"><a href="#performance-collections">19.5. Entendiendo el rendimiento de Colecciones</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-collections-taxonomy">19.5.1. Taxonomia</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficientupdate">19.5.2. Las listas, mapas, idbags y conjuntos son las colecciones más eficientes de actualizar</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficentinverse">19.5.3. Los Bags y las listas son las colecciones inversas más eficientes</a></span></dt><dt><span class="sect2"><a href="#performance-collections-oneshotdelete">19.5.4. Borrado de un solo tiro</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-monitoring">19.6. Monitoreando el rendimiento</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-monitoring-sf">19.6.1. Monitoreando una SessionFactory</a></span></dt><dt><span class="sect2"><a href="#performance-monitoring-metrics">19.6.2. Métricas</a></span></dt></dl></dd></dl></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="performance-fetching"/>19.1. Estrategias de recuperación</h2></div></div></div><p>Hibernate uses a <span class="emphasis"><em>fetching strategy</em></span> to retrieve associated objects if the application needs to navigate the association. Fetch strategies can be declared in the O/R mapping metadata, or over-ridden by a particular HQL or <code class="literal">Criteria</code> query. </p><p>Hibernate3 define las siguientes estrategias de recuperación: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Join fetching</em></span>: Hibernate retrieves the associated instance or collection in the same <code class="literal">SELECT</code>, using an <code class="literal">OUTER JOIN</code>. </p></li><li><p><span class="emphasis"><em>Select fetching</em></span>: a second <code class="literal">SELECT</code> is used to retrieve the associated entity or collection. Unless you explicitly disable lazy fetching by specifying <code class="literal">lazy="false"</code>, this second select will only be executed when you access the association. </p></li><li><p><span class="emphasis"><em>Subselect fetching</em></span>: a second <code class="literal">SELECT</code> is used to retrieve the associated collections for all entities retrieved in a previous query or fetch. Unless you explicitly disable lazy fetching by specifying <code class="literal">lazy="false"</code>, this second select will only be executed when you access the association. </p></li><li><p><span class="emphasis"><em>Batch fetching</em></span>: an optimization strategy for select fetching. Hibernate retrieves a batch of entity instances or collections in a single <code class="literal">SELECT</code> by specifying a list of primary or foreign keys. </p></li></ul></div><p>Hibernate también distingue entre: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Immediate fetching</em></span>: an association, collection or attribute is fetched immediately when the owner is loaded. </p></li><li><p><span class="emphasis"><em>Lazy collection fetching</em></span>: a collection is fetched when the application invokes an operation upon that collection. This is the default for collections. </p></li><li><p><span class="emphasis"><em>"Extra-lazy" collection fetching</em></span>: individual elements of the collection are accessed from the database as needed. Hibernate tries not to fetch the whole collection into memory unless absolutely needed. It is suitable for large collections. </p></li><li><p><span class="emphasis"><em>Proxy fetching</em></span>: a single-valued association is fetched when a method other than the identifier getter is invoked upon the associated object. </p></li><li><p><span class="emphasis"><em>"No-proxy" fetching</em></span>: a single-valued association is fetched when the instance variable is accessed. Compared to proxy fetching, this approach is less lazy; the association is fetched even when only the identifier is accessed. It is also more transparent, since no proxy is visible to the application. This approach requires buildtime bytecode instrumentation and is rarely necessary. </p></li><li><p><span class="emphasis"><em>Lazy attribute fetching</em></span>: an attribute or single valued association is fetched when the instance variable is accessed. This approach requires buildtime bytecode instrumentation and is rarely necessary. </p></li></ul></div><p>We have two orthogonal notions here: <span class="emphasis"><em>when</em></span> is the association fetched and <span class="emphasis"><em>how</em></span> is it fetched. It is important that you do not confuse them. We use <code class="literal">fetch</code> to tune performance. We can use <code class="literal">lazy</code> to define a contract for what data is always available in any detached instance of a particular class. </p><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-lazy"/>19.1.1. Trabajando con asociaciones perezosas</h3></div></div></div><p>By default, Hibernate3 uses lazy select fetching for collections and lazy proxy fetching for single-valued associations. These defaults make sense for most associations in the majority of applications. </p><p>If you set <code class="literal">hibernate.default_batch_fetch_size</code>, Hibernate will use the batch fetch optimization for lazy fetching. This optimization can also be enabled at a more granular level. </p><p>Please be aware that access to a lazy association outside of the context of an open Hibernate session will result in an exception. For example: </p><pre class="programlisting">s = sessions.openSession();
Transaction tx = s.beginTransaction();
            
User u = (User) s.createQuery("from User u where u.name=:userName")
    .setString("userName", userName).uniqueResult();
Map permissions = u.getPermissions();

tx.commit();
s.close();

Integer accessLevel = (Integer) permissions.get("accounts");  // Error!</pre><p>Since the permissions collection was not initialized when the <code class="literal">Session</code> was closed, the collection will not be able to load its state. <span class="emphasis"><em>Hibernate does not support lazy initialization for detached objects</em></span>. This can be fixed by moving the code that reads from the collection to just before the transaction is committed. </p><p>Alternatively, you can use a non-lazy collection or association, by specifying <code class="literal">lazy="false"</code> for the association mapping. However, it is intended that lazy initialization be used for almost all collections and associations. If you define too many non-lazy associations in your object model, Hibernate will fetch the entire database into memory in every transaction. </p><p>On the other hand, you can use join fetching, which is non-lazy by nature, instead of select fetching in a particular transaction. We will now explain how to customize the fetching strategy. In Hibernate3, the mechanisms for choosing a fetch strategy are identical for single-valued associations and collections. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-custom"/>19.1.2. Afinando las estrategias de recuperación</h3></div></div></div><p>La recuperación por selección (la preestablecida) es extremadamente vulnerable a problemas de selección N+1, de modo querríamos habilitar la recuperación por unión (join fetching) en el documento de mapeo: </p><pre class="programlisting">&lt;set name="permissions" 
            fetch="join"&gt;
    &lt;key column="userId"/&gt;
    &lt;one-to-many class="Permission"/&gt;
&lt;/set</pre><pre class="programlisting">&lt;many-to-one name="mother" class="Cat" fetch="join"/&gt;</pre><p>La estrategia de recuperación definida en el documento de mapeo afecta a: </p><div class="itemizedlist"><ul><li><p>las recuperaciones vía <code class="literal">get()</code> o <code class="literal">load()</code> </p></li><li><p>las recuperaciones que ocurren implícitamente cuando se navega una asociación (recuperación perezosa) </p></li><li><p>las consultas de <code class="literal">Criteria</code> </p></li><li><p>HQL queries if <code class="literal">subselect</code> fetching is used </p></li></ul></div><p>Irrespective of the fetching strategy you use, the defined non-lazy graph is guaranteed to be loaded into memory. This might, however, result in several immediate selects being used to execute a particular HQL query. </p><p>Usually, the mapping document is not used to customize fetching. Instead, we keep the default behavior, and override it for a particular transaction, using <code class="literal">left join fetch</code> in HQL. This tells Hibernate to fetch the association eagerly in the first select, using an outer join. In the <code class="literal">Criteria</code> query API, you would use <code class="literal">setFetchMode(FetchMode.JOIN)</code>. </p><p>If you want to change the fetching strategy used by <code class="literal">get()</code> or <code class="literal">load()</code>, you can use a <code class="literal">Criteria</code> query. For example: </p><pre class="programlisting">User user = (User) session.createCriteria(User.class)
                .setFetchMode("permissions", FetchMode.JOIN)
                .add( Restrictions.idEq(userId) )
                .uniqueResult();</pre><p>This is Hibernate's equivalent of what some ORM solutions call a "fetch plan". </p><p>A completely different approach to problems with N+1 selects is to use the second-level cache. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-proxies"/>19.1.3. Proxies de asociaciones de un solo extremo</h3></div></div></div><p>Lazy fetching for collections is implemented using Hibernate's own implementation of persistent collections. However, a different mechanism is needed for lazy behavior in single-ended associations. The target entity of the association must be proxied. Hibernate implements lazy initializing proxies for persistent objects using runtime bytecode enhancement which is accessed via the CGLIB library. </p><p>At startup, Hibernate3 generates proxies by default for all persistent classes and uses them to enable lazy fetching of <code class="literal">many-to-one</code> and <code class="literal">one-to-one</code> associations. </p><p>The mapping file may declare an interface to use as the proxy interface for that class, with the <code class="literal">proxy</code> attribute. By default, Hibernate uses a subclass of the class. <span class="emphasis"><em>The proxied class must implement a default constructor with at least package visibility. This constructor is recommended for all persistent classes</em></span>. </p><p>There are potential problems to note when extending this approach to polymorphic classes.For example: </p><pre class="programlisting">&lt;class name="Cat" proxy="Cat"&gt;
    ......
    &lt;subclass name="DomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class
&gt;</pre><p>Primero, las instancias de <code class="literal">Cat</code> nunca serán objeto de un cast a <code class="literal">DomesticCat</code>, incluso aunque la instancia subyacente sea instancia de <code class="literal">DomesticCat</code>: </p><pre class="programlisting">Cat cat = (Cat) session.load(Cat.class, id);  // instantiate a proxy (does not hit the db)
if ( cat.isDomesticCat() ) {                  // hit the db to initialize the proxy
    DomesticCat dc = (DomesticCat) cat;       // Error!
    ....
}</pre><p>Secondly, it is possible to break proxy <code class="literal">==</code>: </p><pre class="programlisting">Cat cat = (Cat) session.load(Cat.class, id);            // instantiate a Cat proxy
DomesticCat dc = 
        (DomesticCat) session.load(DomesticCat.class, id);  // acquire new DomesticCat proxy!
System.out.println(cat==dc);                            // false</pre><p>Sin embargo, la situación no en absoluta tan mala como parece. Aunque tenemos ahora dos referencias a objetos proxy diferentes, la instancia subyacente será aún el mismo objeto: </p><pre class="programlisting">cat.setWeight(11.0);  // hit the db to initialize the proxy
System.out.println( dc.getWeight() );  // 11.0</pre><p>Third, you cannot use a CGLIB proxy for a <code class="literal">final</code> class or a class with any <code class="literal">final</code> methods. </p><p>Finally, if your persistent object acquires any resources upon instantiation (e.g. in initializers or default constructor), then those resources will also be acquired by the proxy. The proxy class is an actual subclass of the persistent class. </p><p>These problems are all due to fundamental limitations in Java's single inheritance model. To avoid these problems your persistent classes must each implement an interface that declares its business methods. You should specify these interfaces in the mapping file where <code class="literal">CatImpl</code> implements the interface <code class="literal">Cat</code> and <code class="literal">DomesticCatImpl</code> implements the interface <code class="literal">DomesticCat</code>. For example: </p><pre class="programlisting">&lt;class name="CatImpl" proxy="Cat"&gt;
    ......
    &lt;subclass name="DomesticCatImpl" proxy="DomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class
&gt;</pre><p>Then proxies for instances of <code class="literal">Cat</code> and <code class="literal">DomesticCat</code> can be returned by <code class="literal">load()</code> or <code class="literal">iterate()</code>. </p><pre class="programlisting">Cat cat = (Cat) session.load(CatImpl.class, catid);
Iterator iter = session.createQuery("from CatImpl as cat where cat.name='fritz'").iterate();
Cat fritz = (Cat) iter.next();</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p><code class="literal">list()</code> does not usually return proxies. </p></div><p>Las relaciones también son inicializadas perezosamente. Esto significa que debes declarar cualquier propiedad como de tipo <code class="literal">Cat</code>, no <code class="literal">CatImpl</code>. </p><p>Certain operations do <span class="emphasis"><em>not</em></span> require proxy initialization: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">equals()</code>: if the persistent class does not override <code class="literal">equals()</code> </p></li><li><p><code class="literal">hashCode()</code>: if the persistent class does not override <code class="literal">hashCode()</code> </p></li><li><p>El método getter del identificador </p></li></ul></div><p>Hibernate detectará las clase persistentes que sobrescriban <code class="literal">equals()</code> o <code class="literal">hashCode()</code>. </p><p>By choosing <code class="literal">lazy="no-proxy"</code> instead of the default <code class="literal">lazy="proxy"</code>, you can avoid problems associated with typecasting. However, buildtime bytecode instrumentation is required, and all operations will result in immediate proxy initialization. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-initialization"/>19.1.4. Inicializando colecciones y proxies</h3></div></div></div><p>A <code class="literal">LazyInitializationException</code> will be thrown by Hibernate if an uninitialized collection or proxy is accessed outside of the scope of the <code class="literal">Session</code>, i.e., when the entity owning the collection or having the reference to the proxy is in the detached state. </p><p>Sometimes a proxy or collection needs to be initialized before closing the <code class="literal">Session</code>. You can force initialization by calling <code class="literal">cat.getSex()</code> or <code class="literal">cat.getKittens().size()</code>, for example. However, this can be confusing to readers of the code and it is not convenient for generic code. </p><p>The static methods <code class="literal">Hibernate.initialize()</code> and <code class="literal">Hibernate.isInitialized()</code>, provide the application with a convenient way of working with lazily initialized collections or proxies. <code class="literal">Hibernate.initialize(cat)</code> will force the initialization of a proxy, <code class="literal">cat</code>, as long as its <code class="literal">Session</code> is still open. <code class="literal">Hibernate.initialize( cat.getKittens() )</code> has a similar effect for the collection of kittens. </p><p>Another option is to keep the <code class="literal">Session</code> open until all required collections and proxies have been loaded. In some application architectures, particularly where the code that accesses data using Hibernate, and the code that uses it are in different application layers or different physical processes, it can be a problem to ensure that the <code class="literal">Session</code> is open when a collection is initialized. There are two basic ways to deal with this issue: </p><div class="itemizedlist"><ul><li><p>In a web-based application, a servlet filter can be used to close the <code class="literal">Session</code> only at the end of a user request, once the rendering of the view is complete (the <span class="emphasis"><em>Open Session in View</em></span> pattern). Of course, this places heavy demands on the correctness of the exception handling of your application infrastructure. It is vitally important that the <code class="literal">Session</code> is closed and the transaction ended before returning to the user, even when an exception occurs during rendering of the view. See the Hibernate Wiki for examples of this "Open Session in View" pattern. </p></li><li><p>In an application with a separate business tier, the business logic must "prepare" all collections that the web tier needs before returning. This means that the business tier should load all the data and return all the data already initialized to the presentation/web tier that is required for a particular use case. Usually, the application calls <code class="literal">Hibernate.initialize()</code> for each collection that will be needed in the web tier (this call must occur before the session is closed) or retrieves the collection eagerly using a Hibernate query with a <code class="literal">FETCH</code> clause or a <code class="literal">FetchMode.JOIN</code> in <code class="literal">Criteria</code>. This is usually easier if you adopt the <span class="emphasis"><em>Command</em></span> pattern instead of a <span class="emphasis"><em>Session Facade</em></span>. </p></li><li><p>You can also attach a previously loaded object to a new <code class="literal">Session</code> with <code class="literal">merge()</code> or <code class="literal">lock()</code> before accessing uninitialized collections or other proxies. Hibernate does not, and certainly <span class="emphasis"><em>should</em></span> not, do this automatically since it would introduce impromptu transaction semantics. </p></li></ul></div><p>Sometimes you do not want to initialize a large collection, but still need some information about it, like its size, for example, or a subset of the data. </p><p>Puedes usar un filtro de colecciones para obtener el tamaño de una colección sin inicializarla: </p><pre class="programlisting">( (Integer) s.createFilter( collection, "select count(*)" ).list().get(0) ).intValue()</pre><p>El método <code class="literal">createFilter()</code> se usa también para recuperar eficientemente subconjuntos de una colección sin necesidad de inicializar toda la colección: </p><pre class="programlisting">s.createFilter( lazyCollection, "").setFirstResult(0).setMaxResults(10).list();</pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-batch"/>19.1.5. Usando recuperación en lotes</h3></div></div></div><p>Using batch fetching, Hibernate can load several uninitialized proxies if one proxy is accessed. Batch fetching is an optimization of the lazy select fetching strategy. There are two ways you can configure batch fetching: on the class level and the collection level. </p><p>Batch fetching for classes/entities is easier to understand. Consider the following example: at runtime you have 25 <code class="literal">Cat</code> instances loaded in a <code class="literal">Session</code>, and each <code class="literal">Cat</code> has a reference to its <code class="literal">owner</code>, a <code class="literal">Person</code>. The <code class="literal">Person</code> class is mapped with a proxy, <code class="literal">lazy="true"</code>. If you now iterate through all cats and call <code class="literal">getOwner()</code> on each, Hibernate will, by default, execute 25 <code class="literal">SELECT</code> statements to retrieve the proxied owners. You can tune this behavior by specifying a <code class="literal">batch-size</code> in the mapping of <code class="literal">Person</code>: </p><pre class="programlisting">&lt;class name="Person" batch-size="10"
&gt;...&lt;/class
&gt;</pre><p>Hibernate will now execute only three queries: the pattern is 10, 10, 5. </p><p>You can also enable batch fetching of collections. For example, if each <code class="literal">Person</code> has a lazy collection of <code class="literal">Cat</code>s, and 10 persons are currently loaded in the <code class="literal">Session</code>, iterating through all persons will generate 10 <code class="literal">SELECT</code>s, one for every call to <code class="literal">getCats()</code>. If you enable batch fetching for the <code class="literal">cats</code> collection in the mapping of <code class="literal">Person</code>, Hibernate can pre-fetch collections: </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;set name="cats" batch-size="3"&gt;
        ...
    &lt;/set&gt;
&lt;/class
&gt;</pre><p>Con un <code class="literal">batch-size</code> de 3, Hibernate cargará 3, 3, 3, 1 colecciones en cuatro <code class="literal">SELECT</code>s. Una vez más, el valor del atributo depende del número esperado de colecciones sin inicializar en una <code class="literal">Session</code> en particular. </p><p>Batch fetching of collections is particularly useful if you have a nested tree of items, i.e. the typical bill-of-materials pattern. However, a <span class="emphasis"><em>nested set</em></span> or a <span class="emphasis"><em>materialized path</em></span> might be a better option for read-mostly trees. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-subselect"/>19.1.6. Usando recuperación por subselección</h3></div></div></div><p>If one lazy collection or single-valued proxy has to be fetched, Hibernate will load all of them, re-running the original query in a subselect. This works in the same way as batch-fetching but without the piecemeal loading. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-lazyproperties"/>19.1.7. Usando recuperación perezosa de propiedades</h3></div></div></div><p>Hibernate3 supports the lazy fetching of individual properties. This optimization technique is also known as <span class="emphasis"><em>fetch groups</em></span>. Please note that this is mostly a marketing feature; optimizing row reads is much more important than optimization of column reads. However, only loading some properties of a class could be useful in extreme cases. For example, when legacy tables have hundreds of columns and the data model cannot be improved. </p><p>Para habilitar la carga perezosa de propiedades, establece el atributo <code class="literal">lazy</code> en tus mapeos de propiedades: </p><pre class="programlisting">&lt;class name="Document"&gt;
       &lt;id name="id"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true" length="50"/&gt;
    &lt;property name="summary" not-null="true" length="200" lazy="true"/&gt;
    &lt;property name="text" not-null="true" length="2000" lazy="true"/&gt;
&lt;/class
&gt;</pre><p>Lazy property loading requires buildtime bytecode instrumentation. If your persistent classes are not enhanced, Hibernate will ignore lazy property settings and return to immediate fetching. </p><p>Para la instrumentación del bytecode, usa la siguiente tarea Ant: </p><pre class="programlisting">&lt;target name="instrument" depends="compile"&gt;
    &lt;taskdef name="instrument" classname="org.hibernate.tool.instrument.InstrumentTask"&gt;
        &lt;classpath path="${jar.path}"/&gt;
        &lt;classpath path="${classes.dir}"/&gt;
        &lt;classpath refid="lib.class.path"/&gt;
    &lt;/taskdef&gt;

    &lt;instrument verbose="true"&gt;
        &lt;fileset dir="${testclasses.dir}/org/hibernate/auction/model"&gt;
            &lt;include name="*.class"/&gt;
        &lt;/fileset&gt;
    &lt;/instrument&gt;
&lt;/target
&gt;</pre><p>A different way of avoiding unnecessary column reads, at least for read-only transactions, is to use the projection features of HQL or Criteria queries. This avoids the need for buildtime bytecode processing and is certainly a preferred solution. </p><p>You can force the usual eager fetching of properties using <code class="literal">fetch all properties</code> in HQL. </p></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="performance-cache"/>19.2. El Caché de Segundo Nivel</h2></div></div></div><p>A Hibernate <code class="literal">Session</code> is a transaction-level cache of persistent data. It is possible to configure a cluster or JVM-level (<code class="literal">SessionFactory</code>-level) cache on a class-by-class and collection-by-collection basis. You can even plug in a clustered cache. Be aware that caches are not aware of changes made to the persistent store by another application. They can, however, be configured to regularly expire cached data. </p><p>You have the option to tell Hibernate which caching implementation to use by specifying the name of a class that implements <code class="literal">org.hibernate.cache.CacheProvider</code> using the property <code class="literal">hibernate.cache.provider_class</code>. Hibernate is bundled with a number of built-in integrations with the open-source cache providers that are listed below. You can also implement your own and plug it in as outlined above. Note that versions prior to 3.2 use EhCache as the default cache provider. </p><div class="table"><a id="cacheproviders"/><p class="title"><b>Tabla 19.1. Proveedores de Caché</b></p><div class="table-contents"><table summary="Proveedores de Caché" border="1"><colgroup><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/></colgroup><thead><tr><th align="left">Caché</th><th align="left">clase del Provedor</th><th align="left">Tipo</th><th align="left">Cluster Seguro</th><th align="left">Caché de Consultas Soportado</th></tr></thead><tbody><tr><td align="left">Hashtable (no pensado para uso en producción)</td><td align="left"><code class="literal">org.hibernate.cache.HashtableCacheProvider</code></td><td align="left">memoria</td><td align="left"> </td><td align="left">si</td></tr><tr><td align="left">EHCache</td><td align="left"><code class="literal">org.hibernate.cache.EhCacheProvider</code></td><td align="left">memoria, disco</td><td align="left"> </td><td align="left">si</td></tr><tr><td align="left">OSCache</td><td align="left"><code class="literal">org.hibernate.cache.OSCacheProvider</code></td><td align="left">memoria, disco</td><td align="left"> </td><td align="left">si</td></tr><tr><td align="left">SwarmCache</td><td align="left"><code class="literal">org.hibernate.cache.SwarmCacheProvider</code></td><td align="left">clusterizado (ip multicast)</td><td align="left">sí (invalidación en cluster)</td><td align="left"> </td></tr><tr><td align="left">JBoss Cache 1.x</td><td align="left"><code class="literal">org.hibernate.cache.TreeCacheProvider</code></td><td align="left">clusterizado (ip multicast), transaccional</td><td align="left">sí (replicación)</td><td align="left">sí (requiere sincronización de reloj)</td></tr><tr><td align="left">JBoss Cache 2</td><td align="left"><code class="literal">org.hibernate.cache.jbc2.JBossCacheRegionFactory</code></td><td align="left">clusterizado (ip multicast), transaccional</td><td align="left">yes (replication or invalidation)</td><td align="left">sí (requiere sincronización de reloj)</td></tr></tbody></table></div></div><br class="table-break"/><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-mapping"/>19.2.1. Mapeos de caché</h3></div></div></div><p>El elemento <code class="literal">&lt;cache&gt;</code> de una mapeo de clase o colección tiene la siguiente forma: </p><div class="programlistingco"><pre class="programlisting">&lt;cache 
    usage="transactional|read-write|nonstrict-read-write|read-only"  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">usage</code> especifica la estrategia de caching: <code class="literal">transactional</code>, <code class="literal">read-write</code>, <code class="literal">nonstrict-read-write</code> o <code class="literal">read-only</code> </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">region</code> (optional: defaults to the class or collection role name): specifies the name of the second level cache region </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">include</code> (optional: defaults to <code class="literal">all</code>) <code class="literal">non-lazy</code>: specifies that properties of the entity mapped with <code class="literal">lazy="true"</code> cannot be cached when attribute-level lazy fetching is enabled </p></td></tr></table></div></div><p>Alternatively, you can specify <code class="literal">&lt;class-cache&gt;</code> and <code class="literal">&lt;collection-cache&gt;</code> elements in <code class="literal">hibernate.cfg.xml</code>. </p><p>El atributo <code class="literal">usage</code> especifica una <span class="emphasis"><em>estrategia de concurrencia al caché</em></span>. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-readonly"/>19.2.2. Estrategia: sólo lectura (read only)</h3></div></div></div><p>If your application needs to read, but not modify, instances of a persistent class, a <code class="literal">read-only</code> cache can be used. This is the simplest and optimal performing strategy. It is even safe for use in a cluster. </p><pre class="programlisting">&lt;class name="eg.Immutable" mutable="false"&gt;
    &lt;cache usage="read-only"/&gt;
    ....
&lt;/class
&gt;</pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-readwrite"/>19.2.3. Estrategia: lectura/escritura (read/write)</h3></div></div></div><p>If the application needs to update data, a <code class="literal">read-write</code> cache might be appropriate. This cache strategy should never be used if serializable transaction isolation level is required. If the cache is used in a JTA environment, you must specify the property <code class="literal">hibernate.transaction.manager_lookup_class</code> and naming a strategy for obtaining the JTA <code class="literal">TransactionManager</code>. In other environments, you should ensure that the transaction is completed when <code class="literal">Session.close()</code> or <code class="literal">Session.disconnect()</code> is called. If you want to use this strategy in a cluster, you should ensure that the underlying cache implementation supports locking. The built-in cache providers <span class="emphasis"><em>do not</em></span> support locking. </p><pre class="programlisting">&lt;class name="eg.Cat" .... &gt;
    &lt;cache usage="read-write"/&gt;
    ....
    &lt;set name="kittens" ... &gt;
        &lt;cache usage="read-write"/&gt;
        ....
    &lt;/set&gt;
&lt;/class
&gt;</pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-nonstrict"/>19.2.4. Estrategia: lectura/escritura no estricta (nonstrict read/write)</h3></div></div></div><p>If the application only occasionally needs to update data (i.e. if it is extremely unlikely that two transactions would try to update the same item simultaneously), and strict transaction isolation is not required, a <code class="literal">nonstrict-read-write</code> cache might be appropriate. If the cache is used in a JTA environment, you must specify <code class="literal">hibernate.transaction.manager_lookup_class</code>. In other environments, you should ensure that the transaction is completed when <code class="literal">Session.close()</code> or <code class="literal">Session.disconnect()</code> is called. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-transactional"/>19.2.5. Estrategia: transaccional</h3></div></div></div><p>The <code class="literal">transactional</code> cache strategy provides support for fully transactional cache providers such as JBoss TreeCache. Such a cache can only be used in a JTA environment and you must specify <code class="literal">hibernate.transaction.manager_lookup_class</code>. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-compat-matrix"/>19.2.6. Cache-provider/concurrency-strategy compatibility</h3></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Importante</h2><p>None of the cache providers support all of the cache concurrency strategies. </p></div><p>The following table shows which providers are compatible with which concurrency strategies. </p><div class="table"><a id="d0e14952"/><p class="title"><b>Tabla 19.2. Soporte a Estrategia de Concurrencia a Caché</b></p><div class="table-contents"><table summary="Soporte a Estrategia de Concurrencia a Caché" border="1"><colgroup><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/></colgroup><thead><tr><th align="left">Caché</th><th align="left">read-only</th><th align="left">nonstrict-read-write</th><th align="left">read-write</th><th align="left">transactional</th></tr></thead><tbody><tr><td align="left">Hashtable (no pensado para uso en producción)</td><td align="left">si</td><td align="left">si</td><td align="left">si</td><td align="left"> </td></tr><tr><td align="left">EHCache</td><td align="left">si</td><td align="left">si</td><td align="left">si</td><td align="left"> </td></tr><tr><td align="left">OSCache</td><td align="left">si</td><td align="left">si</td><td align="left">si</td><td align="left"> </td></tr><tr><td align="left">SwarmCache</td><td align="left">si</td><td align="left">si</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">JBoss Cache 1.x</td><td align="left">si</td><td align="left"> </td><td align="left"> </td><td align="left">si</td></tr><tr><td align="left">JBoss Cache 2</td><td align="left">si</td><td align="left"> </td><td align="left"> </td><td align="left">si</td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="performance-sessioncache"/>19.3. Gestionando los cachés</h2></div></div></div><p>Whenever you pass an object to <code class="literal">save()</code>, <code class="literal">update()</code> or <code class="literal">saveOrUpdate()</code>, and whenever you retrieve an object using <code class="literal">load()</code>, <code class="literal">get()</code>, <code class="literal">list()</code>, <code class="literal">iterate()</code> or <code class="literal">scroll()</code>, that object is added to the internal cache of the <code class="literal">Session</code>. </p><p>When <code class="literal">flush()</code> is subsequently called, the state of that object will be synchronized with the database. If you do not want this synchronization to occur, or if you are processing a huge number of objects and need to manage memory efficiently, the <code class="literal">evict()</code> method can be used to remove the object and its collections from the first-level cache. </p><pre class="programlisting">ScrollableResult cats = sess.createQuery("from Cat as cat").scroll(); //a huge result set
while ( cats.next() ) {
    Cat cat = (Cat) cats.get(0);
    doSomethingWithACat(cat);
    sess.evict(cat);
}</pre><p>La <code class="literal">Session</code> también provee un método <code class="literal">contains()</code> para determinar si una instancia pertenece al caché de la sesión. </p><p>To evict all objects from the session cache, call <code class="literal">Session.clear()</code> </p><p>Para el caché de segundo nivel, hay métodos definidos en <code class="literal">SessionFactory</code> para desahuciar el estado en caché de una instancia, clase entera, instancia de colección o rol enter de colección. </p><pre class="programlisting">sessionFactory.evict(Cat.class, catId); //evict a particular Cat
sessionFactory.evict(Cat.class);  //evict all Cats
sessionFactory.evictCollection("Cat.kittens", catId); //evict a particular collection of kittens
sessionFactory.evictCollection("Cat.kittens"); //evict all kitten collections</pre><p>The <code class="literal">CacheMode</code> controls how a particular session interacts with the second-level cache: </p><div class="itemizedlist"><ul><li><p><code class="literal">CacheMode.NORMAL</code>: will read items from and write items to the second-level cache </p></li><li><p><code class="literal">CacheMode.GET</code>: will read items from the second-level cache. Do not write to the second-level cache except when updating data </p></li><li><p><code class="literal">CacheMode.PUT</code>: will write items to the second-level cache. Do not read from the second-level cache </p></li><li><p><code class="literal">CacheMode.REFRESH</code>: will write items to the second-level cache. Do not read from the second-level cache. Bypass the effect of <code class="literal">hibernate.cache.use_minimal_puts</code> forcing a refresh of the second-level cache for all items read from the database </p></li></ul></div><p>Para navegar por los contenidos de una región de caché de segundo nivel o de consultas, usa la API de <code class="literal">Statistics</code>: </p><pre class="programlisting">Map cacheEntries = sessionFactory.getStatistics()
        .getSecondLevelCacheStatistics(regionName)
        .getEntries();</pre><p>You will need to enable statistics and, optionally, force Hibernate to keep the cache entries in a more readable format: </p><pre class="programlisting">hibernate.generate_statistics true
hibernate.cache.use_structured_entries true</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="performance-querycache"/>19.4. El Caché de Consultas</h2></div></div></div><p>Query result sets can also be cached. This is only useful for queries that are run frequently with the same parameters. You will first need to enable the query cache: </p><pre class="programlisting">hibernate.cache.use_query_cache true</pre><p>This setting creates two new cache regions: one holding cached query result sets (<code class="literal">org.hibernate.cache.StandardQueryCache</code>), the other holding timestamps of the most recent updates to queryable tables (<code class="literal">org.hibernate.cache.UpdateTimestampsCache</code>). Note that the query cache does not cache the state of the actual entities in the result set; it caches only identifier values and results of value type. The query cache should always be used in conjunction with the second-level cache. </p><p>Most queries do not benefit from caching, so by default, queries are not cached. To enable caching, call <code class="literal">Query.setCacheable(true)</code>. This call allows the query to look for existing cache results or add its results to the cache when it is executed. </p><p>If you require fine-grained control over query cache expiration policies, you can specify a named cache region for a particular query by calling <code class="literal">Query.setCacheRegion()</code>. </p><pre class="programlisting">List blogs = sess.createQuery("from Blog blog where blog.blogger = :blogger")
    .setEntity("blogger", blogger)
    .setMaxResults(15)
    .setCacheable(true)
    .setCacheRegion("frontpages")
    .list();</pre><p>Si la consulta debe forzar un refresco de si región del caché de consultas, debes llamar a <code class="literal">Query.setCacheMode(CacheMode.REFRESH)</code>. Esto es particularmente útil en casos donde los datos subyacentes pueden haber sido actualizados por medio de un proceso separado (es decir, no modificados a través de Hibernate) y permite a la aplicación refrescar selectivamente conjuntos resultado de consultas en particular. Esto es una alternativa más eficient al desahuciamiento de una región del caché de consultas vía <code class="literal">SessionFactory.evictQueries()</code>. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="performance-collections"/>19.5. Entendiendo el rendimiento de Colecciones</h2></div></div></div><p>In the previous sections we have covered collections and their applications. In this section we explore some more issues in relation to collections at runtime. </p><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-taxonomy"/>19.5.1. Taxonomia</h3></div></div></div><p>Hibernate define tres tipos básicos de colecciones:</p><div class="itemizedlist"><ul><li><p>colecciones de valores</p></li><li><p>one-to-many associations</p></li><li><p>many-to-many associations</p></li></ul></div><p>Esta clasificación distingue las varias tablas y relaciones de clave foránea pero no nos dice absolutamente todo lo que necesitamos saber sobre el modelo relacional. Para entender completamente la estructura relacional y las características de rendimiento, debemos considerar la estructura de la clave primaria que es usada por Hibernate para actualizar o borrar filas de colección. Esto sugiere la siguiente clasificación: </p><div class="itemizedlist"><ul><li><p>colecciones indexadas</p></li><li><p>conjuntos (sets)</p></li><li><p>bolsas (bags)</p></li></ul></div><p>All indexed collections (maps, lists, and arrays) have a primary key consisting of the <code class="literal">&lt;key&gt;</code> and <code class="literal">&lt;index&gt;</code> columns. In this case, collection updates are extremely efficient. The primary key can be efficiently indexed and a particular row can be efficiently located when Hibernate tries to update or delete it. </p><p>Sets have a primary key consisting of <code class="literal">&lt;key&gt;</code> and element columns. This can be less efficient for some types of collection element, particularly composite elements or large text or binary fields, as the database may not be able to index a complex primary key as efficiently. However, for one-to-many or many-to-many associations, particularly in the case of synthetic identifiers, it is likely to be just as efficient. If you want <code class="literal">SchemaExport</code> to actually create the primary key of a <code class="literal">&lt;set&gt;</code>, you must declare all columns as <code class="literal">not-null="true"</code>. </p><p><code class="literal">&lt;idbag&gt;</code> mappings define a surrogate key, so they are efficient to update. In fact, they are the best case. </p><p>Bags are the worst case since they permit duplicate element values and, as they have no index column, no primary key can be defined. Hibernate has no way of distinguishing between duplicate rows. Hibernate resolves this problem by completely removing in a single <code class="literal">DELETE</code> and recreating the collection whenever it changes. This can be inefficient. </p><p>For a one-to-many association, the "primary key" may not be the physical primary key of the database table. Even in this case, the above classification is still useful. It reflects how Hibernate "locates" individual rows of the collection. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-mostefficientupdate"/>19.5.2. Las listas, mapas, idbags y conjuntos son las colecciones más eficientes de actualizar</h3></div></div></div><p>From the discussion above, it should be clear that indexed collections and sets allow the most efficient operation in terms of adding, removing and updating elements. </p><p>There is, arguably, one more advantage that indexed collections have over sets for many-to-many associations or collections of values. Because of the structure of a <code class="literal">Set</code>, Hibernate does not <code class="literal">UPDATE</code> a row when an element is "changed". Changes to a <code class="literal">Set</code> always work via <code class="literal">INSERT</code> and <code class="literal">DELETE</code> of individual rows. Once again, this consideration does not apply to one-to-many associations. </p><p>After observing that arrays cannot be lazy, you can conclude that lists, maps and idbags are the most performant (non-inverse) collection types, with sets not far behind. You can expect sets to be the most common kind of collection in Hibernate applications. This is because the "set" semantics are most natural in the relational model. </p><p>However, in well-designed Hibernate domain models, most collections are in fact one-to-many associations with <code class="literal">inverse="true"</code>. For these associations, the update is handled by the many-to-one end of the association, and so considerations of collection update performance simply do not apply. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-mostefficentinverse"/>19.5.3. Los Bags y las listas son las colecciones inversas más eficientes</h3></div></div></div><p>There is a particular case, however, in which bags, and also lists, are much more performant than sets. For a collection with <code class="literal">inverse="true"</code>, the standard bidirectional one-to-many relationship idiom, for example, we can add elements to a bag or list without needing to initialize (fetch) the bag elements. This is because, unlike a <code class="literal">set</code>, <code class="literal">Collection.add()</code> or <code class="literal">Collection.addAll()</code> must always return true for a bag or <code class="literal">List</code>. This can make the following common code much faster: </p><pre class="programlisting">Parent p = (Parent) sess.load(Parent.class, id);
    Child c = new Child();
    c.setParent(p);
    p.getChildren().add(c);  //no need to fetch the collection!
    sess.flush();</pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-oneshotdelete"/>19.5.4. Borrado de un solo tiro</h3></div></div></div><p>Deleting collection elements one by one can sometimes be extremely inefficient. Hibernate knows not to do that in the case of an newly-empty collection (if you called <code class="literal">list.clear()</code>, for example). In this case, Hibernate will issue a single <code class="literal">DELETE</code>. </p><p>Suppose you added a single element to a collection of size twenty and then remove two elements. Hibernate will issue one <code class="literal">INSERT</code> statement and two <code class="literal">DELETE</code> statements, unless the collection is a bag. This is certainly desirable. </p><p>Sin embargo, supón que quitamos dieciocho elementos, dejando dos y luego añadimos tres nuevos elementos. Hay dos formas posibles de proceder </p><div class="itemizedlist"><ul><li><p>borrar dieciocho filas una a una y luego insertar tres filas</p></li><li><p>remove the whole collection in one SQL <code class="literal">DELETE</code> and insert all five current elements one by one</p></li></ul></div><p>Hibernate cannot know that the second option is probably quicker. It would probably be undesirable for Hibernate to be that intuitive as such behavior might confuse database triggers, etc. </p><p>Fortunately, you can force this behavior (i.e. the second strategy) at any time by discarding (i.e. dereferencing) the original collection and returning a newly instantiated collection with all the current elements. </p><p>One-shot-delete does not apply to collections mapped <code class="literal">inverse="true"</code>. </p></div></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="performance-monitoring"/>19.6. Monitoreando el rendimiento</h2></div></div></div><p>La optimización no es de mucho uso sin el monitoreo y el acceso a números de rendimiento. Hibernate provee un rango completo de figuras sobre sus operaciones internas. Las estadísticas en Hibernate están disponibles por <code class="literal">SessionFactory</code>. </p><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="performance-monitoring-sf"/>19.6.1. Monitoreando una SessionFactory</h3></div></div></div><p>Puedes acceder a las métricas de <code class="literal">SessionFactory</code> de dos formas. Tu primera opción es llamar a <code class="literal">sessionFactory.getStatistics()</code> y leer o mostrar por pantalla la <code class="literal">Statistics</code> por ti mismo. </p><p>Hibernate can also use JMX to publish metrics if you enable the <code class="literal">StatisticsService</code> MBean. You can enable a single MBean for all your <code class="literal">SessionFactory</code> or one per factory. See the following code for minimalistic configuration examples: </p><pre class="programlisting">// MBean service registration for a specific SessionFactory
Hashtable tb = new Hashtable();
tb.put("type", "statistics");
tb.put("sessionFactory", "myFinancialApp");
ObjectName on = new ObjectName("hibernate", tb); // MBean object name

StatisticsService stats = new StatisticsService(); // MBean implementation
stats.setSessionFactory(sessionFactory); // Bind the stats to a SessionFactory
server.registerMBean(stats, on); // Register the Mbean on the server</pre><pre class="programlisting">// MBean service registration for all SessionFactory's
Hashtable tb = new Hashtable();
tb.put("type", "statistics");
tb.put("sessionFactory", "all");
ObjectName on = new ObjectName("hibernate", tb); // MBean object name

StatisticsService stats = new StatisticsService(); // MBean implementation
server.registerMBean(stats, on); // Register the MBean on the server</pre><p>You can activate and deactivate the monitoring for a <code class="literal">SessionFactory</code>: </p><div class="itemizedlist"><ul><li><p>en tiempo de configuración, establece <code class="literal">hibernate.generate_statistics</code> a <code class="literal">false</code> </p></li></ul></div><div class="itemizedlist"><ul><li><p>en tiempo de ejecución: <code class="literal">sf.getStatistics().setStatisticsEnabled(true)</code> o <code class="literal">hibernateStatsBean.setStatisticsEnabled(true)</code> </p></li></ul></div><p>Statistics can be reset programmatically using the <code class="literal">clear()</code> method. A summary can be sent to a logger (info level) using the <code class="literal">logSummary()</code> method. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="performance-monitoring-metrics"/>19.6.2. Métricas</h3></div></div></div><p>Hibernate provides a number of metrics, from basic information to more specialized information that is only relevant in certain scenarios. All available counters are described in the <code class="literal">Statistics</code> interface API, in three categories: </p><div class="itemizedlist"><ul><li><p>Métricas relacionadas al uso general de <code class="literal">Session</code> usage, tales como número de sesiones abiertas, conexiones JDBC recuperadas, etc, </p></li><li><p>Metrics related to the entities, collections, queries, and caches as a whole (aka global metrics). </p></li><li><p>Métricas detalladas relacionadas a una entidad, colección, consulta o región de caché en particular. </p></li></ul></div><p>For example, you can check the cache hit, miss, and put ratio of entities, collections and queries, and the average time a query needs. Be aware that the number of milliseconds is subject to approximation in Java. Hibernate is tied to the JVM precision and on some platforms this might only be accurate to 10 seconds. </p><p>Simple getters are used to access the global metrics (i.e. not tied to a particular entity, collection, cache region, etc.). You can access the metrics of a particular entity, collection or cache region through its name, and through its HQL or SQL representation for queries. Please refer to the <code class="literal">Statistics</code>, <code class="literal">EntityStatistics</code>, <code class="literal">CollectionStatistics</code>, <code class="literal">SecondLevelCacheStatistics</code>, and <code class="literal">QueryStatistics</code> API Javadoc for more information. The following code is a simple example: </p><pre class="programlisting">Statistics stats = HibernateUtil.sessionFactory.getStatistics();

double queryCacheHitCount  = stats.getQueryCacheHitCount();
double queryCacheMissCount = stats.getQueryCacheMissCount();
double queryCacheHitRatio =
  queryCacheHitCount / (queryCacheHitCount + queryCacheMissCount);

log.info("Query Hit ratio:" + queryCacheHitRatio);

EntityStatistics entityStats =
  stats.getEntityStatistics( Cat.class.getName() );
long changes =
        entityStats.getInsertCount()
        + entityStats.getUpdateCount()
        + entityStats.getDeleteCount();
log.info(Cat.class.getName() + " changed " + changes + "times"  );</pre><p>You can work on all entities, collections, queries and region caches, by retrieving the list of names of entities, collections, queries and region caches using the following methods: <code class="literal">getQueries()</code>, <code class="literal">getEntityNames()</code>, <code class="literal">getCollectionRoleNames()</code>, and <code class="literal">getSecondLevelCacheRegionNames()</code>. </p></div></div></div><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="toolsetguide"/>Capítulo 20. Guía del Conjunto de Herramientas</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#toolsetguide-s1">20.1. Generación automática de esquemas</a></span></dt><dd><dl><dt><span class="sect2"><a href="#toolsetguide-s1-2">20.1.1. Personalizando el esquema</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-3">20.1.2. Ejecutando la herramienta</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-4">20.1.3. Propiedades</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-5">20.1.4. Usando Ant</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-6">20.1.5. Actualizaciones incrementales de esquema</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-7">20.1.6. Usando Ant para actualizaciones incrementales de esquema</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-8">20.1.7. Schema validation</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-9">20.1.8. Using Ant for schema validation</a></span></dt></dl></dd></dl></div><p>Roundtrip engineering with Hibernate is possible using a set of Eclipse plugins, commandline tools, and Ant tasks. </p><p><span class="emphasis"><em>Hibernate Tools</em></span> currently include plugins for the Eclipse IDE as well as Ant tasks for reverse engineering of existing databases: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Mapping Editor:</em></span> an editor for Hibernate XML mapping files that supports auto-completion and syntax highlighting. It also supports semantic auto-completion for class names and property/field names, making it more versatile than a normal XML editor. </p></li><li><p><span class="emphasis"><em>Console:</em></span> the console is a new view in Eclipse. In addition to a tree overview of your console configurations, you are also provided with an interactive view of your persistent classes and their relationships. The console allows you to execute HQL queries against your database and browse the result directly in Eclipse. </p></li><li><p><span class="emphasis"><em>Development Wizards:</em></span> several wizards are provided with the Hibernate Eclipse tools. You can use a wizard to quickly generate Hibernate configuration (cfg.xml) files, or to reverse engineer an existing database schema into POJO source files and Hibernate mapping files. The reverse engineering wizard supports customizable templates. </p></li><li><p>

        </p></li></ul></div><p>Please refer to the <span class="emphasis"><em>Hibernate Tools</em></span> package documentation for more information. </p><p>However, the Hibernate main package comes bundled with an integrated tool : <span class="emphasis"><em>SchemaExport</em></span> aka <code class="literal">hbm2ddl</code>.It can even be used from "inside" Hibernate. </p><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="toolsetguide-s1"/>20.1. Generación automática de esquemas</h2></div></div></div><p>DDL can be generated from your mapping files by a Hibernate utility. The generated schema includes referential integrity constraints, primary and foreign keys, for entity and collection tables. Tables and sequences are also created for mapped identifier generators. </p><p>You <span class="emphasis"><em>must</em></span> specify a SQL <code class="literal">Dialect</code> via the <code class="literal">hibernate.dialect</code> property when using this tool, as DDL is highly vendor-specific. </p><p>First, you must customize your mapping files to improve the generated schema. The next section covers schema customization. </p><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-2"/>20.1.1. Personalizando el esquema</h3></div></div></div><p>Many Hibernate mapping elements define optional attributes named <code class="literal">length</code>, <code class="literal">precision</code> and <code class="literal">scale</code>. You can set the length, precision and scale of a column with this attribute. </p><pre class="programlisting">&lt;property name="zip" length="5"/&gt;</pre><pre class="programlisting">&lt;property name="balance" precision="12" scale="2"/&gt;</pre><p>Some tags also accept a <code class="literal">not-null</code> attribute for generating a <code class="literal">NOT NULL</code> constraint on table columns, and a <code class="literal">unique</code> attribute for generating <code class="literal">UNIQUE</code> constraint on table columns. </p><pre class="programlisting">&lt;many-to-one name="bar" column="barId" not-null="true"/&gt;</pre><pre class="programlisting">&lt;element column="serialNumber" type="long" not-null="true" unique="true"/&gt;</pre><p>A <code class="literal">unique-key</code> attribute can be used to group columns in a single, unique key constraint. Currently, the specified value of the <code class="literal">unique-key</code> attribute is <span class="emphasis"><em>not</em></span> used to name the constraint in the generated DDL. It is only used to group the columns in the mapping file. </p><pre class="programlisting">&lt;many-to-one name="org" column="orgId" unique-key="OrgEmployeeId"/&gt;
&lt;property name="employeeId" unique-key="OrgEmployee"/&gt;</pre><p>An <code class="literal">index</code> attribute specifies the name of an index that will be created using the mapped column or columns. Multiple columns can be grouped into the same index by simply specifying the same index name. </p><pre class="programlisting">&lt;property name="lastName" index="CustName"/&gt;
        &lt;property name="firstName" index="CustName"/&gt;</pre><p>A <code class="literal">foreign-key</code> attribute can be used to override the name of any generated foreign key constraint. </p><pre class="programlisting">&lt;many-to-one name="bar" column="barId" foreign-key="FKFooBar"/&gt;</pre><p>Many mapping elements also accept a child <code class="literal">&lt;column&gt;</code> element. This is particularly useful for mapping multi-column types: </p><pre class="programlisting">&lt;property name="name" type="my.customtypes.Name"/&gt;
        &lt;column name="last" not-null="true" index="bar_idx" length="30"/&gt;
        &lt;column name="first" not-null="true" index="bar_idx" length="20"/&gt;
        &lt;column name="initial"/&gt;
&lt;/property
&gt;</pre><p>The <code class="literal">default</code> attribute allows you to specify a default value for a column.You should assign the same value to the mapped property before saving a new instance of the mapped class. </p><pre class="programlisting">&lt;property name="credits" type="integer" insert="false"&gt;
                &lt;column name="credits" default="10"/&gt;
        &lt;/property
&gt;</pre><pre class="programlisting">&lt;version name="version" type="integer" insert="false"&gt;
                &lt;column name="version" default="0"/&gt;
        &lt;/property
&gt;</pre><p>El atributo <code class="literal">sql-type</code> permite al usuario sobrescribir el mapeo por defecto de tipo Hibernate a tipo de datos SQL. </p><pre class="programlisting">&lt;property name="balance" type="float"&gt;
                            &lt;column name="balance" sql-type="decimal(13,3)"/&gt;
&lt;/property
&gt;</pre><p>El atributo <code class="literal">check</code> te permite especificar una comprobación de restricción. </p><pre class="programlisting">&lt;property name="foo" type="integer"&gt;
    &lt;column name="foo" check="foo 
&gt; 10"/&gt;
&lt;/property
&gt;</pre><pre class="programlisting">&lt;class name="Foo" table="foos" check="bar &lt; 100.0"&gt;
    ...
    &lt;property name="bar" type="float"/&gt;
&lt;/class
&gt;</pre><p>The following table summarizes these optional attributes.</p><div class="table"><a id="schemattributes-summary"/><p class="title"><b>Tabla 20.1. Resumen</b></p><div class="table-contents"><table summary="Resumen" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Atributo</th><th>Valores</th><th>Interpretación</th></tr></thead><tbody><tr><td><code class="literal">length</code></td><td>number</td><td>largo de columna/precisión decimal</td></tr><tr><td><code class="literal">precision</code></td><td>number</td><td>column decimal precision</td></tr><tr><td><code class="literal">scale</code></td><td>number</td><td>column decimal scale</td></tr><tr><td><code class="literal">not-null</code></td><td><code class="literal">true|false</code></td><td>specifies that the column should be non-nullable</td></tr><tr><td><code class="literal">unique</code></td><td><code class="literal">true|false</code></td><td>especifica que la columna debe tener una restricción de unicidad</td></tr><tr><td><code class="literal">index</code></td><td><code class="literal">index_name</code></td><td>especifica el nombre de un índice (multicolumna)</td></tr><tr><td><code class="literal">unique-key</code></td><td><code class="literal">unique_key_name</code></td><td>especifica el nombre de una restricción de unicidad multicolumna</td></tr><tr><td><code class="literal">foreign-key</code></td><td><code class="literal">foreign_key_name</code></td><td>especifica el nombre de la restricción de clave foránea generada por una asociación, úsalo e <code class="literal">&lt;one-to-one&gt;</code>, <code class="literal">&lt;many-to-one&gt;</code>, <code class="literal">&lt;key&gt;</code>, or <code class="literal">&lt;many-to-many&gt;</code> . Nota que los lados <code class="literal">inverse="true"</code> no serán considerados por <code class="literal">SchemaExport</code>. </td></tr><tr><td><code class="literal">sql-type</code></td><td><code class="literal">column_type</code></td><td>sobrescribe el tipo de columna por defecto (sólo atributo del elemento <code class="literal">&lt;column&gt;</code>) </td></tr><tr><td><code class="literal">default</code></td><td>SQL expression</td><td>specify a default value for the column </td></tr><tr><td><code class="literal">check</code></td><td>SQL expression</td><td>crea una restricción de comprobación SQL en columna o tabla </td></tr></tbody></table></div></div><br class="table-break"/><p>El elemento <code class="literal">&lt;comment&gt;</code> te permite especificar un comentario para el esquema generado. </p><pre class="programlisting">&lt;class name="Customer" table="CurCust"&gt;
    &lt;comment
&gt;Current customers only&lt;/comment&gt;
    ...
&lt;/class
&gt;</pre><pre class="programlisting">&lt;property name="balance"&gt;
    &lt;column name="bal"&gt;
        &lt;comment
&gt;Balance in USD&lt;/comment&gt;
    &lt;/column&gt;
&lt;/property
&gt;</pre><p>This results in a <code class="literal">comment on table</code> or <code class="literal">comment on column</code> statement in the generated DDL where supported. </p></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-3"/>20.1.2. Ejecutando la herramienta</h3></div></div></div><p>La herramienta <code class="literal">SchemaExport</code> escribe un guión DDL a la salida estándar y/o ejecuta las sentencias DDL. </p><p>The following table displays the <code class="literal">SchemaExport</code> command line options</p><p><code class="literal">java -cp </code><span class="emphasis"><em>classpaths_de_hibernate</em></span> <code class="literal">org.hibernate.tool.hbm2ddl.SchemaExport</code> <span class="emphasis"><em>opciones ficheros_de_mapeo</em></span> </p><div class="table"><a id="d0e15780"/><p class="title"><b>Tabla 20.2. Opciones de Línea de Comandos de <code class="literal">SchemaExport</code></b></p><div class="table-contents"><table summary="Opciones de Línea de Comandos de SchemaExport" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Opción</th><th>Descripción</th></tr></thead><tbody><tr><td><code class="literal">--quiet</code></td><td>do not output the script to stdout</td></tr><tr><td><code class="literal">--drop</code></td><td>sólo desechar las tablas</td></tr><tr><td><code class="literal">--create</code></td><td>only create the tables</td></tr><tr><td><code class="literal">--text</code></td><td>do not export to the database</td></tr><tr><td><code class="literal">--output=my_schema.ddl</code></td><td>enviar la salida del guión ddl a un fichero</td></tr><tr><td><code class="literal">--naming=eg.MyNamingStrategy</code></td><td>select a <code class="literal">NamingStrategy</code></td></tr><tr><td><code class="literal">--config=hibernate.cfg.xml</code></td><td>lee la configuración de Hibernate de un fichero XML</td></tr><tr><td><code class="literal">--properties=hibernate.properties</code></td><td>lee las propiedades de base de datos de un fichero</td></tr><tr><td><code class="literal">--format</code></td><td>formatea agradablemente el SQL generado en el guión</td></tr><tr><td><code class="literal">--delimiter=x</code></td><td>establece un delimitador de fin de línea para el guión</td></tr></tbody></table></div></div><br class="table-break"/><p>You can even embed <code class="literal">SchemaExport</code> in your application: </p><pre class="programlisting">Configuration cfg = ....;
new SchemaExport(cfg).create(false, true);</pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-4"/>20.1.3. Propiedades</h3></div></div></div><p>Database properties can be specified: </p><div class="itemizedlist"><ul compact="compact"><li><p>como propiedades de sistema con <code class="literal">-D</code><span class="emphasis"><em>&lt;property&gt;</em></span></p></li><li><p>en <code class="literal">hibernate.properties</code></p></li><li><p>en un fichero de propiedades mencionado con <code class="literal">--properties</code></p></li></ul></div><p>Las propiedades necesarias son: </p><div class="table"><a id="d0e15889"/><p class="title"><b>Tabla 20.3. Propiedades de Conexión de SchemaExport</b></p><div class="table-contents"><table summary="Propiedades de Conexión de SchemaExport" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Nombre de Propiedad</th><th>Descripción</th></tr></thead><tbody><tr><td><code class="literal">hibernate.connection.driver_class</code></td><td>clase del driver jdbc</td></tr><tr><td><code class="literal">hibernate.connection.url</code></td><td>url de jdbc</td></tr><tr><td><code class="literal">hibernate.connection.username</code></td><td>usuario de base de datos</td></tr><tr><td><code class="literal">hibernate.connection.password</code></td><td>contraseña de usuario</td></tr><tr><td><code class="literal">hibernate.dialect</code></td><td>dialecto</td></tr></tbody></table></div></div><br class="table-break"/></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-5"/>20.1.4. Usando Ant</h3></div></div></div><p>Puedes llamar a <code class="literal">SchemaExport</code> desde tu guión de construcción de Ant: </p><pre class="programlisting">&lt;target name="schemaexport"&gt;
    &lt;taskdef name="schemaexport"
        classname="org.hibernate.tool.hbm2ddl.SchemaExportTask"
        classpathref="class.path"/&gt;
    
    &lt;schemaexport
        properties="hibernate.properties"
        quiet="no"
        text="no"
        drop="no"
        delimiter=";"
        output="schema-export.sql"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemaexport&gt;
&lt;/target
&gt;</pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-6"/>20.1.5. Actualizaciones incrementales de esquema</h3></div></div></div><p>The <code class="literal">SchemaUpdate</code> tool will update an existing schema with "incremental" changes. The <code class="literal">SchemaUpdate</code> depends upon the JDBC metadata API and, as such, will not work with all JDBC drivers. </p><p><code class="literal">java -cp </code><span class="emphasis"><em>classpaths_de_hibernate</em></span> <code class="literal">org.hibernate.tool.hbm2ddl.SchemaUpdate</code> <span class="emphasis"><em>opciones ficheros_de_mapeo</em></span> </p><div class="table"><a id="d0e15965"/><p class="title"><b>Tabla 20.4. Opciones de Línea de Comandos de <code class="literal">SchemaUpdate</code></b></p><div class="table-contents"><table summary="Opciones de Línea de Comandos de SchemaUpdate" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Opción</th><th>Descripción</th></tr></thead><tbody><tr><td><code class="literal">--quiet</code></td><td>do not output the script to stdout</td></tr><tr><td><code class="literal">--text</code></td><td>do not export the script to the database</td></tr><tr><td><code class="literal">--naming=eg.MyNamingStrategy</code></td><td>select a <code class="literal">NamingStrategy</code></td></tr><tr><td><code class="literal">--properties=hibernate.properties</code></td><td>lee las propiedades de base de datos de un fichero</td></tr><tr><td><code class="literal">--config=hibernate.cfg.xml</code></td><td>specify a <code class="literal">.cfg.xml</code> file</td></tr></tbody></table></div></div><br class="table-break"/><p>You can embed <code class="literal">SchemaUpdate</code> in your application: </p><pre class="programlisting">Configuration cfg = ....;
new SchemaUpdate(cfg).execute(false);</pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-7"/>20.1.6. Usando Ant para actualizaciones incrementales de esquema</h3></div></div></div><p>Puedes llamar a <code class="literal">SchemaUpdate</code> desde el guión de Ant: </p><pre class="programlisting">&lt;target name="schemaupdate"&gt;
    &lt;taskdef name="schemaupdate"
        classname="org.hibernate.tool.hbm2ddl.SchemaUpdateTask"
        classpathref="class.path"/&gt;
    
    &lt;schemaupdate
        properties="hibernate.properties"
        quiet="no"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemaupdate&gt;
&lt;/target
&gt;</pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-8"/>20.1.7. Schema validation</h3></div></div></div><p>The <code class="literal">SchemaValidator</code> tool will validate that the existing database schema "matches" your mapping documents. The <code class="literal">SchemaValidator</code> depends heavily upon the JDBC metadata API and, as such, will not work with all JDBC drivers. This tool is extremely useful for testing. </p><p><code class="literal">java -cp </code><span class="emphasis"><em>hibernate_classpaths</em></span> <code class="literal">org.hibernate.tool.hbm2ddl.SchemaValidator</code> <span class="emphasis"><em>options mapping_files</em></span> </p><div class="table"><a id="d0e16055"/><p class="title"><b>Tabla 20.5. <code class="literal">SchemaValidator</code> Command Line Options</b></p><div class="table-contents"><table summary="SchemaValidator Command Line Options" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Opción</th><th>Descripción</th></tr></thead><tbody><tr><td><code class="literal">--naming=eg.MyNamingStrategy</code></td><td>select a <code class="literal">NamingStrategy</code></td></tr><tr><td><code class="literal">--properties=hibernate.properties</code></td><td>lee las propiedades de base de datos de un fichero</td></tr><tr><td><code class="literal">--config=hibernate.cfg.xml</code></td><td>specify a <code class="literal">.cfg.xml</code> file</td></tr></tbody></table></div></div><br class="table-break"/><p>You can embed <code class="literal">SchemaValidator</code> in your application: </p><pre class="programlisting">Configuration cfg = ....;
                                                       new SchemaValidator(cfg).validate();</pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-9"/>20.1.8. Using Ant for schema validation</h3></div></div></div><p>You can call <code class="literal">SchemaValidator</code> from the Ant script: </p><pre class="programlisting">&lt;target name="schemavalidate"&gt;
                                &lt;taskdef name="schemavalidator"
                                         classname="org.hibernate.tool.hbm2ddl.SchemaValidatorTask"
                                         classpathref="class.path"/&gt;
                                
                                &lt;schemavalidator
                                                properties="hibernate.properties"&gt;
                                        &lt;fileset dir="src"&gt;
                                                &lt;include name="**/*.hbm.xml"/&gt;
                                        &lt;/fileset&gt;
                                &lt;/schemavalidator&gt;
                        &lt;/target
&gt;</pre></div></div></div><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild"/>Capítulo 21. Ejemplo: Padre/Hijo</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#example-parentchild-collections">21.1. Una nota sobre las colecciones</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-bidir">21.2. Uno-a-muchos bidirectional</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-cascades">21.3. Ciclo de vida en cascada</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-update">21.4. Tratamiento en cascada y <code class="literal">unsaved-value</code></a></span></dt><dt><span class="sect1"><a href="#example-parentchild-conclusion">21.5. Conclusión</a></span></dt></dl></div><p>One of the first things that new users want to do with Hibernate is to model a parent/child type relationship. There are two different approaches to this. The most convenient approach, especially for new users, is to model both <code class="literal">Parent</code> and <code class="literal">Child</code> as entity classes with a <code class="literal">&lt;one-to-many&gt;</code> association from <code class="literal">Parent</code> to <code class="literal">Child</code>. The alternative approach is to declare the <code class="literal">Child</code> as a <code class="literal">&lt;composite-element&gt;</code>. The default semantics of a one-to-many association in Hibernate are much less close to the usual semantics of a parent/child relationship than those of a composite element mapping. We will explain how to use a <span class="emphasis"><em>bidirectional one-to-many association with cascades</em></span> to model a parent/child relationship efficiently and elegantly. </p><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-collections"/>21.1. Una nota sobre las colecciones</h2></div></div></div><p>Hibernate collections are considered to be a logical part of their owning entity and not of the contained entities. Be aware that this is a critical distinction that has the following consequences: </p><div class="itemizedlist"><ul><li><p>When you remove/add an object from/to a collection, the version number of the collection owner is incremented. </p></li><li><p>If an object that was removed from a collection is an instance of a value type (e.g. a composite element), that object will cease to be persistent and its state will be completely removed from the database. Likewise, adding a value type instance to the collection will cause its state to be immediately persistent. </p></li><li><p>Conversely, if an entity is removed from a collection (a one-to-many or many-to-many association), it will not be deleted by default. This behavior is completely consistent; a change to the internal state of another entity should not cause the associated entity to vanish. Likewise, adding an entity to a collection does not cause that entity to become persistent, by default. </p></li></ul></div><p>Adding an entity to a collection, by default, merely creates a link between the two entities. Removing the entity will remove the link. This is appropriate for all sorts of cases. However, it is not appropriate in the case of a parent/child relationship. In this case, the life of the child is bound to the life cycle of the parent. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-bidir"/>21.2. Uno-a-muchos bidirectional</h2></div></div></div><p>Supón que empezamos con una asociación simple <code class="literal">&lt;one-to-many&gt;</code> desde <code class="literal">Parent</code> a <code class="literal">Child</code>. </p><pre class="programlisting">&lt;set name="children"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set
&gt;</pre><p>If we were to execute the following code: </p><pre class="programlisting">Parent p = .....;
Child c = new Child();
p.getChildren().add(c);
session.save(c);
session.flush();</pre><p>Hibernate publicaría dos sentencias SQL: </p><div class="itemizedlist"><ul><li><p>un <code class="literal">INSERT</code> para crear el registro de <code class="literal">c</code></p></li><li><p>un <code class="literal">UPDATE</code> para crear el enlace desde <code class="literal">p</code> a <code class="literal">c</code> </p></li></ul></div><p>This is not only inefficient, but also violates any <code class="literal">NOT NULL</code> constraint on the <code class="literal">parent_id</code> column. You can fix the nullability constraint violation by specifying <code class="literal">not-null="true"</code> in the collection mapping: </p><pre class="programlisting">&lt;set name="children"&gt;
    &lt;key column="parent_id" not-null="true"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set
&gt;</pre><p>Sin embargo, esta no es la solución recomendada. </p><p>The underlying cause of this behavior is that the link (the foreign key <code class="literal">parent_id</code>) from <code class="literal">p</code> to <code class="literal">c</code> is not considered part of the state of the <code class="literal">Child</code> object and is therefore not created in the <code class="literal">INSERT</code>. The solution is to make the link part of the <code class="literal">Child</code> mapping. </p><pre class="programlisting">&lt;many-to-one name="parent" column="parent_id" not-null="true"/&gt;</pre><p>You also need to add the <code class="literal">parent</code> property to the <code class="literal">Child</code> class. </p><p>Now that the <code class="literal">Child</code> entity is managing the state of the link, we tell the collection not to update the link. We use the <code class="literal">inverse</code> attribute to do this: </p><pre class="programlisting">&lt;set name="children" inverse="true"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set
&gt;</pre><p>The following code would be used to add a new <code class="literal">Child</code>: </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
c.setParent(p);
p.getChildren().add(c);
session.save(c);
session.flush();</pre><p>Only one SQL <code class="literal">INSERT</code> would now be issued. </p><p>You could also create an <code class="literal">addChild()</code> method of <code class="literal">Parent</code>. </p><pre class="programlisting">public void addChild(Child c) {
    c.setParent(this);
    children.add(c);
}</pre><p>The code to add a <code class="literal">Child</code> looks like this: </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
p.addChild(c);
session.save(c);
session.flush();</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-cascades"/>21.3. Ciclo de vida en cascada</h2></div></div></div><p>You can address the frustrations of the explicit call to <code class="literal">save()</code> by using cascades. </p><pre class="programlisting">&lt;set name="children" inverse="true" cascade="all"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set
&gt;</pre><p>This simplifies the code above to: </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
p.addChild(c);
session.flush();</pre><p>Similarly, we do not need to iterate over the children when saving or deleting a <code class="literal">Parent</code>. The following removes <code class="literal">p</code> and all its children from the database. </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
session.delete(p);
session.flush();</pre><p>However, the following code: </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = (Child) p.getChildren().iterator().next();
p.getChildren().remove(c);
c.setParent(null);
session.flush();</pre><p>will not remove <code class="literal">c</code> from the database. In this case, it will only remove the link to <code class="literal">p</code> and cause a <code class="literal">NOT NULL</code> constraint violation. You need to explicitly <code class="literal">delete()</code> the <code class="literal">Child</code>. </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = (Child) p.getChildren().iterator().next();
p.getChildren().remove(c);
session.delete(c);
session.flush();</pre><p>In our case, a <code class="literal">Child</code> cannot exist without its parent. So if we remove a <code class="literal">Child</code> from the collection, we do want it to be deleted. To do this, we must use <code class="literal">cascade="all-delete-orphan"</code>. </p><pre class="programlisting">&lt;set name="children" inverse="true" cascade="all-delete-orphan"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set
&gt;</pre><p>Even though the collection mapping specifies <code class="literal">inverse="true"</code>, cascades are still processed by iterating the collection elements. If you need an object be saved, deleted or updated by cascade, you must add it to the collection. It is not enough to simply call <code class="literal">setParent()</code>. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-update"/>21.4. Tratamiento en cascada y <code class="literal">unsaved-value</code></h2></div></div></div><p>Suppose we loaded up a <code class="literal">Parent</code> in one <code class="literal">Session</code>, made some changes in a UI action and wanted to persist these changes in a new session by calling <code class="literal">update()</code>. The <code class="literal">Parent</code> will contain a collection of children and, since the cascading update is enabled, Hibernate needs to know which children are newly instantiated and which represent existing rows in the database. We will also assume that both <code class="literal">Parent</code> and <code class="literal">Child</code> have generated identifier properties of type <code class="literal">Long</code>. Hibernate will use the identifier and version/timestamp property value to determine which of the children are new. (See <a href="#objectstate-saveorupdate" title="10.7. Detección automática de estado">Sección 10.7, “Detección automática de estado”</a>.) <span class="emphasis"><em>In Hibernate3, it is no longer necessary to specify an <code class="literal">unsaved-value</code> explicitly.</em></span> </p><p>The following code will update <code class="literal">parent</code> and <code class="literal">child</code> and insert <code class="literal">newChild</code>: </p><pre class="programlisting">//parent and child were both loaded in a previous session
parent.addChild(child);
Child newChild = new Child();
parent.addChild(newChild);
session.update(parent);
session.flush();</pre><p>This may be suitable for the case of a generated identifier, but what about assigned identifiers and composite identifiers? This is more difficult, since Hibernate cannot use the identifier property to distinguish between a newly instantiated object, with an identifier assigned by the user, and an object loaded in a previous session. In this case, Hibernate will either use the timestamp or version property, or will actually query the second-level cache or, worst case, the database, to see if the row exists. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-conclusion"/>21.5. Conclusión</h2></div></div></div><p>The sections we have just covered can be a bit confusing. However, in practice, it all works out nicely. Most Hibernate applications use the parent/child pattern in many places. </p><p>We mentioned an alternative in the first paragraph. None of the above issues exist in the case of <code class="literal">&lt;composite-element&gt;</code> mappings, which have exactly the semantics of a parent/child relationship. Unfortunately, there are two big limitations with composite element classes: composite elements cannot own collections and they should not be the child of any entity other than the unique parent. </p></div></div><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="example-weblog"/>Capítulo 22. Ejemplo: Aplicación de Weblog</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#example-weblog-classes">22.1. Clases Persistentes</a></span></dt><dt><span class="sect1"><a href="#example-weblog-mappings">22.2. Mapeos de Hibernate</a></span></dt><dt><span class="sect1"><a href="#example-weblog-code">22.3. Código Hibernate</a></span></dt></dl></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="example-weblog-classes"/>22.1. Clases Persistentes</h2></div></div></div><p>The persistent classes here represent a weblog and an item posted in a weblog. They are to be modelled as a standard parent/child relationship, but we will use an ordered bag, instead of a set: </p><pre class="programlisting">package eg;

import java.util.List;

public class Blog {
    private Long _id;
    private String _name;
    private List _items;

    public Long getId() {
        return _id;
    }
    public List getItems() {
        return _items;
    }
    public String getName() {
        return _name;
    }
    public void setId(Long long1) {
        _id = long1;
    }
    public void setItems(List list) {
        _items = list;
    }
    public void setName(String string) {
        _name = string;
    }
}</pre><pre class="programlisting">package eg;

import java.text.DateFormat;
import java.util.Calendar;

public class BlogItem {
    private Long _id;
    private Calendar _datetime;
    private String _text;
    private String _title;
    private Blog _blog;

    public Blog getBlog() {
        return _blog;
    }
    public Calendar getDatetime() {
        return _datetime;
    }
    public Long getId() {
        return _id;
    }
    public String getText() {
        return _text;
    }
    public String getTitle() {
        return _title;
    }
    public void setBlog(Blog blog) {
        _blog = blog;
    }
    public void setDatetime(Calendar calendar) {
        _datetime = calendar;
    }
    public void setId(Long long1) {
        _id = long1;
    }
    public void setText(String string) {
        _text = string;
    }
    public void setTitle(String string) {
        _title = string;
    }
}</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="example-weblog-mappings"/>22.2. Mapeos de Hibernate</h2></div></div></div><p>The XML mappings are now straightforward. For example: </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

    &lt;class
        name="Blog"
        table="BLOGS"&gt;

        &lt;id
            name="id"
            column="BLOG_ID"&gt;

            &lt;generator class="native"/&gt;

        &lt;/id&gt;

        &lt;property
            name="name"
            column="NAME"
            not-null="true"
            unique="true"/&gt;

        &lt;bag
            name="items"
            inverse="true"
            order-by="DATE_TIME"
            cascade="all"&gt;

            &lt;key column="BLOG_ID"/&gt;
            &lt;one-to-many class="BlogItem"/&gt;

        &lt;/bag&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping
&gt;</pre><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

    &lt;class
        name="BlogItem"
        table="BLOG_ITEMS"
        dynamic-update="true"&gt;

        &lt;id
            name="id"
            column="BLOG_ITEM_ID"&gt;

            &lt;generator class="native"/&gt;

        &lt;/id&gt;

        &lt;property
            name="title"
            column="TITLE"
            not-null="true"/&gt;

        &lt;property
            name="text"
            column="TEXT"
            not-null="true"/&gt;

        &lt;property
            name="datetime"
            column="DATE_TIME"
            not-null="true"/&gt;

        &lt;many-to-one
            name="blog"
            column="BLOG_ID"
            not-null="true"/&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping
&gt;</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="example-weblog-code"/>22.3. Código Hibernate</h2></div></div></div><p>The following class demonstrates some of the kinds of things we can do with these classes using Hibernate: </p><pre class="programlisting">package eg;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Iterator;
import java.util.List;

import org.hibernate.HibernateException;
import org.hibernate.Query;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;
import org.hibernate.tool.hbm2ddl.SchemaExport;

public class BlogMain {
    
    private SessionFactory _sessions;
    
    public void configure() throws HibernateException {
        _sessions = new Configuration()
            .addClass(Blog.class)
            .addClass(BlogItem.class)
            .buildSessionFactory();
    }
    
    public void exportTables() throws HibernateException {
        Configuration cfg = new Configuration()
            .addClass(Blog.class)
            .addClass(BlogItem.class);
        new SchemaExport(cfg).create(true, true);
    }
    
    public Blog createBlog(String name) throws HibernateException {
        
        Blog blog = new Blog();
        blog.setName(name);
        blog.setItems( new ArrayList() );
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.persist(blog);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return blog;
    }
    
    public BlogItem createBlogItem(Blog blog, String title, String text)
                        throws HibernateException {
        
        BlogItem item = new BlogItem();
        item.setTitle(title);
        item.setText(text);
        item.setBlog(blog);
        item.setDatetime( Calendar.getInstance() );
        blog.getItems().add(item);
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.update(blog);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return item;
    }
    
    public BlogItem createBlogItem(Long blogid, String title, String text)
                        throws HibernateException {
        
        BlogItem item = new BlogItem();
        item.setTitle(title);
        item.setText(text);
        item.setDatetime( Calendar.getInstance() );
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            Blog blog = (Blog) session.load(Blog.class, blogid);
            item.setBlog(blog);
            blog.getItems().add(item);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return item;
    }
    
    public void updateBlogItem(BlogItem item, String text)
                    throws HibernateException {
        
        item.setText(text);
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.update(item);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
    }
    
    public void updateBlogItem(Long itemid, String text)
                    throws HibernateException {
    
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            BlogItem item = (BlogItem) session.load(BlogItem.class, itemid);
            item.setText(text);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
    }
    
    public List listAllBlogNamesAndItemCounts(int max)
                    throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        List result = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "select blog.id, blog.name, count(blogItem) " +
                "from Blog as blog " +
                "left outer join blog.items as blogItem " +
                "group by blog.name, blog.id " +
                "order by max(blogItem.datetime)"
            );
            q.setMaxResults(max);
            result = q.list();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return result;
    }
    
    public Blog getBlogAndAllItems(Long blogid)
                    throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        Blog blog = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "from Blog as blog " +
                "left outer join fetch blog.items " +
                "where blog.id = :blogid"
            );
            q.setParameter("blogid", blogid);
            blog  = (Blog) q.uniqueResult();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return blog;
    }
    
    public List listBlogsAndRecentItems() throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        List result = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "from Blog as blog " +
                "inner join blog.items as blogItem " +
                "where blogItem.datetime 
&gt; :minDate"
            );

            Calendar cal = Calendar.getInstance();
            cal.roll(Calendar.MONTH, false);
            q.setCalendar("minDate", cal);
            
            result = q.list();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return result;
    }
}</pre></div></div><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="example-mappings"/>Capítulo 23. Ejemplo: Varios Mapeos</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#example-mappings-emp">23.1. Empleador/Empleado</a></span></dt><dt><span class="sect1"><a href="#example-mappings-authorwork">23.2. Autor/Obra</a></span></dt><dt><span class="sect1"><a href="#example-mappings-customerorderproduct">23.3. Cliente/Orden/Producto</a></span></dt><dt><span class="sect1"><a href="#misc">23.4. Mapeos misceláneos de ejemplo</a></span></dt><dd><dl><dt><span class="sect2"><a href="#example-mappings-typed-onetone">23.4.1. Asociación uno-a-uno "Tipificada"</a></span></dt><dt><span class="sect2"><a href="#example-mappings-composite-key">23.4.2. Ejemplo de clave compuesta</a></span></dt><dt><span class="sect2"><a href="#example-mappings-composite-key-manytomany">23.4.3. Muchos-a-muchos con atributo de clave compuesta compartido</a></span></dt><dt><span class="sect2"><a href="#example-mappings-content-discrimination">23.4.4. Discriminación basada en contenido</a></span></dt><dt><span class="sect2"><a href="#example-mappings-association-alternatekeys">23.4.5. Asociaciones sobre claves alternativas</a></span></dt></dl></dd></dl></div><p>This chapters explores some more complex association mappings. </p><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="example-mappings-emp"/>23.1. Empleador/Empleado</h2></div></div></div><p>The following model of the relationship between <code class="literal">Employer</code> and <code class="literal">Employee</code> uses an entity class (<code class="literal">Employment</code>) to represent the association. You can do this when there might be more than one period of employment for the same two parties. Components are used to model monetary values and employee names. </p><div class="mediaobject" align="center"><img src="../images/EmployerEmployee.png" align="middle"/></div><p>Here is a possible mapping document: </p><pre class="programlisting">&lt;hibernate-mapping&gt;
        
    &lt;class name="Employer" table="employers"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"
&gt;employer_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

    &lt;class name="Employment" table="employment_periods"&gt;

        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"
&gt;employment_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="startDate" column="start_date"/&gt;
        &lt;property name="endDate" column="end_date"/&gt;

        &lt;component name="hourlyRate" class="MonetaryAmount"&gt;
            &lt;property name="amount"&gt;
                &lt;column name="hourly_rate" sql-type="NUMERIC(12, 2)"/&gt;
            &lt;/property&gt;
            &lt;property name="currency" length="12"/&gt;
        &lt;/component&gt;

        &lt;many-to-one name="employer" column="employer_id" not-null="true"/&gt;
        &lt;many-to-one name="employee" column="employee_id" not-null="true"/&gt;

    &lt;/class&gt;

    &lt;class name="Employee" table="employees"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"
&gt;employee_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="taxfileNumber"/&gt;
        &lt;component name="name" class="Name"&gt;
            &lt;property name="firstName"/&gt;
            &lt;property name="initial"/&gt;
            &lt;property name="lastName"/&gt;
        &lt;/component&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping
&gt;</pre><p>Here is the table schema generated by <code class="literal">SchemaExport</code>. </p><pre class="programlisting">create table employers (
    id BIGINT not null, 
    name VARCHAR(255), 
    primary key (id)
)

create table employment_periods (
    id BIGINT not null,
    hourly_rate NUMERIC(12, 2),
    currency VARCHAR(12), 
    employee_id BIGINT not null, 
    employer_id BIGINT not null, 
    end_date TIMESTAMP, 
    start_date TIMESTAMP, 
    primary key (id)
)

create table employees (
    id BIGINT not null, 
    firstName VARCHAR(255), 
    initial CHAR(1), 
    lastName VARCHAR(255), 
    taxfileNumber VARCHAR(255), 
    primary key (id)
)

alter table employment_periods 
    add constraint employment_periodsFK0 foreign key (employer_id) references employers
alter table employment_periods 
    add constraint employment_periodsFK1 foreign key (employee_id) references employees
create sequence employee_id_seq
create sequence employment_id_seq
create sequence employer_id_seq</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="example-mappings-authorwork"/>23.2. Autor/Obra</h2></div></div></div><p>Consider the following model of the relationships between <code class="literal">Work</code>, <code class="literal">Author</code> and <code class="literal">Person</code>. In the example, the relationship between <code class="literal">Work</code> and <code class="literal">Author</code> is represented as a many-to-many association and the relationship between <code class="literal">Author</code> and <code class="literal">Person</code> is represented as one-to-one association. Another possibility would be to have <code class="literal">Author</code> extend <code class="literal">Person</code>. </p><div class="mediaobject" align="center"><img src="../images/AuthorWork.png" align="middle"/></div><p>El siguiente documento de mapeo representa estas relaciones correctamente: </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Work" table="works" discriminator-value="W"&gt;

        &lt;id name="id" column="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;discriminator column="type" type="character"/&gt;

        &lt;property name="title"/&gt;
        &lt;set name="authors" table="author_work"&gt;
            &lt;key column name="work_id"/&gt;
            &lt;many-to-many class="Author" column name="author_id"/&gt;
        &lt;/set&gt;

        &lt;subclass name="Book" discriminator-value="B"&gt;
            &lt;property name="text"/&gt;
        &lt;/subclass&gt;

        &lt;subclass name="Song" discriminator-value="S"&gt;
            &lt;property name="tempo"/&gt;
            &lt;property name="genre"/&gt;
        &lt;/subclass&gt;

    &lt;/class&gt;

    &lt;class name="Author" table="authors"&gt;

        &lt;id name="id" column="id"&gt;
            &lt;!-- The Author must have the same identifier as the Person --&gt;
            &lt;generator class="assigned"/&gt; 
        &lt;/id&gt;

        &lt;property name="alias"/&gt;
        &lt;one-to-one name="person" constrained="true"/&gt;

        &lt;set name="works" table="author_work" inverse="true"&gt;
            &lt;key column="author_id"/&gt;
            &lt;many-to-many class="Work" column="work_id"/&gt;
        &lt;/set&gt;

    &lt;/class&gt;

    &lt;class name="Person" table="persons"&gt;
        &lt;id name="id" column="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping
&gt;</pre><p>There are four tables in this mapping: <code class="literal">works</code>, <code class="literal">authors</code> and <code class="literal">persons</code> hold work, author and person data respectively. <code class="literal">author_work</code> is an association table linking authors to works. Here is the table schema, as generated by <code class="literal">SchemaExport</code>: </p><pre class="programlisting">create table works (
    id BIGINT not null generated by default as identity, 
    tempo FLOAT, 
    genre VARCHAR(255), 
    text INTEGER, 
    title VARCHAR(255), 
    type CHAR(1) not null, 
    primary key (id)
)

create table author_work (
    author_id BIGINT not null, 
    work_id BIGINT not null, 
    primary key (work_id, author_id)
)

create table authors (
    id BIGINT not null generated by default as identity, 
    alias VARCHAR(255), 
    primary key (id)
)

create table persons (
    id BIGINT not null generated by default as identity, 
    name VARCHAR(255), 
    primary key (id)
)

alter table authors 
    add constraint authorsFK0 foreign key (id) references persons
alter table author_work 
    add constraint author_workFK0 foreign key (author_id) references authors
alter table author_work
    add constraint author_workFK1 foreign key (work_id) references works</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="example-mappings-customerorderproduct"/>23.3. Cliente/Orden/Producto</h2></div></div></div><p>In this section we consider a model of the relationships between <code class="literal">Customer</code>, <code class="literal">Order</code>, <code class="literal">Line Item</code> and <code class="literal">Product</code>. There is a one-to-many association between <code class="literal">Customer</code> and <code class="literal">Order</code>, but how can you represent <code class="literal">Order</code> / <code class="literal">LineItem</code> / <code class="literal">Product</code>? In the example, <code class="literal">LineItem</code> is mapped as an association class representing the many-to-many association between <code class="literal">Order</code> and <code class="literal">Product</code>. In Hibernate this is called a composite element. </p><div class="mediaobject" align="center"><img src="../images/CustomerOrderProduct.png" align="middle"/></div><p>The mapping document will look like this: </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Customer" table="customers"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
        &lt;set name="orders" inverse="true"&gt;
            &lt;key column="customer_id"/&gt;
            &lt;one-to-many class="Order"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Order" table="orders"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="date"/&gt;
        &lt;many-to-one name="customer" column="customer_id"/&gt;
        &lt;list name="lineItems" table="line_items"&gt;
            &lt;key column="order_id"/&gt;
            &lt;list-index column="line_number"/&gt;
            &lt;composite-element class="LineItem"&gt;
                &lt;property name="quantity"/&gt;
                &lt;many-to-one name="product" column="product_id"/&gt;
            &lt;/composite-element&gt;
        &lt;/list&gt;
    &lt;/class&gt;

    &lt;class name="Product" table="products"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="serialNumber"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping
&gt;</pre><p><code class="literal">customers</code>, <code class="literal">orders</code>, <code class="literal">line_items</code> y <code class="literal">products</code> tienen los datos de cliente, orden, ítem de línea de orden y producto respectivamente. Además <code class="literal">line_items</code> actúa como una tabla de asociación enlazando órdenes con productos. </p><pre class="programlisting">create table customers (
    id BIGINT not null generated by default as identity, 
    name VARCHAR(255), 
    primary key (id)
)

create table orders (
    id BIGINT not null generated by default as identity, 
    customer_id BIGINT, 
    date TIMESTAMP, 
    primary key (id)
)

create table line_items (
    line_number INTEGER not null, 
    order_id BIGINT not null, 
    product_id BIGINT, 
    quantity INTEGER, 
    primary key (order_id, line_number)
)

create table products (
    id BIGINT not null generated by default as identity, 
    serialNumber VARCHAR(255), 
    primary key (id)
)

alter table orders 
    add constraint ordersFK0 foreign key (customer_id) references customers
alter table line_items
    add constraint line_itemsFK0 foreign key (product_id) references products
alter table line_items
    add constraint line_itemsFK1 foreign key (order_id) references orders</pre></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="misc"/>23.4. Mapeos misceláneos de ejemplo</h2></div></div></div><p>These examples are available from the Hibernate test suite. You will find many other useful example mappings there by searching in the <code class="literal">test</code> folder of the Hibernate distribution. </p><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="example-mappings-typed-onetone"/>23.4.1. Asociación uno-a-uno "Tipificada"</h3></div></div></div><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="name"/&gt;
    &lt;one-to-one name="address" 
            cascade="all"&gt;
        &lt;formula
&gt;name&lt;/formula&gt;
        &lt;formula
&gt;'HOME'&lt;/formula&gt;
    &lt;/one-to-one&gt;
    &lt;one-to-one name="mailingAddress" 
            cascade="all"&gt;
        &lt;formula
&gt;name&lt;/formula&gt;
        &lt;formula
&gt;'MAILING'&lt;/formula&gt;
    &lt;/one-to-one&gt;
&lt;/class&gt;

&lt;class name="Address" batch-size="2" 
        check="addressType in ('MAILING', 'HOME', 'BUSINESS')"&gt;
    &lt;composite-id&gt;
        &lt;key-many-to-one name="person" 
                column="personName"/&gt;
        &lt;key-property name="type" 
                column="addressType"/&gt;
    &lt;/composite-id&gt;
    &lt;property name="street" type="text"/&gt;
    &lt;property name="state"/&gt;
    &lt;property name="zip"/&gt;
&lt;/class
&gt;</pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="example-mappings-composite-key"/>23.4.2. Ejemplo de clave compuesta</h3></div></div></div><pre class="programlisting">&lt;class name="Customer"&gt;

    &lt;id name="customerId"
        length="10"&gt;
        &lt;generator class="assigned"/&gt;
    &lt;/id&gt;

    &lt;property name="name" not-null="true" length="100"/&gt;
    &lt;property name="address" not-null="true" length="200"/&gt;

    &lt;list name="orders"
            inverse="true"
            cascade="save-update"&gt;
        &lt;key column="customerId"/&gt;
        &lt;index column="orderNumber"/&gt;
        &lt;one-to-many class="Order"/&gt;
    &lt;/list&gt;

&lt;/class&gt;

&lt;class name="Order" table="CustomerOrder" lazy="true"&gt;
    &lt;synchronize table="LineItem"/&gt;
    &lt;synchronize table="Product"/&gt;
    
    &lt;composite-id name="id" 
            class="Order$Id"&gt;
        &lt;key-property name="customerId" length="10"/&gt;
        &lt;key-property name="orderNumber"/&gt;
    &lt;/composite-id&gt;
    
    &lt;property name="orderDate" 
            type="calendar_date"
            not-null="true"/&gt;
    
    &lt;property name="total"&gt;
        &lt;formula&gt;
            ( select sum(li.quantity*p.price) 
            from LineItem li, Product p 
            where li.productId = p.productId 
                and li.customerId = customerId 
                and li.orderNumber = orderNumber )
        &lt;/formula&gt;
    &lt;/property&gt;
    
    &lt;many-to-one name="customer"
            column="customerId"
            insert="false"
            update="false" 
            not-null="true"/&gt;
        
    &lt;bag name="lineItems"
            fetch="join" 
            inverse="true"
            cascade="save-update"&gt;
        &lt;key&gt;
            &lt;column name="customerId"/&gt;
            &lt;column name="orderNumber"/&gt;
        &lt;/key&gt;
        &lt;one-to-many class="LineItem"/&gt;
    &lt;/bag&gt;
    
&lt;/class&gt;
    
&lt;class name="LineItem"&gt;
    
    &lt;composite-id name="id" 
            class="LineItem$Id"&gt;
        &lt;key-property name="customerId" length="10"/&gt;
        &lt;key-property name="orderNumber"/&gt;
        &lt;key-property name="productId" length="10"/&gt;
    &lt;/composite-id&gt;
    
    &lt;property name="quantity"/&gt;
    
    &lt;many-to-one name="order"
            insert="false"
            update="false" 
            not-null="true"&gt;
        &lt;column name="customerId"/&gt;
        &lt;column name="orderNumber"/&gt;
    &lt;/many-to-one&gt;
    
    &lt;many-to-one name="product"
            insert="false"
            update="false" 
            not-null="true"
            column="productId"/&gt;
        
&lt;/class&gt;

&lt;class name="Product"&gt;
    &lt;synchronize table="LineItem"/&gt;

    &lt;id name="productId"
        length="10"&gt;
        &lt;generator class="assigned"/&gt;
    &lt;/id&gt;
    
    &lt;property name="description" 
        not-null="true" 
        length="200"/&gt;
    &lt;property name="price" length="3"/&gt;
    &lt;property name="numberAvailable"/&gt;
    
    &lt;property name="numberOrdered"&gt;
        &lt;formula&gt;
            ( select sum(li.quantity) 
            from LineItem li 
            where li.productId = productId )
        &lt;/formula&gt;
    &lt;/property&gt;
    
&lt;/class
&gt;</pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="example-mappings-composite-key-manytomany"/>23.4.3. Muchos-a-muchos con atributo de clave compuesta compartido</h3></div></div></div><pre class="programlisting">&lt;class name="User" table="`User`"&gt;
    &lt;composite-id&gt;
        &lt;key-property name="name"/&gt;
        &lt;key-property name="org"/&gt;
    &lt;/composite-id&gt;
    &lt;set name="groups" table="UserGroup"&gt;
        &lt;key&gt;
            &lt;column name="userName"/&gt;
            &lt;column name="org"/&gt;
        &lt;/key&gt;
        &lt;many-to-many class="Group"&gt;
            &lt;column name="groupName"/&gt;
            &lt;formula
&gt;org&lt;/formula&gt;
        &lt;/many-to-many&gt;
    &lt;/set&gt;
&lt;/class&gt;
    
&lt;class name="Group" table="`Group`"&gt;
    &lt;composite-id&gt;
        &lt;key-property name="name"/&gt;
        &lt;key-property name="org"/&gt;
    &lt;/composite-id&gt;
    &lt;property name="description"/&gt;
    &lt;set name="users" table="UserGroup" inverse="true"&gt;
        &lt;key&gt;
            &lt;column name="groupName"/&gt;
            &lt;column name="org"/&gt;
        &lt;/key&gt;
        &lt;many-to-many class="User"&gt;
            &lt;column name="userName"/&gt;
            &lt;formula
&gt;org&lt;/formula&gt;
        &lt;/many-to-many&gt;
    &lt;/set&gt;
&lt;/class&gt;
</pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="example-mappings-content-discrimination"/>23.4.4. Discriminación basada en contenido</h3></div></div></div><pre class="programlisting">&lt;class name="Person"
    discriminator-value="P"&gt;
    
    &lt;id name="id" 
        column="person_id" 
        unsaved-value="0"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    
            
    &lt;discriminator 
        type="character"&gt;
        &lt;formula&gt;
            case 
                when title is not null then 'E' 
                when salesperson is not null then 'C' 
                else 'P' 
            end
        &lt;/formula&gt;
    &lt;/discriminator&gt;

    &lt;property name="name" 
        not-null="true"
        length="80"/&gt;
        
    &lt;property name="sex" 
        not-null="true"
        update="false"/&gt;
    
    &lt;component name="address"&gt;
        &lt;property name="address"/&gt;
        &lt;property name="zip"/&gt;
        &lt;property name="country"/&gt;
    &lt;/component&gt;
    
    &lt;subclass name="Employee" 
        discriminator-value="E"&gt;
            &lt;property name="title"
                length="20"/&gt;
            &lt;property name="salary"/&gt;
            &lt;many-to-one name="manager"/&gt;
    &lt;/subclass&gt;
    
    &lt;subclass name="Customer" 
        discriminator-value="C"&gt;
            &lt;property name="comments"/&gt;
            &lt;many-to-one name="salesperson"/&gt;
    &lt;/subclass&gt;
    
&lt;/class
&gt;</pre></div><div class="sect2" lang="es-ES"><div class="titlepage"><div><div><h3 class="title"><a id="example-mappings-association-alternatekeys"/>23.4.5. Asociaciones sobre claves alternativas</h3></div></div></div><pre class="programlisting">&lt;class name="Person"&gt;
    
    &lt;id name="id"&gt;
        &lt;generator class="hilo"/&gt;
    &lt;/id&gt;
    
    &lt;property name="name" length="100"/&gt;
    
    &lt;one-to-one name="address" 
        property-ref="person"
        cascade="all"
        fetch="join"/&gt;
    
    &lt;set name="accounts" 
        inverse="true"&gt;
        &lt;key column="userId"
            property-ref="userId"/&gt;
        &lt;one-to-many class="Account"/&gt;
    &lt;/set&gt;
    
    &lt;property name="userId" length="8"/&gt;

&lt;/class&gt;

&lt;class name="Address"&gt;

    &lt;id name="id"&gt;
        &lt;generator class="hilo"/&gt;
    &lt;/id&gt;

    &lt;property name="address" length="300"/&gt;
    &lt;property name="zip" length="5"/&gt;
    &lt;property name="country" length="25"/&gt;
    &lt;many-to-one name="person" unique="true" not-null="true"/&gt;

&lt;/class&gt;

&lt;class name="Account"&gt;
    &lt;id name="accountId" length="32"&gt;
        &lt;generator class="uuid.hex"/&gt;
    &lt;/id&gt;
    
    &lt;many-to-one name="user"
        column="userId"
        property-ref="userId"/&gt;
    
    &lt;property name="type" not-null="true"/&gt;
    
&lt;/class
&gt;</pre></div></div></div><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="best-practices"/>Capítulo 24. Mejores Prácticas</h2></div></div></div><div class="variablelist"><dl><dt><span class="term">Write fine-grained classes and map them using <code class="literal">&lt;component&gt;</code>:</span></dt><dd><p>Usa una clase <code class="literal">Dirección</code> para encapsular <code class="literal">calle</code>, <code class="literal">distrito</code>, <code class="literal">estado</code>, <code class="literal">código postal</code>. Esto alienta la reutilización de código y simplifica el refactoring. </p></dd><dt><span class="term">Declare identifier properties on persistent classes:</span></dt><dd><p>Hibernate makes identifier properties optional. There are a range of reasons why you should use them. We recommend that identifiers be 'synthetic', that is, generated with no business meaning. </p></dd><dt><span class="term">Identify natural keys:</span></dt><dd><p>Identifica las claves naturales de todas las entidades, y mapealas usando <code class="literal">&lt;natural-id&gt;</code>. Implementa <code class="literal">equals()</code> y <code class="literal">hashCode()</code> para comparar las propiedades que componen la clave natural. </p></dd><dt><span class="term">Place each class mapping in its own file:</span></dt><dd><p>Do not use a single monolithic mapping document. Map <code class="literal">com.eg.Foo</code> in the file <code class="literal">com/eg/Foo.hbm.xml</code>. This makes sense, particularly in a team environment. </p></dd><dt><span class="term">Load mappings as resources:</span></dt><dd><p>Despliega los mapeos junto a las clases que mapean. </p></dd><dt><span class="term">Consider externalizing query strings:</span></dt><dd><p>This is recommended if your queries call non-ANSI-standard SQL functions. Externalizing the query strings to mapping files will make the application more portable. </p></dd><dt><span class="term">Usa variables de ligado.</span></dt><dd><p>As in JDBC, always replace non-constant values by "?". Do not use string manipulation to bind a non-constant value in a query. You should also consider using named parameters in queries. </p></dd><dt><span class="term">Do not manage your own JDBC connections:</span></dt><dd><p>Hibernate allows the application to manage JDBC connections, but his approach should be considered a last-resort. If you cannot use the built-in connection providers, consider providing your own implementation of <code class="literal">org.hibernate.connection.ConnectionProvider</code>. </p></dd><dt><span class="term">Consider using a custom type:</span></dt><dd><p>Suppose you have a Java type from a library that needs to be persisted but does not provide the accessors needed to map it as a component. You should consider implementing <code class="literal">org.hibernate.UserType</code>. This approach frees the application code from implementing transformations to/from a Hibernate type. </p></dd><dt><span class="term">Use hand-coded JDBC in bottlenecks:</span></dt><dd><p>In performance-critical areas of the system, some kinds of operations might benefit from direct JDBC. Do not assume, however, that JDBC is necessarily faster. Please wait until you <span class="emphasis"><em>know</em></span> something is a bottleneck. If you need to use direct JDBC, you can open a Hibernate <code class="literal">Session</code> and usingfile:///usr/share/doc/HTML/en-US/index.html that JDBC connection. This way you can still use the same transaction strategy and underlying connection provider. </p></dd><dt><span class="term">Understand <code class="literal">Session</code> flushing:</span></dt><dd><p>Sometimes the Session synchronizes its persistent state with the database. Performance will be affected if this process occurs too often. You can sometimes minimize unnecessary flushing by disabling automatic flushing, or even by changing the order of queries and other operations within a particular transaction. </p></dd><dt><span class="term">In a three tiered architecture, consider using detached objects:</span></dt><dd><p>When using a servlet/session bean architecture, you can pass persistent objects loaded in the session bean to and from the servlet/JSP layer. Use a new session to service each request. Use <code class="literal">Session.merge()</code> or <code class="literal">Session.saveOrUpdate()</code> to synchronize objects with the database. </p></dd><dt><span class="term">In a two tiered architecture, consider using long persistence contexts:</span></dt><dd><p>Database Transactions have to be as short as possible for best scalability. However, it is often necessary to implement long running <span class="emphasis"><em>application transactions</em></span>, a single unit-of-work from the point of view of a user. An application transaction might span several client request/response cycles. It is common to use detached objects to implement application transactions. An appropriate alternative in a two tiered architecture, is to maintain a single open persistence contact session for the whole life cycle of the application transaction. Then simply disconnect from the JDBC connection at the end of each request and reconnect at the beginning of the subsequent request. Never share a single session across more than one application transaction or you will be working with stale data. </p></dd><dt><span class="term">Do not treat exceptions as recoverable:</span></dt><dd><p>This is more of a necessary practice than a "best" practice. When an exception occurs, roll back the <code class="literal">Transaction</code> and close the <code class="literal">Session</code>. If you do not do this, Hibernate cannot guarantee that in-memory state accurately represents the persistent state. For example, do not use <code class="literal">Session.load()</code> to determine if an instance with the given identifier exists on the database; use <code class="literal">Session.get()</code> or a query instead. </p></dd><dt><span class="term">Prefer lazy fetching for associations:</span></dt><dd><p>Use eager fetching sparingly. Use proxies and lazy collections for most associations to classes that are not likely to be completely held in the second-level cache. For associations to cached classes, where there is an a extremely high probability of a cache hit, explicitly disable eager fetching using <code class="literal">lazy="false"</code>. When join fetching is appropriate to a particular use case, use a query with a <code class="literal">left join fetch</code>. </p></dd><dt><span class="term">Use the <span class="emphasis"><em>open session in view</em></span> pattern, or a disciplined <span class="emphasis"><em>assembly phase</em></span> to avoid problems with unfetched data: </span></dt><dd><p>Hibernate frees the developer from writing tedious <span class="emphasis"><em>Data Transfer Objects</em></span> (DTO). In a traditional EJB architecture, DTOs serve dual purposes: first, they work around the problem that entity beans are not serializable; second, they implicitly define an assembly phase where all data to be used by the view is fetched and marshalled into the DTOs before returning control to the presentation tier. Hibernate eliminates the first purpose. Unless you are prepared to hold the persistence context (the session) open across the view rendering process, you will still need an assembly phase. Think of your business methods as having a strict contract with the presentation tier about what data is available in the detached objects. This is not a limitation of Hibernate. It is a fundamental requirement of safe transactional data access. </p></dd><dt><span class="term">Consider abstracting your business logic from Hibernate:</span></dt><dd><p>Hide Hibernate data-access code behind an interface. Combine the <span class="emphasis"><em>DAO</em></span> and <span class="emphasis"><em>Thread Local Session</em></span> patterns. You can even have some classes persisted by handcoded JDBC associated to Hibernate via a <code class="literal">UserType</code>. This advice is, however, intended for "sufficiently large" applications. It is not appropriate for an application with five tables. </p></dd><dt><span class="term">Do not use exotic association mappings:</span></dt><dd><p>Practical test cases for real many-to-many associations are rare. Most of the time you need additional information stored in the "link table". In this case, it is much better to use two one-to-many associations to an intermediate link class. In fact, most associations are one-to-many and many-to-one. For this reason, you should proceed cautiously when using any other association style. </p></dd><dt><span class="term">Prefer bidirectional associations:</span></dt><dd><p>Las asociaciones unidireccionales son más difíciles de consultar. En una aplicación grande, casi todas las asociaciones deben ser navegables en ambas direcciones en consultas. </p></dd></dl></div></div><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="portability"/>Capítulo 25. Database Portability Considerations</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#portability-basics">25.1. Portability Basics</a></span></dt><dt><span class="sect1"><a href="#portability-dialect">25.2. Dialect</a></span></dt><dt><span class="sect1"><a href="#portability-dialectresolver">25.3. Dialect resolution</a></span></dt><dt><span class="sect1"><a href="#portability-idgen">25.4. Identifier generation</a></span></dt><dt><span class="sect1"><a href="#portability-functions">25.5. Database functions</a></span></dt><dt><span class="sect1"><a href="#portability-types">25.6. Type mappings</a></span></dt></dl></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="portability-basics"/>25.1. Portability Basics</h2></div></div></div><p>One of the selling points of Hibernate (and really Object/Relational Mapping as a whole) is the notion of database portability. This could mean an internal IT user migrating from one database vendor to another, or it could mean a framework or deployable application consuming Hibernate to simultaneously target multiple database products by their users. Regardless of the exact scenario, the basic idea is that you want Hibernate to help you run against any number of databases without changes to your code, and ideally without any changes to the mapping metadata. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="portability-dialect"/>25.2. Dialect</h2></div></div></div><p>The first line of portability for Hibernate is the dialect, which is a specialization of the <code class="classname">org.hibernate.dialect.Dialect</code> contract. A dialect encapsulates all the differences in how Hibernate must communicate with a particular database to accomplish some task like getting a sequence value or structuring a SELECT query. Hibernate bundles a wide range of dialects for many of the most popular databases. If you find that your particular database is not among them, it is not terribly difficult to write your own. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="portability-dialectresolver"/>25.3. Dialect resolution</h2></div></div></div><p>Originally, Hibernate would always require that users specify which dialect to use. In the case of users looking to simultaneously target multiple databases with their build that was problematic. Generally this required their users to configure the Hibernate dialect or defining their own method of setting that value. </p><p>Starting with version 3.2, Hibernate introduced the notion of automatically detecting the dialect to use based on the <code class="interfacename">java.sql.DatabaseMetaData</code> obtained from a <code class="interfacename">java.sql.Connection</code> to that database. This was much better, expect that this resolution was limited to databases Hibernate know about ahead of time and was in no way configurable or overrideable. </p><p>Starting with version 3.3, Hibernate has a fare more powerful way to automatically determine which dialect to should be used by relying on a series of delegates which implement the <code class="interfacename">org.hibernate.dialect.resolver.DialectResolver</code> which defines only a single method:</p><pre class="programlisting">public Dialect resolveDialect(DatabaseMetaData metaData) throws JDBCConnectionException</pre><p>. The basic contract here is that if the resolver 'understands' the given database metadata then it returns the corresponding Dialect; if not it returns null and the process continues to the next resolver. The signature also identifies <code class="exceptionname">org.hibernate.exception.JDBCConnectionException</code> as possibly being thrown. A JDBCConnectionException here is interpreted to imply a "non transient" (aka non-recoverable) connection problem and is used to indicate an immediate stop to resolution attempts. All other exceptions result in a warning and continuing on to the next resolver. </p><p>The cool part about these resolvers is that users can also register their own custom resolvers which will be processed ahead of the built-in Hibernate ones. This might be useful in a number of different situations: it allows easy integration for auto-detection of dialects beyond those shipped with HIbernate itself; it allows you to specify to use a custom dialect when a particular database is recognized; etc. To register one or more resolvers, simply specify them (seperated by commas, tabs or spaces) using the 'hibernate.dialect_resolvers' configuration setting (see the <code class="constant">DIALECT_RESOLVERS</code> constant on <code class="classname">org.hibernate.cfg.Environment</code>). </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="portability-idgen"/>25.4. Identifier generation</h2></div></div></div><p>When considering portability between databases, another important decision is selecting the identifier generation stratagy you want to use. Originally Hibernate provided the <span class="emphasis"><em>native</em></span> generator for this purpose, which was intended to select between a <span class="emphasis"><em>sequence</em></span>, <span class="emphasis"><em>identity</em></span>, or <span class="emphasis"><em>table</em></span> strategy depending on the capability of the underlying database. However, an insidious implication of this approach comes about when targtetting some databases which support <span class="emphasis"><em>identity</em></span> generation and some which do not. <span class="emphasis"><em>identity</em></span> generation relies on the SQL definition of an IDENTITY (or auto-increment) column to manage the identifier value; it is what is known as a post-insert generation strategy becauase the insert must actually happen before we can know the identifier value. Because Hibernate relies on this identifier value to uniquely reference entities within a persistence context it must then issue the insert immediately when the users requests the entitiy be associated with the session (like via save() e.g.) regardless of current transactional semantics. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Nota</h2><p> Hibernate was changed slightly once the implication of this was better understood so that the insert is delayed in cases where that is feasible. </p></div><p> The underlying issue is that the actual semanctics of the application itself changes in these cases. </p><p>Starting with version 3.2.3, Hibernate comes with a set of <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://in.relation.to/2082.lace">enhanced</a> identifier generators targetting portability in a much different way. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Nota</h2><p> There are specifically 2 bundled <span class="emphasis"><em>enhanced</em></span>generators: </p><div class="itemizedlist"><ul><li><p> <code class="classname">org.hibernate.id.enhanced.SequenceStyleGenerator</code> </p></li><li><p> <code class="classname">org.hibernate.id.enhanced.TableGenerator</code> </p></li></ul></div><p> </p></div><p> The idea behind these generators is to port the actual semantics of the identifer value generation to the different databases. For example, the <code class="classname">org.hibernate.id.enhanced.SequenceStyleGenerator</code> mimics the behavior of a sequence on databases which do not support sequences by using a table. </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="portability-functions"/>25.5. Database functions</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Aviso</h2><p>This is an area in Hibernate in need of improvement. In terms of portability concerns, this function handling currently works pretty well from HQL; however, it is quite lacking in all other aspects. </p></div><p>SQL functions can be referenced in many ways by users. However, not all databases support the same set of functions. Hibernate, provides a means of mapping a <span class="emphasis"><em>logical</em></span> function name to a a delegate which knows how to render that particular function, perhaps even using a totally different physical function call. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Importante</h2><p>Technically this function registration is handled through the <code class="classname">org.hibernate.dialect.function.SQLFunctionRegistry</code> class which is intended to allow users to provide custom function definitions without having to provide a custom dialect. This specific behavior is not fully completed as of yet. </p><p>It is sort of implemented such that users can programatically register functions with the <code class="classname">org.hibernate.cfg.Configuration</code> and those functions will be recognized for HQL. </p></div><p>
        </p></div><div class="sect1" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="portability-types"/>25.6. Type mappings</h2></div></div></div><p>This section scheduled for completion at a later date... </p></div></div><div class="bibliography"><div class="titlepage"><div><div><h2 class="title"><a id="d0e16988"/>References</h2></div></div></div><div class="biblioentry"><a id="biblio-PoEAA"/><p>[<abbr class="abbrev">PoEAA</abbr>] <span class="title"><i>Patterns of Enterprise Application Architecture</i>. </span><span class="isbn">0-321-12742-0. </span><span class="authorgroup">por <span class="firstname">Martin</span> <span class="surname">Fowler</span>. </span><span class="copyright">Copyright © 2003 Pearson Education, Inc.. </span><span class="publisher"><span class="publishername">Addison-Wesley Publishing Company. </span></span></p></div><div class="biblioentry"><a id="biblio-JPwH"/><p>[<abbr class="abbrev">JPwH</abbr>] <span class="title"><i>Java Persistence with Hibernate</i>. </span><span class="subtitle">Second Edition of Hibernate in Action. </span><span class="isbn">1-932394-88-5. </span><span class="bibliomisc">
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.manning.com/bauer2">http://www.manning.com/bauer2</a>
        . </span><span class="authorgroup">por <span class="firstname">Christian</span> <span class="surname">Bauer</span> y <span class="firstname">Gavin</span> <span class="surname">King</span>. </span><span class="copyright">Copyright © 2007 Manning Publications Co.. </span><span class="publisher"><span class="publishername">Manning Publications Co.. </span></span></p></div></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2004 Red Hat Middleware, LLC.</p></a></body></html>