<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">10장. 객체들로 작업하기</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="HIBERNATE - 개성있는 자바를 위한 관계 영속"/><link rel="up" href="index.html" title="HIBERNATE - 개성있는 자바를 위한 관계 영속"/><link rel="prev" href="inheritance.html" title="9장. Inheritance mapping"/><link rel="next" href="transactions.html" title="11장. Transactions and Concurrency"/><link rel="copyright" href="ln-Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="inheritance.html"><strong>이전</strong></a></li><li class="next"><a accesskey="n" href="transactions.html"><strong>다음</strong></a></li></ul><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate"/>10장. 객체들로 작업하기</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="objectstate.html#objectstate-overview">10.1. Hibernate 객체 상태들</a></span></dt><dt><span class="sect1"><a href="objectstate.html#objectstate-makingpersistent">10.2. 객체들을 영속화 시키기</a></span></dt><dt><span class="sect1"><a href="objectstate.html#objectstate-loading">10.3. 객체를 로드시키기</a></span></dt><dt><span class="sect1"><a href="objectstate.html#objectstate-querying">10.4. 질의하기</a></span></dt><dd><dl><dt><span class="sect2"><a href="objectstate.html#objectstate-querying-executing">10.4.1. 질의들을 실행하기</a></span></dt><dt><span class="sect2"><a href="objectstate.html#objectstate-filtering">10.4.2. 콜렉션들을 필터링 하기</a></span></dt><dt><span class="sect2"><a href="objectstate.html#objecstate-querying-criteria">10.4.3. Criteria 질의들</a></span></dt><dt><span class="sect2"><a href="objectstate.html#objectstate-querying-nativesql">10.4.4. native SQL에서 질의들</a></span></dt></dl></dd><dt><span class="sect1"><a href="objectstate.html#objectstate-modifying">10.5. 영속 객체들을 변경하기</a></span></dt><dt><span class="sect1"><a href="objectstate.html#objectstate-detached">10.6. detached 객체들을 변경시키기</a></span></dt><dt><span class="sect1"><a href="objectstate.html#objectstate-saveorupdate">10.7. 자동적인 상태 검출</a></span></dt><dt><span class="sect1"><a href="objectstate.html#objectstate-deleting">10.8. 영속 객체들을 삭제하기</a></span></dt><dt><span class="sect1"><a href="objectstate.html#objectstate-replicating">10.9. 두 개의 다른 데이터저장소들 사이에 객체들을 복제하기</a></span></dt><dt><span class="sect1"><a href="objectstate.html#objectstate-flushing">10.10. Session을 flush 시키기</a></span></dt><dt><span class="sect1"><a href="objectstate.html#objectstate-transitive">10.11. Transitive persistence(전이 영속)</a></span></dt><dt><span class="sect1"><a href="objectstate.html#objectstate-metadata">10.12. 메타데이터 사용하기</a></span></dt></dl></div><p>Hibernate is a full object/relational mapping solution that not only shields the developer from the details of the underlying database management system, but also offers <span class="emphasis"><em>state management</em></span> of objects. This is, contrary to the management of SQL <code class="literal">statements</code> in common JDBC/SQL persistence layers, a natural object-oriented view of persistence in Java applications. </p><p>달리 말해, Hibernate 어플리케이션 개발자들은 그들의 객체들의 <span class="emphasis"><em>상태</em></span>에 대해 항상 생각해야 하고, SQL 문장들의 실행에 대해서는 필수적이지 않다. 이 부분은 Hibernate에 의해 처리되고 시스템의 퍼포먼스를 튜닝할 때 어플리케이션 개발자와 유일하게 관련된다. </p><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-overview"/>10.1. Hibernate 객체 상태들</h2></div></div></div><p>Hibernate 다음 객체 상태들을 정의하고 지원한다: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Transient</em></span> - an object is transient if it has just been instantiated using the <code class="literal">new</code> operator, and it is not associated with a Hibernate <code class="literal">Session</code>. It has no persistent representation in the database and no identifier value has been assigned. Transient instances will be destroyed by the garbage collector if the application does not hold a reference anymore. Use the Hibernate <code class="literal">Session</code> to make an object persistent (and let Hibernate take care of the SQL statements that need to be executed for this transition). </p></li><li><p><span class="emphasis"><em>Persistent</em></span> - a persistent instance has a representation in the database and an identifier value. It might just have been saved or loaded, however, it is by definition in the scope of a <code class="literal">Session</code>. Hibernate will detect any changes made to an object in persistent state and synchronize the state with the database when the unit of work completes. Developers do not execute manual <code class="literal">UPDATE</code> statements, or <code class="literal">DELETE</code> statements when an object should be made transient. </p></li><li><p><span class="emphasis"><em>Detached</em></span> - a detached instance is an object that has been persistent, but its <code class="literal">Session</code> has been closed. The reference to the object is still valid, of course, and the detached instance might even be modified in this state. A detached instance can be reattached to a new <code class="literal">Session</code> at a later point in time, making it (and all the modifications) persistent again. This feature enables a programming model for long running units of work that require user think-time. We call them <span class="emphasis"><em>application transactions</em></span>, i.e., a unit of work from the point of view of the user. </p></li></ul></div><p>We will now discuss the states and state transitions (and the Hibernate methods that trigger a transition) in more detail. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-makingpersistent"/>10.2. 객체들을 영속화 시키기</h2></div></div></div><p>하나의 영속 클래스의 새로이 초기화 된 인스턴스들은 Hibernate에 의해 <span class="emphasis"><em>transient</em></span>로 간주된다. 우리는 그것을 세션과 연관지어서 transient 인스턴스를 <span class="emphasis"><em>영속화</em></span> 시킬 수 있다: </p><pre class="programlisting">DomesticCat fritz = new DomesticCat();
fritz.setColor(Color.GINGER);
fritz.setSex('M');
fritz.setName("Fritz");
Long generatedId = (Long) sess.save(fritz);</pre><p>If <code class="literal">Cat</code> has a generated identifier, the identifier is generated and assigned to the <code class="literal">cat</code> when <code class="literal">save()</code> is called. If <code class="literal">Cat</code> has an <code class="literal">assigned</code> identifier, or a composite key, the identifier should be assigned to the <code class="literal">cat</code> instance before calling <code class="literal">save()</code>. You can also use <code class="literal">persist()</code> instead of <code class="literal">save()</code>, with the semantics defined in the EJB3 early draft. </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">persist()</code> makes a transient instance persistent. However, it does not guarantee that the identifier value will be assigned to the persistent instance immediately, the assignment might happen at flush time. <code class="literal">persist()</code> also guarantees that it will not execute an <code class="literal">INSERT</code> statement if it is called outside of transaction boundaries. This is useful in long-running conversations with an extended Session/persistence context. </p></li><li><p><code class="literal">save()</code> does guarantee to return an identifier. If an INSERT has to be executed to get the identifier ( e.g. "identity" generator, not "sequence"), this INSERT happens immediately, no matter if you are inside or outside of a transaction. This is problematic in a long-running conversation with an extended Session/persistence context. </p></li></ul></div><p>Alternatively, you can assign the identifier using an overloaded version of <code class="literal">save()</code>. </p><pre class="programlisting">DomesticCat pk = new DomesticCat();
pk.setColor(Color.TABBY);
pk.setSex('F');
pk.setName("PK");
pk.setKittens( new HashSet() );
pk.addKitten(fritz);
sess.save( pk, new Long(1234) );</pre><p>If the object you make persistent has associated objects (e.g. the <code class="literal">kittens</code> collection in the previous example), these objects can be made persistent in any order you like unless you have a <code class="literal">NOT NULL</code> constraint upon a foreign key column. There is never a risk of violating foreign key constraints. However, you might violate a <code class="literal">NOT NULL</code> constraint if you <code class="literal">save()</code> the objects in the wrong order. </p><p>Usually you do not bother with this detail, as you will normally use Hibernate's <span class="emphasis"><em>transitive persistence</em></span> feature to save the associated objects automatically. Then, even <code class="literal">NOT NULL</code> constraint violations do not occur - Hibernate will take care of everything. Transitive persistence is discussed later in this chapter. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-loading"/>10.3. 객체를 로드시키기</h2></div></div></div><p>The <code class="literal">load()</code> methods of <code class="literal">Session</code> provide a way of retrieving a persistent instance if you know its identifier. <code class="literal">load()</code> takes a class object and loads the state into a newly instantiated instance of that class in a persistent state. </p><pre class="programlisting">Cat fritz = (Cat) sess.load(Cat.class, generatedId);</pre><pre class="programlisting">// you need to wrap primitive identifiers
long id = 1234;
DomesticCat pk = (DomesticCat) sess.load( DomesticCat.class, new Long(id) );</pre><p>다른 방법으로 당신은 주어진 인스턴스 속으로 상태를 로드시킬 수 있다: </p><pre class="programlisting">Cat cat = new DomesticCat();
// load pk's state into cat
sess.load( cat, new Long(pkId) );
Set kittens = cat.getKittens();</pre><p>Be aware that <code class="literal">load()</code> will throw an unrecoverable exception if there is no matching database row. If the class is mapped with a proxy, <code class="literal">load()</code> just returns an uninitialized proxy and does not actually hit the database until you invoke a method of the proxy. This is useful if you wish to create an association to an object without actually loading it from the database. It also allows multiple instances to be loaded as a batch if <code class="literal">batch-size</code> is defined for the class mapping. </p><p>If you are not certain that a matching row exists, you should use the <code class="literal">get()</code> method which hits the database immediately and returns null if there is no matching row. </p><pre class="programlisting">Cat cat = (Cat) sess.get(Cat.class, id);
if (cat==null) {
    cat = new Cat();
    sess.save(cat, id);
}
return cat;</pre><p>You can even load an object using an SQL <code class="literal">SELECT ... FOR UPDATE</code>, using a <code class="literal">LockMode</code>. See the API documentation for more information. </p><pre class="programlisting">Cat cat = (Cat) sess.get(Cat.class, id, LockMode.UPGRADE);</pre><p>Any associated instances or contained collections will <span class="emphasis"><em>not</em></span> be selected <code class="literal">FOR UPDATE</code>, unless you decide to specify <code class="literal">lock</code> or <code class="literal">all</code> as a cascade style for the association. </p><p><code class="literal">refresh()</code> 메소드를 사용하여, 아무때나 하나의 객체와 모든 그것의 콜렉션들을 다시 로드시키는 것이 가능하다. 데이터베이스 트리거들이 그 객체의 프로퍼티들 중 어떤 것을 초기화 시키는데 사용될 때 이것이 유용하다. </p><pre class="programlisting">sess.save(cat);
sess.flush(); //force the SQL INSERT
sess.refresh(cat); //re-read the state (after the trigger executes)</pre><p>How much does Hibernate load from the database and how many SQL <code class="literal">SELECT</code>s will it use? This depends on the <span class="emphasis"><em>fetching strategy</em></span>. This is explained in <a href="performance.html#performance-fetching" title="19.1. 페칭 방도들">19.1절. “페칭 방도들”</a>. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-querying"/>10.4. 질의하기</h2></div></div></div><p>If you do not know the identifiers of the objects you are looking for, you need a query. Hibernate supports an easy-to-use but powerful object oriented query language (HQL). For programmatic query creation, Hibernate supports a sophisticated Criteria and Example query feature (QBC and QBE). You can also express your query in the native SQL of your database, with optional support from Hibernate for result set conversion into objects. </p><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="objectstate-querying-executing"/>10.4.1. 질의들을 실행하기</h3></div></div></div><p>HQL 질의와 native SQL 질의는 <code class="literal">org.hibernate.Query</code>의 인스턴스로 표현된다. 이 인터페이스는 파라미터 바인딩, 결과셋 핸들링을 위한, 그리고 실제 질의의 실행을 위한 메소드들을 제공한다. 당신은 항상 현재 <code class="literal">Session</code>을 사용하여 하나의 <code class="literal">Query</code>를 얻는다: </p><pre class="programlisting">List cats = session.createQuery(
    "from Cat as cat where cat.birthdate &lt; ?")
    .setDate(0, date)
    .list();

List mothers = session.createQuery(
    "select mother from Cat as cat join cat.mother as mother where cat.name = ?")
    .setString(0, name)
    .list();

List kittens = session.createQuery(
    "from Cat as cat where cat.mother = ?")
    .setEntity(0, pk)
    .list();

Cat mother = (Cat) session.createQuery(
    "select cat.mother from Cat as cat where cat = ?")
    .setEntity(0, izi)
    .uniqueResult();]]

Query mothersWithKittens = (Cat) session.createQuery(
    "select mother from Cat as mother left join fetch mother.kittens");
Set uniqueMothers = new HashSet(mothersWithKittens.list());</pre><p>A query is usually executed by invoking <code class="literal">list()</code>. The result of the query will be loaded completely into a collection in memory. Entity instances retrieved by a query are in a persistent state. The <code class="literal">uniqueResult()</code> method offers a shortcut if you know your query will only return a single object. Queries that make use of eager fetching of collections usually return duplicates of the root objects, but with their collections initialized. You can filter these duplicates through a <code class="literal">Set</code>. </p><div class="sect3" lang="ko-KR"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-iterate"/>10.4.1.1. 결과들을 반복하기</h4></div></div></div><p>Occasionally, you might be able to achieve better performance by executing the query using the <code class="literal">iterate()</code> method. This will usually be the case if you expect that the actual entity instances returned by the query will already be in the session or second-level cache. If they are not already cached, <code class="literal">iterate()</code> will be slower than <code class="literal">list()</code> and might require many database hits for a simple query, usually <span class="emphasis"><em>1</em></span> for the initial select which only returns identifiers, and <span class="emphasis"><em>n</em></span> additional selects to initialize the actual instances. </p><pre class="programlisting">// fetch ids
Iterator iter = sess.createQuery("from eg.Qux q order by q.likeliness").iterate();
while ( iter.hasNext() ) {
    Qux qux = (Qux) iter.next();  // fetch the object
    // something we couldnt express in the query
    if ( qux.calculateComplicatedAlgorithm() ) {
        // delete the current instance
        iter.remove();
        // dont need to process the rest
        break;
    }
}</pre></div><div class="sect3" lang="ko-KR"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-tuples"/>10.4.1.2. 튜플들을 반환하는 질의들</h4></div></div></div><p>Hibernate queries sometimes return tuples of objects. Each tuple is returned as an array: </p><pre class="programlisting">Iterator kittensAndMothers = sess.createQuery(
            "select kitten, mother from Cat kitten join kitten.mother mother")
            .list()
            .iterator();

while ( kittensAndMothers.hasNext() ) {
    Object[] tuple = (Object[]) kittensAndMothers.next();
    Cat kitten = (Cat) tuple[0];
    Cat mother = (Cat) tuple[1];
    ....
}</pre></div><div class="sect3" lang="ko-KR"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-scalar"/>10.4.1.3. 스칼라 결과들</h4></div></div></div><p>Queries can specify a property of a class in the <code class="literal">select</code> clause. They can even call SQL aggregate functions. Properties or aggregates are considered "scalar" results and not entities in persistent state. </p><pre class="programlisting">Iterator results = sess.createQuery(
        "select cat.color, min(cat.birthdate), count(cat) from Cat cat " +
        "group by cat.color")
        .list()
        .iterator();

while ( results.hasNext() ) {
    Object[] row = (Object[]) results.next();
    Color type = (Color) row[0];
    Date oldest = (Date) row[1];
    Integer count = (Integer) row[2];
    .....
}</pre></div><div class="sect3" lang="ko-KR"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-parameters"/>10.4.1.4. 바인드 프라미터들</h4></div></div></div><p>Methods on <code class="literal">Query</code> are provided for binding values to named parameters or JDBC-style <code class="literal">?</code> parameters. <span class="emphasis"><em>Contrary to JDBC, Hibernate numbers parameters from zero.</em></span> Named parameters are identifiers of the form <code class="literal">:name</code> in the query string. The advantages of named parameters are as follows: </p><div class="itemizedlist"><ul compact="compact"><li><p>명명된 파라미터들은 그것들이 질의 문자열 내에 발생하는 순서에 관계없다 </p></li><li><p>they can occur multiple times in the same query </p></li><li><p>그것은 자기-설명적이다 </p></li></ul></div><pre class="programlisting">//named parameter (preferred)
Query q = sess.createQuery("from DomesticCat cat where cat.name = :name");
q.setString("name", "Fritz");
Iterator cats = q.iterate();</pre><pre class="programlisting">//positional parameter
Query q = sess.createQuery("from DomesticCat cat where cat.name = ?");
q.setString(0, "Izi");
Iterator cats = q.iterate();</pre><pre class="programlisting">//named parameter list
List names = new ArrayList();
names.add("Izi");
names.add("Fritz");
Query q = sess.createQuery("from DomesticCat cat where cat.name in (:namesList)");
q.setParameterList("namesList", names);
List cats = q.list();</pre></div><div class="sect3" lang="ko-KR"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-pagination"/>10.4.1.5. 쪽매김</h4></div></div></div><p>If you need to specify bounds upon your result set, that is, the maximum number of rows you want to retrieve and/or the first row you want to retrieve, you can use methods of the <code class="literal">Query</code> interface: </p><pre class="programlisting">Query q = sess.createQuery("from DomesticCat cat");
q.setFirstResult(20);
q.setMaxResults(10);
List cats = q.list();</pre><p>Hibernate는 이 limit 질의를 당신의 DBMS의 native SQL로 번역하는 방법을 알고 있다. </p></div><div class="sect3" lang="ko-KR"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-scrolling"/>10.4.1.6. 스크롤 가능한 iteration</h4></div></div></div><p>If your JDBC driver supports scrollable <code class="literal">ResultSet</code>s, the <code class="literal">Query</code> interface can be used to obtain a <code class="literal">ScrollableResults</code> object that allows flexible navigation of the query results. </p><pre class="programlisting">Query q = sess.createQuery("select cat.name, cat from DomesticCat cat " +
                            "order by cat.name");
ScrollableResults cats = q.scroll();
if ( cats.first() ) {

    // find the first name on each page of an alphabetical list of cats by name
    firstNamesOfPages = new ArrayList();
    do {
        String name = cats.getString(0);
        firstNamesOfPages.add(name);
    }
    while ( cats.scroll(PAGE_SIZE) );

    // Now get the first page of cats
    pageOfCats = new ArrayList();
    cats.beforeFirst();
    int i=0;
    while( ( PAGE_SIZE &gt; i++ ) &amp;&amp; cats.next() ) pageOfCats.add( cats.get(1) );

}
cats.close()</pre><p>Note that an open database connection and cursor is required for this functionality. Use <code class="literal">setMaxResult()</code>/<code class="literal">setFirstResult()</code> if you need offline pagination functionality. </p></div><div class="sect3" lang="ko-KR"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-named"/>10.4.1.7. 명명된 질의들을 구체화 시키기</h4></div></div></div><p>You can also define named queries in the mapping document. Remember to use a <code class="literal">CDATA</code> section if your query contains characters that could be interpreted as markup. </p><pre class="programlisting">&lt;query name="ByNameAndMaximumWeight"&gt;&lt;![CDATA[
    from eg.DomesticCat as cat
        where cat.name = ?
        and cat.weight &gt; ?
] ]&gt;&lt;/query&gt;</pre><p>파라미터 바인딩과 실행은 프로그램 상으로 행해진다: </p><pre class="programlisting">Query q = sess.getNamedQuery("ByNameAndMaximumWeight");
q.setString(0, name);
q.setInt(1, minWeight);
List cats = q.list();</pre><p>The actual program code is independent of the query language that is used. You can also define native SQL queries in metadata, or migrate existing queries to Hibernate by placing them in mapping files. </p><p>Also note that a query declaration inside a <code class="literal">&lt;hibernate-mapping&gt;</code> element requires a global unique name for the query, while a query declaration inside a <code class="literal">&lt;class&gt;</code> element is made unique automatically by prepending the fully qualified name of the class. For example <code class="literal">eg.Cat.ByNameAndMaximumWeight</code>. </p></div></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="objectstate-filtering"/>10.4.2. 콜렉션들을 필터링 하기</h3></div></div></div><p>A collection <span class="emphasis"><em>filter</em></span> is a special type of query that can be applied to a persistent collection or array. The query string can refer to <code class="literal">this</code>, meaning the current collection element. </p><pre class="programlisting">Collection blackKittens = session.createFilter(
    pk.getKittens(), 
    "where this.color = ?")
    .setParameter( Color.BLACK, Hibernate.custom(ColorUserType.class) )
    .list()
);</pre><p>The returned collection is considered a bag that is a copy of the given collection. The original collection is not modified. This is contrary to the implication of the name "filter", but consistent with expected behavior. </p><p>Observe that filters do not require a <code class="literal">from</code> clause, although they can have one if required. Filters are not limited to returning the collection elements themselves. </p><pre class="programlisting">Collection blackKittenMates = session.createFilter(
    pk.getKittens(), 
    "select this.mate where this.color = eg.Color.BLACK.intValue")
    .list();</pre><p>Even an empty filter query is useful, e.g. to load a subset of elements in a large collection: </p><pre class="programlisting">Collection tenKittens = session.createFilter(
    mother.getKittens(), "")
    .setFirstResult(0).setMaxResults(10)
    .list();</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="objecstate-querying-criteria"/>10.4.3. Criteria 질의들</h3></div></div></div><p>HQL is extremely powerful, but some developers prefer to build queries dynamically using an object-oriented API, rather than building query strings. Hibernate provides an intuitive <code class="literal">Criteria</code> query API for these cases: </p><pre class="programlisting">Criteria crit = session.createCriteria(Cat.class);
crit.add( Restrictions.eq( "color", eg.Color.BLACK ) );
crit.setMaxResults(10);
List cats = crit.list();</pre><p><code class="literal">Criteria</code>와 연관된 <code class="literal">Example</code> API 는 <a href="querycriteria.html" title="15장. Criteria 질의들">15장. <i xmlns:xlink="http://www.w3.org/1999/xlink">Criteria 질의들</i></a>에서 상세하게 논의된다. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="objectstate-querying-nativesql"/>10.4.4. native SQL에서 질의들</h3></div></div></div><p>You can express a query in SQL, using <code class="literal">createSQLQuery()</code> and let Hibernate manage the mapping from result sets to objects. You can at any time call <code class="literal">session.connection()</code> and use the JDBC <code class="literal">Connection</code> directly. If you choose to use the Hibernate API, you must enclose SQL aliases in braces: </p><pre class="programlisting">List cats = session.createSQLQuery("SELECT {cat.*} FROM CAT {cat} WHERE ROWNUM&lt;10")
    .addEntity("cat", Cat.class)
.list();</pre><pre class="programlisting">List cats = session.createSQLQuery(
    "SELECT {cat}.ID AS {cat.id}, {cat}.SEX AS {cat.sex}, " +
           "{cat}.MATE AS {cat.mate}, {cat}.SUBCLASS AS {cat.class}, ... " +
    "FROM CAT {cat} WHERE ROWNUM&lt;10")
    .addEntity("cat", Cat.class)
.list()</pre><p>SQL queries can contain named and positional parameters, just like Hibernate queries. More information about native SQL queries in Hibernate can be found in <a href="querysql.html" title="16장. Native SQL">16장. <i xmlns:xlink="http://www.w3.org/1999/xlink">Native SQL</i></a>. </p></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-modifying"/>10.5. 영속 객체들을 변경하기</h2></div></div></div><p><span class="emphasis"><em>Transactional persistent instances</em></span> (i.e. objects loaded, saved, created or queried by the <code class="literal">Session</code>) can be manipulated by the application, and any changes to persistent state will be persisted when the <code class="literal">Session</code> is <span class="emphasis"><em>flushed</em></span>. This is discussed later in this chapter. There is no need to call a particular method (like <code class="literal">update()</code>, which has a different purpose) to make your modifications persistent. The most straightforward way to update the state of an object is to <code class="literal">load()</code> it and then manipulate it directly while the <code class="literal">Session</code> is open: </p><pre class="programlisting">DomesticCat cat = (DomesticCat) sess.load( Cat.class, new Long(69) );
cat.setName("PK");
sess.flush();  // changes to cat are automatically detected and persisted</pre><p>Sometimes this programming model is inefficient, as it requires in the same session both an SQL <code class="literal">SELECT</code> to load an object and an SQL <code class="literal">UPDATE</code> to persist its updated state. Hibernate offers an alternate approach by using detached instances. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>중요</h2><p>Hibernate does not offer its own API for direct execution of <code class="literal">UPDATE</code> or <code class="literal">DELETE</code> statements. Hibernate is a <span class="emphasis"><em>state management</em></span> service, you do not have to think in <span class="emphasis"><em>statements</em></span> to use it. JDBC is a perfect API for executing SQL statements, you can get a JDBC <code class="literal">Connection</code> at any time by calling <code class="literal">session.connection()</code>. Furthermore, the notion of mass operations conflicts with object/relational mapping for online transaction processing-oriented applications. Future versions of Hibernate can, however, provide special mass operation functions. See <a href="batch.html" title="13장. Batch ì²ë¦¬">13장. <i xmlns:xlink="http://www.w3.org/1999/xlink">Batch ì²ë¦¬</i></a> for some possible batch operation tricks. </p></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-detached"/>10.6. detached 객체들을 변경시키기</h2></div></div></div><p>많은 어플리케이션들은 하나의 트랜잭션 내에서 하나의 객체를 검색하고, 처리를 위한 UI 계층으로 그것을 전송하고, 그런 다음 새로운 트랜잭션 내에서 변경들을 저장할 필요가 있다. 고도의-동시성 환경에서 이런 종류의 접근법을 사용하는 어플리케이션들은 대개 작업의 "긴" 단위를 확실히 격리시키기 위해 버전화 된 데이터를 사용한다. </p><p>Hibernate는 <code class="literal">Session.update()</code> 메소드 또는 <code class="literal">Session.merge()</code> 메소드를 사용하여 detached 인스턴스들의 재첨부를 제공함으로써 이 모형을 지원한다: </p><pre class="programlisting">// in the first session
Cat cat = (Cat) firstSession.load(Cat.class, catId);
Cat potentialMate = new Cat();
firstSession.save(potentialMate);

// in a higher layer of the application
cat.setMate(potentialMate);

// later, in a new session
secondSession.update(cat);  // update cat
secondSession.update(mate); // update mate</pre><p>만일 <code class="literal">catId</code> 식별자를 가진 <code class="literal">Cat</code>이 <code class="literal">secondSession</code>에 의해 이미 로드되었을 경우에 어플리케이션이 그것을 다시 재첨부하려고 시도할 때, 예외상황이 던져졌을 것이다. </p><p>Use <code class="literal">update()</code> if you are certain that the session does not contain an already persistent instance with the same identifier. Use <code class="literal">merge()</code> if you want to merge your modifications at any time without consideration of the state of the session. In other words, <code class="literal">update()</code> is usually the first method you would call in a fresh session, ensuring that the reattachment of your detached instances is the first operation that is executed. </p><p>The application should individually <code class="literal">update()</code> detached instances that are reachable from the given detached instance <span class="emphasis"><em>only</em></span> if it wants their state to be updated. This can be automated using <span class="emphasis"><em>transitive persistence</em></span>. See <a href="objectstate.html#objectstate-transitive" title="10.11. Transitive persistence(전이 영속)">10.11절. “Transitive persistence(전이 영속)”</a> for more information. </p><p>The <code class="literal">lock()</code> method also allows an application to reassociate an object with a new session. However, the detached instance has to be unmodified. </p><pre class="programlisting">//just reassociate:
sess.lock(fritz, LockMode.NONE);
//do a version check, then reassociate:
sess.lock(izi, LockMode.READ);
//do a version check, using SELECT ... FOR UPDATE, then reassociate:
sess.lock(pk, LockMode.UPGRADE);</pre><p>Note that <code class="literal">lock()</code> can be used with various <code class="literal">LockMode</code>s. See the API documentation and the chapter on transaction handling for more information. Reattachment is not the only usecase for <code class="literal">lock()</code>. </p><p>긴 작업 단위에 대한 다른 모형들은 <a href="transactions.html#transactions-optimistic" title="11.3. Optimistic 동시성 제어">11.3절. “Optimistic 동시성 제어”</a>에서 논의된다. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-saveorupdate"/>10.7. 자동적인 상태 검출</h2></div></div></div><p>Hibernate 사용자들은 새로운 식별자를 생성시켜서 transient 인스턴스를 저장하거나 그것의 현재 식별자와 연관된 detached 인스턴스들을 업데이트/재첨부 시키는 일반적인 용도의 메소드를 요청했다. <code class="literal">saveOrUpdate()</code> 메소드는 이 기능을 구현한다. </p><pre class="programlisting">// in the first session
Cat cat = (Cat) firstSession.load(Cat.class, catID);

// in a higher tier of the application
Cat mate = new Cat();
cat.setMate(mate);

// later, in a new session
secondSession.saveOrUpdate(cat);   // update existing state (cat has a non-null id)
secondSession.saveOrUpdate(mate);  // save the new instance (mate has a null id)</pre><p><code class="literal">saveOrUpdate()</code>의 사용 예제와 의미는 초심자들에게는 혼동스러워 보인다. 먼저, 하나의 세션에서 온 인스턴스를 또 다른 새로운 세션 내에서 사용하려고 시도하지 않는 한, 당신은 <code class="literal">update()</code>, <code class="literal">saveOrUpdate()</code>, 또는 <code class="literal">merge()</code>를 사용할 필요는 없을 것이다. 몇몇 전체 어플리케이션들은 이들 메소드들 중 어느 것도 결코 사용하지 않을 것이다. </p><p>대개 <code class="literal">update()</code> 또는 <code class="literal">saveOrUpdate()</code>는 다음 시나리오에서 사용된다: </p><div class="itemizedlist"><ul compact="compact"><li><p>어플리케이션이 첫 번째 세션 내에 객체를 로드시킨다 </p></li><li><p>객체가 UI 티어로 전달된다 </p></li><li><p>몇몇 변경들이 그 객체에 행해진다 </p></li><li><p>객체가 비지니스 로직 티어로 전달된다 </p></li><li><p>어플리케이션은 두 번째 세션에서 <code class="literal">update()</code>를 호출함으로써 이들 변경들을 영속화 시킨다 </p></li></ul></div><p><code class="literal">saveOrUpdate()</code>는 다음을 행한다: </p><div class="itemizedlist"><ul compact="compact"><li><p>만일 객체가 이 세션 내에서 이미 영속화 되어 있을 경우, 아무것도 행하지 않는다 </p></li><li><p>만일 그 세션과 연관된 또 다른 객체가 동일한 식별자를 가질 경우, 예외상황을 던진다 </p></li><li><p>만일 그 객체가 식별자 프로퍼티를 갖지 않을 경우, 그것을 <code class="literal">save()</code> 시킨다 </p></li><li><p>만일 객체의 식별자가 새로이 초기화 된 객체에 할당된 값을 가질 경우, 그것을 <code class="literal">save()</code> 시킨다 </p></li><li><p>if the object is versioned by a <code class="literal">&lt;version&gt;</code> or <code class="literal">&lt;timestamp&gt;</code>, and the version property value is the same value assigned to a newly instantiated object, <code class="literal">save()</code> it </p></li><li><p>그 밖의 경우 그 객체를 <code class="literal">update()</code> 시킨다 </p></li></ul></div><p>그리고 <code class="literal">merge()</code>는 매우 다르다: </p><div class="itemizedlist"><ul compact="compact"><li><p>만일 세션과 현재 연관된 동일한 식별자를 가진 영속 인스턴스가 존재할 경우, 주어진 객체의 상태를 영속 인스턴스 상으로 복사한다 </p></li><li><p>만일 세션과 현재 연관된 영속 인스턴스가 존재하지 않을 경우, 데이터베이스로부터 그것을 로드시키려고 시도하거나 새로운 영속 인스턴스를 생성시키려고 시도한다 </p></li><li><p>영속 인스턴스가 반환된다 </p></li><li><p>주어진 인스턴스는 세션과 연관되지 않고, 그것은 detached 상태에 머무른다 </p></li></ul></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-deleting"/>10.8. 영속 객체들을 삭제하기</h2></div></div></div><p><code class="literal">Session.delete()</code> will remove an object's state from the database. Your application, however, can still hold a reference to a deleted object. It is best to think of <code class="literal">delete()</code> as making a persistent instance, transient. </p><pre class="programlisting">sess.delete(cat);</pre><p>You can delete objects in any order, without risk of foreign key constraint violations. It is still possible to violate a <code class="literal">NOT NULL</code> constraint on a foreign key column by deleting objects in the wrong order, e.g. if you delete the parent, but forget to delete the children. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-replicating"/>10.9. 두 개의 다른 데이터저장소들 사이에 객체들을 복제하기</h2></div></div></div><p>It is sometimes useful to be able to take a graph of persistent instances and make them persistent in a different datastore, without regenerating identifier values. </p><pre class="programlisting">//retrieve a cat from one database
Session session1 = factory1.openSession();
Transaction tx1 = session1.beginTransaction();
Cat cat = session1.get(Cat.class, catId);
tx1.commit();
session1.close();

//reconcile with a second database
Session session2 = factory2.openSession();
Transaction tx2 = session2.beginTransaction();
session2.replicate(cat, ReplicationMode.LATEST_VERSION);
tx2.commit();
session2.close();</pre><p>The <code class="literal">ReplicationMode</code> determines how <code class="literal">replicate()</code> will deal with conflicts with existing rows in the database: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">ReplicationMode.IGNORE</code>: ignores the object when there is an existing database row with the same identifier </p></li><li><p><code class="literal">ReplicationMode.OVERWRITE</code>: overwrites any existing database row with the same identifier </p></li><li><p><code class="literal">ReplicationMode.EXCEPTION</code>: throws an exception if there is an existing database row with the same identifier </p></li><li><p><code class="literal">ReplicationMode.LATEST_VERSION</code>: overwrites the row if its version number is earlier than the version number of the object, or ignore the object otherwise </p></li></ul></div><p>이 특징의 쓰임새들은 다른 데이터베이스 인스턴스들 속으로 입력된 데이터 일치시키기, 제품 업그레이드 동안에 시스템 구성 정보 업데이트 하기, non-ACID 트랜잭션들 동안에 행해진 변경들을 롤백시키기 등을 포함한다. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-flushing"/>10.10. Session을 flush 시키기</h2></div></div></div><p>Sometimes the <code class="literal">Session</code> will execute the SQL statements needed to synchronize the JDBC connection's state with the state of objects held in memory. This process, called <span class="emphasis"><em>flush</em></span>, occurs by default at the following points: </p><div class="itemizedlist"><ul compact="compact"><li><p>몇몇 질의들이 실행되기 전에 </p></li><li><p><code class="literal">org.hibernate.Transaction.commit()</code> 시점에서 </p></li><li><p><code class="literal">Session.flush()</code> 시점에서 </p></li></ul></div><p>The SQL statements are issued in the following order: </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>all entity insertions in the same order the corresponding objects were saved using <code class="literal">Session.save()</code> </p></li><li><p>모든 엔티티 업데이트들 </p></li><li><p>모든 콜렉션 삭제들 </p></li><li><p>모든 콜렉션 요소 삭제들, 업데이트들 그리고 삽입들 </p></li><li><p>모든 콜렉션 삽입들 </p></li><li><p>all entity deletions in the same order the corresponding objects were deleted using <code class="literal">Session.delete()</code> </p></li></ol></div><p>An exception is that objects using <code class="literal">native</code> ID generation are inserted when they are saved. </p><p>Except when you explicitly <code class="literal">flush()</code>, there are absolutely no guarantees about <span class="emphasis"><em>when</em></span> the <code class="literal">Session</code> executes the JDBC calls, only the <span class="emphasis"><em>order</em></span> in which they are executed. However, Hibernate does guarantee that the <code class="literal">Query.list(..)</code> will never return stale or incorrect data. </p><p>It is possible to change the default behavior so that flush occurs less frequently. The <code class="literal">FlushMode</code> class defines three different modes: only flush at commit time when the Hibernate <code class="literal">Transaction</code> API is used, flush automatically using the explained routine, or never flush unless <code class="literal">flush()</code> is called explicitly. The last mode is useful for long running units of work, where a <code class="literal">Session</code> is kept open and disconnected for a long time (see <a href="transactions.html#transactions-optimistic-longsession" title="11.3.2. 확장된 세션과 자동적인 버전화">11.3.2절. “확장된 세션과 자동적인 버전화”</a>). </p><pre class="programlisting">sess = sf.openSession();
Transaction tx = sess.beginTransaction();
sess.setFlushMode(FlushMode.COMMIT); // allow queries to return stale state

Cat izi = (Cat) sess.load(Cat.class, id);
izi.setName(iznizi);

// might return stale data
sess.find("from Cat as cat left outer join cat.kittens kitten");

// change to izi is not flushed!
...
tx.commit(); // flush occurs
sess.close();</pre><p>flush 동안에, 하나의 예외상황이 발생할 수도 있다(예를 들면. 만일 DML 오퍼레이션이 컨스트레인트를 위반할 경우). 예외상황들을 처리하는 것은 Hibernatem의 트랜잭션 특징에 관한 어떤 이해를 수반하며, 우리는 <a href="transactions.html" title="11장. Transactions and Concurrency">11장. <i xmlns:xlink="http://www.w3.org/1999/xlink">Transactions and Concurrency</i></a>에서 그것을 논의한다. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-transitive"/>10.11. Transitive persistence(전이 영속)</h2></div></div></div><p>특히 당신이 연관된 객체들의 그래프를 다룰 경우에, 특히 개별 객체들을 저장하고, 삭제하거나, 재첨부시키는 것이 꽤 번거롭다. 공통된 경우는 하나의 부모/자식 관계이다. 다음 예제를 검토하자: </p><p>If the children in a parent/child relationship would be value typed (e.g. a collection of addresses or strings), their life cycle would depend on the parent and no further action would be required for convenient "cascading" of state changes. When the parent is saved, the value-typed child objects are saved and when the parent is deleted, the children will be deleted, etc. This works for operations such as the removal of a child from the collection. Since value-typed objects cannot have shared references, Hibernate will detect this and delete the child from the database. </p><p>Now consider the same scenario with parent and child objects being entities, not value-types (e.g. categories and items, or parent and child cats). Entities have their own life cycle and support shared references. Removing an entity from the collection does not mean it can be deleted), and there is by default no cascading of state from one entity to any other associated entities. Hibernate does not implement <span class="emphasis"><em>persistence by reachability</em></span> by default. </p><p>- <code class="literal">persist(), merge(), saveOrUpdate(), delete(), lock(), refresh(), evict(), replicate()</code>를 포함하는- Hibernate 세션에 대한 각각의 기본 오퍼레이션에 대해서 하나의 대응하는 케스케이딩 스타일이 존재한다. 케스케이드 스타일들 각각은 <code class="literal">create, merge, save-update, delete, lock, refresh, evict, replicate</code>로 명명된다. 만일 당신이 하나의 오퍼레이션이 하나의 연관에 따라 케스케이딩되는 것을 원할 경우, 당신은 매핑 문서 내에 그것을 지시해야 한다. 예를 들면: </p><pre class="programlisting">&lt;one-to-one name="person" cascade="persist"/&gt;</pre><p>케스케이딩 스타일들이 결합될 수도 있다: </p><pre class="programlisting">&lt;one-to-one name="person" cascade="persist,delete,lock"/&gt;</pre><p>You can even use <code class="literal">cascade="all"</code> to specify that <span class="emphasis"><em>all</em></span> operations should be cascaded along the association. The default <code class="literal">cascade="none"</code> specifies that no operations are to be cascaded. </p><p>특정한 케스케이드 스타일인, <code class="literal">delete-orphan</code>은 오직 one-to-many 연관들에만 적용되고, <code class="literal">delete()</code> 오퍼레이션이 그 연관으로부터 제거되는 임의의 자식 객체에 적용되어야 함을 나타낸다. </p><p>권장사항들 : </p><div class="itemizedlist"><ul compact="compact"><li><p>It does not usually make sense to enable cascade on a <code class="literal">&lt;many-to-one&gt;</code> or <code class="literal">&lt;many-to-many&gt;</code> association. Cascade is often useful for <code class="literal">&lt;one-to-one&gt;</code> and <code class="literal">&lt;one-to-many&gt;</code> associations. </p></li><li><p>만일 자식 객체의 수명이 그 부모 객체의 수명에 묶여져 있을 경우, <code class="literal">cascade="all,delete-orphan"</code>을 지정함으로써 그것을 <span class="emphasis"><em>생명 주기 객체</em></span>로 만들어라. </p></li><li><p>그 밖의 경우, 당신은 케스케이드를 전혀 필요로 하지 않을 수 있다. 그러나 만일 당신이 동일한 트랜잭션 내에서 부모와 자식에 대해 자주 함께 작업하게 될 것이라 생각되고, 당신 스스로 타이핑 하는 것을 절약하고자 원할 경우, <code class="literal">cascade="persist,merge,save-update"</code>를 사용하는 것을 고려하라. </p></li></ul></div><p><code class="literal">cascade="all"</code>을 가진 (단일 값 연관이든 하나의 콜렉션이든) 하나의 연관을 매핑시키는 것은 그 연관을 부모의 저장/업데이트/삭제가 자식 또는 자식들의 저장/업데이트/삭제로 귀결되는 <span class="emphasis"><em>부모/자식</em></span> 스타일의 관계로 마크한다. </p><p>Furthermore, a mere reference to a child from a persistent parent will result in save/update of the child. This metaphor is incomplete, however. A child which becomes unreferenced by its parent is <span class="emphasis"><em>not</em></span> automatically deleted, except in the case of a <code class="literal">&lt;one-to-many&gt;</code> association mapped with <code class="literal">cascade="delete-orphan"</code>. The precise semantics of cascading operations for a parent/child relationship are as follows: </p><div class="itemizedlist"><ul compact="compact"><li><p>만일 부모가 <code class="literal">persist()</code>에 전달될 경우, 모든 자식들이 <code class="literal">persist()</code>에 전달된다 </p></li><li><p>만일 부모가 <code class="literal">merge()</code>에 전달될 경우, 모든 자식들이 <code class="literal">merge()</code>에 전달된다 </p></li><li><p>만일 부모가 <code class="literal">save()</code>, <code class="literal">update()</code> 또는 <code class="literal">saveOrUpdate()</code>에 전달될 경우, 모든 자식들이 <code class="literal">saveOrUpdate()</code>에 전달된다 </p></li><li><p>만일 transient 또는 detached 자식이 영속 부모에 의해 참조될 경우, 그것은 <code class="literal">saveOrUpdate()</code>에 전달된다 </p></li><li><p>만일 부모가 삭제될 경우, 모든 자식들이 <code class="literal">delete()</code>에 전달된다 </p></li><li><p>만일 자식이 영속 부모에 의해 참조 해제 될 경우, <code class="literal">cascade="delete-orphan"</code>이 아닌 한, <span class="emphasis"><em>특별한 어떤 것도 발생하지 않는다</em></span> - 어플리케이션은 필요한 경우에 자식을 명시적으로 삭제해야 한다 -, <code class="literal">cascade="delete-orphan"</code>인 경우에 "orphaned(고아)"인 경우 자식이 삭제된다. </p></li></ul></div><p>Finally, note that cascading of operations can be applied to an object graph at <span class="emphasis"><em>call time</em></span> or at <span class="emphasis"><em>flush time</em></span>. All operations, if enabled, are cascaded to associated entities reachable when the operation is executed. However, <code class="literal">save-update</code> and <code class="literal">delete-orphan</code> are transitive for all associated entities reachable during flush of the <code class="literal">Session</code>. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-metadata"/>10.12. 메타데이터 사용하기</h2></div></div></div><p>Hibernate requires a rich meta-level model of all entity and value types. This model can be useful to the application itself. For example, the application might use Hibernate's metadata to implement a "smart" deep-copy algorithm that understands which objects should be copied (eg. mutable value types) and which objects that should not (e.g. immutable value types and, possibly, associated entities). </p><p>Hibernate exposes metadata via the <code class="literal">ClassMetadata</code> and <code class="literal">CollectionMetadata</code> interfaces and the <code class="literal">Type</code> hierarchy. Instances of the metadata interfaces can be obtained from the <code class="literal">SessionFactory</code>. </p><pre class="programlisting">Cat fritz = ......;
ClassMetadata catMeta = sessionfactory.getClassMetadata(Cat.class);

Object[] propertyValues = catMeta.getPropertyValues(fritz);
String[] propertyNames = catMeta.getPropertyNames();
Type[] propertyTypes = catMeta.getPropertyTypes();

// get a Map of all properties which are not collections or associations
Map namedValues = new HashMap();
for ( int i=0; i&lt;propertyNames.length; i++ ) {
    if ( !propertyTypes[i].isEntityType() &amp;&amp; !propertyTypes[i].isCollectionType() ) {
        namedValues.put( propertyNames[i], propertyValues[i] );
    }
}</pre></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">저작권 © 2004 Red Hat Middleware, LLC.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="inheritance.html"><strong>이전</strong>9장. Inheritance mapping</a></li><li class="up"><a accesskey="u" href="#"><strong>위로</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>처음으로</strong></a></li><li class="next"><a accesskey="n" href="transactions.html"><strong>다음</strong>11장. Transactions and Concurrency</a></li></ul></body></html>