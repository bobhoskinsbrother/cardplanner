<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">19장. 퍼포먼스 개선하기</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="HIBERNATE - 개성있는 자바를 위한 관계 영속"/><link rel="up" href="index.html" title="HIBERNATE - 개성있는 자바를 위한 관계 영속"/><link rel="prev" href="xml.html" title="18장. XML 매핑"/><link rel="next" href="toolsetguide.html" title="20장. 도구셋 안내"/><link rel="copyright" href="ln-Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="xml.html"><strong>이전</strong></a></li><li class="next"><a accesskey="n" href="toolsetguide.html"><strong>다음</strong></a></li></ul><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="performance"/>19장. 퍼포먼스 개선하기</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="performance.html#performance-fetching">19.1. 페칭 방도들</a></span></dt><dd><dl><dt><span class="sect2"><a href="performance.html#performance-fetching-lazy">19.1.1. lazy 연관들로 작업하기</a></span></dt><dt><span class="sect2"><a href="performance.html#performance-fetching-custom">19.1.2. 페치 방도들을 튜닝하기</a></span></dt><dt><span class="sect2"><a href="performance.html#performance-fetching-proxies">19.1.3. Single-ended 연관 프락시</a></span></dt><dt><span class="sect2"><a href="performance.html#performance-fetching-initialization">19.1.4. 콜렉션들과 프락시들을 초기화 시키기</a></span></dt><dt><span class="sect2"><a href="performance.html#performance-fetching-batch">19.1.5. batch 페칭 사용하기</a></span></dt><dt><span class="sect2"><a href="performance.html#performance-fetching-subselect">19.1.6. subselect 페칭 사용하기</a></span></dt><dt><span class="sect2"><a href="performance.html#performance-fetching-lazyproperties">19.1.7. lazy 프로퍼티 페칭 사용하기</a></span></dt></dl></dd><dt><span class="sect1"><a href="performance.html#performance-cache">19.2. 두번째 레벨 캐시</a></span></dt><dd><dl><dt><span class="sect2"><a href="performance.html#performance-cache-mapping">19.2.1. Cache 매핑들</a></span></dt><dt><span class="sect2"><a href="performance.html#performance-cache-readonly">19.2.2. 방도: 읽기 전용</a></span></dt><dt><span class="sect2"><a href="performance.html#performance-cache-readwrite">19.2.3. 방도: 읽기/쓰기</a></span></dt><dt><span class="sect2"><a href="performance.html#performance-cache-nonstrict">19.2.4. 방도: 엄격하지 않은 읽기/쓰기</a></span></dt><dt><span class="sect2"><a href="performance.html#performance-cache-transactional">19.2.5. 방도: transactional</a></span></dt><dt><span class="sect2"><a href="performance.html#performance-cache-compat-matrix">19.2.6. Cache-provider/concurrency-strategy compatibility</a></span></dt></dl></dd><dt><span class="sect1"><a href="performance.html#performance-sessioncache">19.3. 캐시들을 관리하기</a></span></dt><dt><span class="sect1"><a href="performance.html#performance-querycache">19.4. 질의 캐시</a></span></dt><dt><span class="sect1"><a href="performance.html#performance-collections">19.5. 콜렉션 퍼포먼스 이해하기</a></span></dt><dd><dl><dt><span class="sect2"><a href="performance.html#performance-collections-taxonomy">19.5.1. 분류</a></span></dt><dt><span class="sect2"><a href="performance.html#performance-collections-mostefficientupdate">19.5.2. List, map, idbag, set들은 update에 가장 효율적인 콜렉션들이다</a></span></dt><dt><span class="sect2"><a href="performance.html#performance-collections-mostefficentinverse">19.5.3. Bag들과 list들은 가장 효율적인 inverse 콜렉션들이다</a></span></dt><dt><span class="sect2"><a href="performance.html#performance-collections-oneshotdelete">19.5.4. 원 샷 delete</a></span></dt></dl></dd><dt><span class="sect1"><a href="performance.html#performance-monitoring">19.6. 퍼포먼스 모니터링하기</a></span></dt><dd><dl><dt><span class="sect2"><a href="performance.html#performance-monitoring-sf">19.6.1. SessionFactory 모니터링 하기</a></span></dt><dt><span class="sect2"><a href="performance.html#performance-monitoring-metrics">19.6.2. Metrics</a></span></dt></dl></dd></dl></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-fetching"/>19.1. 페칭 방도들</h2></div></div></div><p>Hibernate uses a <span class="emphasis"><em>fetching strategy</em></span> to retrieve associated objects if the application needs to navigate the association. Fetch strategies can be declared in the O/R mapping metadata, or over-ridden by a particular HQL or <code class="literal">Criteria</code> query. </p><p>Hibernate3는 다음 페칭 방도들을 정의한다: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Join fetching</em></span>: Hibernate retrieves the associated instance or collection in the same <code class="literal">SELECT</code>, using an <code class="literal">OUTER JOIN</code>. </p></li><li><p><span class="emphasis"><em>Select fetching</em></span>: a second <code class="literal">SELECT</code> is used to retrieve the associated entity or collection. Unless you explicitly disable lazy fetching by specifying <code class="literal">lazy="false"</code>, this second select will only be executed when you access the association. </p></li><li><p><span class="emphasis"><em>Subselect fetching</em></span>: a second <code class="literal">SELECT</code> is used to retrieve the associated collections for all entities retrieved in a previous query or fetch. Unless you explicitly disable lazy fetching by specifying <code class="literal">lazy="false"</code>, this second select will only be executed when you access the association. </p></li><li><p><span class="emphasis"><em>Batch fetching</em></span>: an optimization strategy for select fetching. Hibernate retrieves a batch of entity instances or collections in a single <code class="literal">SELECT</code> by specifying a list of primary or foreign keys. </p></li></ul></div><p>Hibernate는 또한 다음 사이를 구별 짓는다: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Immediate fetching</em></span>: an association, collection or attribute is fetched immediately when the owner is loaded. </p></li><li><p><span class="emphasis"><em>Lazy collection fetching</em></span>: a collection is fetched when the application invokes an operation upon that collection. This is the default for collections. </p></li><li><p><span class="emphasis"><em>"Extra-lazy" collection fetching</em></span>: individual elements of the collection are accessed from the database as needed. Hibernate tries not to fetch the whole collection into memory unless absolutely needed. It is suitable for large collections. </p></li><li><p><span class="emphasis"><em>Proxy fetching</em></span>: a single-valued association is fetched when a method other than the identifier getter is invoked upon the associated object. </p></li><li><p><span class="emphasis"><em>"No-proxy" fetching</em></span>: a single-valued association is fetched when the instance variable is accessed. Compared to proxy fetching, this approach is less lazy; the association is fetched even when only the identifier is accessed. It is also more transparent, since no proxy is visible to the application. This approach requires buildtime bytecode instrumentation and is rarely necessary. </p></li><li><p><span class="emphasis"><em>Lazy attribute fetching</em></span>: an attribute or single valued association is fetched when the instance variable is accessed. This approach requires buildtime bytecode instrumentation and is rarely necessary. </p></li></ul></div><p>We have two orthogonal notions here: <span class="emphasis"><em>when</em></span> is the association fetched and <span class="emphasis"><em>how</em></span> is it fetched. It is important that you do not confuse them. We use <code class="literal">fetch</code> to tune performance. We can use <code class="literal">lazy</code> to define a contract for what data is always available in any detached instance of a particular class. </p><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-lazy"/>19.1.1. lazy 연관들로 작업하기</h3></div></div></div><p>By default, Hibernate3 uses lazy select fetching for collections and lazy proxy fetching for single-valued associations. These defaults make sense for most associations in the majority of applications. </p><p>If you set <code class="literal">hibernate.default_batch_fetch_size</code>, Hibernate will use the batch fetch optimization for lazy fetching. This optimization can also be enabled at a more granular level. </p><p>Please be aware that access to a lazy association outside of the context of an open Hibernate session will result in an exception. For example: </p><pre class="programlisting">s = sessions.openSession();
Transaction tx = s.beginTransaction();
            
User u = (User) s.createQuery("from User u where u.name=:userName")
    .setString("userName", userName).uniqueResult();
Map permissions = u.getPermissions();

tx.commit();
s.close();

Integer accessLevel = (Integer) permissions.get("accounts");  // Error!</pre><p>Since the permissions collection was not initialized when the <code class="literal">Session</code> was closed, the collection will not be able to load its state. <span class="emphasis"><em>Hibernate does not support lazy initialization for detached objects</em></span>. This can be fixed by moving the code that reads from the collection to just before the transaction is committed. </p><p>Alternatively, you can use a non-lazy collection or association, by specifying <code class="literal">lazy="false"</code> for the association mapping. However, it is intended that lazy initialization be used for almost all collections and associations. If you define too many non-lazy associations in your object model, Hibernate will fetch the entire database into memory in every transaction. </p><p>On the other hand, you can use join fetching, which is non-lazy by nature, instead of select fetching in a particular transaction. We will now explain how to customize the fetching strategy. In Hibernate3, the mechanisms for choosing a fetch strategy are identical for single-valued associations and collections. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-custom"/>19.1.2. 페치 방도들을 튜닝하기</h3></div></div></div><p>select 페칭(디폴트)은 N+1 selects 문제점들에 매우 취약해서, 우리는 매핑 문서에서 join 페칭을 사용 가능하게 하기를 원할 수도 있다: </p><pre class="programlisting">&lt;set name="permissions" 
            fetch="join"&gt;
    &lt;key column="userId"/&gt;
    &lt;one-to-many class="Permission"/&gt;
&lt;/set</pre><pre class="programlisting">&lt;many-to-one name="mother" class="Cat" fetch="join"/&gt;</pre><p>매핑 문서 내에 정의된 <code class="literal">fetch</code> 방도는 다음에 영향을 준다: </p><div class="itemizedlist"><ul><li><p><code class="literal">get()</code> 또는 <code class="literal">load()</code>를 통한 검색 </p></li><li><p>연관이 네비게이트될 때 함축적으로 발생하는 검색 </p></li><li><p><code class="literal">Criteria</code> 질의들 </p></li><li><p><code class="literal">subselect</code> 페칭이 사용될 경우에 HQL 질의들 </p></li></ul></div><p>Irrespective of the fetching strategy you use, the defined non-lazy graph is guaranteed to be loaded into memory. This might, however, result in several immediate selects being used to execute a particular HQL query. </p><p>Usually, the mapping document is not used to customize fetching. Instead, we keep the default behavior, and override it for a particular transaction, using <code class="literal">left join fetch</code> in HQL. This tells Hibernate to fetch the association eagerly in the first select, using an outer join. In the <code class="literal">Criteria</code> query API, you would use <code class="literal">setFetchMode(FetchMode.JOIN)</code>. </p><p>If you want to change the fetching strategy used by <code class="literal">get()</code> or <code class="literal">load()</code>, you can use a <code class="literal">Criteria</code> query. For example: </p><pre class="programlisting">User user = (User) session.createCriteria(User.class)
                .setFetchMode("permissions", FetchMode.JOIN)
                .add( Restrictions.idEq(userId) )
                .uniqueResult();</pre><p>This is Hibernate's equivalent of what some ORM solutions call a "fetch plan". </p><p>A completely different approach to problems with N+1 selects is to use the second-level cache. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-proxies"/>19.1.3. Single-ended 연관 프락시</h3></div></div></div><p>Lazy fetching for collections is implemented using Hibernate's own implementation of persistent collections. However, a different mechanism is needed for lazy behavior in single-ended associations. The target entity of the association must be proxied. Hibernate implements lazy initializing proxies for persistent objects using runtime bytecode enhancement which is accessed via the CGLIB library. </p><p>At startup, Hibernate3 generates proxies by default for all persistent classes and uses them to enable lazy fetching of <code class="literal">many-to-one</code> and <code class="literal">one-to-one</code> associations. </p><p>The mapping file may declare an interface to use as the proxy interface for that class, with the <code class="literal">proxy</code> attribute. By default, Hibernate uses a subclass of the class. <span class="emphasis"><em>The proxied class must implement a default constructor with at least package visibility. This constructor is recommended for all persistent classes</em></span>. </p><p>There are potential problems to note when extending this approach to polymorphic classes.For example: </p><pre class="programlisting">&lt;class name="Cat" proxy="Cat"&gt;
    ......
    &lt;subclass name="DomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>첫 번째로, 심지어 기본 인스턴스가 <code class="literal">DomesticCat</code>의 인스턴스인 경우조차도, <code class="literal">Cat</code>의 인스턴스들은 결코 <code class="literal">DomesticCat</code>으로 타입캐스트가 가능하지 않을 것이다: </p><pre class="programlisting">Cat cat = (Cat) session.load(Cat.class, id);  // instantiate a proxy (does not hit the db)
if ( cat.isDomesticCat() ) {                  // hit the db to initialize the proxy
    DomesticCat dc = (DomesticCat) cat;       // Error!
    ....
}</pre><p>Secondly, it is possible to break proxy <code class="literal">==</code>: </p><pre class="programlisting">Cat cat = (Cat) session.load(Cat.class, id);            // instantiate a Cat proxy
DomesticCat dc = 
        (DomesticCat) session.load(DomesticCat.class, id);  // acquire new DomesticCat proxy!
System.out.println(cat==dc);                            // false</pre><p>하지만, 그 경우는 보이는 만큼 그렇게 나쁘지는 않다. 심지어 우리가 이제 다른 프락시 객체들에 대한 두 개의 참조를 가질지라도, 기본 인스턴스는 여전히 동일한 객체들일 것이다: </p><pre class="programlisting">cat.setWeight(11.0);  // hit the db to initialize the proxy
System.out.println( dc.getWeight() );  // 11.0</pre><p>Third, you cannot use a CGLIB proxy for a <code class="literal">final</code> class or a class with any <code class="literal">final</code> methods. </p><p>Finally, if your persistent object acquires any resources upon instantiation (e.g. in initializers or default constructor), then those resources will also be acquired by the proxy. The proxy class is an actual subclass of the persistent class. </p><p>These problems are all due to fundamental limitations in Java's single inheritance model. To avoid these problems your persistent classes must each implement an interface that declares its business methods. You should specify these interfaces in the mapping file where <code class="literal">CatImpl</code> implements the interface <code class="literal">Cat</code> and <code class="literal">DomesticCatImpl</code> implements the interface <code class="literal">DomesticCat</code>. For example: </p><pre class="programlisting">&lt;class name="CatImpl" proxy="Cat"&gt;
    ......
    &lt;subclass name="DomesticCatImpl" proxy="DomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>Then proxies for instances of <code class="literal">Cat</code> and <code class="literal">DomesticCat</code> can be returned by <code class="literal">load()</code> or <code class="literal">iterate()</code>. </p><pre class="programlisting">Cat cat = (Cat) session.load(CatImpl.class, catid);
Iterator iter = session.createQuery("from CatImpl as cat where cat.name='fritz'").iterate();
Cat fritz = (Cat) iter.next();</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p><code class="literal">list()</code> does not usually return proxies. </p></div><p>관계들은 또한 lazy 초기화 된다. 이것은 당신이 임의의 프로퍼티들을 <code class="literal">CatImpl</code> 타입이 아닌 <code class="literal">Cat</code> 타입으로 선언해야 함을 의미한다. </p><p>Certain operations do <span class="emphasis"><em>not</em></span> require proxy initialization: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">equals()</code>: if the persistent class does not override <code class="literal">equals()</code> </p></li><li><p><code class="literal">hashCode()</code>: if the persistent class does not override <code class="literal">hashCode()</code> </p></li><li><p>식별자 getter 메소드 </p></li></ul></div><p>Hibernate는 <code class="literal">equals()</code> 또는 <code class="literal">hashCode()</code>를 오버라이드 시키는 영속 클래스들을 검출할 것이다. </p><p>By choosing <code class="literal">lazy="no-proxy"</code> instead of the default <code class="literal">lazy="proxy"</code>, you can avoid problems associated with typecasting. However, buildtime bytecode instrumentation is required, and all operations will result in immediate proxy initialization. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-initialization"/>19.1.4. 콜렉션들과 프락시들을 초기화 시키기</h3></div></div></div><p>A <code class="literal">LazyInitializationException</code> will be thrown by Hibernate if an uninitialized collection or proxy is accessed outside of the scope of the <code class="literal">Session</code>, i.e., when the entity owning the collection or having the reference to the proxy is in the detached state. </p><p>Sometimes a proxy or collection needs to be initialized before closing the <code class="literal">Session</code>. You can force initialization by calling <code class="literal">cat.getSex()</code> or <code class="literal">cat.getKittens().size()</code>, for example. However, this can be confusing to readers of the code and it is not convenient for generic code. </p><p>The static methods <code class="literal">Hibernate.initialize()</code> and <code class="literal">Hibernate.isInitialized()</code>, provide the application with a convenient way of working with lazily initialized collections or proxies. <code class="literal">Hibernate.initialize(cat)</code> will force the initialization of a proxy, <code class="literal">cat</code>, as long as its <code class="literal">Session</code> is still open. <code class="literal">Hibernate.initialize( cat.getKittens() )</code> has a similar effect for the collection of kittens. </p><p>Another option is to keep the <code class="literal">Session</code> open until all required collections and proxies have been loaded. In some application architectures, particularly where the code that accesses data using Hibernate, and the code that uses it are in different application layers or different physical processes, it can be a problem to ensure that the <code class="literal">Session</code> is open when a collection is initialized. There are two basic ways to deal with this issue: </p><div class="itemizedlist"><ul><li><p>In a web-based application, a servlet filter can be used to close the <code class="literal">Session</code> only at the end of a user request, once the rendering of the view is complete (the <span class="emphasis"><em>Open Session in View</em></span> pattern). Of course, this places heavy demands on the correctness of the exception handling of your application infrastructure. It is vitally important that the <code class="literal">Session</code> is closed and the transaction ended before returning to the user, even when an exception occurs during rendering of the view. See the Hibernate Wiki for examples of this "Open Session in View" pattern. </p></li><li><p>In an application with a separate business tier, the business logic must "prepare" all collections that the web tier needs before returning. This means that the business tier should load all the data and return all the data already initialized to the presentation/web tier that is required for a particular use case. Usually, the application calls <code class="literal">Hibernate.initialize()</code> for each collection that will be needed in the web tier (this call must occur before the session is closed) or retrieves the collection eagerly using a Hibernate query with a <code class="literal">FETCH</code> clause or a <code class="literal">FetchMode.JOIN</code> in <code class="literal">Criteria</code>. This is usually easier if you adopt the <span class="emphasis"><em>Command</em></span> pattern instead of a <span class="emphasis"><em>Session Facade</em></span>. </p></li><li><p>You can also attach a previously loaded object to a new <code class="literal">Session</code> with <code class="literal">merge()</code> or <code class="literal">lock()</code> before accessing uninitialized collections or other proxies. Hibernate does not, and certainly <span class="emphasis"><em>should</em></span> not, do this automatically since it would introduce impromptu transaction semantics. </p></li></ul></div><p>Sometimes you do not want to initialize a large collection, but still need some information about it, like its size, for example, or a subset of the data. </p><p>당신은 그것을 초기화 시키지 않고서 콜렉션의 사이즈를 얻는데 콜렉션 필터를 사용할 수 있다: </p><pre class="programlisting">( (Integer) s.createFilter( collection, "select count(*)" ).list().get(0) ).intValue()</pre><p><code class="literal">createFilter()</code> 메소드는 또한 전체 콜렉션을 초기화 시킬 필요 없이 콜렉션의 부분집합들을 효율적으로 검색하는데 사용된다: </p><pre class="programlisting">s.createFilter( lazyCollection, "").setFirstResult(0).setMaxResults(10).list();</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-batch"/>19.1.5. batch 페칭 사용하기</h3></div></div></div><p>Using batch fetching, Hibernate can load several uninitialized proxies if one proxy is accessed. Batch fetching is an optimization of the lazy select fetching strategy. There are two ways you can configure batch fetching: on the class level and the collection level. </p><p>Batch fetching for classes/entities is easier to understand. Consider the following example: at runtime you have 25 <code class="literal">Cat</code> instances loaded in a <code class="literal">Session</code>, and each <code class="literal">Cat</code> has a reference to its <code class="literal">owner</code>, a <code class="literal">Person</code>. The <code class="literal">Person</code> class is mapped with a proxy, <code class="literal">lazy="true"</code>. If you now iterate through all cats and call <code class="literal">getOwner()</code> on each, Hibernate will, by default, execute 25 <code class="literal">SELECT</code> statements to retrieve the proxied owners. You can tune this behavior by specifying a <code class="literal">batch-size</code> in the mapping of <code class="literal">Person</code>: </p><pre class="programlisting">&lt;class name="Person" batch-size="10"&gt;...&lt;/class&gt;</pre><p>Hibernate will now execute only three queries: the pattern is 10, 10, 5. </p><p>You can also enable batch fetching of collections. For example, if each <code class="literal">Person</code> has a lazy collection of <code class="literal">Cat</code>s, and 10 persons are currently loaded in the <code class="literal">Session</code>, iterating through all persons will generate 10 <code class="literal">SELECT</code>s, one for every call to <code class="literal">getCats()</code>. If you enable batch fetching for the <code class="literal">cats</code> collection in the mapping of <code class="literal">Person</code>, Hibernate can pre-fetch collections: </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;set name="cats" batch-size="3"&gt;
        ...
    &lt;/set&gt;
&lt;/class&gt;</pre><p><code class="literal">batch-size</code> 8로서, Hibernate는 4개의 SELECT들에서 3, 3, 3, 1 개의 콜렉션들을 로드시킬 것이다. 다시 그 속성의 값은 특정 <code class="literal">Session</code> 내에서 초기화 되지 않은 콜렉션들의 예상되는 개수에 의존한다. </p><p>Batch fetching of collections is particularly useful if you have a nested tree of items, i.e. the typical bill-of-materials pattern. However, a <span class="emphasis"><em>nested set</em></span> or a <span class="emphasis"><em>materialized path</em></span> might be a better option for read-mostly trees. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-subselect"/>19.1.6. subselect 페칭 사용하기</h3></div></div></div><p>If one lazy collection or single-valued proxy has to be fetched, Hibernate will load all of them, re-running the original query in a subselect. This works in the same way as batch-fetching but without the piecemeal loading. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-lazyproperties"/>19.1.7. lazy 프로퍼티 페칭 사용하기</h3></div></div></div><p>Hibernate3 supports the lazy fetching of individual properties. This optimization technique is also known as <span class="emphasis"><em>fetch groups</em></span>. Please note that this is mostly a marketing feature; optimizing row reads is much more important than optimization of column reads. However, only loading some properties of a class could be useful in extreme cases. For example, when legacy tables have hundreds of columns and the data model cannot be improved. </p><p>lazy 프로퍼티 로딩을 이용가능하게 하려면, 당신의 특정 property 매핑들에 대해 <code class="literal">lazy</code> 속성을 설정하라: </p><pre class="programlisting">&lt;class name="Document"&gt;
       &lt;id name="id"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true" length="50"/&gt;
    &lt;property name="summary" not-null="true" length="200" lazy="true"/&gt;
    &lt;property name="text" not-null="true" length="2000" lazy="true"/&gt;
&lt;/class&gt;</pre><p>Lazy property loading requires buildtime bytecode instrumentation. If your persistent classes are not enhanced, Hibernate will ignore lazy property settings and return to immediate fetching. </p><p>bytecode 수단으로, 다음 Ant 태스크를 사용하라: </p><pre class="programlisting">&lt;target name="instrument" depends="compile"&gt;
    &lt;taskdef name="instrument" classname="org.hibernate.tool.instrument.InstrumentTask"&gt;
        &lt;classpath path="${jar.path}"/&gt;
        &lt;classpath path="${classes.dir}"/&gt;
        &lt;classpath refid="lib.class.path"/&gt;
    &lt;/taskdef&gt;

    &lt;instrument verbose="true"&gt;
        &lt;fileset dir="${testclasses.dir}/org/hibernate/auction/model"&gt;
            &lt;include name="*.class"/&gt;
        &lt;/fileset&gt;
    &lt;/instrument&gt;
&lt;/target&gt;</pre><p>A different way of avoiding unnecessary column reads, at least for read-only transactions, is to use the projection features of HQL or Criteria queries. This avoids the need for buildtime bytecode processing and is certainly a preferred solution. </p><p>You can force the usual eager fetching of properties using <code class="literal">fetch all properties</code> in HQL. </p></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-cache"/>19.2. 두번째 레벨 캐시</h2></div></div></div><p>A Hibernate <code class="literal">Session</code> is a transaction-level cache of persistent data. It is possible to configure a cluster or JVM-level (<code class="literal">SessionFactory</code>-level) cache on a class-by-class and collection-by-collection basis. You can even plug in a clustered cache. Be aware that caches are not aware of changes made to the persistent store by another application. They can, however, be configured to regularly expire cached data. </p><p>You have the option to tell Hibernate which caching implementation to use by specifying the name of a class that implements <code class="literal">org.hibernate.cache.CacheProvider</code> using the property <code class="literal">hibernate.cache.provider_class</code>. Hibernate is bundled with a number of built-in integrations with the open-source cache providers that are listed below. You can also implement your own and plug it in as outlined above. Note that versions prior to 3.2 use EhCache as the default cache provider. </p><div class="table"><a id="cacheproviders"/><p class="title"><b>표 19.1. 캐시 프로바이더들</b></p><div class="table-contents"><table summary="캐시 프로바이더들" border="1"><colgroup><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/></colgroup><thead><tr><th align="left">캐시</th><th align="left">프로바이더 클래스</th><th align="left">타입</th><th align="left">클러스터 안전</th><th align="left">질의 캐시 지원</th></tr></thead><tbody><tr><td align="left">Hashtable (not intended for production use)</td><td align="left"><code class="literal">org.hibernate.cache.HashtableCacheProvider</code></td><td align="left">memory</td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">EHCache</td><td align="left"><code class="literal">org.hibernate.cache.EhCacheProvider</code></td><td align="left">memory, disk</td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">OSCache</td><td align="left"><code class="literal">org.hibernate.cache.OSCacheProvider</code></td><td align="left">memory, disk</td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">SwarmCache</td><td align="left"><code class="literal">org.hibernate.cache.SwarmCacheProvider</code></td><td align="left">clustered (ip multicast)</td><td align="left">yes (clustered invalidation)</td><td align="left"> </td></tr><tr><td align="left">JBoss Cache 1.x</td><td align="left"><code class="literal">org.hibernate.cache.TreeCacheProvider</code></td><td align="left">clustered (ip multicast), transactional</td><td align="left">yes (replication)</td><td align="left">yes (clock sync req.)</td></tr><tr><td align="left">JBoss Cache 2</td><td align="left"><code class="literal">org.hibernate.cache.jbc2.JBossCacheRegionFactory</code></td><td align="left">clustered (ip multicast), transactional</td><td align="left">yes (replication or invalidation)</td><td align="left">yes (clock sync req.)</td></tr></tbody></table></div></div><br class="table-break"/><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-mapping"/>19.2.1. Cache 매핑들</h3></div></div></div><p>클래스 또는 콜렉션 매핑의 <code class="literal">&lt;cache&gt;</code> 요소는 다음 형식을 갖는다: </p><div class="programlistingco"><pre class="programlisting">&lt;cache 
    usage="transactional|read-write|nonstrict-read-write|read-only"  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
    region="RegionName"                                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
    include="all|non-lazy"                                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">usage</code>(필수) 캐싱 방도를 지정한다: <code class="literal">transactional</code>, <code class="literal">read-write</code>, <code class="literal">nonstrict-read-write</code> 또는 <code class="literal">read-only</code> </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">region</code> (optional: defaults to the class or collection role name): specifies the name of the second level cache region </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">include</code> (optional: defaults to <code class="literal">all</code>) <code class="literal">non-lazy</code>: specifies that properties of the entity mapped with <code class="literal">lazy="true"</code> cannot be cached when attribute-level lazy fetching is enabled </p></td></tr></table></div></div><p>Alternatively, you can specify <code class="literal">&lt;class-cache&gt;</code> and <code class="literal">&lt;collection-cache&gt;</code> elements in <code class="literal">hibernate.cfg.xml</code>. </p><p><code class="literal">usage</code> 속성은 <span class="emphasis"><em> 캐시 동시성 방도</em></span>를 지정한다. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-readonly"/>19.2.2. 방도: 읽기 전용</h3></div></div></div><p>If your application needs to read, but not modify, instances of a persistent class, a <code class="literal">read-only</code> cache can be used. This is the simplest and optimal performing strategy. It is even safe for use in a cluster. </p><pre class="programlisting">&lt;class name="eg.Immutable" mutable="false"&gt;
    &lt;cache usage="read-only"/&gt;
    ....
&lt;/class&gt;</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-readwrite"/>19.2.3. 방도: 읽기/쓰기</h3></div></div></div><p>If the application needs to update data, a <code class="literal">read-write</code> cache might be appropriate. This cache strategy should never be used if serializable transaction isolation level is required. If the cache is used in a JTA environment, you must specify the property <code class="literal">hibernate.transaction.manager_lookup_class</code> and naming a strategy for obtaining the JTA <code class="literal">TransactionManager</code>. In other environments, you should ensure that the transaction is completed when <code class="literal">Session.close()</code> or <code class="literal">Session.disconnect()</code> is called. If you want to use this strategy in a cluster, you should ensure that the underlying cache implementation supports locking. The built-in cache providers <span class="emphasis"><em>do not</em></span> support locking. </p><pre class="programlisting">&lt;class name="eg.Cat" .... &gt;
    &lt;cache usage="read-write"/&gt;
    ....
    &lt;set name="kittens" ... &gt;
        &lt;cache usage="read-write"/&gt;
        ....
    &lt;/set&gt;
&lt;/class&gt;</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-nonstrict"/>19.2.4. 방도: 엄격하지 않은 읽기/쓰기</h3></div></div></div><p>If the application only occasionally needs to update data (i.e. if it is extremely unlikely that two transactions would try to update the same item simultaneously), and strict transaction isolation is not required, a <code class="literal">nonstrict-read-write</code> cache might be appropriate. If the cache is used in a JTA environment, you must specify <code class="literal">hibernate.transaction.manager_lookup_class</code>. In other environments, you should ensure that the transaction is completed when <code class="literal">Session.close()</code> or <code class="literal">Session.disconnect()</code> is called. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-transactional"/>19.2.5. 방도: transactional</h3></div></div></div><p>The <code class="literal">transactional</code> cache strategy provides support for fully transactional cache providers such as JBoss TreeCache. Such a cache can only be used in a JTA environment and you must specify <code class="literal">hibernate.transaction.manager_lookup_class</code>. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-compat-matrix"/>19.2.6. Cache-provider/concurrency-strategy compatibility</h3></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>중요</h2><p>None of the cache providers support all of the cache concurrency strategies. </p></div><p>The following table shows which providers are compatible with which concurrency strategies. </p><div class="table"><a id="d0e14846"/><p class="title"><b>표 19.2. 캐시 동시성 방도 지원</b></p><div class="table-contents"><table summary="캐시 동시성 방도 지원" border="1"><colgroup><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/></colgroup><thead><tr><th align="left">캐시</th><th align="left">읽기 전용</th><th align="left">엄격하지 않은 읽기-쓰기</th><th align="left">읽기-쓰기</th><th align="left">transactional</th></tr></thead><tbody><tr><td align="left">Hashtable (not intended for production use)</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td></tr><tr><td align="left">EHCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td></tr><tr><td align="left">OSCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td></tr><tr><td align="left">SwarmCache</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">JBoss Cache 1.x</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">JBoss Cache 2</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td><td align="left">yes</td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-sessioncache"/>19.3. 캐시들을 관리하기</h2></div></div></div><p>Whenever you pass an object to <code class="literal">save()</code>, <code class="literal">update()</code> or <code class="literal">saveOrUpdate()</code>, and whenever you retrieve an object using <code class="literal">load()</code>, <code class="literal">get()</code>, <code class="literal">list()</code>, <code class="literal">iterate()</code> or <code class="literal">scroll()</code>, that object is added to the internal cache of the <code class="literal">Session</code>. </p><p>When <code class="literal">flush()</code> is subsequently called, the state of that object will be synchronized with the database. If you do not want this synchronization to occur, or if you are processing a huge number of objects and need to manage memory efficiently, the <code class="literal">evict()</code> method can be used to remove the object and its collections from the first-level cache. </p><pre class="programlisting">ScrollableResult cats = sess.createQuery("from Cat as cat").scroll(); //a huge result set
while ( cats.next() ) {
    Cat cat = (Cat) cats.get(0);
    doSomethingWithACat(cat);
    sess.evict(cat);
}</pre><p><code class="literal">Session</code>은 또한 인스턴스가 세션 캐시에 속하는지 여부를 결정하는데 <code class="literal">contains()</code> 메소드를 제공한다. </p><p>To evict all objects from the session cache, call <code class="literal">Session.clear()</code> </p><p>second-level 캐시의 경우, 하나의 인스턴스, 전체 클래스, 콜렉션 인스턴스 또는 전체 콜렉션 role의 캐시된 상태를 퇴거시키는 <code class="literal">SessionFactory</code> 상에 정의된 메소드들이 존재한다. </p><pre class="programlisting">sessionFactory.evict(Cat.class, catId); //evict a particular Cat
sessionFactory.evict(Cat.class);  //evict all Cats
sessionFactory.evictCollection("Cat.kittens", catId); //evict a particular collection of kittens
sessionFactory.evictCollection("Cat.kittens"); //evict all kitten collections</pre><p>The <code class="literal">CacheMode</code> controls how a particular session interacts with the second-level cache: </p><div class="itemizedlist"><ul><li><p><code class="literal">CacheMode.NORMAL</code>: will read items from and write items to the second-level cache </p></li><li><p><code class="literal">CacheMode.GET</code>: will read items from the second-level cache. Do not write to the second-level cache except when updating data </p></li><li><p><code class="literal">CacheMode.PUT</code>: will write items to the second-level cache. Do not read from the second-level cache </p></li><li><p><code class="literal">CacheMode.REFRESH</code>: will write items to the second-level cache. Do not read from the second-level cache. Bypass the effect of <code class="literal">hibernate.cache.use_minimal_puts</code> forcing a refresh of the second-level cache for all items read from the database </p></li></ul></div><p>second-level 캐시 또는 질의 캐시 영역의 내용물을 브라우징하려면 <code class="literal">Statistics</code> API를 사용하라: </p><pre class="programlisting">Map cacheEntries = sessionFactory.getStatistics()
        .getSecondLevelCacheStatistics(regionName)
        .getEntries();</pre><p>You will need to enable statistics and, optionally, force Hibernate to keep the cache entries in a more readable format: </p><pre class="programlisting">hibernate.generate_statistics true
hibernate.cache.use_structured_entries true</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-querycache"/>19.4. 질의 캐시</h2></div></div></div><p>Query result sets can also be cached. This is only useful for queries that are run frequently with the same parameters. You will first need to enable the query cache: </p><pre class="programlisting">hibernate.cache.use_query_cache true</pre><p>This setting creates two new cache regions: one holding cached query result sets (<code class="literal">org.hibernate.cache.StandardQueryCache</code>), the other holding timestamps of the most recent updates to queryable tables (<code class="literal">org.hibernate.cache.UpdateTimestampsCache</code>). Note that the query cache does not cache the state of the actual entities in the result set; it caches only identifier values and results of value type. The query cache should always be used in conjunction with the second-level cache. </p><p>Most queries do not benefit from caching, so by default, queries are not cached. To enable caching, call <code class="literal">Query.setCacheable(true)</code>. This call allows the query to look for existing cache results or add its results to the cache when it is executed. </p><p>If you require fine-grained control over query cache expiration policies, you can specify a named cache region for a particular query by calling <code class="literal">Query.setCacheRegion()</code>. </p><pre class="programlisting">List blogs = sess.createQuery("from Blog blog where blog.blogger = :blogger")
    .setEntity("blogger", blogger)
    .setMaxResults(15)
    .setCacheable(true)
    .setCacheRegion("frontpages")
    .list();</pre><p>만일 질의가 그것의 질의 캐시 영역의 갱신을 강제시켜야 하는 경우에, 당신은 <code class="literal">Query.setCacheMode(CacheMode.REFRESH)</code>를 호출해야 한다. 이것은 기본 데이터가 별도의 프로세스를 통해 업데이트되었고(예를 들면, Hibernate를 통해 변경되지 않았고) 특정 질의 결과 셋들을 선택적으로 갱신하는 것을 어플리케이션에게 허용해주는 경우들에서 특별히 유용하다. 이것은 <code class="literal">SessionFactory.evictQueries()</code>를 통해 질의 캐시 영역을 퇴거시키는 보다 효과적인 대안이다. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-collections"/>19.5. 콜렉션 퍼포먼스 이해하기</h2></div></div></div><p>In the previous sections we have covered collections and their applications. In this section we explore some more issues in relation to collections at runtime. </p><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-taxonomy"/>19.5.1. 분류</h3></div></div></div><p>Hibernate는 세 가지 기본적인 종류의 콜렉션들을 정의한다:</p><div class="itemizedlist"><ul><li><p>값들을 가진 콜렉션들</p></li><li><p>one-to-many associations</p></li><li><p>many-to-many associations</p></li></ul></div><p>이 분류는 여러 가지 테이블과 foreign key 관계들을 구별짓지만 우리가 관계형 모형에 대해 알 필요가 있는 모든 것을 우리에게 말해주지 않는다. 관계형 구조와 퍼포먼스 특징들을 완전하게 이해하기 위해, 우리는 또한 콜렉션 행들을 업데이트하거나 삭제하기 위해 Hibernate에 의해 사용되는 프라이머리 키의 구조를 검토해야 한다. 이것은 다음 분류를 제안한다: </p><div class="itemizedlist"><ul><li><p>인덱싱 된 콜렉션들</p></li><li><p>set들</p></li><li><p>bag들</p></li></ul></div><p>All indexed collections (maps, lists, and arrays) have a primary key consisting of the <code class="literal">&lt;key&gt;</code> and <code class="literal">&lt;index&gt;</code> columns. In this case, collection updates are extremely efficient. The primary key can be efficiently indexed and a particular row can be efficiently located when Hibernate tries to update or delete it. </p><p>Sets have a primary key consisting of <code class="literal">&lt;key&gt;</code> and element columns. This can be less efficient for some types of collection element, particularly composite elements or large text or binary fields, as the database may not be able to index a complex primary key as efficiently. However, for one-to-many or many-to-many associations, particularly in the case of synthetic identifiers, it is likely to be just as efficient. If you want <code class="literal">SchemaExport</code> to actually create the primary key of a <code class="literal">&lt;set&gt;</code>, you must declare all columns as <code class="literal">not-null="true"</code>. </p><p><code class="literal">&lt;idbag&gt;</code> mappings define a surrogate key, so they are efficient to update. In fact, they are the best case. </p><p>Bags are the worst case since they permit duplicate element values and, as they have no index column, no primary key can be defined. Hibernate has no way of distinguishing between duplicate rows. Hibernate resolves this problem by completely removing in a single <code class="literal">DELETE</code> and recreating the collection whenever it changes. This can be inefficient. </p><p>For a one-to-many association, the "primary key" may not be the physical primary key of the database table. Even in this case, the above classification is still useful. It reflects how Hibernate "locates" individual rows of the collection. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-mostefficientupdate"/>19.5.2. List, map, idbag, set들은 update에 가장 효율적인 콜렉션들이다</h3></div></div></div><p>From the discussion above, it should be clear that indexed collections and sets allow the most efficient operation in terms of adding, removing and updating elements. </p><p>There is, arguably, one more advantage that indexed collections have over sets for many-to-many associations or collections of values. Because of the structure of a <code class="literal">Set</code>, Hibernate does not <code class="literal">UPDATE</code> a row when an element is "changed". Changes to a <code class="literal">Set</code> always work via <code class="literal">INSERT</code> and <code class="literal">DELETE</code> of individual rows. Once again, this consideration does not apply to one-to-many associations. </p><p>After observing that arrays cannot be lazy, you can conclude that lists, maps and idbags are the most performant (non-inverse) collection types, with sets not far behind. You can expect sets to be the most common kind of collection in Hibernate applications. This is because the "set" semantics are most natural in the relational model. </p><p>However, in well-designed Hibernate domain models, most collections are in fact one-to-many associations with <code class="literal">inverse="true"</code>. For these associations, the update is handled by the many-to-one end of the association, and so considerations of collection update performance simply do not apply. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-mostefficentinverse"/>19.5.3. Bag들과 list들은 가장 효율적인 inverse 콜렉션들이다</h3></div></div></div><p>There is a particular case, however, in which bags, and also lists, are much more performant than sets. For a collection with <code class="literal">inverse="true"</code>, the standard bidirectional one-to-many relationship idiom, for example, we can add elements to a bag or list without needing to initialize (fetch) the bag elements. This is because, unlike a <code class="literal">set</code>, <code class="literal">Collection.add()</code> or <code class="literal">Collection.addAll()</code> must always return true for a bag or <code class="literal">List</code>. This can make the following common code much faster: </p><pre class="programlisting">Parent p = (Parent) sess.load(Parent.class, id);
Child c = new Child();
c.setParent(p);
p.getChildren().add(c);  //no need to fetch the collection!
sess.flush();</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-oneshotdelete"/>19.5.4. 원 샷 delete</h3></div></div></div><p>Deleting collection elements one by one can sometimes be extremely inefficient. Hibernate knows not to do that in the case of an newly-empty collection (if you called <code class="literal">list.clear()</code>, for example). In this case, Hibernate will issue a single <code class="literal">DELETE</code>. </p><p>Suppose you added a single element to a collection of size twenty and then remove two elements. Hibernate will issue one <code class="literal">INSERT</code> statement and two <code class="literal">DELETE</code> statements, unless the collection is a bag. This is certainly desirable. </p><p>하지만, 우리가 두 개의 요소들을 남겨둔채 18 개의 요소들을 제거하고 나서 세 개의 새로운 요소들을 추가한다고 가정하자. 두 가지 가능한 처리 방법들이 존재한다. </p><div class="itemizedlist"><ul><li><p>하나씩 열 여덟 개의 행들을 삭제한 다음에 세 개의 행들을 삽입시킨다</p></li><li><p>remove the whole collection in one SQL <code class="literal">DELETE</code> and insert all five current elements one by one</p></li></ul></div><p>Hibernate cannot know that the second option is probably quicker. It would probably be undesirable for Hibernate to be that intuitive as such behavior might confuse database triggers, etc. </p><p>Fortunately, you can force this behavior (i.e. the second strategy) at any time by discarding (i.e. dereferencing) the original collection and returning a newly instantiated collection with all the current elements. </p><p>One-shot-delete does not apply to collections mapped <code class="literal">inverse="true"</code>. </p></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-monitoring"/>19.6. 퍼포먼스 모니터링하기</h2></div></div></div><p>최적화는 퍼포먼스 관련 숫자들에 대한 모니터링과 접근 없이는 많이 사용되지 않는다. Hibernate는 그것의 내부적인 오퍼레이션들에 대한 전체 영역의 특징들을 제공한다. Hibernate에서 Statistics는 <code class="literal">SessionFactory</code>에 대해 이용 가능하다. </p><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-monitoring-sf"/>19.6.1. SessionFactory 모니터링 하기</h3></div></div></div><p>당신은 두 가지 방법들로 <code class="literal">SessionFactory</code> metrics에 접근할 수 있다. 당신의 첫 번째 옵션은 <code class="literal">sessionFactory.getStatistics()</code>를 호출하고 당신 스스로 <code class="literal">Statistics</code>를 읽거나 디스플레이 하는 것이다. </p><p>Hibernate can also use JMX to publish metrics if you enable the <code class="literal">StatisticsService</code> MBean. You can enable a single MBean for all your <code class="literal">SessionFactory</code> or one per factory. See the following code for minimalistic configuration examples: </p><pre class="programlisting">// MBean service registration for a specific SessionFactory
Hashtable tb = new Hashtable();
tb.put("type", "statistics");
tb.put("sessionFactory", "myFinancialApp");
ObjectName on = new ObjectName("hibernate", tb); // MBean object name

StatisticsService stats = new StatisticsService(); // MBean implementation
stats.setSessionFactory(sessionFactory); // Bind the stats to a SessionFactory
server.registerMBean(stats, on); // Register the Mbean on the server</pre><pre class="programlisting">// MBean service registration for all SessionFactory's
Hashtable tb = new Hashtable();
tb.put("type", "statistics");
tb.put("sessionFactory", "all");
ObjectName on = new ObjectName("hibernate", tb); // MBean object name

StatisticsService stats = new StatisticsService(); // MBean implementation
server.registerMBean(stats, on); // Register the MBean on the server</pre><p>You can activate and deactivate the monitoring for a <code class="literal">SessionFactory</code>: </p><div class="itemizedlist"><ul><li><p>구성 시 : <code class="literal">hibernate.generate_statistics</code>, 디폴트는 <code class="literal">false</code> </p></li></ul></div><div class="itemizedlist"><ul><li><p>실행 시 : <code class="literal">sf.getStatistics().setStatisticsEnabled(true)</code> 또는 <code class="literal">hibernateStatsBean.setStatisticsEnabled(true)</code> </p></li></ul></div><p>Statistics can be reset programmatically using the <code class="literal">clear()</code> method. A summary can be sent to a logger (info level) using the <code class="literal">logSummary()</code> method. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-monitoring-metrics"/>19.6.2. Metrics</h3></div></div></div><p>Hibernate provides a number of metrics, from basic information to more specialized information that is only relevant in certain scenarios. All available counters are described in the <code class="literal">Statistics</code> interface API, in three categories: </p><div class="itemizedlist"><ul><li><p>열려진 세션들의 개수, 검색된 JDBC 커넥션들의 개수 등과 같은 일반적인 <code class="literal">Session</code> 사용에 관련된 metrics. </p></li><li><p>Metrics related to the entities, collections, queries, and caches as a whole (aka global metrics). </p></li><li><p>특정한 엔티티, 콜렉션, 질의 또는 캐시 영역에 관련된 상세 metrics. </p></li></ul></div><p>For example, you can check the cache hit, miss, and put ratio of entities, collections and queries, and the average time a query needs. Be aware that the number of milliseconds is subject to approximation in Java. Hibernate is tied to the JVM precision and on some platforms this might only be accurate to 10 seconds. </p><p>Simple getters are used to access the global metrics (i.e. not tied to a particular entity, collection, cache region, etc.). You can access the metrics of a particular entity, collection or cache region through its name, and through its HQL or SQL representation for queries. Please refer to the <code class="literal">Statistics</code>, <code class="literal">EntityStatistics</code>, <code class="literal">CollectionStatistics</code>, <code class="literal">SecondLevelCacheStatistics</code>, and <code class="literal">QueryStatistics</code> API Javadoc for more information. The following code is a simple example: </p><pre class="programlisting">Statistics stats = HibernateUtil.sessionFactory.getStatistics();

double queryCacheHitCount  = stats.getQueryCacheHitCount();
double queryCacheMissCount = stats.getQueryCacheMissCount();
double queryCacheHitRatio =
  queryCacheHitCount / (queryCacheHitCount + queryCacheMissCount);

log.info("Query Hit ratio:" + queryCacheHitRatio);

EntityStatistics entityStats =
  stats.getEntityStatistics( Cat.class.getName() );
long changes =
        entityStats.getInsertCount()
        + entityStats.getUpdateCount()
        + entityStats.getDeleteCount();
log.info(Cat.class.getName() + " changed " + changes + "times"  );</pre><p>You can work on all entities, collections, queries and region caches, by retrieving the list of names of entities, collections, queries and region caches using the following methods: <code class="literal">getQueries()</code>, <code class="literal">getEntityNames()</code>, <code class="literal">getCollectionRoleNames()</code>, and <code class="literal">getSecondLevelCacheRegionNames()</code>. </p></div></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">저작권 © 2004 Red Hat Middleware, LLC.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="xml.html"><strong>이전</strong>18장. XML 매핑</a></li><li class="up"><a accesskey="u" href="#"><strong>위로</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>처음으로</strong></a></li><li class="next"><a accesskey="n" href="toolsetguide.html"><strong>다음</strong>20장. 도구셋 안내</a></li></ul></body></html>