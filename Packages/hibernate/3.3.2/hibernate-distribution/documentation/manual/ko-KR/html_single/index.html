<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">HIBERNATE - 개성있는 자바를 위한 관계 영속</title><link rel="stylesheet" href="css/hibernate-single.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.72.0"/></head><body><div class="book" lang="ko-KR"><div class="titlepage"><div><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><div><h1 class="title"><a id="d0e2"/>HIBERNATE - 개성있는 자바를 위한 관계 영속</h1></div><div><h2 class="subtitle">하이버네이트 참조 문서</h2></div><div><div xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="authorgroup"><div class="authors">지은이 <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Gavin</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">King</span>, <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Christian</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Bauer</span>, <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Max</span> <span xmlns="http://www.w3.org/1999/xhtml" class="othername">Rydahl</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Andersen</span>, <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Emmanuel</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Bernard</span>, 그리고 <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Steve</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Ebersole</span></div><div class="editors"/><div class="others">and thanks to <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">James</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Cobb</span> (Graphic Design) 그리고 <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Cheyenne</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Weaver</span> (Graphic Design)</div></div></div><div><p class="releaseinfo">3.3.2.GA</p></div><div><p class="copyright">저작권 © 2004 Red Hat Middleware, LLC.</p></div><div><a href="legalnotice.html">Legal Notice</a></div><div><p class="pubdate">June 24, 2009</p></div></div><hr/></div><div class="toc"><dl><dt><span class="preface"><a href="#preface">머리말</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e199">1. Feedback</a></span></dt></dl></dd><dt><span class="chapter"><a href="#tutorial">1. Tutorial</a></span></dt><dd><dl><dt><span class="sect1"><a href="#tutorial-firstapp">1.1. 파트 1 - 첫 번째 Hibernate 어플리케이션</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-firstapp-setup">1.1.1. Setup</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-firstclass">1.1.2. 첫 번째 클래스</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-mapping">1.1.3. The mapping file</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-configuration">1.1.4. Hibernate 구성</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-mvn">1.1.5. Building with Maven</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-helpers">1.1.6. 시작과 helper들</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-workingpersistence">1.1.7. 객체 로딩과 객체 저장</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-associations">1.2. 파트 2 - 연관들을 매핑하기</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-associations-mappinguser">1.2.1. Person 클래스 매핑하기</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-unidirset">1.2.2. 단방향 Set-기반의 연관</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-working">1.2.3. 연관들에 작업하기</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-valuecollections">1.2.4. 값들을 가진 콜렉션</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-bidirectional">1.2.5. Bi-directional associations</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-usingbidir">1.2.6. 양방향 링크들에 작업하기</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-webapp">1.3. 파트 3 - EventManager 웹 어플리케이션</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-webapp-servlet">1.3.1. 기본 서블릿 작성하기</a></span></dt><dt><span class="sect2"><a href="#tutorial-webapp-processing">1.3.2. 프로세싱과 렌더링</a></span></dt><dt><span class="sect2"><a href="#tutorial-webapp-deploy">1.3.3. 배치하기 그리고 테스트하기</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-summary">1.4. 요약</a></span></dt></dl></dd><dt><span class="chapter"><a href="#architecture">2. 아키텍처</a></span></dt><dd><dl><dt><span class="sect1"><a href="#architecture-overview">2.1. 개요</a></span></dt><dt><span class="sect1"><a href="#architecture-states">2.2. 인스턴스 상태들</a></span></dt><dt><span class="sect1"><a href="#architecture-jmx">2.3. JMX 통합</a></span></dt><dt><span class="sect1"><a href="#architecture-jca">2.4. JCA 지원</a></span></dt><dt><span class="sect1"><a href="#architecture-current-session">2.5. Contextual sessions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#session-configuration">3. 구성</a></span></dt><dd><dl><dt><span class="sect1"><a href="#configuration-programmatic">3.1. 프로그램 상의 구성</a></span></dt><dt><span class="sect1"><a href="#configuration-sessionfactory">3.2. SessionFactory 얻기</a></span></dt><dt><span class="sect1"><a href="#configuration-hibernatejdbc">3.3. JDBC 커넥션들</a></span></dt><dt><span class="sect1"><a href="#configuration-optional">3.4. 선택적인 구성 프로퍼티들</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuration-optional-dialects">3.4.1. SQL Dialects</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-outerjoin">3.4.2. Outer Join Fetching</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-binarystreams">3.4.3. Binary Streams</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-cacheprovider">3.4.4. Second-level 캐시와 query 캐시</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-querysubstitution">3.4.5. Query Language 치환</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-statistics">3.4.6. Hibernate 통계</a></span></dt></dl></dd><dt><span class="sect1"><a href="#configuration-logging">3.5. 로깅</a></span></dt><dt><span class="sect1"><a href="#configuration-namingstrategy">3.6. <code class="literal">NamingStrategy</code> 구현하기</a></span></dt><dt><span class="sect1"><a href="#configuration-xmlconfig">3.7. XML 구성 파일</a></span></dt><dt><span class="sect1"><a href="#configuration-j2ee">3.8. J2EE 어플리케이션 서버 통합</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuration-optional-transactionstrategy">3.8.1. 트랜잭션 방도 구성</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-jndi">3.8.2. JNDI-bound <code class="literal">SessionFactory</code></a></span></dt><dt><span class="sect2"><a href="#configuration-j2ee-currentsession">3.8.3. Current Session context management with JTA</a></span></dt><dt><span class="sect2"><a href="#configuration-j2ee-jmx">3.8.4. JMX 배치</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#persistent-classes">4. 영속 클래스들</a></span></dt><dd><dl><dt><span class="sect1"><a href="#persistent-classes-pojo">4.1. 간단한 POJO 예제</a></span></dt><dd><dl><dt><span class="sect2"><a href="#persistent-classes-pojo-constructor">4.1.1. 아규먼트 없는 생성자를 구현하라</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-identifier">4.1.2. identifier 프로퍼티를 제공하라(옵션)</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-final">4.1.3. final이 아닌 클래스들을 선호하라(옵션)</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-accessors">4.1.4. 영속 필드들을 위한 accessor들과 mutator들을 선언하라(옵션)</a></span></dt></dl></dd><dt><span class="sect1"><a href="#persistent-classes-inheritance">4.2. 상속 구현하기</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-equalshashcode">4.3. <code class="literal">equals()</code>와 <code class="literal">hashCode()</code> 구현하기</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-dynamicmodels">4.4. 동적인 모형들</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-tuplizers">4.5. Tuplizer들</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-entity-name-resolver">4.6. EntityNameResolvers</a></span></dt></dl></dd><dt><span class="chapter"><a href="#mapping">5. 기본 O/R 매핑</a></span></dt><dd><dl><dt><span class="sect1"><a href="#mapping-declaration">5.1. 매핑 선언</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-declaration-doctype">5.1.1. Doctype</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-mapping">5.1.2. Hibernate-mapping</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-class">5.1.3. Class</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id">5.1.4. id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id-enhanced">5.1.5. NOT TRANSLATED!Enhanced identifier generators</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id-enhanced-optimizers">5.1.6. NOT TRANSLATED! Identifier generator optimization</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-compositeid">5.1.7. composite-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-discriminator">5.1.8. Discriminator</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-version">5.1.9. Version (optional)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-timestamp">5.1.10. Timestamp (optional)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-property">5.1.11. Property</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-manytoone">5.1.12. Many-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-onetoone">5.1.13. One-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-naturalid">5.1.14. Natural-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-component">5.1.15. Component and dynamic-component</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-properties">5.1.16. Properties</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-subclass">5.1.17. Subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-joinedsubclass">5.1.18. Joined-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-unionsubclass">5.1.19. Union-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-join">5.1.20. Join</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-key">5.1.21. Key</a></span></dt><dt><span class="sect2"><a href="#mapping-column">5.1.22. Column and formula elements</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-import">5.1.23. Import</a></span></dt><dt><span class="sect2"><a href="#mapping-types-anymapping">5.1.24. Any</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-types">5.2. Hibernate types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-types-entitiesvalues">5.2.1. 엔티티들과 값들</a></span></dt><dt><span class="sect2"><a href="#mapping-types-basictypes">5.2.2. 기본 value 타입들</a></span></dt><dt><span class="sect2"><a href="#mapping-types-custom">5.2.3. 맞춤형 value 타입들</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-entityname">5.3. 하나의 클래스를 한 번 이상 매핑하기</a></span></dt><dt><span class="sect1"><a href="#mapping-quotedidentifiers">5.4. SQL 인용부호 표시된 식별자들</a></span></dt><dt><span class="sect1"><a href="#mapping-alternatives">5.5. Metadata 대안들</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-xdoclet">5.5.1. XDoclet 마크업 사용하기</a></span></dt><dt><span class="sect2"><a href="#mapping-annotations">5.5.2. JDK 5.0 Annotations 사용하기</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-generated">5.6. Generated properties</a></span></dt><dt><span class="sect1"><a href="#mapping-database-object">5.7. Auxiliary database objects</a></span></dt></dl></dd><dt><span class="chapter"><a href="#collections">6. Collection mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#collections-persistent">6.1. 영속 콜렉션들</a></span></dt><dt><span class="sect1"><a href="#collections-mapping">6.2. 콜렉션 매핑들</a></span></dt><dd><dl><dt><span class="sect2"><a href="#collections-foreignkeys">6.2.1. 콜렉션 foreign 키들</a></span></dt><dt><span class="sect2"><a href="#collections-elements">6.2.2. 콜렉션 요소들</a></span></dt><dt><span class="sect2"><a href="#collections-indexed">6.2.3. 인덱싱 된 콜렉션들</a></span></dt><dt><span class="sect2"><a href="#collections-ofvalues">6.2.4. 값들을 가진 콜렉션들과 many-to-many 연관들</a></span></dt><dt><span class="sect2"><a href="#collections-onetomany">6.2.5. One-to-many 연관들</a></span></dt></dl></dd><dt><span class="sect1"><a href="#collections-advancedmappings">6.3. 개선된 콜렉션 매핑들</a></span></dt><dd><dl><dt><span class="sect2"><a href="#collections-sorted">6.3.1. Sorted 콜렉션들</a></span></dt><dt><span class="sect2"><a href="#collections-bidirectional">6.3.2. 양방향 연관들</a></span></dt><dt><span class="sect2"><a href="#collections-indexedbidirectional">6.3.3. 인덱싱된 콜렉션들을 가진 양방향 연관들</a></span></dt><dt><span class="sect2"><a href="#collections-ternary">6.3.4. Ternary associations(세겹 연관들)</a></span></dt><dt><span class="sect2"><a href="#collections-idbag">6.3.5. <code class="literal"><code class="literal">&lt;idbag&gt;</code> 사용하기</code></a></span></dt></dl></dd><dt><span class="sect1"><a href="#collections-example">6.4. 콜렉션 예제들</a></span></dt></dl></dd><dt><span class="chapter"><a href="#associations">7. 연관 매핑들</a></span></dt><dd><dl><dt><span class="sect1"><a href="#assoc-intro">7.1. 개요</a></span></dt><dt><span class="sect1"><a href="#assoc-unidirectional">7.2. 단방향 연관들</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-unidirectional-m21">7.2.1. Many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-121">7.2.2. One-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-12m">7.2.3. One-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-unidirectional-join">7.3. join 테이블들에 대한 단방향 연관들</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-unidirectional-join-12m">7.3.1. One-to-many</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-m21">7.3.2. Many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-121">7.3.3. One-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-m2m">7.3.4. Many-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-bidirectional">7.4. 양방향 연관들</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-bidirectional-m21">7.4.1. one-to-many / many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-121">7.4.2. One-to-one</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-bidirectional-join">7.5. join 테이블들에 대한 양방향 연관들</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-bidirectional-join-12m">7.5.1. one-to-many / many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-join-121">7.5.2. one to one</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-join-m2m">7.5.3. Many-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-complex">7.6. 보다 복잡한 연관 매핑들</a></span></dt></dl></dd><dt><span class="chapter"><a href="#components">8. Component 매핑</a></span></dt><dd><dl><dt><span class="sect1"><a href="#components-dependentobjects">8.1. 종속 객체들</a></span></dt><dt><span class="sect1"><a href="#components-incollections">8.2. 종속 객체들을 가진 콜렉션들</a></span></dt><dt><span class="sect1"><a href="#components-asmapindex">8.3. Map 인덱스들로서 컴포넌트들</a></span></dt><dt><span class="sect1"><a href="#components-compositeid">8.4. composite 식별자들로서 컴포넌트들</a></span></dt><dt><span class="sect1"><a href="#components-dynamic">8.5. 동적인 컴포넌트들</a></span></dt></dl></dd><dt><span class="chapter"><a href="#inheritance">9. Inheritance mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#inheritance-strategies">9.1. The three strategies</a></span></dt><dd><dl><dt><span class="sect2"><a href="#inheritance-tableperclass">9.1.1. Table per class hierarchy</a></span></dt><dt><span class="sect2"><a href="#inheritance-tablepersubclass">9.1.2. Table per subclass</a></span></dt><dt><span class="sect2"><a href="#inheritance-tablepersubclass-discriminator">9.1.3. Table per subclass: using a discriminator</a></span></dt><dt><span class="sect2"><a href="#inheritance-mixing-tableperclass-tablepersubclass">9.1.4. table per class hierarchy와 table per subclass를 혼합하기</a></span></dt><dt><span class="sect2"><a href="#inheritance-tableperconcrete">9.1.5. Table per concrete class</a></span></dt><dt><span class="sect2"><a href="#inheritance-tableperconcreate-polymorphism">9.1.6. Table per concrete class using implicit polymorphism</a></span></dt><dt><span class="sect2"><a href="#inheritance-mixingpolymorphism">9.1.7. 함축적인 다형성을 다른 상속 매핑들과 혼합하기</a></span></dt></dl></dd><dt><span class="sect1"><a href="#inheritance-limitations">9.2. 제약들</a></span></dt></dl></dd><dt><span class="chapter"><a href="#objectstate">10. 객체들로 작업하기</a></span></dt><dd><dl><dt><span class="sect1"><a href="#objectstate-overview">10.1. Hibernate 객체 상태들</a></span></dt><dt><span class="sect1"><a href="#objectstate-makingpersistent">10.2. 객체들을 영속화 시키기</a></span></dt><dt><span class="sect1"><a href="#objectstate-loading">10.3. 객체를 로드시키기</a></span></dt><dt><span class="sect1"><a href="#objectstate-querying">10.4. 질의하기</a></span></dt><dd><dl><dt><span class="sect2"><a href="#objectstate-querying-executing">10.4.1. 질의들을 실행하기</a></span></dt><dt><span class="sect2"><a href="#objectstate-filtering">10.4.2. 콜렉션들을 필터링 하기</a></span></dt><dt><span class="sect2"><a href="#objecstate-querying-criteria">10.4.3. Criteria 질의들</a></span></dt><dt><span class="sect2"><a href="#objectstate-querying-nativesql">10.4.4. native SQL에서 질의들</a></span></dt></dl></dd><dt><span class="sect1"><a href="#objectstate-modifying">10.5. 영속 객체들을 변경하기</a></span></dt><dt><span class="sect1"><a href="#objectstate-detached">10.6. detached 객체들을 변경시키기</a></span></dt><dt><span class="sect1"><a href="#objectstate-saveorupdate">10.7. 자동적인 상태 검출</a></span></dt><dt><span class="sect1"><a href="#objectstate-deleting">10.8. 영속 객체들을 삭제하기</a></span></dt><dt><span class="sect1"><a href="#objectstate-replicating">10.9. 두 개의 다른 데이터저장소들 사이에 객체들을 복제하기</a></span></dt><dt><span class="sect1"><a href="#objectstate-flushing">10.10. Session을 flush 시키기</a></span></dt><dt><span class="sect1"><a href="#objectstate-transitive">10.11. Transitive persistence(전이 영속)</a></span></dt><dt><span class="sect1"><a href="#objectstate-metadata">10.12. 메타데이터 사용하기</a></span></dt></dl></dd><dt><span class="chapter"><a href="#transactions">11. Transactions and Concurrency</a></span></dt><dd><dl><dt><span class="sect1"><a href="#transactions-basics">11.1. 세션 영역과 트랜잭션 영역</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-basics-uow">11.1.1. 작업 단위</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-apptx">11.1.2. 장기간의 대화</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-identity">11.1.3. 객체 identity 고려하기</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-issues">11.1.4. 공통된 쟁점들</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-demarcation">11.2. 데이터베이스 트랜잭션 경계 설정</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-demarcation-nonmanaged">11.2.1. 관리되지 않는 환경</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-jta">11.2.2. JTA 사용하기</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-exceptions">11.2.3. 예외상황 처리</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-timeout">11.2.4. 트랜잭션 타임아웃</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-optimistic">11.3. Optimistic 동시성 제어</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-optimistic-manual">11.3.1. 어플리케이션 버전 체킹</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-longsession">11.3.2. 확장된 세션과 자동적인 버전화</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-detached">11.3.3. Detached 객체들과 자동적인 버전화</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-customizing">11.3.4. 자동적인 버전화를 맞춤화 시키기</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-locking">11.4. Pessimistic locking</a></span></dt><dt><span class="sect1"><a href="#transactions-connection-release">11.5. Connection release modes</a></span></dt></dl></dd><dt><span class="chapter"><a href="#events">12. 인터셉터들과 이벤트들</a></span></dt><dd><dl><dt><span class="sect1"><a href="#objectstate-interceptors">12.1. 인터셉터들</a></span></dt><dt><span class="sect1"><a href="#objectstate-events">12.2. 이벤트 시스템</a></span></dt><dt><span class="sect1"><a href="#objectstate-decl-security">12.3. Hibernate 선언적인 보안</a></span></dt></dl></dd><dt><span class="chapter"><a href="#batch">13. Batch ì²ë¦¬</a></span></dt><dd><dl><dt><span class="sect1"><a href="#batch-inserts">13.1. Batch inserts</a></span></dt><dt><span class="sect1"><a href="#batch-update">13.2. Batch updates</a></span></dt><dt><span class="sect1"><a href="#batch-statelesssession">13.3. StatelessSession ì¸í°íì´ì¤</a></span></dt><dt><span class="sect1"><a href="#batch-direct">13.4. DML-ì¤íì¼ ì°ì°ë¤</a></span></dt></dl></dd><dt><span class="chapter"><a href="#queryhql">14. HQL: 하이버네이트 질의 언어(Hibernate Query Language)</a></span></dt><dd><dl><dt><span class="sect1"><a href="#queryhql-casesensitivity">14.1. 대소문자 구분</a></span></dt><dt><span class="sect1"><a href="#queryhql-from">14.2. from 절</a></span></dt><dt><span class="sect1"><a href="#queryhql-joins">14.3. 연관들과 조인들</a></span></dt><dt><span class="sect1"><a href="#queryhql-joins-forms">14.4. join 구문의 형식들</a></span></dt><dt><span class="sect1"><a href="#queryhql-identifier-property">14.5. Referring to identifier property</a></span></dt><dt><span class="sect1"><a href="#queryhql-select">14.6. select 절</a></span></dt><dt><span class="sect1"><a href="#queryhql-aggregation">14.7. 집계 함수들</a></span></dt><dt><span class="sect1"><a href="#queryhql-polymorphism">14.8. Polymorphic(다형성) 질의들</a></span></dt><dt><span class="sect1"><a href="#queryhql-where">14.9. where 절</a></span></dt><dt><span class="sect1"><a href="#queryhql-expressions">14.10. 표현식들</a></span></dt><dt><span class="sect1"><a href="#queryhql-ordering">14.11. order by 절</a></span></dt><dt><span class="sect1"><a href="#queryhql-grouping">14.12. group by 절</a></span></dt><dt><span class="sect1"><a href="#queryhql-subqueries">14.13. 서브질의들</a></span></dt><dt><span class="sect1"><a href="#queryhql-examples">14.14. HQL 예제들</a></span></dt><dt><span class="sect1"><a href="#queryhql-bulk">14.15. 대량 update와 delete</a></span></dt><dt><span class="sect1"><a href="#queryhql-tipstricks">14.16. 팁들 &amp; 트릭들</a></span></dt><dt><span class="sect1"><a href="#queryhql-components">14.17. 컴포넌트들</a></span></dt><dt><span class="sect1"><a href="#queryhql-tuple">14.18. Row value constructor 구문</a></span></dt></dl></dd><dt><span class="chapter"><a href="#querycriteria">15. Criteria 질의들</a></span></dt><dd><dl><dt><span class="sect1"><a href="#querycriteria-creating">15.1. <code class="literal">Criteria</code> 인스턴스 생성하기</a></span></dt><dt><span class="sect1"><a href="#querycriteria-narrowing">15.2. 결과 셋 제한하기</a></span></dt><dt><span class="sect1"><a href="#querycriteria-ordering">15.3. 결과들을 순서지우기(ordering)</a></span></dt><dt><span class="sect1"><a href="#querycriteria-associations">15.4. 연관들</a></span></dt><dt><span class="sect1"><a href="#querycriteria-dynamicfetching">15.5. 동적인 연관 페칭</a></span></dt><dt><span class="sect1"><a href="#querycriteria-examples">15.6. 예제 질의들</a></span></dt><dt><span class="sect1"><a href="#querycriteria-projection">15.7. Projections, aggregation 그리고 grouping</a></span></dt><dt><span class="sect1"><a href="#querycriteria-detachedqueries">15.8. Detached 질의들과 서브질의들</a></span></dt><dt><span class="sect1"><a href="#query-criteria-naturalid">15.9. natural 식별자에 의한 질의들</a></span></dt></dl></dd><dt><span class="chapter"><a href="#querysql">16. Native SQL</a></span></dt><dd><dl><dt><span class="sect1"><a href="#querysql-creating">16.1. <code class="literal">SQLQuery</code> 사용하기</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e13314">16.1.1. 스칼라 질의들</a></span></dt><dt><span class="sect2"><a href="#d0e13364">16.1.2. Entity 질의들</a></span></dt><dt><span class="sect2"><a href="#d0e13400">16.1.3. 연관들과 콜렉션들을 처리하기</a></span></dt><dt><span class="sect2"><a href="#d0e13431">16.1.4. 여러 개의 엔티티들을 반환하기</a></span></dt><dt><span class="sect2"><a href="#d0e13572">16.1.5. non-managed 엔티티들을 반환하기</a></span></dt><dt><span class="sect2"><a href="#d0e13596">16.1.6. 상속 처리하기</a></span></dt><dt><span class="sect2"><a href="#d0e13601">16.1.7. 파라미터들</a></span></dt></dl></dd><dt><span class="sect1"><a href="#querysql-namedqueries">16.2. 명명된 SQL 질의들</a></span></dt><dd><dl><dt><span class="sect2"><a href="#propertyresults">16.2.1. 명시적으로 column/alias 이름들을 지정하는데 return-property 사용하기</a></span></dt><dt><span class="sect2"><a href="#sp_query">16.2.2. 질의를 위한 내장 프로시저 사용하기</a></span></dt></dl></dd><dt><span class="sect1"><a href="#querysql-cud">16.3. create, update 그리고 delete를 위한 맞춤형 SQL</a></span></dt><dt><span class="sect1"><a href="#querysql-load">16.4. 로딩을 위한 맞춤형 SQL</a></span></dt></dl></dd><dt><span class="chapter"><a href="#filters">17. 데이터 필터링하기</a></span></dt><dd><dl><dt><span class="sect1"><a href="#objectstate-filters">17.1. Hibernate 필터들</a></span></dt></dl></dd><dt><span class="chapter"><a href="#xml">18. XML 매핑</a></span></dt><dd><dl><dt><span class="sect1"><a href="#xml-intro">18.1. XML 데이터로 작업하기</a></span></dt><dd><dl><dt><span class="sect2"><a href="#xml-intro-mapping">18.1.1. XML과 클래스 매핑을 함께 지정하기</a></span></dt><dt><span class="sect2"><a href="#xml-onlyxml">18.1.2. XML 매핑만을 지정하기</a></span></dt></dl></dd><dt><span class="sect1"><a href="#xml-mapping">18.2. XML 매핑 메타데이터</a></span></dt><dt><span class="sect1"><a href="#xml-manipulation">18.3. XML 데이터 처리하기</a></span></dt></dl></dd><dt><span class="chapter"><a href="#performance">19. 퍼포먼스 개선하기</a></span></dt><dd><dl><dt><span class="sect1"><a href="#performance-fetching">19.1. 페칭 방도들</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-fetching-lazy">19.1.1. lazy 연관들로 작업하기</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-custom">19.1.2. 페치 방도들을 튜닝하기</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-proxies">19.1.3. Single-ended 연관 프락시</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-initialization">19.1.4. 콜렉션들과 프락시들을 초기화 시키기</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-batch">19.1.5. batch 페칭 사용하기</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-subselect">19.1.6. subselect 페칭 사용하기</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-lazyproperties">19.1.7. lazy 프로퍼티 페칭 사용하기</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-cache">19.2. 두번째 레벨 캐시</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-cache-mapping">19.2.1. Cache 매핑들</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readonly">19.2.2. 방도: 읽기 전용</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readwrite">19.2.3. 방도: 읽기/쓰기</a></span></dt><dt><span class="sect2"><a href="#performance-cache-nonstrict">19.2.4. 방도: 엄격하지 않은 읽기/쓰기</a></span></dt><dt><span class="sect2"><a href="#performance-cache-transactional">19.2.5. 방도: transactional</a></span></dt><dt><span class="sect2"><a href="#performance-cache-compat-matrix">19.2.6. Cache-provider/concurrency-strategy compatibility</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-sessioncache">19.3. 캐시들을 관리하기</a></span></dt><dt><span class="sect1"><a href="#performance-querycache">19.4. 질의 캐시</a></span></dt><dt><span class="sect1"><a href="#performance-collections">19.5. 콜렉션 퍼포먼스 이해하기</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-collections-taxonomy">19.5.1. 분류</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficientupdate">19.5.2. List, map, idbag, set들은 update에 가장 효율적인 콜렉션들이다</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficentinverse">19.5.3. Bag들과 list들은 가장 효율적인 inverse 콜렉션들이다</a></span></dt><dt><span class="sect2"><a href="#performance-collections-oneshotdelete">19.5.4. 원 샷 delete</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-monitoring">19.6. 퍼포먼스 모니터링하기</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-monitoring-sf">19.6.1. SessionFactory 모니터링 하기</a></span></dt><dt><span class="sect2"><a href="#performance-monitoring-metrics">19.6.2. Metrics</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#toolsetguide">20. 도구셋 안내</a></span></dt><dd><dl><dt><span class="sect1"><a href="#toolsetguide-s1">20.1. 자동적인 스키마 생성</a></span></dt><dd><dl><dt><span class="sect2"><a href="#toolsetguide-s1-2">20.1.1. 스키마 맞춤화 시키기</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-3">20.1.2. 도구 실행하기</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-4">20.1.3. 프로퍼티들</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-5">20.1.4. Ant 사용하기</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-6">20.1.5. 점증하는 스키마 업데이트들</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-7">20.1.6. 점증하는 스키마 업데이트들에 Ant 사용하기</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-8">20.1.7. 스키마 유효성 검사</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-9">20.1.8. 스키마 유효성 검사를 위해 Ant 사용하기</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#example-parentchild">21. 예제: 부모/자식</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-parentchild-collections">21.1. 콜렉션들에 관한 노트</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-bidir">21.2. 양방향 one-to-many</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-cascades">21.3. 케스케이딩 생명주기</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-update">21.4. 케스케이드들과 <code class="literal">unsaved-value</code></a></span></dt><dt><span class="sect1"><a href="#example-parentchild-conclusion">21.5. 결론</a></span></dt></dl></dd><dt><span class="chapter"><a href="#example-weblog">22. 예제: Weblog 어플리케이션</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-weblog-classes">22.1. 영속 클래스들</a></span></dt><dt><span class="sect1"><a href="#example-weblog-mappings">22.2. Hibernate 매핑들</a></span></dt><dt><span class="sect1"><a href="#example-weblog-code">22.3. Hibernate 코드</a></span></dt></dl></dd><dt><span class="chapter"><a href="#example-mappings">23. 예제: 여러 가지 매핑들</a></span></dt><dd><dl><dt><span class="sect1"><a href="#example-mappings-emp">23.1. Employer/Employee</a></span></dt><dt><span class="sect1"><a href="#example-mappings-authorwork">23.2. Author/Work</a></span></dt><dt><span class="sect1"><a href="#example-mappings-customerorderproduct">23.3. Customer/Order/Product</a></span></dt><dt><span class="sect1"><a href="#misc">23.4. 기타 예제 매핑들</a></span></dt><dd><dl><dt><span class="sect2"><a href="#example-mappings-typed-onetone">23.4.1. "형식화된(Typed)" one-to-one 연관</a></span></dt><dt><span class="sect2"><a href="#example-mappings-composite-key">23.4.2. Composite 키 예제</a></span></dt><dt><span class="sect2"><a href="#example-mappings-composite-key-manytomany">23.4.3. 공유된 합성 키 속성을 가진 Many-to-many</a></span></dt><dt><span class="sect2"><a href="#example-mappings-content-discrimination">23.4.4. 내용 기반 판별</a></span></dt><dt><span class="sect2"><a href="#example-mappings-association-alternatekeys">23.4.5. 대체 키들에 대한 연관들</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#best-practices">24. 최상의 실전 경험들</a></span></dt><dt><span class="chapter"><a href="#portability">25. Database Portability Considerations</a></span></dt><dd><dl><dt><span class="sect1"><a href="#portability-basics">25.1. Portability Basics</a></span></dt><dt><span class="sect1"><a href="#portability-dialect">25.2. Dialect</a></span></dt><dt><span class="sect1"><a href="#portability-dialectresolver">25.3. Dialect resolution</a></span></dt><dt><span class="sect1"><a href="#portability-idgen">25.4. Identifier generation</a></span></dt><dt><span class="sect1"><a href="#portability-functions">25.5. Database functions</a></span></dt><dt><span class="sect1"><a href="#portability-types">25.6. Type mappings</a></span></dt></dl></dd><dt><span class="bibliography"><a href="#d0e16873">References</a></span></dt></dl></div><div class="preface" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="preface"/>머리말</h2></div></div></div><p>Working with object-oriented software and a relational database can be cumbersome and time consuming in today's enterprise environments. Hibernate is an Object/Relational Mapping tool for Java environments. The term Object/Relational Mapping (ORM) refers to the technique of mapping a data representation from an object model to a relational data model with a SQL-based schema. </p><p>Hibernate not only takes care of the mapping from Java classes to database tables (and from Java data types to SQL data types), but also provides data query and retrieval facilities. It can also significantly reduce development time otherwise spent with manual data handling in SQL and JDBC. </p><p>Hibernate's goal is to relieve the developer from 95 percent of common data persistence related programming tasks. Hibernate may not be the best solution for data-centric applications that only use stored-procedures to implement the business logic in the database, it is most useful with object-oriented domain models and business logic in the Java-based middle-tier. However, Hibernate can certainly help you to remove or encapsulate vendor-specific SQL code and will help with the common task of result set translation from a tabular representation to a graph of objects. </p><p>만일 당신이 Hibernate와 Object/Relational 매핑 또는 심지어 자바에 초심자라면, 다음 단계들을 따르기 바란다: </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>더 많은 단계적인 사용 설명서들을 가진 더 긴 튜토리얼은 <a href="#tutorial" title="1장. Tutorial">1장. <i xmlns:xlink="http://www.w3.org/1999/xlink">Tutorial</i></a> 을 읽어라. 튜토리얼을 위한 소스 코드는 <code class="literal">doc/reference/tutorial/</code> 디렉토리에 포함되어 있다. </p></li><li><p>Hibernate가 사용될 수 있는 환경을 이해려면 <a href="#architecture" title="2장. 아키텍처">2장. <i xmlns:xlink="http://www.w3.org/1999/xlink">아키텍처</i></a> 를 읽어라. </p></li><li><p>View the <code class="literal">eg/</code> directory in the Hibernate distribution. It contains a simple standalone application. Copy your JDBC driver to the <code class="literal">lib/</code> directory and edit <code class="literal">etc/hibernate.properties</code>, specifying correct values for your database. From a command prompt in the distribution directory, type <code class="literal">ant eg</code> (using Ant), or under Windows, type <code class="literal">build eg</code>. </p></li><li><p>Use this reference documentation as your primary source of information. Consider reading [<a xmlns:xlink="http://www.w3.org/1999/xlink" href="#biblio-JPwH" title="[JPwH]"><abbr class="abbrev">JPwH</abbr></a>] if you need more help with application design, or if you prefer a step-by-step tutorial. Also visit <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://caveatemptor.hibernate.org">http://caveatemptor.hibernate.org</a> and download the example application from [<a xmlns:xlink="http://www.w3.org/1999/xlink" href="#biblio-JPwH" title="[JPwH]"><abbr class="abbrev">JPwH</abbr></a>]. </p></li><li><p>FAQ들은 Hibernate 웹 사이트 상에 답변되어 있다. </p></li><li><p>Links to third party demos, examples, and tutorials are maintained on the Hibernate website. </p></li><li><p>Hibernate 웹사이트 상의 공동체 영역은 설계 패턴과 다양한 통합 솔루션들(Tomcat, JBoss AS, Struts, EJB 등.)에 관한 좋은 리소스이다. </p></li></ol></div><p>If you have questions, use the user forum linked on the Hibernate website. We also provide a JIRA issue tracking system for bug reports and feature requests. If you are interested in the development of Hibernate, join the developer mailing list. If you are interested in translating this documentation into your language, contact us on the developer mailing list. </p><p>Hibernate를 위한 상용 개발 지원, 제품 지원, 그리고 교육은 JBoss Inc를 통해 이용 가능하다 (http://www.hibernate.org/SupportTraining/를 보라). Hibernate는 JBoss Professional Open Source product 프로젝트이고 제품들에 대한 JBoss Enterprise Middleware System (JEMS) suite의 중대한 컴포넌트이다. </p><div class="section" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="d0e199"/>1. Feedback</h2></div></div></div><p>Use <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://opensource.atlassian.com/projects/hibernate">Hibernate JIRA</a> to report errors or request enhacements to this documentation. </p></div></div><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial"/>1장. Tutorial</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#tutorial-firstapp">1.1. 파트 1 - 첫 번째 Hibernate 어플리케이션</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-firstapp-setup">1.1.1. Setup</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-firstclass">1.1.2. 첫 번째 클래스</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-mapping">1.1.3. The mapping file</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-configuration">1.1.4. Hibernate 구성</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-mvn">1.1.5. Building with Maven</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-helpers">1.1.6. 시작과 helper들</a></span></dt><dt><span class="sect2"><a href="#tutorial-firstapp-workingpersistence">1.1.7. 객체 로딩과 객체 저장</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-associations">1.2. 파트 2 - 연관들을 매핑하기</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-associations-mappinguser">1.2.1. Person 클래스 매핑하기</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-unidirset">1.2.2. 단방향 Set-기반의 연관</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-working">1.2.3. 연관들에 작업하기</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-valuecollections">1.2.4. 값들을 가진 콜렉션</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-bidirectional">1.2.5. Bi-directional associations</a></span></dt><dt><span class="sect2"><a href="#tutorial-associations-usingbidir">1.2.6. 양방향 링크들에 작업하기</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-webapp">1.3. 파트 3 - EventManager 웹 어플리케이션</a></span></dt><dd><dl><dt><span class="sect2"><a href="#tutorial-webapp-servlet">1.3.1. 기본 서블릿 작성하기</a></span></dt><dt><span class="sect2"><a href="#tutorial-webapp-processing">1.3.2. 프로세싱과 렌더링</a></span></dt><dt><span class="sect2"><a href="#tutorial-webapp-deploy">1.3.3. 배치하기 그리고 테스트하기</a></span></dt></dl></dd><dt><span class="sect1"><a href="#tutorial-summary">1.4. 요약</a></span></dt></dl></div><p>Intended for new users, this chapter provides an step-by-step introduction to Hibernate, starting with a simple application using an in-memory database. The tutorial is based on an earlier tutorial developed by Michael Gloegl. All code is contained in the <code class="filename">tutorials/web</code> directory of the project source. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>중요</h2><p>This tutorial expects the user have knowledge of both Java and SQL. If you have a limited knowledge of JAVA or SQL, it is advised that you start with a good introduction to that technology prior to attempting to learn Hibernate. </p></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>참고</h2><p>The distribution contains another example application under the <code class="filename">tutorial/eg</code> project source directory. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial-firstapp"/>1.1. 파트 1 - 첫 번째 Hibernate 어플리케이션</h2></div></div></div><p>For this example, we will set up a small database application that can store events we want to attend and information about the host(s) of these events. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>참고</h2><p>Although you can use whatever database you feel comfortable using, we will use <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://hsqldb.org/">HSQLDB</a> (an in-memory, Java database) to avoid describing installation/setup of any particular database servers. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-setup"/>1.1.1. Setup</h3></div></div></div><p>The first thing we need to do is to set up the development environment. We will be using the "standard layout" advocated by alot of build tools such as <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://maven.org">Maven</a>. Maven, in particular, has a good resource describing this <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html">layout</a>. As this tutorial is to be a web application, we will be creating and making use of <code class="filename">src/main/java</code>, <code class="filename">src/main/resources</code> and <code class="filename">src/main/webapp</code> directories. </p><p>We will be using Maven in this tutorial, taking advantage of its transitive dependency management capabilities as well as the ability of many IDEs to automatically set up a project for us based on the maven descriptor. </p><pre class="programlisting">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;

    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.hibernate.tutorials&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-tutorial&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;First Hibernate Tutorial&lt;/name&gt;

    &lt;build&gt;
         &lt;!-- we dont want the version to be part of the generated war file name --&gt;
         &lt;finalName&gt;${artifactId}&lt;/finalName&gt;
    &lt;/build&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- Because this is a web app, we also have a dependency on the servlet api. --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- Hibernate uses slf4j for logging, for our purposes here use the simple backend --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- Hibernate gives you a choice of bytecode providers between cglib and javassist --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javassist&lt;/groupId&gt;
            &lt;artifactId&gt;javassist&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>작은 정보</h2><p>It is not a requirement to use Maven. If you wish to use something else to build this tutoial (such as Ant), the layout will remain the same. The only change is that you will need to manually account for all the needed dependencies. If you use something like <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://ant.apache.org/ivy/">Ivy</a> providing transitive dependency management you would still use the dependencies mentioned below. Otherwise, you'd need to grab <span class="emphasis"><em>all</em></span> dependencies, both explicit and transitive, and add them to the project's classpath. If working from the Hibernate distribution bundle, this would mean <code class="filename">hibernate3.jar</code>, all artifacts in the <code class="filename">lib/required</code> directory and all files from either the <code class="filename">lib/bytecode/cglib</code> or <code class="filename">lib/bytecode/javassist</code> directory; additionally you will need both the servlet-api jar and one of the slf4j logging backends. </p></div><p>Save this file as <code class="filename">pom.xml</code> in the project root directory. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-firstclass"/>1.1.2. 첫 번째 클래스</h3></div></div></div><p>Next, we create a class that represents the event we want to store in the database; it is a simple JavaBean class with some properties: </p><pre class="programlisting">package org.hibernate.tutorial.domain;

import java.util.Date;

public class Event {
    private Long id;

    private String title;
    private Date date;

    public Event() {}

    public Long getId() {
        return id;
    }

    private void setId(Long id) {
        this.id = id;
    }

    public Date getDate() {
        return date;
    }

    public void setDate(Date date) {
        this.date = date;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }
}</pre><p>This class uses standard JavaBean naming conventions for property getter and setter methods, as well as private visibility for the fields. Although this is the recommended design, it is not required. Hibernate can also access fields directly, the benefit of accessor methods is robustness for refactoring. </p><p>The <code class="literal">id</code> property holds a unique identifier value for a particular event. All persistent entity classes (there are less important dependent classes as well) will need such an identifier property if we want to use the full feature set of Hibernate. In fact, most applications, especially web applications, need to distinguish objects by identifier, so you should consider this a feature rather than a limitation. However, we usually do not manipulate the identity of an object, hence the setter method should be private. Only Hibernate will assign identifiers when an object is saved. Hibernate can access public, private, and protected accessor methods, as well as public, private and protected fields directly. The choice is up to you and you can match it to fit your application design. </p><p>The no-argument constructor is a requirement for all persistent classes; Hibernate has to create objects for you, using Java Reflection. The constructor can be private, however package or public visibility is required for runtime proxy generation and efficient data retrieval without bytecode instrumentation. </p><p>Save this file to the <code class="filename">src/main/java/org/hibernate/tutorial/domain</code> directory. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-mapping"/>1.1.3. The mapping file</h3></div></div></div><p>Hibernate는 영속 크래스들에 대한 객체들을 로드시키고 저장시키는 방법을 알 필요가 있다. 이곳은 Hibernate 매핑 파일이 역할을 행하는 곳이다. 매핑 파일은 Hibernate가 접근해야 하는 데이터베이스 내의 테이블이 무엇인지, 그리고 그것이 사용해야 하는 그 테이블 내의 컬럼들이 무엇인지를 Hibernate에게 알려준다. </p><p>매핑 파일의 기본 구조는 다음과 같다: </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;
[...]
&lt;/hibernate-mapping&gt;</pre><p>Hibernate DTD is sophisticated. You can use it for auto-completion of XML mapping elements and attributes in your editor or IDE. Opening up the DTD file in your text editor is the easiest way to get an overview of all elements and attributes, and to view the defaults, as well as some comments. Hibernate will not load the DTD file from the web, but first look it up from the classpath of the application. The DTD file is included in <code class="filename">hibernate-core.jar</code> (it is also included in the <code class="filename">hibernate3.jar</code>, if using the distribution bundle). </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>중요</h2><p>We will omit the DTD declaration in future examples to shorten the code. It is, of course, not optional. </p></div><p>Between the two <code class="literal">hibernate-mapping</code> tags, include a <code class="literal">class</code> element. All persistent entity classes (again, there might be dependent classes later on, which are not first-class entities) need a mapping to a table in the SQL database: </p><pre class="programlisting">&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;

    &lt;class name="Event" table="EVENTS"&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>So far we have told Hibernate how to persist and load object of class <code class="literal">Event</code> to the table <code class="literal">EVENTS</code>. Each instance is now represented by a row in that table. Now we can continue by mapping the unique identifier property to the tables primary key. As we do not want to care about handling this identifier, we configure Hibernate's identifier generation strategy for a surrogate primary key column: </p><pre class="programlisting">&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;

    &lt;class name="Event" table="EVENTS"&gt;
        &lt;id name="id" column="EVENT_ID"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>The <code class="literal">id</code> element is the declaration of the identifier property. The <code class="literal">name="id"</code> mapping attribute declares the name of the JavaBean property and tells Hibernate to use the <code class="literal">getId()</code> and <code class="literal">setId()</code> methods to access the property. The column attribute tells Hibernate which column of the <code class="literal">EVENTS</code> table holds the primary key value. </p><p>The nested <code class="literal">generator</code> element specifies the identifier generation strategy (aka how are identifier values generated?). In this case we choose <code class="literal">native</code>, which offers a level of portability depending on the configured database dialect. Hibernate supports database generated, globally unique, as well as application assigned, identifiers. Identifier value generation is also one of Hibernate's many extension points and you can plugin in your own strategy. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>작은 정보</h2><p><code class="literal">native</code> is no longer consider the best strategy in terms of portability. for further discussion, see <a href="#portability-idgen" title="25.4. Identifier generation">25.4절. “Identifier generation”</a> </p></div><p>Lastly, we need to tell Hibernate about the remaining entity class properties. By default, no properties of the class are considered persistent: </p><pre class="programlisting">
&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;

    &lt;class name="Event" table="EVENTS"&gt;
        &lt;id name="id" column="EVENT_ID"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="date" type="timestamp" column="EVENT_DATE"/&gt;
        &lt;property name="title"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>Similar to the <code class="literal">id</code> element, the <code class="literal">name</code> attribute of the <code class="literal">property</code> element tells Hibernate which getter and setter methods to use. In this case, Hibernate will search for <code class="literal">getDate()</code>, <code class="literal">setDate()</code>, <code class="literal">getTitle()</code> and <code class="literal">setTitle()</code> methods. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>참고</h2><p>Why does the <code class="literal">date</code> property mapping include the <code class="literal">column</code> attribute, but the <code class="literal">title</code> does not? Without the <code class="literal">column</code> attribute, Hibernate by default uses the property name as the column name. This works for <code class="literal">title</code>, however, <code class="literal">date</code> is a reserved keyword in most databases so you will need to map it to a different name. </p></div><p>The <code class="literal">title</code> mapping also lacks a <code class="literal">type</code> attribute. The types declared and used in the mapping files are not Java data types; they are not SQL database types either. These types are called <span class="emphasis"><em>Hibernate mapping types</em></span>, converters which can translate from Java to SQL data types and vice versa. Again, Hibernate will try to determine the correct conversion and mapping type itself if the <code class="literal">type</code> attribute is not present in the mapping. In some cases this automatic detection using Reflection on the Java class might not have the default you expect or need. This is the case with the <code class="literal">date</code> property. Hibernate cannot know if the property, which is of <code class="literal">java.util.Date</code>, should map to a SQL <code class="literal">date</code>, <code class="literal">timestamp</code>, or <code class="literal">time</code> column. Full date and time information is preserved by mapping the property with a <code class="literal">timestamp</code> converter. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>작은 정보</h2><p>Hibernate makes this mapping type determination using reflection when the mapping files are processed. This can take time and resources, so if startup performance is important you should consider explicitly defining the type to use. </p></div><p>Save this mapping file as <code class="filename">src/main/resources/org/hibernate/tutorial/domain/Event.hbm.xml</code>. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-configuration"/>1.1.4. Hibernate 구성</h3></div></div></div><p>At this point, you should have the persistent class and its mapping file in place. It is now time to configure Hibernate. First let's set up HSQLDB to run in "server mode" </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>참고</h2><p>We do this do that the data remains between runs. </p></div><p>We will utilize the Maven exec plugin to launch the HSQLDB server by running: <code class="command"> mvn exec:java -Dexec.mainClass="org.hsqldb.Server" -Dexec.args="-database.0 file:target/data/tutorial"</code> You will see it start up and bind to a TCP/IP socket; this is where our application will connect later. If you want to start with a fresh database during this tutorial, shutdown HSQLDB, delete all files in the <code class="filename">target/data</code> directory, and start HSQLDB again. </p><p>Hibernate will be connecting to the database on behalf of your application, so it needs to know how to obtain connections. For this tutorial we will be using a standalone connection pool (as opposed to a <code class="interfacename">javax.sql.DataSource</code>). Hibernate comes with support for two third-party open source JDBC connection pools: <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://sourceforge.net/projects/c3p0">c3p0</a> and <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://proxool.sourceforge.net/">proxool</a>. However, we will be using the Hibernate built-in connection pool for this tutorial. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="caution"><h2>경고</h2><p>The built-in Hibernate connection pool is in no way intended for production use. It lacks several features found on any decent connection pool. </p></div><p>For Hibernate's configuration, we can use a simple <code class="literal">hibernate.properties</code> file, a more sophisticated <code class="literal">hibernate.cfg.xml</code> file, or even complete programmatic setup. Most users prefer the XML configuration file: </p><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;

&lt;hibernate-configuration&gt;

    &lt;session-factory&gt;

        &lt;!-- Database connection settings --&gt;
        &lt;property name="connection.driver_class"&gt;org.hsqldb.jdbcDriver&lt;/property&gt;
        &lt;property name="connection.url"&gt;jdbc:hsqldb:hsql://localhost&lt;/property&gt;
        &lt;property name="connection.username"&gt;sa&lt;/property&gt;
        &lt;property name="connection.password"&gt;&lt;/property&gt;

        &lt;!-- JDBC connection pool (use the built-in) --&gt;
        &lt;property name="connection.pool_size"&gt;1&lt;/property&gt;

        &lt;!-- SQL dialect --&gt;
        &lt;property name="dialect"&gt;org.hibernate.dialect.HSQLDialect&lt;/property&gt;

        &lt;!-- Enable Hibernate's automatic session context management --&gt;
        &lt;property name="current_session_context_class"&gt;thread&lt;/property&gt;

        &lt;!-- Disable the second-level cache  --&gt;
        &lt;property name="cache.provider_class"&gt;org.hibernate.cache.NoCacheProvider&lt;/property&gt;

        &lt;!-- Echo all executed SQL to stdout --&gt;
        &lt;property name="show_sql"&gt;true&lt;/property&gt;

        &lt;!-- Drop and re-create the database schema on startup --&gt;
        &lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt;

        &lt;mapping resource="org/hibernate/tutorial/domain/Event.hbm.xml"/&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>참고</h2><p>Notice that this configuration file specifies a different DTD</p></div><p>You configure Hibernate's <code class="literal">SessionFactory</code>. SessionFactory is a global factory responsible for a particular database. If you have several databases, for easier startup you should use several <code class="literal">&lt;session-factory&gt;</code> configurations in several configuration files. </p><p>The first four <code class="literal">property</code> elements contain the necessary configuration for the JDBC connection. The dialect <code class="literal">property</code> element specifies the particular SQL variant Hibernate generates. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>작은 정보</h2><p>In most cases, Hibernate is able to properly determine which dialect to use. See <a href="#portability-dialectresolver" title="25.3. Dialect resolution">25.3절. “Dialect resolution”</a> for more information. </p></div><p>Hibernate's automatic session management for persistence contexts is particularly useful in this context. The <code class="literal">hbm2ddl.auto</code> option turns on automatic generation of database schemas directly into the database. This can also be turned off by removing the configuration option, or redirected to a file with the help of the <code class="literal">SchemaExport</code> Ant task. Finally, add the mapping file(s) for persistent classes to the configuration. </p><p>Save this file as <code class="filename">hibernate.cfg.xml</code> into the <code class="filename">src/main/resources</code> directory. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-mvn"/>1.1.5. Building with Maven</h3></div></div></div><p>We will now build the tutorial with Maven. You will need to have Maven installed; it is available from the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://maven.apache.org/download.html">Maven download page</a>. Maven will read the <code class="filename">/pom.xml</code> file we created earlier and know how to perform some basic project tasks. First, lets run the <code class="literal">compile</code> goal to make sure we can compile everything so far: </p><pre class="programlisting">[hibernateTutorial]$ mvn compile
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Building First Hibernate Tutorial
[INFO]    task-segment: [compile]
[INFO] ------------------------------------------------------------------------
[INFO] [resources:resources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:compile]
[INFO] Compiling 1 source file to /home/steve/projects/sandbox/hibernateTutorial/target/classes
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 2 seconds
[INFO] Finished at: Tue Jun 09 12:25:25 CDT 2009
[INFO] Final Memory: 5M/547M
[INFO] ------------------------------------------------------------------------</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-helpers"/>1.1.6. 시작과 helper들</h3></div></div></div><p>It is time to load and store some <code class="literal">Event</code> objects, but first you have to complete the setup with some infrastructure code. You have to startup Hibernate by building a global <code class="interfacename">org.hibernate.SessionFactory</code> object and storing it somewhere for easy access in application code. A <code class="interfacename">org.hibernate.SessionFactory</code> is used to obtain <code class="interfacename">org.hibernate.Session</code> instances. A <code class="interfacename">org.hibernate.Session</code> represents a single-threaded unit of work. The <code class="interfacename">org.hibernate.SessionFactory</code> is a thread-safe global object that is instantiated once. </p><p>We will create a <code class="literal">HibernateUtil</code> helper class that takes care of startup and makes accessing the <code class="interfacename">org.hibernate.SessionFactory</code> more convenient. </p><pre class="programlisting">package org.hibernate.tutorial.util;

import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;

public class HibernateUtil {

    private static final SessionFactory sessionFactory = buildSessionFactory();

    private static SessionFactory buildSessionFactory() {
        try {
            // Create the SessionFactory from hibernate.cfg.xml
            return new Configuration().configure().buildSessionFactory();
        }
        catch (Throwable ex) {
            // Make sure you log the exception, as it might be swallowed
            System.err.println("Initial SessionFactory creation failed." + ex);
            throw new ExceptionInInitializerError(ex);
        }
    }

    public static SessionFactory getSessionFactory() {
        return sessionFactory;
    }

}</pre><p>Save this code as <code class="filename">src/main/java/org/hibernate/tutorial/util/HibernateUtil.java</code> </p><p>This class not only produces the global <code class="interfacename">org.hibernate.SessionFactory</code> reference in its static initializer; it also hides the fact that it uses a static singleton. We might just as well have looked up the <code class="interfacename">org.hibernate.SessionFactory</code> reference from JNDI in an application server or any other location for that matter. </p><p>If you give the <code class="interfacename">org.hibernate.SessionFactory</code> a name in your configuration, Hibernate will try to bind it to JNDI under that name after it has been built. Another, better option is to use a JMX deployment and let the JMX-capable container instantiate and bind a <code class="literal">HibernateService</code> to JNDI. Such advanced options are discussed later. </p><p>You now need to configure a logging system. Hibernate uses commons logging and provides two choices: Log4j and JDK 1.4 logging. Most developers prefer Log4j: copy <code class="literal">log4j.properties</code> from the Hibernate distribution in the <code class="literal">etc/</code> directory to your <code class="literal">src</code> directory, next to <code class="literal">hibernate.cfg.xml</code>. If you prefer to have more verbose output than that provided in the example configuration, you can change the settings. By default, only the Hibernate startup message is shown on stdout. </p><p>The tutorial infrastructure is complete and you are now ready to do some real work with Hibernate. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-firstapp-workingpersistence"/>1.1.7. 객체 로딩과 객체 저장</h3></div></div></div><p>We are now ready to start doing some real worjk with Hibernate. Let's start by writing an <code class="literal">EventManager</code> class with a <code class="literal">main()</code> method: </p><pre class="programlisting">package org.hibernate.tutorial;

import org.hibernate.Session;

import java.util.*;

import org.hibernate.tutorial.domain.Event;
import org.hibernate.tutorial.util.HibernateUtil;

public class EventManager {

    public static void main(String[] args) {
        EventManager mgr = new EventManager();

        if (args[0].equals("store")) {
            mgr.createAndStoreEvent("My Event", new Date());
        }

        HibernateUtil.getSessionFactory().close();
    }

    private void createAndStoreEvent(String title, Date theDate) {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();

        Event theEvent = new Event();
        theEvent.setTitle(title);
        theEvent.setDate(theDate);
        session.save(theEvent);

        session.getTransaction().commit();
    }

}</pre><p>In <code class="literal">createAndStoreEvent()</code> we created a new <code class="literal">Event</code> object and handed it over to Hibernate. At that point, Hibernate takes care of the SQL and executes an <code class="literal">INSERT</code> on the database. </p><p>A <span class="interface">org.hibernate.Session</span> is designed to represent a single unit of work (a single atmoic piece of work to be performed). For now we will keep things simple and assume a one-to-one granularity between a Hibernate <span class="interface">org.hibernate.Session</span> and a database transaction. To shield our code from the actual underlying transaction system we use the Hibernate <code class="interfacename">org.hibernate.Transaction</code> API. In this particular case we are using JDBC-based transactional semantics, but it could also run with JTA. </p><p>What does <code class="literal">sessionFactory.getCurrentSession()</code> do? First, you can call it as many times and anywhere you like once you get hold of your <code class="interfacename">org.hibernate.SessionFactory</code>. The <code class="literal">getCurrentSession()</code> method always returns the "current" unit of work. Remember that we switched the configuration option for this mechanism to "thread" in our <code class="filename">src/main/resources/hibernate.cfg.xml</code>? Due to that setting, the context of a current unit of work is bound to the current Java thread that executes the application. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>중요</h2><p>Hibernate offers three methods of current session tracking. The "thread" based method is not intended for production use; it is merely useful for prototyping and tutorials such as this one. Current session tracking is discussed in more detail later on. </p></div><p>A <span class="interface">org.hibernate.Session</span> begins when the first call to <code class="literal">getCurrentSession()</code> is made for the current thread. It is then bound by Hibernate to the current thread. When the transaction ends, either through commit or rollback, Hibernate automatically unbinds the <span class="interface">org.hibernate.Session</span> from the thread and closes it for you. If you call <code class="literal">getCurrentSession()</code> again, you get a new <span class="interface">org.hibernate.Session</span> and can start a new unit of work. </p><p>Related to the unit of work scope, should the Hibernate <span class="interface">org.hibernate.Session</span> be used to execute one or several database operations? The above example uses one <span class="interface">org.hibernate.Session</span> for one operation. However this is pure coincidence; the example is just not complex enough to show any other approach. The scope of a Hibernate <span class="interface">org.hibernate.Session</span> is flexible but you should never design your application to use a new Hibernate <span class="interface">org.hibernate.Session</span> for <span class="emphasis"><em>every</em></span> database operation. Even though it is used in the following examples, consider <span class="emphasis"><em>session-per-operation</em></span> an anti-pattern. A real web application is shown later in the tutorial which will help illustrate this. </p><p>See <a href="#transactions" title="11장. Transactions and Concurrency">11장. <i xmlns:xlink="http://www.w3.org/1999/xlink">Transactions and Concurrency</i></a> for more information about transaction handling and demarcation. The previous example also skipped any error handling and rollback. </p><p>To run this, we will make use of the Maven exec plugin to call our class with the necessary classpath setup: <code class="command">mvn exec:java -Dexec.mainClass="org.hibernate.tutorial.EventManager" -Dexec.args="store"</code> </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>참고</h2><p>You may need to perform <code class="command">mvn compile</code> first. </p></div><p>You should see Hibernate starting up and, depending on your configuration, lots of log output. Towards the end, the following line will be displayed: </p><pre class="programlisting">[java] Hibernate: insert into EVENTS (EVENT_DATE, title, EVENT_ID) values (?, ?, ?)</pre><p>This is the <code class="literal">INSERT</code> executed by Hibernate. </p><p>To list stored events an option is added to the main method: </p><pre class="programlisting">        if (args[0].equals("store")) {
            mgr.createAndStoreEvent("My Event", new Date());
        }
        else if (args[0].equals("list")) {
            List events = mgr.listEvents();
            for (int i = 0; i &lt; events.size(); i++) {
                Event theEvent = (Event) events.get(i);
                System.out.println(
                        "Event: " + theEvent.getTitle() + " Time: " + theEvent.getDate()
                );
            }
        }</pre><p>A new <code class="literal">listEvents() method is also added</code>: </p><pre class="programlisting">    private List listEvents() {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();
        List result = session.createQuery("from Event").list();
        session.getTransaction().commit();
        return result;
    }</pre><p>Here, we are using a Hibernate Query Language (HQL) query to load all existing <code class="literal">Event</code> objects from the database. Hibernate will generate the appropriate SQL, send it to the database and populate <code class="literal">Event</code> objects with the data. You can create more complex queries with HQL. See <a href="#queryhql" title="14장. HQL: 하이버네이트 질의 언어(Hibernate Query Language)">14장. <i xmlns:xlink="http://www.w3.org/1999/xlink">HQL: 하이버네이트 질의 언어(Hibernate Query Language)</i></a> for more information. </p><p>Now we can call our new functionality, again using the Maven exec plugin: <code class="command">mvn exec:java -Dexec.mainClass="org.hibernate.tutorial.EventManager" -Dexec.args="list"</code> </p></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial-associations"/>1.2. 파트 2 - 연관들을 매핑하기</h2></div></div></div><p>So far we have mapped a single persistent entity class to a table in isolation. Let's expand on that a bit and add some class associations. We will add people to the application and store a list of events in which they participate. </p><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-mappinguser"/>1.2.1. Person 클래스 매핑하기</h3></div></div></div><p>The first cut of the <code class="literal">Person</code> class looks like this: </p><pre class="programlisting">package org.hibernate.tutorial.domain;

public class Person {

    private Long id;
    private int age;
    private String firstname;
    private String lastname;

    public Person() {}

    // Accessor methods for all properties, private setter for 'id'

}</pre><p>Save this to a file named <code class="filename">src/main/java/org/hibernate/tutorial/domain/Person.java</code> </p><p>Next, create the new mapping file as <code class="filename">src/main/resources/org/hibernate/tutorial/domain/Person.hbm.xml</code> </p><pre class="programlisting">&lt;hibernate-mapping package="org.hibernate.tutorial.domain"&gt;

    &lt;class name="Person" table="PERSON"&gt;
        &lt;id name="id" column="PERSON_ID"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="age"/&gt;
        &lt;property name="firstname"/&gt;
        &lt;property name="lastname"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>마지막으로 새로운 매핑을 Hibernate의 구성에 추가하라: </p><pre class="programlisting">&lt;mapping resource="events/Event.hbm.xml"/&gt;
&lt;mapping resource="events/Person.hbm.xml"/&gt;</pre><p>Create an association between these two entities. Persons can participate in events, and events have participants. The design questions you have to deal with are: directionality, multiplicity, and collection behavior. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-unidirset"/>1.2.2. 단방향 Set-기반의 연관</h3></div></div></div><p>By adding a collection of events to the <code class="literal">Person</code> class, you can easily navigate to the events for a particular person, without executing an explicit query - by calling <code class="literal">Person#getEvents</code>. Multi-valued associations are represented in Hibernate by one of the Java Collection Framework contracts; here we choose a <code class="interfacename">java.util.Set</code> because the collection will not contain duplicate elements and the ordering is not relevant to our examples: </p><pre class="programlisting">public class Person {

    private Set events = new HashSet();

    public Set getEvents() {
        return events;
    }

    public void setEvents(Set events) {
        this.events = events;
    }
}</pre><p>Before mapping this association, let's consider the other side. We could just keep this unidirectional or create another collection on the <code class="literal">Event</code>, if we wanted to be able to navigate it from both directions. This is not necessary, from a functional perspective. You can always execute an explicit query to retrieve the participants for a particular event. This is a design choice left to you, but what is clear from this discussion is the multiplicity of the association: "many" valued on both sides is called a <span class="emphasis"><em>many-to-many</em></span> association. Hence, we use Hibernate's many-to-many mapping: </p><pre class="programlisting">&lt;class name="Person" table="PERSON"&gt;
    &lt;id name="id" column="PERSON_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="age"/&gt;
    &lt;property name="firstname"/&gt;
    &lt;property name="lastname"/&gt;

    &lt;set name="events" table="PERSON_EVENT"&gt;
        &lt;key column="PERSON_ID"/&gt;
        &lt;many-to-many column="EVENT_ID" class="Event"/&gt;
    &lt;/set&gt;

&lt;/class&gt;</pre><p>Hibernate supports a broad range of collection mappings, a <code class="literal">set</code> being most common. For a many-to-many association, or <span class="emphasis"><em>n:m</em></span> entity relationship, an association table is required. Each row in this table represents a link between a person and an event. The table name is decalred using the <code class="literal">table</code> attribute of the <code class="literal">set</code> element. The identifier column name in the association, for the person side, is defined with the <code class="literal">key</code> element, the column name for the event's side with the <code class="literal">column</code> attribute of the <code class="literal">many-to-many</code>. You also have to tell Hibernate the class of the objects in your collection (the class on the other side of the collection of references). </p><p>따라서 이 매핑을 위한 데이터베이스 스키마는 다음과 같다: </p><pre class="programlisting">
    _____________        __________________
   |             |      |                  |       _____________
   |   EVENTS    |      |   PERSON_EVENT   |      |             |
   |_____________|      |__________________|      |    PERSON   |
   |             |      |                  |      |_____________|
   | *EVENT_ID   | &lt;--&gt; | *EVENT_ID        |      |             |
   |  EVENT_DATE |      | *PERSON_ID       | &lt;--&gt; | *PERSON_ID  |
   |  TITLE      |      |__________________|      |  AGE        |
   |_____________|                                |  FIRSTNAME  |
                                                  |  LASTNAME   |
                                                  |_____________|
 </pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-working"/>1.2.3. 연관들에 작업하기</h3></div></div></div><p>Now we will bring some people and events together in a new method in <code class="literal">EventManager</code>: </p><pre class="programlisting">    private void addPersonToEvent(Long personId, Long eventId) {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();

        Person aPerson = (Person) session.load(Person.class, personId);
        Event anEvent = (Event) session.load(Event.class, eventId);
        aPerson.getEvents().add(anEvent);

        session.getTransaction().commit();
    }</pre><p>After loading a <code class="literal">Person</code> and an <code class="literal">Event</code>, simply modify the collection using the normal collection methods. There is no explicit call to <code class="literal">update()</code> or <code class="literal">save()</code>; Hibernate automatically detects that the collection has been modified and needs to be updated. This is called <span class="emphasis"><em>automatic dirty checking</em></span>. You can also try it by modifying the name or the date property of any of your objects. As long as they are in <span class="emphasis"><em>persistent</em></span> state, that is, bound to a particular Hibernate <code class="interfacename">org.hibernate.Session</code>, Hibernate monitors any changes and executes SQL in a write-behind fashion. The process of synchronizing the memory state with the database, usually only at the end of a unit of work, is called <span class="emphasis"><em>flushing</em></span>. In our code, the unit of work ends with a commit, or rollback, of the database transaction. </p><p>You can load person and event in different units of work. Or you can modify an object outside of a <code class="interfacename">org.hibernate.Session</code>, when it is not in persistent state (if it was persistent before, this state is called <span class="emphasis"><em>detached</em></span>). You can even modify a collection when it is detached: </p><pre class="programlisting">    private void addPersonToEvent(Long personId, Long eventId) {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();

        Person aPerson = (Person) session
                .createQuery("select p from Person p left join fetch p.events where p.id = :pid")
                .setParameter("pid", personId)
                .uniqueResult(); // Eager fetch the collection so we can use it detached
        Event anEvent = (Event) session.load(Event.class, eventId);

        session.getTransaction().commit();

        // End of first unit of work

        aPerson.getEvents().add(anEvent); // aPerson (and its collection) is detached

        // Begin second unit of work

        Session session2 = HibernateUtil.getSessionFactory().getCurrentSession();
        session2.beginTransaction();
        session2.update(aPerson); // Reattachment of aPerson

        session2.getTransaction().commit();
    }</pre><p>The call to <code class="literal">update</code> makes a detached object persistent again by binding it to a new unit of work, so any modifications you made to it while detached can be saved to the database. This includes any modifications (additions/deletions) you made to a collection of that entity object. </p><p>This is not much use in our example, but it is an important concept you can incorporate into your own application. Complete this exercise by adding a new action to the main method of the <code class="literal">EventManager</code> and call it from the command line. If you need the identifiers of a person and an event - the <code class="literal">save()</code> method returns it (you might have to modify some of the previous methods to return that identifier): </p><pre class="programlisting">        else if (args[0].equals("addpersontoevent")) {
            Long eventId = mgr.createAndStoreEvent("My Event", new Date());
            Long personId = mgr.createAndStorePerson("Foo", "Bar");
            mgr.addPersonToEvent(personId, eventId);
            System.out.println("Added person " + personId + " to event " + eventId);
        }</pre><p>This is an example of an association between two equally important classes : two entities. As mentioned earlier, there are other classes and types in a typical model, usually "less important". Some you have already seen, like an <code class="literal">int</code> or a <code class="classname">java.lang.String</code>. We call these classes <span class="emphasis"><em>value types</em></span>, and their instances <span class="emphasis"><em>depend</em></span> on a particular entity. Instances of these types do not have their own identity, nor are they shared between entities. Two persons do not reference the same <code class="literal">firstname</code> object, even if they have the same first name. Value types cannot only be found in the JDK , but you can also write dependent classes yourself such as an <code class="literal">Address</code> or <code class="literal">MonetaryAmount</code> class. In fact, in a Hibernate application all JDK classes are considered value types. </p><p>You can also design a collection of value types. This is conceptually different from a collection of references to other entities, but looks almost the same in Java. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-valuecollections"/>1.2.4. 값들을 가진 콜렉션</h3></div></div></div><p>Let's add a collection of email addresses to the <code class="literal">Person</code> entity. This will be represented as a <code class="interfacename">java.util.Set</code> of <code class="classname">java.lang.String</code> instances: </p><pre class="programlisting">    private Set emailAddresses = new HashSet();

    public Set getEmailAddresses() {
        return emailAddresses;
    }

    public void setEmailAddresses(Set emailAddresses) {
        this.emailAddresses = emailAddresses;
    }</pre><p>The mapping of this <code class="literal">Set</code> is as follows: </p><pre class="programlisting">        &lt;set name="emailAddresses" table="PERSON_EMAIL_ADDR"&gt;
            &lt;key column="PERSON_ID"/&gt;
            &lt;element type="string" column="EMAIL_ADDR"/&gt;
        &lt;/set&gt;</pre><p>The difference compared with the earlier mapping is the use of the <code class="literal">element</code> part which tells Hibernate that the collection does not contain references to another entity, but is rather a collection whose elements are values types, here specifically of type <code class="literal">string</code>. The lowercase name tells you it is a Hibernate mapping type/converter. Again the <code class="literal">table</code> attribute of the <code class="literal">set</code> element determines the table name for the collection. The <code class="literal">key</code> element defines the foreign-key column name in the collection table. The <code class="literal">column</code> attribute in the <code class="literal">element</code> element defines the column name where the email address values will actually be stored. </p><p>Here is the updated schema: </p><pre class="programlisting">
  _____________        __________________
 |             |      |                  |       _____________
 |   EVENTS    |      |   PERSON_EVENT   |      |             |       ___________________
 |_____________|      |__________________|      |    PERSON   |      |                   |
 |             |      |                  |      |_____________|      | PERSON_EMAIL_ADDR |
 | *EVENT_ID   | &lt;--&gt; | *EVENT_ID        |      |             |      |___________________|
 |  EVENT_DATE |      | *PERSON_ID       | &lt;--&gt; | *PERSON_ID  | &lt;--&gt; |  *PERSON_ID       |
 |  TITLE      |      |__________________|      |  AGE        |      |  *EMAIL_ADDR      |
 |_____________|                                |  FIRSTNAME  |      |___________________|
                                                |  LASTNAME   |
                                                |_____________|
 </pre><p>You can see that the primary key of the collection table is in fact a composite key that uses both columns. This also implies that there cannot be duplicate email addresses per person, which is exactly the semantics we need for a set in Java. </p><p>You can now try to add elements to this collection, just like we did before by linking persons and events. It is the same code in Java: </p><pre class="programlisting">    private void addEmailToPerson(Long personId, String emailAddress) {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        session.beginTransaction();

        Person aPerson = (Person) session.load(Person.class, personId);
        // adding to the emailAddress collection might trigger a lazy load of the collection
        aPerson.getEmailAddresses().add(emailAddress);

        session.getTransaction().commit();
    }</pre><p>This time we did not use a <span class="emphasis"><em>fetch</em></span> query to initialize the collection. Monitor the SQL log and try to optimize this with an eager fetch. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-bidirectional"/>1.2.5. Bi-directional associations</h3></div></div></div><p>Next you will map a bi-directional association. You will make the association between person and event work from both sides in Java. The database schema does not change, so you will still have many-to-many multiplicity. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>참고</h2><p>A relational database is more flexible than a network programming language, in that it does not need a navigation direction; data can be viewed and retrieved in any possible way. </p></div><p>First, add a collection of participants to the <code class="literal">Event</code> class: </p><pre class="programlisting">    private Set participants = new HashSet();

    public Set getParticipants() {
        return participants;
    }

    public void setParticipants(Set participants) {
        this.participants = participants;
    }</pre><p>Now map this side of the association in <code class="literal">Event.hbm.xml</code>. </p><pre class="programlisting">        &lt;set name="participants" table="PERSON_EVENT" inverse="true"&gt;
            &lt;key column="EVENT_ID"/&gt;
            &lt;many-to-many column="PERSON_ID" class="events.Person"/&gt;
        &lt;/set&gt;</pre><p>These are normal <code class="literal">set</code> mappings in both mapping documents. Notice that the column names in <code class="literal">key</code> and <code class="literal">many-to-many</code> swap in both mapping documents. The most important addition here is the <code class="literal">inverse="true"</code> attribute in the <code class="literal">set</code> element of the <code class="literal">Event</code>'s collection mapping. </p><p>What this means is that Hibernate should take the other side, the <code class="literal">Person</code> class, when it needs to find out information about the link between the two. This will be a lot easier to understand once you see how the bi-directional link between our two entities is created. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-associations-usingbidir"/>1.2.6. 양방향 링크들에 작업하기</h3></div></div></div><p>First, keep in mind that Hibernate does not affect normal Java semantics. How did we create a link between a <code class="literal">Person</code> and an <code class="literal">Event</code> in the unidirectional example? You add an instance of <code class="literal">Event</code> to the collection of event references, of an instance of <code class="literal">Person</code>. If you want to make this link bi-directional, you have to do the same on the other side by adding a <code class="literal">Person</code> reference to the collection in an <code class="literal">Event</code>. This process of "setting the link on both sides" is absolutely necessary with bi-directional links. </p><p>Many developers program defensively and create link management methods to correctly set both sides (for example, in <code class="literal">Person</code>): </p><pre class="programlisting">    protected Set getEvents() {
        return events;
    }

    protected void setEvents(Set events) {
        this.events = events;
    }

    public void addToEvent(Event event) {
        this.getEvents().add(event);
        event.getParticipants().add(this);
    }

    public void removeFromEvent(Event event) {
        this.getEvents().remove(event);
        event.getParticipants().remove(this);
    }</pre><p>The get and set methods for the collection are now protected. This allows classes in the same package and subclasses to still access the methods, but prevents everybody else from altering the collections directly. Repeat the steps for the collection on the other side. </p><p>What about the <code class="literal">inverse</code> mapping attribute? For you, and for Java, a bi-directional link is simply a matter of setting the references on both sides correctly. Hibernate, however, does not have enough information to correctly arrange SQL <code class="literal">INSERT</code> and <code class="literal">UPDATE</code> statements (to avoid constraint violations). Making one side of the association <code class="literal">inverse</code> tells Hibernate to consider it a <span class="emphasis"><em>mirror</em></span> of the other side. That is all that is necessary for Hibernate to resolve any issues that arise when transforming a directional navigation model to a SQL database schema. The rules are straightforward: all bi-directional associations need one side as <code class="literal">inverse</code>. In a one-to-many association it has to be the many-side, and in many-to-many association you can select either side. </p></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial-webapp"/>1.3. 파트 3 - EventManager 웹 어플리케이션</h2></div></div></div><p>A Hibernate web application uses <code class="literal">Session</code> and <code class="literal">Transaction</code> almost like a standalone application. However, some common patterns are useful. You can now write an <code class="literal">EventManagerServlet</code>. This servlet can list all events stored in the database, and it provides an HTML form to enter new events. </p><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-webapp-servlet"/>1.3.1. 기본 서블릿 작성하기</h3></div></div></div><p>First we need create our basic processing servlet. Since our servlet only handles HTTP <code class="literal">GET</code> requests, we will only implement the <code class="literal">doGet()</code> method: </p><pre class="programlisting">package org.hibernate.tutorial.web;

// Imports

public class EventManagerServlet extends HttpServlet {

    protected void doGet(
            HttpServletRequest request,
            HttpServletResponse response) throws ServletException, IOException {

        SimpleDateFormat dateFormatter = new SimpleDateFormat( "dd.MM.yyyy" );

        try {
            // Begin unit of work
            HibernateUtil.getSessionFactory().getCurrentSession().beginTransaction();

            // Process request and render page...

            // End unit of work
            HibernateUtil.getSessionFactory().getCurrentSession().getTransaction().commit();
        }
        catch (Exception ex) {
            HibernateUtil.getSessionFactory().getCurrentSession().getTransaction().rollback();
            if ( ServletException.class.isInstance( ex ) ) {
                throw ( ServletException ) ex;
            }
            else {
                throw new ServletException( ex );
            }
        }
    }

}</pre><p>Save this servlet as <code class="filename">src/main/java/org/hibernate/tutorial/web/EventManagerServlet.java</code> </p><p>The pattern applied here is called <span class="emphasis"><em>session-per-request</em></span>. When a request hits the servlet, a new Hibernate <code class="literal">Session</code> is opened through the first call to <code class="literal">getCurrentSession()</code> on the <code class="literal">SessionFactory</code>. A database transaction is then started. All data access occurs inside a transaction irrespective of whether the data is read or written. Do not use the auto-commit mode in applications. </p><p>모든 데이터베이스 오퍼레이션 각각에 대해 새로운 Hibernate <code class="literal">Session</code>을 사용하지 <span class="emphasis"><em>말라</em></span>. 전체 요청에 대해 영역지워진 한 개의 Hibernate <code class="literal">Session</code>을 사용하라. 그것이 자동적으로 현재의 자바 쓰레드에 바인드되도록 <code class="literal">getCurrentSession()</code>을 사용하라. </p><p>Next, the possible actions of the request are processed and the response HTML is rendered. We will get to that part soon. </p><p>Finally, the unit of work ends when processing and rendering are complete. If any problems occurred during processing or rendering, an exception will be thrown and the database transaction rolled back. This completes the <code class="literal">session-per-request</code> pattern. Instead of the transaction demarcation code in every servlet, you could also write a servlet filter. See the Hibernate website and Wiki for more information about this pattern called <span class="emphasis"><em>Open Session in View</em></span>. You will need it as soon as you consider rendering your view in JSP, not in a servlet. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-webapp-processing"/>1.3.2. 프로세싱과 렌더링</h3></div></div></div><p>Now you can implement the processing of the request and the rendering of the page. </p><pre class="programlisting">        // Write HTML header
        PrintWriter out = response.getWriter();
        out.println("&lt;html&gt;&lt;head&gt;&lt;title&gt;Event Manager&lt;/title&gt;&lt;/head&gt;&lt;body&gt;");

        // Handle actions
        if ( "store".equals(request.getParameter("action")) ) {

            String eventTitle = request.getParameter("eventTitle");
            String eventDate = request.getParameter("eventDate");

            if ( "".equals(eventTitle) || "".equals(eventDate) ) {
                out.println("&lt;b&gt;&lt;i&gt;Please enter event title and date.&lt;/i&gt;&lt;/b&gt;");
            }
            else {
                createAndStoreEvent(eventTitle, dateFormatter.parse(eventDate));
                out.println("&lt;b&gt;&lt;i&gt;Added event.&lt;/i&gt;&lt;/b&gt;");
            }
        }

        // Print page
       printEventForm(out);
       listEvents(out, dateFormatter);

       // Write HTML footer
       out.println("&lt;/body&gt;&lt;/html&gt;");
       out.flush();
       out.close();</pre><p>This coding style, with a mix of Java and HTML, would not scale in a more complex application-keep in mind that we are only illustrating basic Hibernate concepts in this tutorial. The code prints an HTML header and a footer. Inside this page, an HTML form for event entry and a list of all events in the database are printed. The first method is trivial and only outputs HTML: </p><pre class="programlisting">    private void printEventForm(PrintWriter out) {
        out.println("&lt;h2&gt;Add new event:&lt;/h2&gt;");
        out.println("&lt;form&gt;");
        out.println("Title: &lt;input name='eventTitle' length='50'/&gt;&lt;br/&gt;");
        out.println("Date (e.g. 24.12.2009): &lt;input name='eventDate' length='10'/&gt;&lt;br/&gt;");
        out.println("&lt;input type='submit' name='action' value='store'/&gt;");
        out.println("&lt;/form&gt;");
    }</pre><p><code class="literal">listEvents()</code> 메소드는 하나의 질의를 실행하기 위해서 현재의 쓰레드에 결합된 Hibernate <code class="literal">Session</code>을 사용한다: </p><pre class="programlisting">    private void listEvents(PrintWriter out, SimpleDateFormat dateFormatter) {

        List result = HibernateUtil.getSessionFactory()
                .getCurrentSession().createCriteria(Event.class).list();
        if (result.size() &gt; 0) {
            out.println("&lt;h2&gt;Events in database:&lt;/h2&gt;");
            out.println("&lt;table border='1'&gt;");
            out.println("&lt;tr&gt;");
            out.println("&lt;th&gt;Event title&lt;/th&gt;");
            out.println("&lt;th&gt;Event date&lt;/th&gt;");
            out.println("&lt;/tr&gt;");
            Iterator it = result.iterator();
            while (it.hasNext()) {
                Event event = (Event) it.next();
                out.println("&lt;tr&gt;");
                out.println("&lt;td&gt;" + event.getTitle() + "&lt;/td&gt;");
                out.println("&lt;td&gt;" + dateFormatter.format(event.getDate()) + "&lt;/td&gt;");
                out.println("&lt;/tr&gt;");
            }
            out.println("&lt;/table&gt;");
        }
    }</pre><p>마지막으로, <code class="literal">store</code> 액션은 <code class="literal">createAndStoreEvent()</code> 메소드로 디스패치된다. 그것은 현재 쓰레드의 <code class="literal">Session</code>을 사용한다: </p><pre class="programlisting">    protected void createAndStoreEvent(String title, Date theDate) {
        Event theEvent = new Event();
        theEvent.setTitle(title);
        theEvent.setDate(theDate);

        HibernateUtil.getSessionFactory()
                .getCurrentSession().save(theEvent);
    }</pre><p>The servlet is now complete. A request to the servlet will be processed in a single <code class="literal">Session</code> and <code class="literal">Transaction</code>. As earlier in the standalone application, Hibernate can automatically bind these objects to the current thread of execution. This gives you the freedom to layer your code and access the <code class="literal">SessionFactory</code> in any way you like. Usually you would use a more sophisticated design and move the data access code into data access objects (the DAO pattern). See the Hibernate Wiki for more examples. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="tutorial-webapp-deploy"/>1.3.3. 배치하기 그리고 테스트하기</h3></div></div></div><p>To deploy this application for testing we must create a Web ARchive (WAR). First we must define the WAR descriptor as <code class="filename">src/main/webapp/WEB-INF/web.xml</code> </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="2.4"
    xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;Event Manager&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.hibernate.tutorial.web.EventManagerServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Event Manager&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/eventmanager&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre><p>To build and deploy call <code class="literal">mvn package</code> in your project directory and copy the <code class="filename">hibernate-tutorial.war</code> file into your Tomcat <code class="filename">webapps</code> directory. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>참고</h2><p>If you do not have Tomcat installed, download it from <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://tomcat.apache.org/">http://tomcat.apache.org/</a> and follow the installation instructions. Our application requires no changes to the standard Tomcat configuration. </p></div><p>일단 배치했고 Tomcat이 실행중이면, <code class="literal">http://localhost:8080/hibernate-tutorial/eventmanager</code>로 어플리케이션에 접근하라. 첫 번째 요청이 당신의 서블릿에 도달할 때 Hibernate가 초기화(<code class="literal">HibernateUtil</code> 내에 있는 static initializer가 호출된다) 되는 것을 보기 위해 그리고 만일 어떤 예외상황들이 발생할 경우 상세한 출력을 얻기 위해서 Tomcat 로그를 지켜보도록 하라. </p></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="tutorial-summary"/>1.4. 요약</h2></div></div></div><p>This tutorial covered the basics of writing a simple standalone Hibernate application and a small web application. More tutorials are available from the Hibernate <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://hibernate.org">website</a>. </p></div></div><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture"/>2장. 아키텍처</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#architecture-overview">2.1. 개요</a></span></dt><dt><span class="sect1"><a href="#architecture-states">2.2. 인스턴스 상태들</a></span></dt><dt><span class="sect1"><a href="#architecture-jmx">2.3. JMX 통합</a></span></dt><dt><span class="sect1"><a href="#architecture-jca">2.4. JCA 지원</a></span></dt><dt><span class="sect1"><a href="#architecture-current-session">2.5. Contextual sessions</a></span></dt></dl></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-overview"/>2.1. 개요</h2></div></div></div><p>The diagram below provides a high-level view of the Hibernate architecture: </p><div class="mediaobject" align="center"><img src="../images/overview.png" align="middle"/></div><p>We do not have the scope in this document to provide a more detailed view of all the runtime architectures available; Hibernate is flexible and supports several different approaches. We will, however, show the two extremes: "minimal" architecture and "comprehensive" architecture. </p><p>This next diagram illustrates how Hibernate utilizes database and configuration data to provide persistence services, and persistent objects, to the application. </p><p>The "minimal" architecture has the application provide its own JDBC connections and manage its own transactions. This approach uses a minimal subset of Hibernate's APIs: </p><div class="mediaobject" align="center"><img src="../images/lite.png" align="middle"/></div><p>The "comprehensive" architecture abstracts the application away from the underlying JDBC/JTA APIs and allows Hibernate to manage the details. </p><div class="mediaobject" align="center"><img src="../images/full_cream.png" align="middle"/></div><p>Here are some definitions of the objects depicted in the diagrams: </p><div class="variablelist"><dl><dt><span class="term">SessionFactory (<code class="literal">org.hibernate.SessionFactory</code>)</span></dt><dd><p>A threadsafe, immutable cache of compiled mappings for a single database. A factory for <code class="literal">Session</code> and a client of <code class="literal">ConnectionProvider</code>, <code class="literal">SessionFactory</code> can hold an optional (second-level) cache of data that is reusable between transactions at a process, or cluster, level. </p></dd><dt><span class="term">Session (<code class="literal">org.hibernate.Session</code>)</span></dt><dd><p>A single-threaded, short-lived object representing a conversation between the application and the persistent store. It wraps a JDBC connection and is a factory for <code class="literal">Transaction</code>. <code class="literal">Session</code> holds a mandatory first-level cache of persistent objects that are used when navigating the object graph or looking up objects by identifier. </p></dd><dt><span class="term">영속 객체들과 콜렉션들</span></dt><dd><p>Short-lived, single threaded objects containing persistent state and business function. These can be ordinary JavaBeans/POJOs. They are associated with exactly one <code class="literal">Session</code>. Once the <code class="literal">Session</code> is closed, they will be detached and free to use in any application layer (for example, directly as data transfer objects to and from presentation). </p></dd><dt><span class="term">전이(Transient, 필자 주-과도) 객체들과 콜렉션들</span></dt><dd><p>Instances of persistent classes that are not currently associated with a <code class="literal">Session</code>. They may have been instantiated by the application and not yet persisted, or they may have been instantiated by a closed <code class="literal">Session</code>. </p></dd><dt><span class="term">Transaction (<code class="literal">org.hibernate.Transaction</code>)</span></dt><dd><p>(Optional) A single-threaded, short-lived object used by the application to specify atomic units of work. It abstracts the application from the underlying JDBC, JTA or CORBA transaction. A <code class="literal">Session</code> might span several <code class="literal">Transaction</code>s in some cases. However, transaction demarcation, either using the underlying API or <code class="literal">Transaction</code>, is never optional. </p></dd><dt><span class="term">ConnectionProvider (<code class="literal">org.hibernate.connection.ConnectionProvider</code>)</span></dt><dd><p>(Optional) A factory for, and pool of, JDBC connections. It abstracts the application from underlying <code class="literal">Datasource</code> or <code class="literal">DriverManager</code>. It is not exposed to application, but it can be extended and/or implemented by the developer. </p></dd><dt><span class="term">TransactionFactory (<code class="literal">org.hibernate.TransactionFactory</code>)</span></dt><dd><p>(Optional) A factory for <code class="literal">Transaction</code> instances. It is not exposed to the application, but it can be extended and/or implemented by the developer. </p></dd><dt><span class="term"><span class="emphasis"><em>Extension Interfaces</em></span></span></dt><dd><p>Hibernate offers a range of optional extension interfaces you can implement to customize the behavior of your persistence layer. See the API documentation for details. </p></dd></dl></div><p>
        </p><p>Given a "minimal" architecture, the application bypasses the <code class="literal">Transaction</code>/<code class="literal">TransactionFactory</code> and/or <code class="literal">ConnectionProvider</code> APIs to communicate with JTA or JDBC directly. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-states"/>2.2. 인스턴스 상태들</h2></div></div></div><p>An instance of a persistent class can be in one of three different states. These states are defined in relation to a <span class="emphasis"><em>persistence context</em></span>. The Hibernate <code class="literal">Session</code> object is the persistence context. The three different states are as follows: </p><div class="variablelist"><dl><dt><span class="term">transient</span></dt><dd><p>The instance is not associated with any persistence context. It has no persistent identity or primary key value. </p></dd><dt><span class="term">persistent</span></dt><dd><p>The instance is currently associated with a persistence context. It has a persistent identity (primary key value) and can have a corresponding row in the database. For a particular persistence context, Hibernate <span class="emphasis"><em>guarantees</em></span> that persistent identity is equivalent to Java identity in relation to the in-memory location of the object. </p></dd><dt><span class="term">detached</span></dt><dd><p>The instance was once associated with a persistence context, but that context was closed, or the instance was serialized to another process. It has a persistent identity and can have a corresponding row in the database. For detached instances, Hibernate does not guarantee the relationship between persistent identity and Java identity. </p></dd></dl></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-jmx"/>2.3. JMX 통합</h2></div></div></div><p>JMX is the J2EE standard for the management of Java components. Hibernate can be managed via a JMX standard service. AN MBean implementation is provided in the distribution: <code class="literal">org.hibernate.jmx.HibernateService</code>. </p><p>For an example of how to deploy Hibernate as a JMX service on the JBoss Application Server, please see the JBoss User Guide. JBoss AS also provides these benefits if you deploy using JMX: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Session Management</em></span>: the Hibernate <code class="literal">Session</code>'s life cycle can be automatically bound to the scope of a JTA transaction. This means that you no longer have to manually open and close the <code class="literal">Session</code>; this becomes the job of a JBoss EJB interceptor. You also do not have to worry about transaction demarcation in your code (if you would like to write a portable persistence layer use the optional Hibernate <code class="literal">Transaction</code> API for this). You call the <code class="literal">HibernateContext</code> to access a <code class="literal">Session</code>. </p></li><li><p><span class="emphasis"><em>HAR deployment</em></span>: the Hibernate JMX service is deployed using a JBoss service deployment descriptor in an EAR and/or SAR file, as it supports all the usual configuration options of a Hibernate <code class="literal">SessionFactory</code>. However, you still need to name all your mapping files in the deployment descriptor. If you use the optional HAR deployment, JBoss will automatically detect all mapping files in your HAR file. </p></li></ul></div><p>이들 옵션들에 대한 추가 정보는 JBoss 어플리케이션 서버 사용자 가이드를 참조하라. </p><p>Another feature available as a JMX service is runtime Hibernate statistics. See <a href="#configuration-optional-statistics" title="3.4.6. Hibernate 통계">3.4.6절. “Hibernate 통계”</a> for more information. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-jca"/>2.4. JCA 지원</h2></div></div></div><p>Hibernate can also be configured as a JCA connector. Please see the website for more information. Please note, however, that at this stage Hibernate JCA support is under development. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-current-session"/>2.5. Contextual sessions</h2></div></div></div><p>Most applications using Hibernate need some form of "contextual" session, where a given session is in effect throughout the scope of a given context. However, across applications the definition of what constitutes a context is typically different; different contexts define different scopes to the notion of current. Applications using Hibernate prior to version 3.0 tended to utilize either home-grown <code class="literal">ThreadLocal</code>-based contextual sessions, helper classes such as <code class="literal">HibernateUtil</code>, or utilized third-party frameworks, such as Spring or Pico, which provided proxy/interception-based contextual sessions. </p><p>Starting with version 3.0.1, Hibernate added the <code class="literal">SessionFactory.getCurrentSession()</code> method. Initially, this assumed usage of <code class="literal">JTA</code> transactions, where the <code class="literal">JTA</code> transaction defined both the scope and context of a current session. Given the maturity of the numerous stand-alone <code class="literal">JTA TransactionManager</code> implementations, most, if not all, applications should be using <code class="literal">JTA</code> transaction management, whether or not they are deployed into a <code class="literal">J2EE</code> container. Based on that, the <code class="literal">JTA</code>-based contextual sessions are all you need to use. </p><p>However, as of version 3.1, the processing behind <code class="literal">SessionFactory.getCurrentSession()</code> is now pluggable. To that end, a new extension interface, <code class="literal">org.hibernate.context.CurrentSessionContext</code>, and a new configuration parameter, <code class="literal">hibernate.current_session_context_class</code>, have been added to allow pluggability of the scope and context of defining current sessions. </p><p>See the Javadocs for the <code class="literal">org.hibernate.context.CurrentSessionContext</code> interface for a detailed discussion of its contract. It defines a single method, <code class="literal">currentSession()</code>, by which the implementation is responsible for tracking the current contextual session. Out-of-the-box, Hibernate comes with three implementations of this interface: </p><div class="itemizedlist"><ul><li><p><code class="literal">org.hibernate.context.JTASessionContext</code>: current sessions are tracked and scoped by a <code class="literal">JTA</code> transaction. The processing here is exactly the same as in the older JTA-only approach. See the Javadocs for details. </p></li><li><p><code class="literal">org.hibernate.context.ThreadLocalSessionContext</code>:current sessions are tracked by thread of execution. See the Javadocs for details. </p></li><li><p><code class="literal">org.hibernate.context.ManagedSessionContext</code>: current sessions are tracked by thread of execution. However, you are responsible to bind and unbind a <code class="literal">Session</code> instance with static methods on this class: it does not open, flush, or close a <code class="literal">Session</code>. </p></li></ul></div><p>The first two implementations provide a "one session - one database transaction" programming model. This is also also known and used as <span class="emphasis"><em>session-per-request</em></span>. The beginning and end of a Hibernate session is defined by the duration of a database transaction. If you use programmatic transaction demarcation in plain JSE without JTA, you are advised to use the Hibernate <code class="literal">Transaction</code> API to hide the underlying transaction system from your code. If you use JTA, you can utilize the JTA interfaces to demarcate transactions. If you execute in an EJB container that supports CMT, transaction boundaries are defined declaratively and you do not need any transaction or session demarcation operations in your code. Refer to <a href="#transactions" title="11장. Transactions and Concurrency">11장. <i xmlns:xlink="http://www.w3.org/1999/xlink">Transactions and Concurrency</i></a> for more information and code examples. </p><p>The <code class="literal">hibernate.current_session_context_class</code> configuration parameter defines which <code class="literal">org.hibernate.context.CurrentSessionContext</code> implementation should be used. For backwards compatibility, if this configuration parameter is not set but a <code class="literal">org.hibernate.transaction.TransactionManagerLookup</code> is configured, Hibernate will use the <code class="literal">org.hibernate.context.JTASessionContext</code>. Typically, the value of this parameter would just name the implementation class to use. For the three out-of-the-box implementations, however, there are three corresponding short names: "jta", "thread", and "managed". </p></div></div><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="session-configuration"/>3장. 구성</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#configuration-programmatic">3.1. 프로그램 상의 구성</a></span></dt><dt><span class="sect1"><a href="#configuration-sessionfactory">3.2. SessionFactory 얻기</a></span></dt><dt><span class="sect1"><a href="#configuration-hibernatejdbc">3.3. JDBC 커넥션들</a></span></dt><dt><span class="sect1"><a href="#configuration-optional">3.4. 선택적인 구성 프로퍼티들</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuration-optional-dialects">3.4.1. SQL Dialects</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-outerjoin">3.4.2. Outer Join Fetching</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-binarystreams">3.4.3. Binary Streams</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-cacheprovider">3.4.4. Second-level 캐시와 query 캐시</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-querysubstitution">3.4.5. Query Language 치환</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-statistics">3.4.6. Hibernate 통계</a></span></dt></dl></dd><dt><span class="sect1"><a href="#configuration-logging">3.5. 로깅</a></span></dt><dt><span class="sect1"><a href="#configuration-namingstrategy">3.6. <code class="literal">NamingStrategy</code> 구현하기</a></span></dt><dt><span class="sect1"><a href="#configuration-xmlconfig">3.7. XML 구성 파일</a></span></dt><dt><span class="sect1"><a href="#configuration-j2ee">3.8. J2EE 어플리케이션 서버 통합</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuration-optional-transactionstrategy">3.8.1. 트랜잭션 방도 구성</a></span></dt><dt><span class="sect2"><a href="#configuration-optional-jndi">3.8.2. JNDI-bound <code class="literal">SessionFactory</code></a></span></dt><dt><span class="sect2"><a href="#configuration-j2ee-currentsession">3.8.3. Current Session context management with JTA</a></span></dt><dt><span class="sect2"><a href="#configuration-j2ee-jmx">3.8.4. JMX 배치</a></span></dt></dl></dd></dl></div><p>Hibernate is designed to operate in many different environments and, as such, there is a broad range of configuration parameters. Fortunately, most have sensible default values and Hibernate is distributed with an example <code class="literal">hibernate.properties</code> file in <code class="literal">etc/</code> that displays the various options. Simply put the example file in your classpath and customize it to suit your needs. </p><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-programmatic"/>3.1. 프로그램 상의 구성</h2></div></div></div><p>An instance of <code class="classname">org.hibernate.cfg.Configuration</code> represents an entire set of mappings of an application's Java types to an SQL database. The <code class="classname">org.hibernate.cfg.Configuration</code> is used to build an immutable <code class="interfacename">org.hibernate.SessionFactory</code>. The mappings are compiled from various XML mapping files. </p><p>You can obtain a <code class="classname">org.hibernate.cfg.Configuration</code> instance by instantiating it directly and specifying XML mapping documents. If the mapping files are in the classpath, use <code class="literal">addResource()</code>. For example: </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addResource("Item.hbm.xml")
    .addResource("Bid.hbm.xml");</pre><p>An alternative way is to specify the mapped class and allow Hibernate to find the mapping document for you: </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class);</pre><p>Hibernate will then search for mapping files named <code class="filename">/org/hibernate/auction/Item.hbm.xml</code> and <code class="filename">/org/hibernate/auction/Bid.hbm.xml</code> in the classpath. This approach eliminates any hardcoded filenames. </p><p>A <code class="classname">org.hibernate.cfg.Configuration</code> also allows you to specify configuration properties. For example: </p><pre class="programlisting">Configuration cfg = new Configuration()
    .addClass(org.hibernate.auction.Item.class)
    .addClass(org.hibernate.auction.Bid.class)
    .setProperty("hibernate.dialect", "org.hibernate.dialect.MySQLInnoDBDialect")
    .setProperty("hibernate.connection.datasource", "java:comp/env/jdbc/test")
    .setProperty("hibernate.order_updates", "true");</pre><p>This is not the only way to pass configuration properties to Hibernate. Some alternative options include: </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>Pass an instance of <code class="classname">java.util.Properties</code> to <code class="literal">Configuration.setProperties()</code>. </p></li><li><p>Place a file named <code class="filename">hibernate.properties</code> in a root directory of the classpath. </p></li><li><p><code class="literal">java -Dproperty=value</code>를 사용하여 <code class="literal">System</code> 프로퍼티들을 설정한다. </p></li><li><p>Include <code class="literal">&lt;property&gt;</code> elements in <code class="literal">hibernate.cfg.xml</code> (this is discussed later). </p></li></ol></div><p>If you want to get started quickly<code class="filename">hibernate.properties</code> is the easiest approach. </p><p>The <code class="classname">org.hibernate.cfg.Configuration</code> is intended as a startup-time object that will be discarded once a <code class="literal">SessionFactory</code> is created. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-sessionfactory"/>3.2. SessionFactory 얻기</h2></div></div></div><p>When all mappings have been parsed by the <code class="classname">org.hibernate.cfg.Configuration</code>, the application must obtain a factory for <code class="interfacename">org.hibernate.Session</code> instances. This factory is intended to be shared by all application threads: </p><pre class="programlisting">SessionFactory sessions = cfg.buildSessionFactory();</pre><p>Hibernate does allow your application to instantiate more than one <code class="interfacename">org.hibernate.SessionFactory</code>. This is useful if you are using more than one database. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-hibernatejdbc"/>3.3. JDBC 커넥션들</h2></div></div></div><p>It is advisable to have the <code class="interfacename">org.hibernate.SessionFactory</code> create and pool JDBC connections for you. If you take this approach, opening a <code class="interfacename">org.hibernate.Session</code> is as simple as: </p><pre class="programlisting">Session session = sessions.openSession(); // open a new Session</pre><p>Once you start a task that requires access to the database, a JDBC connection will be obtained from the pool. </p><p>Before you can do this, you first need to pass some JDBC connection properties to Hibernate. All Hibernate property names and semantics are defined on the class <code class="classname">org.hibernate.cfg.Environment</code>. The most important settings for JDBC connection configuration are outlined below. </p><p>Hibernate will obtain and pool connections using <code class="classname">java.sql.DriverManager</code> if you set the following properties: </p><div class="table"><a id="d0e1747"/><p class="title"><b>표 3.1. Hibernate JDBC 프로퍼티들</b></p><div class="table-contents"><table summary="Hibernate JDBC 프로퍼티들" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>프로퍼티 이름</th><th>용도</th></tr></thead><tbody><tr><td>
                    <span class="property">hibernate.connection.driver_class</span>
                </td><td>
                    <span class="emphasis"><em>jdbc 드라이버 클래스</em></span>
                </td></tr><tr><td>
                    <span class="property">hibernate.connection.url</span>
                </td><td>
                    <span class="emphasis"><em>jdbc URL</em></span>
                </td></tr><tr><td>
                    <span class="property">hibernate.connection.username</span>
                </td><td>
                    <span class="emphasis"><em>데이터베이스 사용자</em></span>
                </td></tr><tr><td>
                    <span class="property">hibernate.connection.password</span>
                </td><td>
                    <span class="emphasis"><em>데이터베이스 사용자 패스워드</em></span>
                </td></tr><tr><td>
                    <span class="property">hibernate.connection.pool_size</span>
                </td><td>
                    <span class="emphasis"><em>풀링된 커넥션들의 최대 개수</em></span>
                </td></tr></tbody></table></div></div><br class="table-break"/><p>Hibernate's own connection pooling algorithm is, however, quite rudimentary. It is intended to help you get started and is <span class="emphasis"><em>not intended for use in a production system</em></span>, or even for performance testing. You should use a third party pool for best performance and stability. Just replace the <span class="property">hibernate.connection.pool_size</span> property with connection pool specific settings. This will turn off Hibernate's internal pool. For example, you might like to use c3p0. </p><p>C3P0 is an open source JDBC connection pool distributed along with Hibernate in the <code class="filename">lib</code> directory. Hibernate will use its <code class="classname">org.hibernate.connection.C3P0ConnectionProvider</code> for connection pooling if you set <span class="property">hibernate.c3p0.*</span> properties. If you would like to use Proxool, refer to the packaged <code class="filename">hibernate.properties</code> and the Hibernate web site for more information. </p><p>The following is an example <code class="filename">hibernate.properties</code> file for c3p0: </p><a id="c3p0-configuration"/><pre class="programlisting">hibernate.connection.driver_class = org.postgresql.Driver
hibernate.connection.url = jdbc:postgresql://localhost/mydatabase
hibernate.connection.username = myuser
hibernate.connection.password = secret
hibernate.c3p0.min_size=5
hibernate.c3p0.max_size=20
hibernate.c3p0.timeout=1800
hibernate.c3p0.max_statements=50
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect</pre><p>For use inside an application server, you should almost always configure Hibernate to obtain connections from an application server <code class="interfacename">javax.sql.Datasource</code> registered in JNDI. You will need to set at least one of the following properties: </p><div class="table"><a id="d0e1849"/><p class="title"><b>표 3.2. Hibernate Datasource Properties</b></p><div class="table-contents"><table summary="Hibernate Datasource Properties" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>프로퍼티 이름</th><th>용도</th></tr></thead><tbody><tr><td>
                    <span class="property">hibernate.connection.datasource</span>
                </td><td>
                    <span class="emphasis"><em>데이터소스 JNDI 이름</em></span>
                </td></tr><tr><td>
                    <span class="property">hibernate.jndi.url</span>
                </td><td><span class="emphasis"><em>URL of the JNDI provider</em></span> (optional) </td></tr><tr><td>
                    <span class="property">hibernate.jndi.class</span>
                </td><td><span class="emphasis"><em>class of the JNDI <code class="literal">InitialContextFactory</code></em></span> (optional) </td></tr><tr><td>
                    <span class="property">hibernate.connection.username</span>
                </td><td><span class="emphasis"><em>database user</em></span> (optional) </td></tr><tr><td>
                    <span class="property">hibernate.connection.password</span>
                </td><td><span class="emphasis"><em>database user password</em></span> (optional) </td></tr></tbody></table></div></div><br class="table-break"/><p>Here is an example <code class="filename">hibernate.properties</code> file for an application server provided JNDI datasource: </p><pre class="programlisting">hibernate.connection.datasource = java:/comp/env/jdbc/test
hibernate.transaction.factory_class = \
    org.hibernate.transaction.JTATransactionFactory
hibernate.transaction.manager_lookup_class = \
    org.hibernate.transaction.JBossTransactionManagerLookup
hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect</pre><p>JNDI datasource로부터 얻어진 JDBC 커넥션들은 어플리케이션 서버의 컨테이너에 의해 관리되는 트랜잭션들에 자동적으로 참여할 것이다. </p><p>Arbitrary connection properties can be given by prepending "<code class="literal">hibernate.connection</code>" to the connection property name. For example, you can specify a <span class="property">charSet</span> connection property using <span class="property">hibernate.connection.charSet</span>. </p><p>You can define your own plugin strategy for obtaining JDBC connections by implementing the interface <code class="interfacename">org.hibernate.connection.ConnectionProvider</code>, and specifying your custom implementation via the <span class="property">hibernate.connection.provider_class</span> property. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-optional"/>3.4. 선택적인 구성 프로퍼티들</h2></div></div></div><p>There are a number of other properties that control the behavior of Hibernate at runtime. All are optional and have reasonable default values. </p><p>
        	</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>주의</h2><span class="emphasis"><em>Some of these properties are "system-level" only.</em></span> System-level properties can be set only via <code class="literal">java -Dproperty=value</code> or <code class="filename">hibernate.properties</code>. They <span class="emphasis"><em>cannot</em></span> be set by the other techniques described above.</div><p>
        </p><div class="table"><a id="configuration-optional-properties"/><p class="title"><b>표 3.3. Hibernate 구성 프로퍼티들</b></p><div class="table-contents"><table summary="Hibernate 구성 프로퍼티들" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>프로퍼티 이름</th><th>용도</th></tr></thead><tbody><tr><td>
                            <span class="property">hibernate.dialect</span>
                        </td><td>The classname of a Hibernate <code class="classname">org.hibernate.dialect.Dialect</code> which allows Hibernate to generate SQL optimized for a particular relational database. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">full.classname.of.Dialect</code> </p>
                            <p>In most cases Hibernate will actually be able to choose the correct <code class="classname">org.hibernate.dialect.Dialect</code> implementation based on the <code class="literal">JDBC metadata</code> returned by the JDBC driver. </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.show_sql</span>
                        </td><td>Write all SQL statements to console. This is an alternative to setting the log category <code class="literal">org.hibernate.SQL</code> to <code class="literal">debug</code>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.format_sql</span>
                        </td><td>Pretty print the SQL in the log and console. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.default_schema</span>
                        </td><td>Qualify unqualified table names with the given schema/tablespace in generated SQL. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">SCHEMA_NAME</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.default_catalog</span>
                        </td><td>Qualifies unqualified table names with the given catalog in generated SQL. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">CATALOG_NAME</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.session_factory_name</span>
                        </td><td>The <code class="interfacename">org.hibernate.SessionFactory</code> will be automatically bound to this name in JNDI after it has been created. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">jndi/composite/name</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.max_fetch_depth</span>
                        </td><td>Sets a maximum "depth" for the outer join fetch tree for single-ended associations (one-to-one, many-to-one). A <code class="literal">0</code> disables default outer join fetching. <p><span class="strong"><strong>e.g.</strong></span> recommended values between <code class="literal">0</code> and <code class="literal">3</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.default_batch_fetch_size</span>
                        </td><td>Sets a default size for Hibernate batch fetching of associations. <p><span class="strong"><strong>e.g.</strong></span> recommended values <code class="literal">4</code>, <code class="literal">8</code>, <code class="literal">16</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.default_entity_mode</span>
                        </td><td>Sets a default mode for entity representation for all sessions opened from this <code class="literal">SessionFactory</code> <p><code class="literal">dynamic-map</code>, <code class="literal">dom4j</code>, <code class="literal">pojo</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.order_updates</span>
                        </td><td>Forces Hibernate to order SQL updates by the primary key value of the items being updated. This will result in fewer transaction deadlocks in highly concurrent systems. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.generate_statistics</span>
                        </td><td>If enabled, Hibernate will collect statistics useful for performance tuning. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.use_identifer_rollback</span>
                        </td><td>If enabled, generated identifier properties will be reset to default values when objects are deleted. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.use_sql_comments</span>
                        </td><td>If turned on, Hibernate will generate comments inside the SQL, for easier debugging, defaults to <code class="literal">false</code>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="configuration-jdbc-properties"/><p class="title"><b>표 3.4. Hibernate JDBC 및 커넥션 프로퍼티들</b></p><div class="table-contents"><table summary="Hibernate JDBC 및 커넥션 프로퍼티들" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>프로퍼티 이름</th><th>용도</th></tr></thead><tbody><tr><td>
                            <span class="property">hibernate.jdbc.fetch_size</span>
                        </td><td>A non-zero value determines the JDBC fetch size (calls <code class="literal">Statement.setFetchSize()</code>). </td></tr><tr><td>
                            <span class="property">hibernate.jdbc.batch_size</span>
                        </td><td>A non-zero value enables use of JDBC2 batch updates by Hibernate. <p><span class="strong"><strong>e.g.</strong></span> recommended values between <code class="literal">5</code> and <code class="literal">30</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.jdbc.batch_versioned_data</span>
                        </td><td>Set this property to <code class="literal">true</code> if your JDBC driver returns correct row counts from <code class="literal">executeBatch()</code>. Iit is usually safe to turn this option on. Hibernate will then use batched DML for automatically versioned data. Defaults to <code class="literal">false</code>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.jdbc.factory_class</span>
                        </td><td>Select a custom <code class="interfacename">org.hibernate.jdbc.Batcher</code>. Most applications will not need this configuration property. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">classname.of.BatcherFactory</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.jdbc.use_scrollable_resultset</span>
                        </td><td>Enables use of JDBC2 scrollable resultsets by Hibernate. This property is only necessary when using user-supplied JDBC connections. Hibernate uses connection metadata otherwise. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.jdbc.use_streams_for_binary</span>
                        </td><td>Use streams when writing/reading <code class="literal">binary</code> or <code class="literal">serializable</code> types to/from JDBC. <span class="emphasis"><em>*system-level property*</em></span> <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.jdbc.use_get_generated_keys</span>
                        </td><td>Enables use of JDBC3 <code class="literal">PreparedStatement.getGeneratedKeys()</code> to retrieve natively generated keys after insert. Requires JDBC3+ driver and JRE1.4+, set to false if your driver has problems with the Hibernate identifier generators. By default, it tries to determine the driver capabilities using connection metadata. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true|false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.connection.provider_class</span>
                        </td><td>The classname of a custom <code class="interfacename">org.hibernate.connection.ConnectionProvider</code> which provides JDBC connections to Hibernate. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">classname.of.ConnectionProvider</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.connection.isolation</span>
                        </td><td>Sets the JDBC transaction isolation level. Check <code class="interfacename">java.sql.Connection</code> for meaningful values, but note that most databases do not support all isolation levels and some define additional, non-standard isolations. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">1, 2, 4, 8</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.connection.autocommit</span>
                        </td><td>Enables autocommit for JDBC pooled connections (it is not recommended). <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <span class="property">hibernate.connection.release_mode</span>
                        </td><td>Specifies when Hibernate should release JDBC connections. By default, a JDBC connection is held until the session is explicitly closed or disconnected. For an application server JTA datasource, use <code class="literal">after_statement</code> to aggressively release connections after every JDBC call. For a non-JTA connection, it often makes sense to release the connection at the end of each transaction, by using <code class="literal">after_transaction</code>. <code class="literal">auto</code> will choose <code class="literal">after_statement</code> for the JTA and CMT transaction strategies and <code class="literal">after_transaction</code> for the JDBC transaction strategy. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">auto</code> (default) | <code class="literal">on_close</code> | <code class="literal">after_transaction</code> | <code class="literal">after_statement</code> </p>
                            <p>This setting only affects <code class="literal">Session</code>s returned from <code class="literal">SessionFactory.openSession</code>. For <code class="literal">Session</code>s obtained through <code class="literal">SessionFactory.getCurrentSession</code>, the <code class="literal">CurrentSessionContext</code> implementation configured for use controls the connection release mode for those <code class="literal">Session</code>s. See <a href="#architecture-current-session" title="2.5. Contextual sessions">2.5절. “Contextual sessions”</a> </p>
                        </td></tr><tr><td><span class="property">hibernate.connection.</span><span class="emphasis"><em>&lt;propertyName&gt;</em></span> </td><td>Pass the JDBC property <span class="emphasis"><em>&lt;propertyName&gt;</em></span> to <code class="literal">DriverManager.getConnection()</code>. </td></tr><tr><td><span class="property">hibernate.jndi.</span><span class="emphasis"><em>&lt;propertyName&gt;</em></span> </td><td>Pass the property <span class="emphasis"><em>&lt;propertyName&gt;</em></span> to the JNDI <code class="literal">InitialContextFactory</code>. </td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="configuration-cache-properties"/><p class="title"><b>표 3.5. Hibernate Cache 프로퍼티들</b></p><div class="table-contents"><table summary="Hibernate Cache 프로퍼티들" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>프로퍼티 이름</th><th>용도</th></tr></thead><tbody><tr><td>
                            <code class="literal">hibernate.cache.provider_class</code>
                        </td><td>The classname of a custom <code class="literal">CacheProvider</code>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">classname.of.CacheProvider</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cache.use_minimal_puts</code>
                        </td><td>Optimizes second-level cache operation to minimize writes, at the cost of more frequent reads. This setting is most useful for clustered caches and, in Hibernate3, is enabled by default for clustered cache implementations. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true|false</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cache.use_query_cache</code>
                        </td><td>Enables the query cache. Individual queries still have to be set cachable. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true|false</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cache.use_second_level_cache</code>
                        </td><td>Can be used to completely disable the second level cache, which is enabled by default for classes which specify a <code class="literal">&lt;cache&gt;</code> mapping. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true|false</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cache.query_cache_factory</code>
                        </td><td>The classname of a custom <code class="literal">QueryCache</code> interface, defaults to the built-in <code class="literal">StandardQueryCache</code>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">classname.of.QueryCache</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cache.region_prefix</code>
                        </td><td>A prefix to use for second-level cache region names. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">prefix</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cache.use_structured_entries</code>
                        </td><td>Forces Hibernate to store data in the second-level cache in a more human-friendly format. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true|false</code> </p>
                        </td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="configuration-transaction-properties"/><p class="title"><b>표 3.6. Hibernate 트랜잭션 프로퍼티들</b></p><div class="table-contents"><table summary="Hibernate 트랜잭션 프로퍼티들" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>프로퍼티 이름</th><th>용도</th></tr></thead><tbody><tr><td>
                            <code class="literal">hibernate.transaction.factory_class</code>
                        </td><td>The classname of a <code class="literal">TransactionFactory</code> to use with Hibernate <code class="literal">Transaction</code> API (defaults to <code class="literal">JDBCTransactionFactory</code>). <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">classname.of.TransactionFactory</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">jta.UserTransaction</code>
                        </td><td>A JNDI name used by <code class="literal">JTATransactionFactory</code> to obtain the JTA <code class="literal">UserTransaction</code> from the application server. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">jndi/composite/name</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.transaction.manager_lookup_class</code>
                        </td><td>The classname of a <code class="literal">TransactionManagerLookup</code>. It is required when JVM-level caching is enabled or when using hilo generator in a JTA environment. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">classname.of.TransactionManagerLookup</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.transaction.flush_before_completion</code>
                        </td><td>If enabled, the session will be automatically flushed during the before completion phase of the transaction. Built-in and automatic session context management is preferred, see <a href="#architecture-current-session" title="2.5. Contextual sessions">2.5절. “Contextual sessions”</a>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.transaction.auto_close_session</code>
                        </td><td>If enabled, the session will be automatically closed during the after completion phase of the transaction. Built-in and automatic session context management is preferred, see <a href="#architecture-current-session" title="2.5. Contextual sessions">2.5절. “Contextual sessions”</a>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="configuration-misc-properties"/><p class="title"><b>표 3.7. 여러가지 프로퍼티들</b></p><div class="table-contents"><table summary="여러가지 프로퍼티들" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>프로퍼티 이름</th><th>용도</th></tr></thead><tbody><tr><td>
                            <code class="literal">hibernate.current_session_context_class</code>
                        </td><td>Supply a custom strategy for the scoping of the "current" <code class="literal">Session</code>. See <a href="#architecture-current-session" title="2.5. Contextual sessions">2.5절. “Contextual sessions”</a> for more information about the built-in strategies. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">jta</code> | <code class="literal">thread</code> | <code class="literal">managed</code> | <code class="literal">custom.Class</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.query.factory_class</code>
                        </td><td>Chooses the HQL parser implementation. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">org.hibernate.hql.ast.ASTQueryTranslatorFactory</code> or <code class="literal">org.hibernate.hql.classic.ClassicQueryTranslatorFactory</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.query.substitutions</code>
                        </td><td>Is used to map from tokens in Hibernate queries to SQL tokens (tokens might be function or literal names, for example). <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.hbm2ddl.auto</code>
                        </td><td>Automatically validates or exports schema DDL to the database when the <code class="literal">SessionFactory</code> is created. With <code class="literal">create-drop</code>, the database schema will be dropped when the <code class="literal">SessionFactory</code> is closed explicitly. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">validate</code> | <code class="literal">update</code> | <code class="literal">create</code> | <code class="literal">create-drop</code> </p>
                        </td></tr><tr><td>
                            <code class="literal">hibernate.cglib.use_reflection_optimizer</code>
                        </td><td>Enables the use of CGLIB instead of runtime reflection (System-level property). Reflection can sometimes be useful when troubleshooting. Hibernate always requires CGLIB even if you turn off the optimizer. You cannot set this property in <code class="literal">hibernate.cfg.xml</code>. <p><span class="strong"><strong>e.g.</strong></span> <code class="literal">true</code> | <code class="literal">false</code> </p>
                        </td></tr></tbody></table></div></div><br class="table-break"/><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-dialects"/>3.4.1. SQL Dialects</h3></div></div></div><p>Always set the <code class="literal">hibernate.dialect</code> property to the correct <code class="literal">org.hibernate.dialect.Dialect</code> subclass for your database. If you specify a dialect, Hibernate will use sensible defaults for some of the other properties listed above. This means that you will not have to specify them manually. </p><div class="table"><a id="sql-dialects"/><p class="title"><b>표 3.8. Hibernate SQL Dialects (<code class="literal">hibernate.dialect</code>)</b></p><div class="table-contents"><table summary="Hibernate SQL Dialects (hibernate.dialect)" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>RDBMS</th><th>Dialect</th></tr></thead><tbody><tr><td>DB2</td><td><code class="literal">org.hibernate.dialect.DB2Dialect</code></td></tr><tr><td>DB2 AS/400</td><td><code class="literal">org.hibernate.dialect.DB2400Dialect</code></td></tr><tr><td>DB2 OS390</td><td><code class="literal">org.hibernate.dialect.DB2390Dialect</code></td></tr><tr><td>PostgreSQL</td><td><code class="literal">org.hibernate.dialect.PostgreSQLDialect</code></td></tr><tr><td>MySQL</td><td><code class="literal">org.hibernate.dialect.MySQLDialect</code></td></tr><tr><td>MySQL with InnoDB</td><td><code class="literal">org.hibernate.dialect.MySQLInnoDBDialect</code></td></tr><tr><td>MySQL with MyISAM</td><td><code class="literal">org.hibernate.dialect.MySQLMyISAMDialect</code></td></tr><tr><td>Oracle (any version)</td><td><code class="literal">org.hibernate.dialect.OracleDialect</code></td></tr><tr><td>Oracle 9i</td><td><code class="literal">org.hibernate.dialect.Oracle9iDialect</code></td></tr><tr><td>Oracle 10g</td><td><code class="literal">org.hibernate.dialect.Oracle10gDialect</code></td></tr><tr><td>Sybase</td><td><code class="literal">org.hibernate.dialect.SybaseDialect</code></td></tr><tr><td>Sybase Anywhere</td><td><code class="literal">org.hibernate.dialect.SybaseAnywhereDialect</code></td></tr><tr><td>Microsoft SQL Server</td><td><code class="literal">org.hibernate.dialect.SQLServerDialect</code></td></tr><tr><td>SAP DB</td><td><code class="literal">org.hibernate.dialect.SAPDBDialect</code></td></tr><tr><td>Informix</td><td><code class="literal">org.hibernate.dialect.InformixDialect</code></td></tr><tr><td>HypersonicSQL</td><td><code class="literal">org.hibernate.dialect.HSQLDialect</code></td></tr><tr><td>Ingres</td><td><code class="literal">org.hibernate.dialect.IngresDialect</code></td></tr><tr><td>Progress</td><td><code class="literal">org.hibernate.dialect.ProgressDialect</code></td></tr><tr><td>Mckoi SQL</td><td><code class="literal">org.hibernate.dialect.MckoiDialect</code></td></tr><tr><td>Interbase</td><td><code class="literal">org.hibernate.dialect.InterbaseDialect</code></td></tr><tr><td>Pointbase</td><td><code class="literal">org.hibernate.dialect.PointbaseDialect</code></td></tr><tr><td>FrontBase</td><td><code class="literal">org.hibernate.dialect.FrontbaseDialect</code></td></tr><tr><td>Firebird</td><td><code class="literal">org.hibernate.dialect.FirebirdDialect</code></td></tr></tbody></table></div></div><br class="table-break"/></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-outerjoin"/>3.4.2. Outer Join Fetching</h3></div></div></div><p>If your database supports ANSI, Oracle or Sybase style outer joins, <span class="emphasis"><em>outer join fetching</em></span> will often increase performance by limiting the number of round trips to and from the database. This is, however, at the cost of possibly more work performed by the database itself. Outer join fetching allows a whole graph of objects connected by many-to-one, one-to-many, many-to-many and one-to-one associations to be retrieved in a single SQL <code class="literal">SELECT</code>. </p><p>Outer join fetching can be disabled <span class="emphasis"><em>globally</em></span> by setting the property <code class="literal">hibernate.max_fetch_depth</code> to <code class="literal">0</code>. A setting of <code class="literal">1</code> or higher enables outer join fetching for one-to-one and many-to-one associations that have been mapped with <code class="literal">fetch="join"</code>. </p><p>추가 정보는 <a href="#performance-fetching" title="19.1. 페칭 방도들">19.1절. “페칭 방도들”</a>를 보라. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-binarystreams"/>3.4.3. Binary Streams</h3></div></div></div><p>Oracle limits the size of <code class="literal">byte</code> arrays that can be passed to and/or from its JDBC driver. If you wish to use large instances of <code class="literal">binary</code> or <code class="literal">serializable</code> type, you should enable <code class="literal">hibernate.jdbc.use_streams_for_binary</code>. <span class="emphasis"><em>This is a system-level setting only.</em></span> </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-cacheprovider"/>3.4.4. Second-level 캐시와 query 캐시</h3></div></div></div><p>The properties prefixed by <code class="literal">hibernate.cache</code> allow you to use a process or cluster scoped second-level cache system with Hibernate. See the <a href="#performance-cache" title="19.2. 두번째 레벨 캐시">19.2절. “두번째 레벨 캐시”</a> for more information. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-querysubstitution"/>3.4.5. Query Language 치환</h3></div></div></div><p>You can define new Hibernate query tokens using <code class="literal">hibernate.query.substitutions</code>. For example: </p><pre class="programlisting">hibernate.query.substitutions true=1, false=0</pre><p>This would cause the tokens <code class="literal">true</code> and <code class="literal">false</code> to be translated to integer literals in the generated SQL. </p><pre class="programlisting">hibernate.query.substitutions toLowercase=LOWER</pre><p>This would allow you to rename the SQL <code class="literal">LOWER</code> function. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-statistics"/>3.4.6. Hibernate 통계</h3></div></div></div><p>If you enable <code class="literal">hibernate.generate_statistics</code>, Hibernate exposes a number of metrics that are useful when tuning a running system via <code class="literal">SessionFactory.getStatistics()</code>. Hibernate can even be configured to expose these statistics via JMX. Read the Javadoc of the interfaces in <code class="literal">org.hibernate.stats</code> for more information. </p></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-logging"/>3.5. 로깅</h2></div></div></div><p>Hibernate utilizes <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.slf4j.org/">Simple Logging Facade for Java</a> (SLF4J) in order to log various system events. SLF4J can direct your logging output to several logging frameworks (NOP, Simple, log4j version 1.2, JDK 1.4 logging, JCL or logback) depending on your chosen binding. In order to setup logging you will need <code class="filename">slf4j-api.jar</code> in your classpath together with the jar file for your preferred binding - <code class="filename">slf4j-log4j12.jar</code> in the case of Log4J. See the SLF4J <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.slf4j.org/manual.html">documentation</a> for more detail. To use Log4j you will also need to place a <code class="filename">log4j.properties</code> file in your classpath. An example properties file is distributed with Hibernate in the <code class="literal">src/</code> directory. </p><p>It is recommended that you familiarize yourself with Hibernate's log messages. A lot of work has been put into making the Hibernate log as detailed as possible, without making it unreadable. It is an essential troubleshooting device. The most interesting log categories are the following: </p><div class="table"><a id="log-categories"/><p class="title"><b>표 3.9. Hibernate 로그 카테고리들</b></p><div class="table-contents"><table summary="Hibernate 로그 카테고리들" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>카테고리</th><th>기능</th></tr></thead><tbody><tr><td><code class="literal">org.hibernate.SQL</code></td><td>SQL DML 문장들이 실행될 때 그것들 모두를 로그 시킨다</td></tr><tr><td><code class="literal">org.hibernate.type</code></td><td>모든 JDBC 파라미터들을 로그시킨다</td></tr><tr><td><code class="literal">org.hibernate.tool.hbm2ddl</code></td><td>SQL DDL 문장들이 실행될 때 그것들 모두를 로그 시킨다</td></tr><tr><td><code class="literal">org.hibernate.pretty</code></td><td>flush 시점에서 세션과 연관된 모든 엔티티들(최대 20개의 엔티티들)의 상태를 로그 시킨다 </td></tr><tr><td><code class="literal">org.hibernate.cache</code></td><td>모든 second-level 캐시 액티비티를 로그시킨다</td></tr><tr><td><code class="literal">org.hibernate.transaction</code></td><td>트랜잭션 관련 액티비티를 로그 시킨다</td></tr><tr><td><code class="literal">org.hibernate.jdbc</code></td><td>모든 JDBC 리소스 취득을 로그 시킨다</td></tr><tr><td><code class="literal">org.hibernate.hql.ast.AST</code></td><td>질의 파싱 동안에 HQL AST와 SQL AST를 로그시킨다 </td></tr><tr><td><code class="literal">org.hibernate.secure</code></td><td>모든 JAAS 허가 요청들을 로그시킨다</td></tr><tr><td><code class="literal">org.hibernate</code></td><td>Log everything. This is a lot of information but it is useful for troubleshooting </td></tr></tbody></table></div></div><br class="table-break"/><p>Hibernate로 어플리케이션들을 개발할 때, 당신은 거의 항상 <code class="literal">org.hibernate.SQL</code> 카테고리에 대해 이용 가능한 <code class="literal">debug</code> 모드로 작업하거나, 다른 방법으로 <code class="literal">hibernate.show_sql</code> 프로퍼티를 이용가능하게 하여 작업해야 할 것이다. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-namingstrategy"/>3.6. <code class="literal">NamingStrategy</code> 구현하기</h2></div></div></div><p><code class="literal">org.hibernate.cfg.NamingStrategy</code> 인터페이스는 데이터베이스 객체들과 스키마 요소들에 대한 "네이밍 표준"을 지정하는 것을 당신에게 허용해준다. </p><p>You can provide rules for automatically generating database identifiers from Java identifiers or for processing "logical" column and table names given in the mapping file into "physical" table and column names. This feature helps reduce the verbosity of the mapping document, eliminating repetitive noise (<code class="literal">TBL_</code> prefixes, for example). The default strategy used by Hibernate is quite minimal. </p><p>You can specify a different strategy by calling <code class="literal">Configuration.setNamingStrategy()</code> before adding mappings: </p><pre class="programlisting">SessionFactory sf = new Configuration()
    .setNamingStrategy(ImprovedNamingStrategy.INSTANCE)
    .addFile("Item.hbm.xml")
    .addFile("Bid.hbm.xml")
    .buildSessionFactory();</pre><p><code class="literal">org.hibernate.cfg.ImprovedNamingStrategy</code>는 어떤 어플리케이션들에 대한 유용한 시작점일 수 있는 미리 빌드된 방도이다. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-xmlconfig"/>3.7. XML 구성 파일</h2></div></div></div><p>구성에 대한 다른 접근법은 <code class="literal">hibernate.cfg.xml</code>로 명명된 파일 속에 전체 구성을 지정하는 것이다. 이 파일은 <code class="literal">hibernate.properties</code> 파일에 대한 대용물로서 사용될 수 있거나, 만일 둘 다 존재할 경우에 프로퍼티들을 중복정의하는데 사용될 수 있다. </p><p>The XML configuration file is by default expected to be in the root of your <code class="literal">CLASSPATH</code>. Here is an example: </p><pre class="programlisting">&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
    "-//Hibernate/Hibernate Configuration DTD//EN"
    "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;

&lt;hibernate-configuration&gt;

    &lt;!-- a SessionFactory instance listed as /jndi/name --&gt;
    &lt;session-factory
        name="java:hibernate/SessionFactory"&gt;

        &lt;!-- properties --&gt;
        &lt;property name="connection.datasource"&gt;java:/comp/env/jdbc/MyDB&lt;/property&gt;
        &lt;property name="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;
        &lt;property name="show_sql"&gt;false&lt;/property&gt;
        &lt;property name="transaction.factory_class"&gt;
            org.hibernate.transaction.JTATransactionFactory
        &lt;/property&gt;
        &lt;property name="jta.UserTransaction"&gt;java:comp/UserTransaction&lt;/property&gt;

        &lt;!-- mapping files --&gt;
        &lt;mapping resource="org/hibernate/auction/Item.hbm.xml"/&gt;
        &lt;mapping resource="org/hibernate/auction/Bid.hbm.xml"/&gt;

        &lt;!-- cache settings --&gt;
        &lt;class-cache class="org.hibernate.auction.Item" usage="read-write"/&gt;
        &lt;class-cache class="org.hibernate.auction.Bid" usage="read-only"/&gt;
        &lt;collection-cache collection="org.hibernate.auction.Item.bids" usage="read-write"/&gt;

    &lt;/session-factory&gt;

&lt;/hibernate-configuration&gt;</pre><p>The advantage of this approach is the externalization of the mapping file names to configuration. The <code class="literal">hibernate.cfg.xml</code> is also more convenient once you have to tune the Hibernate cache. It is your choice to use either <code class="literal">hibernate.properties</code> or <code class="literal">hibernate.cfg.xml</code>. Both are equivalent, except for the above mentioned benefits of using the XML syntax. </p><p>With the XML configuration, starting Hibernate is then as simple as: </p><pre class="programlisting">SessionFactory sf = new Configuration().configure().buildSessionFactory();</pre><p>You can select a different XML configuration file using: </p><pre class="programlisting">SessionFactory sf = new Configuration()
    .configure("catdb.cfg.xml")
    .buildSessionFactory();</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-j2ee"/>3.8. J2EE 어플리케이션 서버 통합</h2></div></div></div><p>Hibernate는 J2EE 인프라스트럭처에 대한 다음 통합 점들을 갖고 있다: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Container-managed datasources</em></span>: Hibernate can use JDBC connections managed by the container and provided through JNDI. Usually, a JTA compatible <code class="literal">TransactionManager</code> and a <code class="literal">ResourceManager</code> take care of transaction management (CMT), especially distributed transaction handling across several datasources. You can also demarcate transaction boundaries programmatically (BMT), or you might want to use the optional Hibernate <code class="literal">Transaction</code> API for this to keep your code portable. </p></li></ul></div><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>자동적인 JNDI 바인딩</em></span>: Hibernate는 시작 후에 그것의 <code class="literal">SessionFactory</code>를 JNDI에 바인드 시킬 수 있다. </p></li></ul></div><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>JTA Session binding:</em></span> the Hibernate <code class="literal">Session</code> can be automatically bound to the scope of JTA transactions. Simply lookup the <code class="literal">SessionFactory</code> from JNDI and get the current <code class="literal">Session</code>. Let Hibernate manage flushing and closing the <code class="literal">Session</code> when your JTA transaction completes. Transaction demarcation is either declarative (CMT) or programmatic (BMT/UserTransaction). </p></li></ul></div><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>JMX deployment:</em></span> if you have a JMX capable application server (e.g. JBoss AS), you can choose to deploy Hibernate as a managed MBean. This saves you the one line startup code to build your <code class="literal">SessionFactory</code> from a <code class="literal">Configuration</code>. The container will startup your <code class="literal">HibernateService</code> and also take care of service dependencies (datasource has to be available before Hibernate starts, etc). </p></li></ul></div><p>당신의 환경에 따라, 당신은 당신의 어플리케이션 서버가 "connection containment(연결 봉쇄)" 예외상황들을 보일 경우에 구성 옵션 <code class="literal">hibernate.connection.aggressive_release</code>를 true로 설정해야 될 수도 있다. </p><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-transactionstrategy"/>3.8.1. 트랜잭션 방도 구성</h3></div></div></div><p>The Hibernate <code class="literal">Session</code> API is independent of any transaction demarcation system in your architecture. If you let Hibernate use JDBC directly through a connection pool, you can begin and end your transactions by calling the JDBC API. If you run in a J2EE application server, you might want to use bean-managed transactions and call the JTA API and <code class="literal">UserTransaction</code> when needed. </p><p>이들 두 개의 (그리고 다른) 환경들에서 당신의 코드에 이식성을 유지하기 위해 우리는 기본 시스템을 포장하고 은폐시키는 선택적인 Hibernate <code class="literal">Transaction</code> API를 권장한다. 당신은 Hibernate 구성 프로퍼티 <code class="literal">hibernate.transaction.factory_class</code>를 사용하여 <code class="literal">Transaction</code> 인스턴스들에 대한 팩토리 클래스를 지정해야 한다. </p><p>There are three standard, or built-in, choices: </p><div class="variablelist"><dl><dt><span class="term"><code class="literal">org.hibernate.transaction.JDBCTransactionFactory</code></span></dt><dd><p>데이터베이스 (JDBC) 트랜잭션들에게 위임시킨다(디폴트)</p></dd><dt><span class="term"><code class="literal">org.hibernate.transaction.JTATransactionFactory</code></span></dt><dd><p>delegates to container-managed transactions if an existing transaction is underway in this context (for example, EJB session bean method). Otherwise, a new transaction is started and bean-managed transactions are used. </p></dd><dt><span class="term"><code class="literal">org.hibernate.transaction.CMTTransactionFactory</code></span></dt><dd><p>container-managed JTA 트랜잭션들에게 위임시킨다</p></dd></dl></div><p>You can also define your own transaction strategies (for a CORBA transaction service, for example). </p><p>Some features in Hibernate (i.e., the second level cache, Contextual Sessions with JTA, etc.) require access to the JTA <code class="literal">TransactionManager</code> in a managed environment. In an application server, since J2EE does not standardize a single mechanism, you have to specify how Hibernate should obtain a reference to the <code class="literal">TransactionManager</code>: </p><div class="table"><a id="jtamanagerlookup"/><p class="title"><b>표 3.10. JTA TransactionManagers</b></p><div class="table-contents"><table summary="JTA TransactionManagers" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>트랜잭션 팩토리</th><th align="center">어플리케이션 서버</th></tr></thead><tbody><tr><td><code class="literal">org.hibernate.transaction.JBossTransactionManagerLookup</code></td><td align="center">JBoss</td></tr><tr><td><code class="literal">org.hibernate.transaction.WeblogicTransactionManagerLookup</code></td><td align="center">Weblogic</td></tr><tr><td><code class="literal">org.hibernate.transaction.WebSphereTransactionManagerLookup</code></td><td align="center">WebSphere</td></tr><tr><td><code class="literal">org.hibernate.transaction.WebSphereExtendedJTATransactionLookup</code></td><td align="center">WebSphere 6</td></tr><tr><td><code class="literal">org.hibernate.transaction.OrionTransactionManagerLookup</code></td><td align="center">Orion</td></tr><tr><td><code class="literal">org.hibernate.transaction.ResinTransactionManagerLookup</code></td><td align="center">Resin</td></tr><tr><td><code class="literal">org.hibernate.transaction.JOTMTransactionManagerLookup</code></td><td align="center">JOTM</td></tr><tr><td><code class="literal">org.hibernate.transaction.JOnASTransactionManagerLookup</code></td><td align="center">JOnAS</td></tr><tr><td><code class="literal">org.hibernate.transaction.JRun4TransactionManagerLookup</code></td><td align="center">JRun4</td></tr><tr><td><code class="literal">org.hibernate.transaction.BESTransactionManagerLookup</code></td><td align="center">Borland ES</td></tr></tbody></table></div></div><br class="table-break"/></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-optional-jndi"/>3.8.2. JNDI-bound <code class="literal">SessionFactory</code></h3></div></div></div><p>A JNDI-bound Hibernate <code class="literal">SessionFactory</code> can simplify the lookup function of the factory and create new <code class="literal">Session</code>s. This is not, however, related to a JNDI bound <code class="literal">Datasource</code>; both simply use the same registry. </p><p>If you wish to have the <code class="literal">SessionFactory</code> bound to a JNDI namespace, specify a name (e.g. <code class="literal">java:hibernate/SessionFactory</code>) using the property <code class="literal">hibernate.session_factory_name</code>. If this property is omitted, the <code class="literal">SessionFactory</code> will not be bound to JNDI. This is especially useful in environments with a read-only JNDI default implementation (in Tomcat, for example). </p><p><code class="literal">SessionFactory</code>를 JNDI에 바인드 시킬 때, Hibernate는 초기 컨텍스트를 초기화 시키기 위해 <code class="literal">hibernate.jndi.url</code>, <code class="literal">hibernate.jndi.class</code>의 값들을 사용할 것이다. 만일 그것들이 지정되어 있지 않을 경우, 디폴트 <code class="literal">InitialContext</code>가 사용될 것이다. </p><p>Hibernate will automatically place the <code class="literal">SessionFactory</code> in JNDI after you call <code class="literal">cfg.buildSessionFactory()</code>. This means you will have this call in some startup code, or utility class in your application, unless you use JMX deployment with the <code class="literal">HibernateService</code> (this is discussed later in greater detail). </p><p>If you use a JNDI <code class="literal">SessionFactory</code>, an EJB or any other class, you can obtain the <code class="literal">SessionFactory</code> using a JNDI lookup. </p><p>It is recommended that you bind the <code class="literal">SessionFactory</code> to JNDI in a managed environment and use a <code class="literal">static</code> singleton otherwise. To shield your application code from these details, we also recommend to hide the actual lookup code for a <code class="literal">SessionFactory</code> in a helper class, such as <code class="literal">HibernateUtil.getSessionFactory()</code>. Note that such a class is also a convenient way to startup Hibernatesee chapter 1. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-j2ee-currentsession"/>3.8.3. Current Session context management with JTA</h3></div></div></div><p>The easiest way to handle <code class="literal">Sessions</code> and transactions is Hibernate's automatic "current" <code class="literal">Session</code> management. For a discussion of contextual sessions see <a href="#architecture-current-session" title="2.5. Contextual sessions">2.5절. “Contextual sessions”</a>. Using the <code class="literal">"jta"</code> session context, if there is no Hibernate <code class="literal">Session</code> associated with the current JTA transaction, one will be started and associated with that JTA transaction the first time you call <code class="literal">sessionFactory.getCurrentSession()</code>. The <code class="literal">Session</code>s retrieved via <code class="literal">getCurrentSession()</code> in the<code class="literal">"jta"</code> context are set to automatically flush before the transaction completes, close after the transaction completes, and aggressively release JDBC connections after each statement. This allows the <code class="literal">Session</code>s to be managed by the life cycle of the JTA transaction to which it is associated, keeping user code clean of such management concerns. Your code can either use JTA programmatically through <code class="literal">UserTransaction</code>, or (recommended for portable code) use the Hibernate <code class="literal">Transaction</code> API to set transaction boundaries. If you run in an EJB container, declarative transaction demarcation with CMT is preferred. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="configuration-j2ee-jmx"/>3.8.4. JMX 배치</h3></div></div></div><p>The line <code class="literal">cfg.buildSessionFactory()</code> still has to be executed somewhere to get a <code class="literal">SessionFactory</code> into JNDI. You can do this either in a <code class="literal">static</code> initializer block, like the one in <code class="literal">HibernateUtil</code>, or you can deploy Hibernate as a <span class="emphasis"><em>managed service</em></span>. </p><p>Hibernate is distributed with <code class="literal">org.hibernate.jmx.HibernateService</code> for deployment on an application server with JMX capabilities, such as JBoss AS. The actual deployment and configuration is vendor-specific. Here is an example <code class="literal">jboss-service.xml</code> for JBoss 4.0.x: </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;server&gt;

&lt;mbean code="org.hibernate.jmx.HibernateService"
    name="jboss.jca:service=HibernateFactory,name=HibernateFactory"&gt;

    &lt;!-- Required services --&gt;
    &lt;depends&gt;jboss.jca:service=RARDeployer&lt;/depends&gt;
    &lt;depends&gt;jboss.jca:service=LocalTxCM,name=HsqlDS&lt;/depends&gt;

    &lt;!-- Bind the Hibernate service to JNDI --&gt;
    &lt;attribute name="JndiName"&gt;java:/hibernate/SessionFactory&lt;/attribute&gt;

    &lt;!-- Datasource settings --&gt;
    &lt;attribute name="Datasource"&gt;java:HsqlDS&lt;/attribute&gt;
    &lt;attribute name="Dialect"&gt;org.hibernate.dialect.HSQLDialect&lt;/attribute&gt;

    &lt;!-- Transaction integration --&gt;
    &lt;attribute name="TransactionStrategy"&gt;
        org.hibernate.transaction.JTATransactionFactory&lt;/attribute&gt;
    &lt;attribute name="TransactionManagerLookupStrategy"&gt;
        org.hibernate.transaction.JBossTransactionManagerLookup&lt;/attribute&gt;
    &lt;attribute name="FlushBeforeCompletionEnabled"&gt;true&lt;/attribute&gt;
    &lt;attribute name="AutoCloseSessionEnabled"&gt;true&lt;/attribute&gt;

    &lt;!-- Fetching options --&gt;
    &lt;attribute name="MaximumFetchDepth"&gt;5&lt;/attribute&gt;

    &lt;!-- Second-level caching --&gt;
    &lt;attribute name="SecondLevelCacheEnabled"&gt;true&lt;/attribute&gt;
    &lt;attribute name="CacheProviderClass"&gt;org.hibernate.cache.EhCacheProvider&lt;/attribute&gt;
    &lt;attribute name="QueryCacheEnabled"&gt;true&lt;/attribute&gt;

    &lt;!-- Logging --&gt;
    &lt;attribute name="ShowSqlEnabled"&gt;true&lt;/attribute&gt;

    &lt;!-- Mapping files --&gt;
    &lt;attribute name="MapResources"&gt;auction/Item.hbm.xml,auction/Category.hbm.xml&lt;/attribute&gt;

&lt;/mbean&gt;

&lt;/server&gt;</pre><p>This file is deployed in a directory called <code class="literal">META-INF</code> and packaged in a JAR file with the extension <code class="literal">.sar</code> (service archive). You also need to package Hibernate, its required third-party libraries, your compiled persistent classes, as well as your mapping files in the same archive. Your enterprise beans (usually session beans) can be kept in their own JAR file, but you can include this EJB JAR file in the main service archive to get a single (hot-)deployable unit. Consult the JBoss AS documentation for more information about JMX service and EJB deployment. </p></div></div></div><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes"/>4장. 영속 클래스들</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#persistent-classes-pojo">4.1. 간단한 POJO 예제</a></span></dt><dd><dl><dt><span class="sect2"><a href="#persistent-classes-pojo-constructor">4.1.1. 아규먼트 없는 생성자를 구현하라</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-identifier">4.1.2. identifier 프로퍼티를 제공하라(옵션)</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-final">4.1.3. final이 아닌 클래스들을 선호하라(옵션)</a></span></dt><dt><span class="sect2"><a href="#persistent-classes-pojo-accessors">4.1.4. 영속 필드들을 위한 accessor들과 mutator들을 선언하라(옵션)</a></span></dt></dl></dd><dt><span class="sect1"><a href="#persistent-classes-inheritance">4.2. 상속 구현하기</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-equalshashcode">4.3. <code class="literal">equals()</code>와 <code class="literal">hashCode()</code> 구현하기</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-dynamicmodels">4.4. 동적인 모형들</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-tuplizers">4.5. Tuplizer들</a></span></dt><dt><span class="sect1"><a href="#persistent-classes-entity-name-resolver">4.6. EntityNameResolvers</a></span></dt></dl></div><p>Persistent classes are classes in an application that implement the entities of the business problem (e.g. Customer and Order in an E-commerce application). Not all instances of a persistent class are considered to be in the persistent state. For example, an instance can instead be transient or detached. </p><p>Hibernate works best if these classes follow some simple rules, also known as the Plain Old Java Object (POJO) programming model. However, none of these rules are hard requirements. Indeed, Hibernate3 assumes very little about the nature of your persistent objects. You can express a domain model in other ways (using trees of <code class="literal">Map</code> instances, for example). </p><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes-pojo"/>4.1. 간단한 POJO 예제</h2></div></div></div><p>Most Java applications require a persistent class representing felines. For example: </p><pre class="programlisting">package eg;
import java.util.Set;
import java.util.Date;

public class Cat {
    private Long id; // identifier

    private Date birthdate;
    private Color color;
    private char sex;
    private float weight;
    private int litterId;

    private Cat mother;
    private Set kittens = new HashSet();

    private void setId(Long id) {
        this.id=id;
    }
    public Long getId() {
        return id;
    }

    void setBirthdate(Date date) {
        birthdate = date;
    }
    public Date getBirthdate() {
        return birthdate;
    }

    void setWeight(float weight) {
        this.weight = weight;
    }
    public float getWeight() {
        return weight;
    }

    public Color getColor() {
        return color;
    }
    void setColor(Color color) {
        this.color = color;
    }

    void setSex(char sex) {
        this.sex=sex;
    }
    public char getSex() {
        return sex;
    }

    void setLitterId(int id) {
        this.litterId = id;
    }
    public int getLitterId() {
        return litterId;
    }

    void setMother(Cat mother) {
        this.mother = mother;
    }
    public Cat getMother() {
        return mother;
    }
    void setKittens(Set kittens) {
        this.kittens = kittens;
    }
    public Set getKittens() {
        return kittens;
    }
    
    // addKitten not needed by Hibernate
    public void addKitten(Cat kitten) {
            kitten.setMother(this);
        kitten.setLitterId( kittens.size() ); 
        kittens.add(kitten);
    }
}</pre><p>The four main rules of persistent classes are explored in more detail in the following sections. </p><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="persistent-classes-pojo-constructor"/>4.1.1. 아규먼트 없는 생성자를 구현하라</h3></div></div></div><p><code class="literal">Cat</code> has a no-argument constructor. All persistent classes must have a default constructor (which can be non-public) so that Hibernate can instantiate them using <code class="literal">Constructor.newInstance()</code>. It is recommended that you have a default constructor with at least <span class="emphasis"><em>package</em></span> visibility for runtime proxy generation in Hibernate. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="persistent-classes-pojo-identifier"/>4.1.2. identifier 프로퍼티를 제공하라(옵션)</h3></div></div></div><p><code class="literal">Cat</code> has a property called <code class="literal">id</code>. This property maps to the primary key column of a database table. The property might have been called anything, and its type might have been any primitive type, any primitive "wrapper" type, <code class="literal">java.lang.String</code> or <code class="literal">java.util.Date</code>. If your legacy database table has composite keys, you can use a user-defined class with properties of these types (see the section on composite identifiers later in the chapter.) </p><p>identifier 프로퍼티는 엄격하게 옵션이다. 당신은 그것을 생략할 수도 있고, Hibernate로 하여금 내부적으로 객체 식별자들을 추적하도록 할 수 있다. 하지만 우리는 이것을 권장하지 않는다. </p><p>In fact, some functionality is available only to classes that declare an identifier property: </p><div class="itemizedlist"><ul compact="compact"><li><p>Transitive reattachment for detached objects (cascade update or cascade merge) - see <a href="#objectstate-transitive" title="10.11. Transitive persistence(전이 영속)">10.11절. “Transitive persistence(전이 영속)”</a> </p></li><li><p>
                        <code class="literal">Session.saveOrUpdate()</code>
                    </p></li><li><p>
                        <code class="literal">Session.merge()</code>
                    </p></li></ul></div><p>We recommend that you declare consistently-named identifier properties on persistent classes and that you use a nullable (i.e., non-primitive) type. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="persistent-classes-pojo-final"/>4.1.3. final이 아닌 클래스들을 선호하라(옵션)</h3></div></div></div><p>Hibernate의 중심 특징인, 프락시(<span class="emphasis"><em>proxies</em></span>)들은 final이 아닌 영속 클래스들 또는 모두 public 메소드들로 선언된 인터페이스의 구현인 영속 클래스들에 의존한다. </p><p>You can persist <code class="literal">final</code> classes that do not implement an interface with Hibernate. You will not, however, be able to use proxies for lazy association fetching which will ultimately limit your options for performance tuning. </p><p>당신은 또한 non-final 클래스들 상에 <code class="literal">public final</code> 메소드들을 선언하는 것을 피해야 한다. 만일 당신이 <code class="literal">public final</code> 메소드를 가진 클래스를 사용하고자 원할 경우, 당신은 <code class="literal">lazy="false"</code>를 설정함으로써 명시적으로 프락싱을 사용 불가능하도록 해야 한다. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="persistent-classes-pojo-accessors"/>4.1.4. 영속 필드들을 위한 accessor들과 mutator들을 선언하라(옵션)</h3></div></div></div><p><code class="literal">Cat</code> declares accessor methods for all its persistent fields. Many other ORM tools directly persist instance variables. It is better to provide an indirection between the relational schema and internal data structures of the class. By default, Hibernate persists JavaBeans style properties and recognizes method names of the form <code class="literal">getFoo</code>, <code class="literal">isFoo</code> and <code class="literal">setFoo</code>. If required, you can switch to direct field access for particular properties. </p><p>프로퍼티들은 public으로 선언될 필요가 <span class="emphasis"><em>없다</em></span> - Hibernate는 디폴트로 <code class="literal">protected</code> get/set 쌍 또는 <code class="literal">private</code> get/set 쌍을 가진 프로퍼티를 영속화 시킬 수 있다. </p></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes-inheritance"/>4.2. 상속 구현하기</h2></div></div></div><p>A subclass must also observe the first and second rules. It inherits its identifier property from the superclass, <code class="literal">Cat</code>. For example: </p><pre class="programlisting">package eg;

public class DomesticCat extends Cat {
        private String name;

        public String getName() {
                return name;
        }
        protected void setName(String name) {
                this.name=name;
        }
}</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes-equalshashcode"/>4.3. <code class="literal">equals()</code>와 <code class="literal">hashCode()</code> 구현하기</h2></div></div></div><p>You have to override the <code class="literal">equals()</code> and <code class="literal">hashCode()</code> methods if you: </p><div class="itemizedlist"><ul compact="compact"><li><p>intend to put instances of persistent classes in a <code class="literal">Set</code> (the recommended way to represent many-valued associations); <span class="emphasis"><em>and</em></span> </p></li><li><p>detached 인스턴스들의 reattachment(재첨부)를 사용하고자 의도하는 </p></li></ul></div><p>Hibernate guarantees equivalence of persistent identity (database row) and Java identity only inside a particular session scope. When you mix instances retrieved in different sessions, you must implement <code class="literal">equals()</code> and <code class="literal">hashCode()</code> if you wish to have meaningful semantics for <code class="literal">Set</code>s. </p><p>The most obvious way is to implement <code class="literal">equals()</code>/<code class="literal">hashCode()</code> by comparing the identifier value of both objects. If the value is the same, both must be the same database row, because they are equal. If both are added to a <code class="literal">Set</code>, you will only have one element in the <code class="literal">Set</code>). Unfortunately, you cannot use that approach with generated identifiers. Hibernate will only assign identifier values to objects that are persistent; a newly created instance will not have any identifier value. Furthermore, if an instance is unsaved and currently in a <code class="literal">Set</code>, saving it will assign an identifier value to the object. If <code class="literal">equals()</code> and <code class="literal">hashCode()</code> are based on the identifier value, the hash code would change, breaking the contract of the <code class="literal">Set</code>. See the Hibernate website for a full discussion of this problem. This is not a Hibernate issue, but normal Java semantics of object identity and equality. </p><p>It is recommended that you implement <code class="literal">equals()</code> and <code class="literal">hashCode()</code> using <span class="emphasis"><em>Business key equality</em></span>. Business key equality means that the <code class="literal">equals()</code> method compares only the properties that form the business key. It is a key that would identify our instance in the real world (a <span class="emphasis"><em>natural</em></span> candidate key): </p><pre class="programlisting">public class Cat {

    ...
    public boolean equals(Object other) {
        if (this == other) return true;
        if ( !(other instanceof Cat) ) return false;

        final Cat cat = (Cat) other;

        if ( !cat.getLitterId().equals( getLitterId() ) ) return false;
        if ( !cat.getMother().equals( getMother() ) ) return false;

        return true;
    }

    public int hashCode() {
        int result;
        result = getMother().hashCode();
        result = 29 * result + getLitterId();
        return result;
    }

}</pre><p>A business key does not have to be as solid as a database primary key candidate (see <a href="#transactions-basics-identity" title="11.1.3. 객체 identity 고려하기">11.1.3절. “객체 identity 고려하기”</a>). Immutable or unique properties are usually good candidates for a business key. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes-dynamicmodels"/>4.4. 동적인 모형들</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
	 <span class="emphasis"><em>The following features are currently considered experimental and may change in the near future.</em></span>
	      
	</p></div><p>Persistent entities do not necessarily have to be represented as POJO classes or as JavaBean objects at runtime. Hibernate also supports dynamic models (using <code class="literal">Map</code>s of <code class="literal">Map</code>s at runtime) and the representation of entities as DOM4J trees. With this approach, you do not write persistent classes, only mapping files. </p><p>By default, Hibernate works in normal POJO mode. You can set a default entity representation mode for a particular <code class="literal">SessionFactory</code> using the <code class="literal">default_entity_mode</code> configuration option (see <a href="#configuration-optional-properties" title="표 3.3. Hibernate 구성 프로퍼티들">표 3.3. “Hibernate 구성 프로퍼티들”</a>). </p><p>The following examples demonstrate the representation using <code class="literal">Map</code>s. First, in the mapping file an <code class="literal">entity-name</code> has to be declared instead of, or in addition to, a class name: </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class entity-name="Customer"&gt;

        &lt;id name="id"
            type="long"
            column="ID"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;

        &lt;property name="name"
            column="NAME"
            type="string"/&gt;

        &lt;property name="address"
            column="ADDRESS"
            type="string"/&gt;

        &lt;many-to-one name="organization"
            column="ORGANIZATION_ID"
            class="Organization"/&gt;

        &lt;bag name="orders"
            inverse="true"
            lazy="false"
            cascade="all"&gt;
            &lt;key column="CUSTOMER_ID"/&gt;
            &lt;one-to-many class="Order"/&gt;
        &lt;/bag&gt;

    &lt;/class&gt;
    
&lt;/hibernate-mapping&gt;</pre><p>Even though associations are declared using target class names, the target type of associations can also be a dynamic entity instead of a POJO. </p><p>After setting the default entity mode to <code class="literal">dynamic-map</code> for the <code class="literal">SessionFactory</code>, you can, at runtime, work with <code class="literal">Map</code>s of <code class="literal">Map</code>s: </p><pre class="programlisting">Session s = openSession();
Transaction tx = s.beginTransaction();
Session s = openSession();

// Create a customer
Map david = new HashMap();
david.put("name", "David");

// Create an organization
Map foobar = new HashMap();
foobar.put("name", "Foobar Inc.");

// Link both
david.put("organization", foobar);

// Save both
s.save("Customer", david);
s.save("Organization", foobar);

tx.commit();
s.close();</pre><p>One of the main advantages of dynamic mapping is quick turnaround time for prototyping, without the need for entity class implementation. However, you lose compile-time type checking and will likely deal with many exceptions at runtime. As a result of the Hibernate mapping, the database schema can easily be normalized and sound, allowing to add a proper domain model implementation on top later on. </p><p>엔티티 표현 모드들은 또한 하나의 단위 <code class="literal">Session</code> 기준에 대해 설정될 수 있다: </p><pre class="programlisting">Session dynamicSession = pojoSession.getSession(EntityMode.MAP);

// Create a customer
Map david = new HashMap();
david.put("name", "David");
dynamicSession.save("Customer", david);
...
dynamicSession.flush();
dynamicSession.close()
...
// Continue on pojoSession
</pre><p>Please note that the call to <code class="literal">getSession()</code> using an <code class="literal">EntityMode</code> is on the <code class="literal">Session</code> API, not the <code class="literal">SessionFactory</code>. That way, the new <code class="literal">Session</code> shares the underlying JDBC connection, transaction, and other context information. This means you do not have to call <code class="literal">flush()</code> and <code class="literal">close()</code> on the secondary <code class="literal">Session</code>, and also leave the transaction and connection handling to the primary unit of work. </p><p>XML 표현 가용성들에 대한 추가 정보는 <a href="#xml" title="18장. XML 매핑">18장. <i xmlns:xlink="http://www.w3.org/1999/xlink">XML 매핑</i></a>에서 찾을 수 있다. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes-tuplizers"/>4.5. Tuplizer들</h2></div></div></div><p><code class="literal">org.hibernate.tuple.Tuplizer</code>, and its sub-interfaces, are responsible for managing a particular representation of a piece of data given that representation's <code class="literal">org.hibernate.EntityMode</code>. If a given piece of data is thought of as a data structure, then a tuplizer is the thing that knows how to create such a data structure and how to extract values from and inject values into such a data structure. For example, for the POJO entity mode, the corresponding tuplizer knows how create the POJO through its constructor. It also knows how to access the POJO properties using the defined property accessors. </p><p>There are two high-level types of Tuplizers, represented by the <code class="literal">org.hibernate.tuple.entity.EntityTuplizer</code> and <code class="literal">org.hibernate.tuple.component.ComponentTuplizer</code> interfaces. <code class="literal">EntityTuplizer</code>s are responsible for managing the above mentioned contracts in regards to entities, while <code class="literal">ComponentTuplizer</code>s do the same for components. </p><p>Users can also plug in their own tuplizers. Perhaps you require that a <code class="literal">java.util.Map</code> implementation other than <code class="literal">java.util.HashMap</code> be used while in the dynamic-map entity-mode. Or perhaps you need to define a different proxy generation strategy than the one used by default. Both would be achieved by defining a custom tuplizer implementation. Tuplizer definitions are attached to the entity or component mapping they are meant to manage. Going back to the example of our customer entity: </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    &lt;class entity-name="Customer"&gt;
        &lt;!--
            Override the dynamic-map entity-mode
            tuplizer for the customer entity
        --&gt;
        &lt;tuplizer entity-mode="dynamic-map"
                class="CustomMapTuplizerImpl"/&gt;

        &lt;id name="id" type="long" column="ID"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;

        &lt;!-- other properties --&gt;
        ...
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;


public class CustomMapTuplizerImpl
        extends org.hibernate.tuple.entity.DynamicMapEntityTuplizer {
    // override the buildInstantiator() method to plug in our custom map...
    protected final Instantiator buildInstantiator(
            org.hibernate.mapping.PersistentClass mappingInfo) {
        return new CustomMapInstantiator( mappingInfo );
    }

    private static final class CustomMapInstantiator
            extends org.hibernate.tuple.DynamicMapInstantitor {
        // override the generateMap() method to return our custom map...
            protected final Map generateMap() {
                    return new CustomMap();
            }
    }
}</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="persistent-classes-entity-name-resolver"/>4.6. EntityNameResolvers</h2></div></div></div><p>The <code class="interfacename">org.hibernate.EntityNameResolver</code> interface is a contract for resolving the entity name of a given entity instance. The interface defines a single method <code class="methodname">resolveEntityName</code> which is passed the entity instance and is expected to return the appropriate entity name (null is allowed and would indicate that the resolver does not know how to resolve the entity name of the given entity instance). Generally speaking, an <code class="interfacename">org.hibernate.EntityNameResolver</code> is going to be most useful in the case of dynamic models. One example might be using proxied interfaces as your domain model. The hibernate test suite has an example of this exact style of usage under the <span class="package">org.hibernate.test.dynamicentity.tuplizer2</span>. Here is some of the code from that package for illustration. </p><pre class="programlisting">/**
 * A very trivial JDK Proxy InvocationHandler implementation where we proxy an interface as
 * the domain model and simply store persistent state in an internal Map.  This is an extremely
 * trivial example meant only for illustration.
 */
public final class DataProxyHandler implements InvocationHandler {
        private String entityName;
        private HashMap data = new HashMap();

        public DataProxyHandler(String entityName, Serializable id) {
                this.entityName = entityName;
                data.put( "Id", id );
        }

        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                String methodName = method.getName();
                if ( methodName.startsWith( "set" ) ) {
                        String propertyName = methodName.substring( 3 );
                        data.put( propertyName, args[0] );
                }
                else if ( methodName.startsWith( "get" ) ) {
                        String propertyName = methodName.substring( 3 );
                        return data.get( propertyName );
                }
                else if ( "toString".equals( methodName ) ) {
                        return entityName + "#" + data.get( "Id" );
                }
                else if ( "hashCode".equals( methodName ) ) {
                        return new Integer( this.hashCode() );
                }
                return null;
        }

        public String getEntityName() {
                return entityName;
        }

        public HashMap getData() {
                return data;
        }
}

/**
 *
 */
public class ProxyHelper {
    public static String extractEntityName(Object object) {
        // Our custom java.lang.reflect.Proxy instances actually bundle
        // their appropriate entity name, so we simply extract it from there
        // if this represents one of our proxies; otherwise, we return null
        if ( Proxy.isProxyClass( object.getClass() ) ) {
            InvocationHandler handler = Proxy.getInvocationHandler( object );
            if ( DataProxyHandler.class.isAssignableFrom( handler.getClass() ) ) {
                DataProxyHandler myHandler = ( DataProxyHandler ) handler;
                return myHandler.getEntityName();
            }
        }
        return null;
    }

    // various other utility methods ....

}

/**
 * The EntityNameResolver implementation.
 * IMPL NOTE : An EntityNameResolver really defines a strategy for how entity names should be
 * resolved.  Since this particular impl can handle resolution for all of our entities we want to
 * take advantage of the fact that SessionFactoryImpl keeps these in a Set so that we only ever
 * have one instance registered.  Why?  Well, when it comes time to resolve an entity name,
 * Hibernate must iterate over all the registered resolvers.  So keeping that number down
 * helps that process be as speedy as possible.  Hence the equals and hashCode impls
 */
public class MyEntityNameResolver implements EntityNameResolver {
    public static final MyEntityNameResolver INSTANCE = new MyEntityNameResolver();

    public String resolveEntityName(Object entity) {
        return ProxyHelper.extractEntityName( entity );
    }

    public boolean equals(Object obj) {
        return getClass().equals( obj.getClass() );
    }

    public int hashCode() {
        return getClass().hashCode();
    }
}

public class MyEntityTuplizer extends PojoEntityTuplizer {
        public MyEntityTuplizer(EntityMetamodel entityMetamodel, PersistentClass mappedEntity) {
                super( entityMetamodel, mappedEntity );
        }

        public EntityNameResolver[] getEntityNameResolvers() {
                return new EntityNameResolver[] { MyEntityNameResolver.INSTANCE };
        }

    public String determineConcreteSubclassEntityName(Object entityInstance, SessionFactoryImplementor factory) {
        String entityName = ProxyHelper.extractEntityName( entityInstance );
        if ( entityName == null ) {
            entityName = super.determineConcreteSubclassEntityName( entityInstance, factory );
        }
        return entityName;
    }

    ...
}
        </pre><p>In order to register an <code class="interfacename">org.hibernate.EntityNameResolver</code> users must either: </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>Implement a custom <a href="#persistent-classes-tuplizers" title="4.5. Tuplizer들">Tuplizer</a>, implementing the <code class="methodname">getEntityNameResolvers</code> method. </p></li><li><p>Register it with the <code class="classname">org.hibernate.impl.SessionFactoryImpl</code> (which is the implementation class for <code class="interfacename">org.hibernate.SessionFactory</code>) using the <code class="methodname">registerEntityNameResolver</code> method. </p></li></ol></div><p>
        </p></div></div><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="mapping"/>5장. 기본 O/R 매핑</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#mapping-declaration">5.1. 매핑 선언</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-declaration-doctype">5.1.1. Doctype</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-mapping">5.1.2. Hibernate-mapping</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-class">5.1.3. Class</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id">5.1.4. id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id-enhanced">5.1.5. NOT TRANSLATED!Enhanced identifier generators</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-id-enhanced-optimizers">5.1.6. NOT TRANSLATED! Identifier generator optimization</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-compositeid">5.1.7. composite-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-discriminator">5.1.8. Discriminator</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-version">5.1.9. Version (optional)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-timestamp">5.1.10. Timestamp (optional)</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-property">5.1.11. Property</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-manytoone">5.1.12. Many-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-onetoone">5.1.13. One-to-one</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-naturalid">5.1.14. Natural-id</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-component">5.1.15. Component and dynamic-component</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-properties">5.1.16. Properties</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-subclass">5.1.17. Subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-joinedsubclass">5.1.18. Joined-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-unionsubclass">5.1.19. Union-subclass</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-join">5.1.20. Join</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-key">5.1.21. Key</a></span></dt><dt><span class="sect2"><a href="#mapping-column">5.1.22. Column and formula elements</a></span></dt><dt><span class="sect2"><a href="#mapping-declaration-import">5.1.23. Import</a></span></dt><dt><span class="sect2"><a href="#mapping-types-anymapping">5.1.24. Any</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-types">5.2. Hibernate types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-types-entitiesvalues">5.2.1. 엔티티들과 값들</a></span></dt><dt><span class="sect2"><a href="#mapping-types-basictypes">5.2.2. 기본 value 타입들</a></span></dt><dt><span class="sect2"><a href="#mapping-types-custom">5.2.3. 맞춤형 value 타입들</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-entityname">5.3. 하나의 클래스를 한 번 이상 매핑하기</a></span></dt><dt><span class="sect1"><a href="#mapping-quotedidentifiers">5.4. SQL 인용부호 표시된 식별자들</a></span></dt><dt><span class="sect1"><a href="#mapping-alternatives">5.5. Metadata 대안들</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mapping-xdoclet">5.5.1. XDoclet 마크업 사용하기</a></span></dt><dt><span class="sect2"><a href="#mapping-annotations">5.5.2. JDK 5.0 Annotations 사용하기</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mapping-generated">5.6. Generated properties</a></span></dt><dt><span class="sect1"><a href="#mapping-database-object">5.7. Auxiliary database objects</a></span></dt></dl></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-declaration"/>5.1. 매핑 선언</h2></div></div></div><p>Object/relational mappings are usually defined in an XML document. The mapping document is designed to be readable and hand-editable. The mapping language is Java-centric, meaning that mappings are constructed around persistent class declarations and not table declarations. </p><p>Please note that even though many Hibernate users choose to write the XML by hand, a number of tools exist to generate the mapping document. These include XDoclet, Middlegen and AndroMDA. </p><p>Here is an example mapping: </p><a id="mapping-declaration-ex1"/><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
      "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
          "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

        &lt;class name="Cat"
            table="cats"
            discriminator-value="C"&gt;

                &lt;id name="id"&gt;
                        &lt;generator class="native"/&gt;
                &lt;/id&gt;

                &lt;discriminator column="subclass"
                     type="character"/&gt;

                &lt;property name="weight"/&gt;

                &lt;property name="birthdate"
                    type="date"
                    not-null="true"
                    update="false"/&gt;

                &lt;property name="color"
                    type="eg.types.ColorUserType"
                    not-null="true"
                    update="false"/&gt;

                &lt;property name="sex"
                    not-null="true"
                    update="false"/&gt;

                &lt;property name="litterId"
                    column="litterId"
                    update="false"/&gt;

                &lt;many-to-one name="mother"
                    column="mother_id"
                    update="false"/&gt;

                &lt;set name="kittens"
                    inverse="true"
                    order-by="litter_id"&gt;
                        &lt;key column="mother_id"/&gt;
                        &lt;one-to-many class="Cat"/&gt;
                &lt;/set&gt;

                &lt;subclass name="DomesticCat"
                    discriminator-value="D"&gt;

                        &lt;property name="name"
                            type="string"/&gt;

                &lt;/subclass&gt;

        &lt;/class&gt;

        &lt;class name="Dog"&gt;
                &lt;!-- mapping for Dog could go here --&gt;
        &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>We will now discuss the content of the mapping document. We will only describe, however, the document elements and attributes that are used by Hibernate at runtime. The mapping document also contains some extra optional attributes and elements that affect the database schemas exported by the schema export tool (for example, the <code class="literal"> not-null</code> attribute). </p><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-doctype"/>5.1.1. Doctype</h3></div></div></div><p>All XML mappings should declare the doctype shown. The actual DTD can be found at the URL above, in the directory <code class="literal">hibernate-x.x.x/src/org/hibernate </code>, or in <code class="literal">hibernate3.jar</code>. Hibernate will always look for the DTD in its classpath first. If you experience lookups of the DTD using an Internet connection, check the DTD declaration against the contents of your classpath. </p><div class="sect3" lang="ko-KR"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-entity-resolution"/>5.1.1.1. EntityResolver</h4></div></div></div><p>Hibernate will first attempt to resolve DTDs in its classpath. It does this is by registering a custom <code class="literal">org.xml.sax.EntityResolver</code> implementation with the SAXReader it uses to read in the xml files. This custom <code class="literal">EntityResolver</code> recognizes two different systemId namespaces: </p><div class="itemizedlist"><ul><li><p>a <code class="literal">hibernate namespace</code> is recognized whenever the resolver encounters a systemId starting with <code class="literal">http://hibernate.sourceforge.net/</code>. The resolver attempts to resolve these entities via the classloader which loaded the Hibernate classes. </p></li><li><p>a <code class="literal">user namespace</code> is recognized whenever the resolver encounters a systemId using a <code class="literal">classpath://</code> URL protocol. The resolver will attempt to resolve these entities via (1) the current thread context classloader and (2) the classloader which loaded the Hibernate classes. </p></li></ul></div><p>The following is an example of utilizing user namespacing: </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd" [
    &lt;!ENTITY types SYSTEM "classpath://your/domain/types.xml"&gt;
]&gt;

&lt;hibernate-mapping package="your.domain"&gt;
    &lt;class name="MyEntity"&gt;
        &lt;id name="id" type="my-custom-id-type"&gt;
            ...
        &lt;/id&gt;
    &lt;class&gt;
    &amp;types;
&lt;/hibernate-mapping&gt;</pre><p>여기서 <code class="literal">types.xml</code>은 <code class="literal">your.domain</code> 패키지 내에 있는 리소스이고 맞춤형 <a href="#mapping-types-custom" title="5.2.3. 맞춤형 value 타입들">5.2.3절. “맞춤형 value 타입들”</a>를 포함한다. </p></div></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-mapping"/>5.1.2. Hibernate-mapping</h3></div></div></div><p>This element has several optional attributes. The <code class="literal">schema</code> and <code class="literal">catalog</code> attributes specify that tables referred to in this mapping belong to the named schema and/or catalog. If they are specified, tablenames will be qualified by the given schema and catalog names. If they are missing, tablenames will be unqualified. The <code class="literal">default-cascade</code> attribute specifies what cascade style should be assumed for properties and collections that do not specify a <code class="literal">cascade</code> attribute. By default, the <code class="literal">auto-import</code> attribute allows you to use unqualified class names in the query language. </p><div class="programlistingco"><pre class="programlisting">&lt;hibernate-mapping
         schema="schemaName"                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
         catalog="catalogName"                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
         default-cascade="cascade_style"              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
         default-access="field|property|ClassName"    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
         default-lazy="true|false"                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
         auto-import="true|false"                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
         package="package.name"                       <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
 /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">schema</code> (optional): the name of a database schema. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">catalog</code> (optional): the name of a database catalog. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">default-cascade</code> (optional - defaults to <code class="literal">none</code>): a default cascade style. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">default-access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate should use for accessing all properties. It can be a custom implementation of <code class="literal">PropertyAccessor</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">default-lazy</code> (optional - defaults to <code class="literal">true</code>): the default value for unspecified <code class="literal">lazy</code> attributes of class and collection mappings. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">auto-import</code> (optional - defaults to <code class="literal">true</code>): specifies whether we can use unqualified class names of classes in this mapping in the query language. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">package</code> (optional): specifies a package prefix to use for unqualified class names in the mapping document. </p></td></tr></table></div></div><p>If you have two persistent classes with the same unqualified name, you should set <code class="literal">auto-import="false"</code>. An exception will result if you attempt to assign two classes to the same "imported" name. </p><p>The <code class="literal">hibernate-mapping</code> element allows you to nest several persistent <code class="literal">&lt;class&gt;</code> mappings, as shown above. It is, however, good practice (and expected by some tools) to map only a single persistent class, or a single class hierarchy, in one mapping file and name it after the persistent superclass. For example, <code class="literal">Cat.hbm.xml</code>, <code class="literal">Dog.hbm.xml</code>, or if using inheritance, <code class="literal">Animal.hbm.xml</code>. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-class"/>5.1.3. Class</h3></div></div></div><p>You can declare a persistent class using the <code class="literal">class</code> element. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;class
        name="ClassName"                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        table="tableName"                             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        discriminator-value="discriminator_value"     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        mutable="true|false"                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        schema="owner"                                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        catalog="catalog"                             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        proxy="ProxyInterface"                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        dynamic-update="true|false"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
        dynamic-insert="true|false"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/9.png" alt="(9)"/></span>
        select-before-update="true|false"             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/10.png" alt="(10)"/></span>
        polymorphism="implicit|explicit"              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/11.png" alt="(11)"/></span>
        where="arbitrary sql where condition"         <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/12.png" alt="(12)"/></span>
        persister="PersisterClass"                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/13.png" alt="(13)"/></span>
        batch-size="N"                                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/14.png" alt="(14)"/></span>
        optimistic-lock="none|version|dirty|all"      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/15.png" alt="(15)"/></span>
        lazy="true|false"                             <span xmlns="" class="co">(16)</span>
        entity-name="EntityName"                      <span xmlns="" class="co">(17)</span>
        check="arbitrary sql check condition"         <span xmlns="" class="co">(18)</span>
        rowid="rowid"                                 <span xmlns="" class="co">(19)</span>
        subselect="SQL expression"                    <span xmlns="" class="co">(20)</span>
        abstract="true|false"                         <span xmlns="" class="co">(21)</span>
        node="element-name"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code> (optional): the fully qualified Java class name of the persistent class or interface. If this attribute is missing, it is assumed that the mapping is for a non-POJO entity. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">table</code> (optional - defaults to the unqualified class name): the name of its database table. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">discriminator-value</code> (optional - defaults to the class name): a value that distinguishes individual subclasses that is used for polymorphic behavior. Acceptable values include <code class="literal">null</code> and <code class="literal">not null</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">mutable</code> (optional - defaults to <code class="literal">true</code>): specifies that instances of the class are (not) mutable. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">schema</code> (optional): overrides the schema name specified by the root <code class="literal">&lt;hibernate-mapping&gt;</code> element. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">catalog</code> (optional): overrides the catalog name specified by the root <code class="literal">&lt;hibernate-mapping&gt;</code> element. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">proxy</code> (optional): specifies an interface to use for lazy initializing proxies. You can specify the name of the class itself. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">dynamic-update</code> (optional - defaults to <code class="literal">false</code>): specifies that <code class="literal">UPDATE</code> SQL should be generated at runtime and can contain only those columns whose values have changed. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/9.png" alt="9" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">dynamic-insert</code> (optional - defaults to <code class="literal">false</code>): specifies that <code class="literal">INSERT</code> SQL should be generated at runtime and contain only the columns whose values are not null. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/10.png" alt="10" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">select-before-update</code> (optional - defaults to <code class="literal">false</code>): specifies that Hibernate should <span class="emphasis"><em>never</em></span> perform an SQL <code class="literal">UPDATE</code> unless it is certain that an object is actually modified. Only when a transient object has been associated with a new session using <code class="literal">update()</code>, will Hibernate perform an extra SQL <code class="literal">SELECT</code> to determine if an <code class="literal">UPDATE</code> is actually required. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/11.png" alt="11" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">polymorphism</code> (optional - defaults to <code class="literal">implicit</code>): determines whether implicit or explicit query polymorphism is used. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/12.png" alt="12" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">where</code> (optional): specifies an arbitrary SQL <code class="literal">WHERE</code> condition to be used when retrieving objects of this class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/13.png" alt="13" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">persister</code> (optional): specifies a custom <code class="literal">ClassPersister</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/14.png" alt="14" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">batch-size</code> (optional - defaults to <code class="literal">1</code>): specifies a "batch size" for fetching instances of this class by identifier. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/15.png" alt="15" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">version</code>): determines the optimistic locking strategy. </p></td></tr><tr><td width="5%" valign="top" align="left">(16)</td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional): lazy fetching can be disabled by setting <code class="literal">lazy="false"</code>. </p></td></tr><tr><td width="5%" valign="top" align="left">(17)</td><td valign="top" align="left"><p><code class="literal">entity-name</code> (optional - defaults to the class name): Hibernate3 allows a class to be mapped multiple times, potentially to different tables. It also allows entity mappings that are represented by Maps or XML at the Java level. In these cases, you should provide an explicit arbitrary name for the entity. See <a href="#persistent-classes-dynamicmodels" title="4.4. 동적인 모형들">4.4절. “동적인 모형들”</a> and <a href="#xml" title="18장. XML 매핑">18장. <i xmlns:xlink="http://www.w3.org/1999/xlink">XML 매핑</i></a> for more information. </p></td></tr><tr><td width="5%" valign="top" align="left">(18)</td><td valign="top" align="left"><p><code class="literal">check</code> (optional): an SQL expression used to generate a multi-row <span class="emphasis"><em>check</em></span> constraint for automatic schema generation. </p></td></tr><tr><td width="5%" valign="top" align="left">(19)</td><td valign="top" align="left"><p><code class="literal">rowid</code> (optional): Hibernate can use ROWIDs on databases. On Oracle, for example, Hibernate can use the <code class="literal">rowid</code> extra column for fast updates once this option has been set to <code class="literal">rowid</code>. A ROWID is an implementation detail and represents the physical location of a stored tuple. </p></td></tr><tr><td width="5%" valign="top" align="left">(20)</td><td valign="top" align="left"><p><code class="literal">subselect</code> (optional): maps an immutable and read-only entity to a database subselect. This is useful if you want to have a view instead of a base table. See below for more information. </p></td></tr><tr><td width="5%" valign="top" align="left">(21)</td><td valign="top" align="left"><p><code class="literal">abstract</code> (optional): is used to mark abstract superclasses in <code class="literal">&lt;union-subclass&gt;</code> hierarchies. </p></td></tr></table></div></div><p>It is acceptable for the named persistent class to be an interface. You can declare implementing classes of that interface using the <code class="literal">&lt;subclass&gt;</code> element. You can persist any <span class="emphasis"><em>static</em></span> inner class. Specify the class name using the standard form i.e. <code class="literal">e.g.Foo$Bar</code>. </p><p>Immutable classes, <code class="literal">mutable="false"</code>, cannot be updated or deleted by the application. This allows Hibernate to make some minor performance optimizations. </p><p>The optional <code class="literal">proxy</code> attribute enables lazy initialization of persistent instances of the class. Hibernate will initially return CGLIB proxies that implement the named interface. The persistent object will load when a method of the proxy is invoked. See "Initializing collections and proxies" below. </p><p><span class="emphasis"><em>Implicit</em></span> polymorphism means that instances of the class will be returned by a query that names any superclass or implemented interface or class, and that instances of any subclass of the class will be returned by a query that names the class itself. <span class="emphasis"><em>Explicit</em></span> polymorphism means that class instances will be returned only by queries that explicitly name that class. Queries that name the class will return only instances of subclasses mapped inside this <code class="literal">&lt;class&gt;</code> declaration as a <code class="literal">&lt;subclass&gt;</code> or <code class="literal">&lt;joined-subclass&gt;</code>. For most purposes, the default <code class="literal">polymorphism="implicit"</code> is appropriate. Explicit polymorphism is useful when two different classes are mapped to the same table This allows a "lightweight" class that contains a subset of the table columns. </p><p>The <code class="literal">persister</code> attribute lets you customize the persistence strategy used for the class. You can, for example, specify your own subclass of <code class="literal">org.hibernate.persister.EntityPersister</code>, or you can even provide a completely new implementation of the interface <code class="literal">org.hibernate.persister.ClassPersister</code> that implements, for example, persistence via stored procedure calls, serialization to flat files or LDAP. See <code class="literal">org.hibernate.test.CustomPersister</code> for a simple example of "persistence" to a <code class="literal">Hashtable</code>. </p><p>The <code class="literal">dynamic-update</code> and <code class="literal">dynamic-insert</code> settings are not inherited by subclasses, so they can also be specified on the <code class="literal">&lt;subclass&gt;</code> or <code class="literal">&lt;joined-subclass&gt;</code> elements. Although these settings can increase performance in some cases, they can actually decrease performance in others. </p><p>Use of <code class="literal">select-before-update</code> will usually decrease performance. It is useful to prevent a database update trigger being called unnecessarily if you reattach a graph of detached instances to a <code class="literal">Session</code>. </p><p><code class="literal">dynamic-update</code>를 사용가능하게 할 경우, 당신은 다음 optimistic 잠금 전략들을 선택하게 될 것이다: </p><div class="itemizedlist"><ul><li><p><code class="literal">version</code>: check the version/timestamp columns </p></li><li><p><code class="literal">all</code>: check all columns </p></li><li><p><code class="literal">dirty</code>: check the changed columns, allowing some concurrent updates </p></li><li><p><code class="literal">none</code>: do not use optimistic locking </p></li></ul></div><p>It is <span class="emphasis"><em>strongly</em></span> recommended that you use version/timestamp columns for optimistic locking with Hibernate. This strategy optimizes performance and correctly handles modifications made to detached instances (i.e. when <code class="literal">Session.merge()</code> is used). </p><p>There is no difference between a view and a base table for a Hibernate mapping. This is transparent at the database level, although some DBMS do not support views properly, especially with updates. Sometimes you want to use a view, but you cannot create one in the database (i.e. with a legacy schema). In this case, you can map an immutable and read-only entity to a given SQL subselect expression: </p><pre class="programlisting">&lt;class name="Summary"&gt;
    &lt;subselect&gt;
        select item.name, max(bid.amount), count(*)
        from item
        join bid on bid.item_id = item.id
        group by item.name
    &lt;/subselect&gt;
    &lt;synchronize table="item"/&gt;
    &lt;synchronize table="bid"/&gt;
    &lt;id name="name"/&gt;
    ...
&lt;/class&gt;</pre><p>Declare the tables to synchronize this entity with, ensuring that auto-flush happens correctly and that queries against the derived entity do not return stale data. The <code class="literal">&lt;subselect&gt;</code> is available both as an attribute and a nested mapping element. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-id"/>5.1.4. id</h3></div></div></div><p>매핑된 클래스들은 데이터베이스 테이블의 프라이머리 키 컬럼을 선언<span class="emphasis"><em>해야 한다</em></span>. 대부분의 클래스들은 또한 인스턴스의 유일 식별자를 소유하는 자바빈즈-스타일 프로퍼티를 가질 것이다. <code class="literal">&lt;id&gt;</code> 요소는 그 프로퍼티로부터 프라이머리 키 컬럼으로의 매핑을 정의한다. </p><div class="programlistingco"><pre class="programlisting">&lt;id
        name="propertyName"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        type="typename"                                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        column="column_name"                                         <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        unsaved-value="null|any|none|undefined|id_value"             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        access="field|property|ClassName"&gt;                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        node="element-name|@attribute-name|element/@attribute|."

        &lt;generator class="generatorClass"/&gt;
&lt;/id&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code> (optional): the name of the identifier property. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">type</code> (옵션): Hibernate 타입을 나타내는 이름. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional - defaults to the property name): the name of the primary key column. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unsaved-value</code> (optional - defaults to a "sensible" value): an identifier property value that indicates an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate should use for accessing the property value. </p></td></tr></table></div></div><p><code class="literal">name</code> 속성이 누락되면, 클래스는 식별자 프로퍼티를 갖지 않는다고 가정된다. </p><p><code class="literal">unsaved-value</code> 속성은 Hibernate3에서는 거의 필요하지 않다. </p><p>There is an alternative <code class="literal">&lt;composite-id&gt;</code> declaration that allows access to legacy data with composite keys. Its use is strongly discouraged for anything else. </p><div class="sect3" lang="ko-KR"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-generator"/>5.1.4.1. Generator</h4></div></div></div><p>선택적인 <code class="literal">&lt;generator&gt;</code> 자식 요소는 영속 클래스의 인스턴스들에 대한 유일 식별자들을 생성시키는데 사용되는 자바 클래스를 명명한다. 만일 임의의 파라미터들이 생성기 인스턴스를 구성하거나 초기화 시키는데 필요할 경우, 그것들은 <code class="literal">&lt;param&gt;</code> 요소 를 사용하여 전달된다. </p><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="org.hibernate.id.TableHiLoGenerator"&gt;
                &lt;param name="table"&gt;uid_table&lt;/param&gt;
                &lt;param name="column"&gt;next_hi_value_column&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>All generators implement the interface <code class="literal">org.hibernate.id.IdentifierGenerator</code>. This is a very simple interface. Some applications can choose to provide their own specialized implementations, however, Hibernate provides a range of built-in implementations. The shortcut names for the built-in generators are as follows: </p><div class="variablelist"><dl><dt><span class="term"><code class="literal">increment</code></span></dt><dd><p>동일한 테이블 속으로 데이터를 입력하는 다른 프로세스가 없을 때에만 유일한 <code class="literal">long</code>, <code class="literal">short</code> 또는 <code class="literal">int</code> 타입의 식별자들을 생성시킨다. <span class="emphasis"><em>클러스터 내에서는 사용하지 말라.</em></span> </p></dd><dt><span class="term"><code class="literal">identity</code></span></dt><dd><p>DB2, MySQL, MS SQL Server, Sybase, HypersonicSQL에서 식별 컬럼들을 지원한다. 반환되는 식별자는 <code class="literal">long</code>, <code class="literal">short</code> 또는 <code class="literal">int</code> 타입이다. </p></dd><dt><span class="term"><code class="literal">sequence</code></span></dt><dd><p>DB2, PostgreSQL, Oracle, SAP DB, McKoi에서 시퀀스를 사용하거나 Interbase에서 생성기(generator)를 사용한다. 반환되는 식별자는 <code class="literal">long</code>, <code class="literal">short</code> 또는 <code class="literal">int</code> 타입이다. </p></dd><dt><span class="term"><code class="literal">hilo</code></span></dt><dd><p><a id="mapping-declaration-id-hilodescription"/>테이블과 컬럼(디폴트로 각각 <code class="literal">hibernate_unique_key</code>와 <code class="literal">next_hi</code>)이 hi 값들의 소스로서 주어지면, <code class="literal">long</code>, <code class="literal">short</code> 또는 <code class="literal">int</code> 타입의 식별자들을 효과적으로 생성시키는데 hi/lo 알고리즘을 사용한다. hi/lo 알고리즘은 특정 데이터베이스에 대해서만 유일한 식별자들을 생성시킨다. </p></dd><dt><span class="term"><code class="literal">seqhilo</code></span></dt><dd><p>명명된 데이터베이스 시퀀스가 주어지면, <code class="literal">long</code>, <code class="literal">short</code> 또는 <code class="literal">int</code> 타입의 식별자들을 효과적으로 생성시키는데 hi/lo 알고리즘을 사용한다. </p></dd><dt><span class="term"><code class="literal">uuid</code></span></dt><dd><p>uses a 128-bit UUID algorithm to generate identifiers of type string that are unique within a network (the IP address is used). The UUID is encoded as a string of 32 hexadecimal digits in length. </p></dd><dt><span class="term"><code class="literal">guid</code></span></dt><dd><p>MS SQL Server와 MySQL 상에서 데이터베이스 생성 GUID 문자열을 사용한다. </p></dd><dt><span class="term"><code class="literal">native</code></span></dt><dd><p>selects <code class="literal">identity</code>, <code class="literal">sequence</code> or <code class="literal">hilo</code> depending upon the capabilities of the underlying database. </p></dd><dt><span class="term"><code class="literal">assigned</code></span></dt><dd><p>lets the application assign an identifier to the object before <code class="literal">save()</code> is called. This is the default strategy if no <code class="literal">&lt;generator&gt;</code> element is specified. </p></dd><dt><span class="term"><code class="literal">select</code></span></dt><dd><p>retrieves a primary key, assigned by a database trigger, by selecting the row by some unique key and retrieving the primary key value. </p></dd><dt><span class="term"><code class="literal">foreign</code></span></dt><dd><p>uses the identifier of another associated object. It is usually used in conjunction with a <code class="literal">&lt;one-to-one&gt;</code> primary key association. </p></dd><dt><span class="term"><code class="literal">sequence-identity</code></span></dt><dd><p>a specialized sequence generation strategy that utilizes a database sequence for the actual value generation, but combines this with JDBC3 getGeneratedKeys to return the generated identifier value as part of the insert statement execution. This strategy is only supported on Oracle 10g drivers targeted for JDK 1.4. Comments on these insert statements are disabled due to a bug in the Oracle drivers. </p></dd></dl></div><p>

                </p></div><div class="sect3" lang="ko-KR"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-hilo"/>5.1.4.2. Hi/lo algorithm</h4></div></div></div><p>The <code class="literal">hilo</code> and <code class="literal">seqhilo</code> generators provide two alternate implementations of the hi/lo algorithm. The first implementation requires a "special" database table to hold the next available "hi" value. Where supported, the second uses an Oracle-style sequence. </p><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="hilo"&gt;
                &lt;param name="table"&gt;hi_value&lt;/param&gt;
                &lt;param name="column"&gt;next_value&lt;/param&gt;
                &lt;param name="max_lo"&gt;100&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><pre class="programlisting">&lt;id name="id" type="long" column="cat_id"&gt;
        &lt;generator class="seqhilo"&gt;
                &lt;param name="sequence"&gt;hi_value&lt;/param&gt;
                &lt;param name="max_lo"&gt;100&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>Unfortunately, you cannot use <code class="literal">hilo</code> when supplying your own <code class="literal">Connection</code> to Hibernate. When Hibernate uses an application server datasource to obtain connections enlisted with JTA, you must configure the <code class="literal">hibernate.transaction.manager_lookup_class</code>. </p></div><div class="sect3" lang="ko-KR"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-uuid"/>5.1.4.3. UUID 알고리즘</h4></div></div></div><p>The UUID contains: IP address, startup time of the JVM that is accurate to a quarter second, system time and a counter value that is unique within the JVM. It is not possible to obtain a MAC address or memory address from Java code, so this is the best option without using JNI. </p></div><div class="sect3" lang="ko-KR"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-sequences"/>5.1.4.4. 식별 컬럼들과 시퀀스들</h4></div></div></div><p>For databases that support identity columns (DB2, MySQL, Sybase, MS SQL), you can use <code class="literal">identity</code> key generation. For databases that support sequences (DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB) you can use <code class="literal">sequence</code> style key generation. Both of these strategies require two SQL queries to insert a new object. For example: </p><pre class="programlisting">&lt;id name="id" type="long" column="person_id"&gt;
        &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;person_id_sequence&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><pre class="programlisting">&lt;id name="id" type="long" column="person_id" unsaved-value="0"&gt;
        &lt;generator class="identity"/&gt;
&lt;/id&gt;</pre><p>For cross-platform development, the <code class="literal">native</code> strategy will, depending on the capabilities of the underlying database, choose from the <code class="literal">identity</code>, <code class="literal">sequence</code> and <code class="literal">hilo</code> strategies. </p></div><div class="sect3" lang="ko-KR"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-assigned"/>5.1.4.5. 할당된 식별자들</h4></div></div></div><p>If you want the application to assign identifiers, as opposed to having Hibernate generate them, you can use the <code class="literal">assigned</code> generator. This special generator uses the identifier value already assigned to the object's identifier property. The generator is used when the primary key is a natural key instead of a surrogate key. This is the default behavior if you do not specify a <code class="literal">&lt;generator&gt;</code> element. </p><p>The <code class="literal">assigned</code> generator makes Hibernate use <code class="literal">unsaved-value="undefined"</code>. This forces Hibernate to go to the database to determine if an instance is transient or detached, unless there is a version or timestamp property, or you define <code class="literal">Interceptor.isUnsaved()</code>. </p></div><div class="sect3" lang="ko-KR"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-select"/>5.1.4.6. 트리거들에 의해 할당된 프라이머리 키들</h4></div></div></div><p>Hibernate does not generate DDL with triggers. It is for legacy schemas only. </p><pre class="programlisting">&lt;id name="id" type="long" column="person_id"&gt;
        &lt;generator class="select"&gt;
                &lt;param name="key"&gt;socialSecurityNumber&lt;/param&gt;
        &lt;/generator&gt;
&lt;/id&gt;</pre><p>In the above example, there is a unique valued property named <code class="literal">socialSecurityNumber</code>. It is defined by the class, as a natural key and a surrogate key named <code class="literal">person_id</code>, whose value is generated by a trigger. </p></div></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-id-enhanced"/>5.1.5. NOT TRANSLATED!Enhanced identifier generators</h3></div></div></div><p>Starting with release 3.2.3, there are 2 new generators which represent a re-thinking of 2 different aspects of identifier generation. The first aspect is database portability; the second is optimization Optimization means that you do not have to query the database for every request for a new identifier value. These two new generators are intended to take the place of some of the named generators described above, starting in 3.3.x. However, they are included in the current releases and can be referenced by FQN. </p><p>The first of these new generators is <code class="literal">org.hibernate.id.enhanced.SequenceStyleGenerator</code> which is intended, firstly, as a replacement for the <code class="literal">sequence</code> generator and, secondly, as a better portability generator than <code class="literal">native</code>. This is because <code class="literal">native</code> generally chooses between <code class="literal">identity</code> and <code class="literal">sequence</code> which have largely different semantics that can cause subtle issues in applications eyeing portability. <code class="literal">org.hibernate.id.enhanced.SequenceStyleGenerator</code>, however, achieves portability in a different manner. It chooses between a table or a sequence in the database to store its incrementing values, depending on the capabilities of the dialect being used. The difference between this and <code class="literal">native</code> is that table-based and sequence-based storage have the same exact semantic. In fact, sequences are exactly what Hibernate tries to emulate with its table-based generators. This generator has a number of configuration parameters: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">sequence_name</code> (optional, defaults to <code class="literal">hibernate_sequence</code>): the name of the sequence or table to be used. </p></li><li><p><code class="literal">initial_value</code> (optional, defaults to <code class="literal">1</code>): the initial value to be retrieved from the sequence/table. In sequence creation terms, this is analogous to the clause typically named "STARTS WITH". </p></li><li><p><code class="literal">increment_size</code> (optional - defaults to <code class="literal">1</code>): the value by which subsequent calls to the sequence/table should differ. In sequence creation terms, this is analogous to the clause typically named "INCREMENT BY". </p></li><li><p><code class="literal">force_table_use</code> (optional - defaults to <code class="literal">false</code>): should we force the use of a table as the backing structure even though the dialect might support sequence? </p></li><li><p><code class="literal">value_column</code> (optional - defaults to <code class="literal">next_val</code>): only relevant for table structures, it is the name of the column on the table which is used to hold the value. </p></li><li><p><code class="literal">optimizer</code> (optional - defaults to <code class="literal">none</code>): See <a href="#mapping-declaration-id-enhanced-optimizers" title="5.1.6. NOT TRANSLATED! Identifier generator optimization">5.1.6절. “NOT TRANSLATED! Identifier generator optimization”</a> </p></li></ul></div><p>
            </p><p>The second of these new generators is <code class="literal">org.hibernate.id.enhanced.TableGenerator</code>, which is intended, firstly, as a replacement for the <code class="literal">table</code> generator, even though it actually functions much more like <code class="literal">org.hibernate.id.MultipleHiLoPerTableGenerator</code>, and secondly, as a re-implementation of <code class="literal">org.hibernate.id.MultipleHiLoPerTableGenerator</code> that utilizes the notion of pluggable optimizers. Essentially this generator defines a table capable of holding a number of different increment values simultaneously by using multiple distinctly keyed rows. This generator has a number of configuration parameters: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">table_name</code> (optional - defaults to <code class="literal">hibernate_sequences</code>): the name of the table to be used. </p></li><li><p><code class="literal">value_column_name</code> (optional - defaults to <code class="literal">next_val</code>): the name of the column on the table that is used to hold the value. </p></li><li><p><code class="literal">segment_column_name</code> (optional - defaults to <code class="literal">sequence_name</code>): the name of the column on the table that is used to hold the "segment key". This is the value which identifies which increment value to use. </p></li><li><p><code class="literal">segment_value</code> (optional - defaults to <code class="literal">default</code>): The "segment key" value for the segment from which we want to pull increment values for this generator. </p></li><li><p><code class="literal">segment_value_length</code> (optional - defaults to <code class="literal">255</code>): Used for schema generation; the column size to create this segment key column. </p></li><li><p><code class="literal">initial_value</code> (optional - defaults to <code class="literal">1</code>): The initial value to be retrieved from the table. </p></li><li><p><code class="literal">increment_size</code> (optional - defaults to <code class="literal">1</code>): The value by which subsequent calls to the table should differ. </p></li><li><p><code class="literal">optimizer</code> (optional - defaults to <code class="literal"/>): See <a href="#mapping-declaration-id-enhanced-optimizers" title="5.1.6. NOT TRANSLATED! Identifier generator optimization">5.1.6절. “NOT TRANSLATED! Identifier generator optimization”</a> </p></li></ul></div><p>
            </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-id-enhanced-optimizers"/>5.1.6. NOT TRANSLATED! Identifier generator optimization</h3></div></div></div><p>For identifier generators that store values in the database, it is inefficient for them to hit the database on each and every call to generate a new identifier value. Instead, you can group a bunch of them in memory and only hit the database when you have exhausted your in-memory value group. This is the role of the pluggable optimizers. Currently only the two enhanced generators (<a href="#mapping-declaration-id-enhanced" title="5.1.5. NOT TRANSLATED!Enhanced identifier generators">5.1.5절. “NOT TRANSLATED!Enhanced identifier generators”</a> support this operation. </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">none</code> (generally this is the default if no optimizer was specified): this will not perform any optimizations and hit the database for each and every request. </p></li><li><p><code class="literal">hilo</code>: applies a hi/lo algorithm around the database retrieved values. The values from the database for this optimizer are expected to be sequential. The values retrieved from the database structure for this optimizer indicates the "group number". The <code class="literal">increment_size</code> is multiplied by that value in memory to define a group "hi value". </p></li><li><p><code class="literal">pooled</code>: as with the case of <code class="literal">hilo</code>, this optimizer attempts to minimize the number of hits to the database. Here, however, we simply store the starting value for the "next group" into the database structure rather than a sequential value in combination with an in-memory grouping algorithm. Here, <code class="literal">increment_size</code> refers to the values coming from the database. </p></li></ul></div><p>
            </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-compositeid"/>5.1.7. composite-id</h3></div></div></div><pre class="programlisting">&lt;composite-id
        name="propertyName"
        class="ClassName"
        mapped="true|false"
        access="field|property|ClassName"&gt;
        node="element-name|."

        &lt;key-property name="propertyName" type="typename" column="column_name"/&gt;
        &lt;key-many-to-one name="propertyName class="ClassName" column="column_name"/&gt;
        ......
&lt;/composite-id&gt;</pre><p>A table with a composite key can be mapped with multiple properties of the class as identifier properties. The <code class="literal">&lt;composite-id&gt;</code> element accepts <code class="literal">&lt;key-property&gt;</code> property mappings and <code class="literal">&lt;key-many-to-one&gt;</code> mappings as child elements. </p><pre class="programlisting">&lt;composite-id&gt;
        &lt;key-property name="medicareNumber"/&gt;
        &lt;key-property name="dependent"/&gt;
&lt;/composite-id&gt;</pre><p>The persistent class <span class="emphasis"><em>must</em></span> override <code class="literal">equals()</code> and <code class="literal">hashCode()</code> to implement composite identifier equality. It must also implement <code class="literal">Serializable</code>. </p><p>Unfortunately, this approach means that a persistent object is its own identifier. There is no convenient "handle" other than the object itself. You must instantiate an instance of the persistent class itself and populate its identifier properties before you can <code class="literal">load()</code> the persistent state associated with a composite key. We call this approach an <span class="emphasis"><em>embedded</em></span> composite identifier, and discourage it for serious applications. </p><p>두 번째 접근법은 우리가 <span class="emphasis"><em>mapped</em></span> composite 식별자라고 부르는 것인데, 여기서 <code class="literal">&lt;composite-id&gt;</code> 요소 내에 명명된 여기서 식별자 프로퍼티들은 영속 클래스와 별도의 식별자 클래스 양자 상에 중복된다. </p><pre class="programlisting">&lt;composite-id class="MedicareId" mapped="true"&gt;
        &lt;key-property name="medicareNumber"/&gt;
        &lt;key-property name="dependent"/&gt;
&lt;/composite-id&gt;</pre><p>In this example, both the composite identifier class, <code class="literal">MedicareId</code>, and the entity class itself have properties named <code class="literal">medicareNumber</code> and <code class="literal">dependent</code>. The identifier class must override <code class="literal">equals()</code> and <code class="literal">hashCode()</code> and implement <code class="literal">Serializable</code>. The main disadvantage of this approach is code duplication. </p><p>다음 속성들은 매핑된 composite 식별자를 지정하는데 사용된다: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">mapped</code> (optional - defaults to <code class="literal">false</code>): indicates that a mapped composite identifier is used, and that the contained property mappings refer to both the entity class and the composite identifier class. </p></li><li><p><code class="literal">class</code> (optional - but required for a mapped composite identifier): the class used as a composite identifier. </p></li></ul></div><p>We will describe a third, even more convenient approach, where the composite identifier is implemented as a component class in <a href="#components-compositeid" title="8.4. composite 식별자들로서 컴포넌트들">8.4절. “composite 식별자들로서 컴포넌트들”</a>. The attributes described below apply only to this alternative approach: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">name</code> (optional - required for this approach): a property of component type that holds the composite identifier. Please see chapter 9 for more information. </p></li><li><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></li><li><p><code class="literal">class</code> (optional - defaults to the property type determined by reflection): the component class used as a composite identifier. Please see the next section for more information. </p></li></ul></div><p>The third approach, an <span class="emphasis"><em>identifier component</em></span>, is recommended for almost all applications. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-discriminator"/>5.1.8. Discriminator</h3></div></div></div><p>The <code class="literal">&lt;discriminator&gt;</code> element is required for polymorphic persistence using the table-per-class-hierarchy mapping strategy. It declares a discriminator column of the table. The discriminator column contains marker values that tell the persistence layer what subclass to instantiate for a particular row. A restricted set of types can be used: <code class="literal">string</code>, <code class="literal">character</code>, <code class="literal">integer</code>, <code class="literal">byte</code>, <code class="literal">short</code>, <code class="literal">boolean</code>, <code class="literal">yes_no</code>, <code class="literal">true_false</code>. </p><div class="programlistingco"><pre class="programlisting">&lt;discriminator
        column="discriminator_column"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        type="discriminator_type"                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        force="true|false"                                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        insert="true|false"                                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        formula="arbitrary sql expression"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional - defaults to <code class="literal">class</code>): the name of the discriminator column. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">type</code> (optional - defaults to <code class="literal">string</code>): a name that indicates the Hibernate type </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">force</code> (optional - defaults to <code class="literal">false</code>): "forces" Hibernate to specify the allowed discriminator values, even when retrieving all instances of the root class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">insert</code> (optional - defaults to <code class="literal">true</code>): set this to <code class="literal">false</code> if your discriminator column is also part of a mapped composite identifier. It tells Hibernate not to include the column in SQL <code class="literal">INSERTs</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">formula</code> (optional): an arbitrary SQL expression that is executed when a type has to be evaluated. It allows content-based discrimination. </p></td></tr></table></div></div><p>discriminator 컬럼의 실제 값들은 <code class="literal">&lt;class&gt;</code> 요소와 <code class="literal">&lt;subclass&gt;</code> 요소의 <code class="literal">discriminator-value</code> 속성에 의해 지정된다. </p><p>The <code class="literal">force</code> attribute is only useful if the table contains rows with "extra" discriminator values that are not mapped to a persistent class. This will not usually be the case. </p><p>The <code class="literal">formula</code> attribute allows you to declare an arbitrary SQL expression that will be used to evaluate the type of a row. For example: </p><pre class="programlisting">&lt;discriminator
    formula="case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end"
    type="integer"/&gt;</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-version"/>5.1.9. Version (optional)</h3></div></div></div><p>The <code class="literal">&lt;version&gt;</code> element is optional and indicates that the table contains versioned data. This is particularly useful if you plan to use <span class="emphasis"><em>long transactions</em></span>. See below for more information: </p><div class="programlistingco"><pre class="programlisting">&lt;version
        column="version_column"                                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        name="propertyName"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        type="typename"                                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        access="field|property|ClassName"                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        unsaved-value="null|negative|undefined"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        generated="never|always"                                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        insert="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        node="element-name|@attribute-name|element/@attribute|."
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional - defaults to the property name): the name of the column holding the version number. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the name of a property of the persistent class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">type</code> (optional - defaults to <code class="literal">integer</code>): the type of the version number. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses to access the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unsaved-value</code> (optional - defaults to <code class="literal">undefined</code>): a version property value that indicates that an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session. <code class="literal">Undefined</code> specifies that the identifier property value should be used. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">generated</code> (optional - defaults to <code class="literal">never</code>): specifies that this version property value is generated by the database. See the discussion of <a href="#mapping-generated" title="5.6. Generated properties">generated properties</a> for more information. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">insert</code> (optional - defaults to <code class="literal">true</code>): specifies whether the version column should be included in SQL insert statements. It can be set to <code class="literal">false</code> if the database column is defined with a default value of <code class="literal">0</code>. </p></td></tr></table></div></div><p>Version numbers can be of Hibernate type <code class="literal">long</code>, <code class="literal">integer</code>, <code class="literal">short</code>, <code class="literal">timestamp</code> or <code class="literal">calendar</code>. </p><p>A version or timestamp property should never be null for a detached instance. Hibernate will detect any instance with a null version or timestamp as transient, irrespective of what other <code class="literal">unsaved-value</code> strategies are specified. <span class="emphasis"><em>Declaring a nullable version or timestamp property is an easy way to avoid problems with transitive reattachment in Hibernate. It is especially useful for people using assigned identifiers or composite keys</em></span>. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-timestamp"/>5.1.10. Timestamp (optional)</h3></div></div></div><p>The optional <code class="literal">&lt;timestamp&gt;</code> element indicates that the table contains timestamped data. This provides an alternative to versioning. Timestamps are a less safe implementation of optimistic locking. However, sometimes the application might use the timestamps in other ways. </p><div class="programlistingco"><pre class="programlisting">&lt;timestamp
        column="timestamp_column"                                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        name="propertyName"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        access="field|property|ClassName"                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        unsaved-value="null|undefined"                               <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        source="vm|db"                                               <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        generated="never|always"                                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        node="element-name|@attribute-name|element/@attribute|."
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional - defaults to the property name): the name of a column holding the timestamp. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the name of a JavaBeans style property of Java type <code class="literal">Date</code> or <code class="literal">Timestamp</code> of the persistent class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unsaved-value</code> (optional - defaults to <code class="literal">null</code>): a version property value that indicates that an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session. <code class="literal">Undefined</code> specifies that the identifier property value should be used. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">source</code> (optional - defaults to <code class="literal">vm</code>): Where should Hibernate retrieve the timestamp value from? From the database, or from the current JVM? Database-based timestamps incur an overhead because Hibernate must hit the database in order to determine the "next value". It is safer to use in clustered environments. Not all <code class="literal">Dialects</code> are known to support the retrieval of the database's current timestamp. Others may also be unsafe for usage in locking due to lack of precision (Oracle 8, for example). </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">generated</code> (optional - defaults to <code class="literal">never</code>): specifies that this timestamp property value is actually generated by the database. See the discussion of <a href="#mapping-generated" title="5.6. Generated properties">generated properties</a> for more information. </p></td></tr></table></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p><code class="literal">&lt;Timestamp&gt;</code> is equivalent to <code class="literal">&lt;version type="timestamp"&gt;</code>. And <code class="literal">&lt;timestamp source="db"&gt;</code> is equivalent to <code class="literal">&lt;version type="dbtimestamp"&gt;</code> </p></div></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-property"/>5.1.11. Property</h3></div></div></div><p>The <code class="literal">&lt;property&gt;</code> element declares a persistent JavaBean style property of the class. </p><div class="programlistingco"><pre class="programlisting">&lt;property
        name="propertyName"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        column="column_name"                                         <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        type="typename"                                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        update="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        insert="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        formula="arbitrary SQL expression"                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        access="field|property|ClassName"                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        lazy="true|false"                                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        unique="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
        not-null="true|false"                                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/9.png" alt="(9)"/></span>
        optimistic-lock="true|false"                                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/10.png" alt="(10)"/></span>
        generated="never|insert|always"                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/11.png" alt="(11)"/></span>
        node="element-name|@attribute-name|element/@attribute|."
        index="index_name"
        unique_key="unique_key_id"
        length="L"
        precision="P"
        scale="S"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: 첫 소문자로 시작하는 프로퍼티 이름. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional - defaults to the property name): the name of the mapped database table column. This can also be specified by nested <code class="literal">&lt;column&gt;</code> element(s). </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">type</code> (옵션): Hibernate 타입을 나타내는 이름. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">update, insert</code> (optional - defaults to <code class="literal">true</code>): specifies that the mapped columns should be included in SQL <code class="literal">UPDATE</code> and/or <code class="literal">INSERT</code> statements. Setting both to <code class="literal">false</code> allows a pure "derived" property whose value is initialized from some other property that maps to the same column(s), or by a trigger or other application. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">formula</code> (옵션): <span class="emphasis"><em>계산되는</em></span> 프로퍼티에 대해 값을 정의하는 SQL 표현식. 계산되는 프로퍼티들은 그것들 자신에 대한 컬럼 매핑을 갖지 않는다. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional - defaults to <code class="literal">false</code>): specifies that this property should be fetched lazily when the instance variable is first accessed. It requires build-time bytecode instrumentation. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unique</code> (optional): enables the DDL generation of a unique constraint for the columns. Also, allow this to be the target of a <code class="literal">property-ref</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/9.png" alt="9" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">not-null</code> (optional): enables the DDL generation of a nullability constraint for the columns. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/10.png" alt="10" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">true</code>): specifies that updates to this property do or do not require acquisition of the optimistic lock. In other words, it determines if a version increment should occur when this property is dirty. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/11.png" alt="11" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">generated</code> (optional - defaults to <code class="literal">never</code>): specifies that this property value is actually generated by the database. See the discussion of <a href="#mapping-generated" title="5.6. Generated properties">generated properties</a> for more information. </p></td></tr></table></div></div><p><span class="emphasis"><em>typename</em></span>은 다음일 수 있다: </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>The name of a Hibernate basic type: <code class="literal">integer, string, character, date, timestamp, float, binary, serializable, object, blob</code> etc. </p></li><li><p>The name of a Java class with a default basic type: <code class="literal">int, float, char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</code> etc. </p></li><li><p>serializable Java 클래스의 이름. </p></li><li><p>The class name of a custom type: <code class="literal">com.illflow.type.MyCustomType</code> etc. </p></li></ol></div><p>If you do not specify a type, Hibernate will use reflection upon the named property and guess the correct Hibernate type. Hibernate will attempt to interpret the name of the return class of the property getter using, in order, rules 2, 3, and 4. In certain cases you will need the <code class="literal">type</code> attribute. For example, to distinguish between <code class="literal">Hibernate.DATE</code> and <code class="literal">Hibernate.TIMESTAMP</code>, or to specify a custom type. </p><p>The <code class="literal">access</code> attribute allows you to control how Hibernate accesses the property at runtime. By default, Hibernate will call the property get/set pair. If you specify <code class="literal">access="field"</code>, Hibernate will bypass the get/set pair and access the field directly using reflection. You can specify your own strategy for property access by naming a class that implements the interface <code class="literal">org.hibernate.property.PropertyAccessor</code>. </p><p>A powerful feature is derived properties. These properties are by definition read-only. The property value is computed at load time. You declare the computation as an SQL expression. This then translates to a <code class="literal">SELECT</code> clause subquery in the SQL query that loads an instance: </p><pre class="programlisting">
&lt;property name="totalPrice"
    formula="( SELECT SUM (li.quantity*p.price) FROM LineItem li, Product p
                WHERE li.productId = p.productId
                AND li.customerId = customerId
                AND li.orderNumber = orderNumber )"/&gt;</pre><p>You can reference the entity table by not declaring an alias on a particular column. This would be <code class="literal">customerId</code> in the given example. You can also use the nested <code class="literal">&lt;formula&gt;</code> mapping element if you do not want to use the attribute. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-manytoone"/>5.1.12. Many-to-one</h3></div></div></div><p>An ordinary association to another persistent class is declared using a <code class="literal">many-to-one</code> element. The relational model is a many-to-one association; a foreign key in one table is referencing the primary key column(s) of the target table. </p><div class="programlistingco"><pre class="programlisting">&lt;many-to-one
        name="propertyName"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        column="column_name"                                         <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        class="ClassName"                                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        cascade="cascade_style"                                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        fetch="join|select"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        update="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        insert="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        property-ref="propertyNameFromAssociatedClass"               <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        access="field|property|ClassName"                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
        unique="true|false"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/9.png" alt="(9)"/></span>
        not-null="true|false"                                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/10.png" alt="(10)"/></span>
        optimistic-lock="true|false"                                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/11.png" alt="(11)"/></span>
        lazy="proxy|no-proxy|false"                                  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/12.png" alt="(12)"/></span>
        not-found="ignore|exception"                                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/13.png" alt="(13)"/></span>
        entity-name="EntityName"                                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/14.png" alt="(14)"/></span>
        formula="arbitrary SQL expression"                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/15.png" alt="(15)"/></span>
        node="element-name|@attribute-name|element/@attribute|."
        embed-xml="true|false"
        index="index_name"
        unique_key="unique_key_id"
        foreign-key="foreign_key_name"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the name of the property. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional): the name of the foreign key column. This can also be specified by nested <code class="literal">&lt;column&gt;</code> element(s). </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">class</code> (optional - defaults to the property type determined by reflection): the name of the associated class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">cascade</code> (optional): specifies which operations should be cascaded from the parent object to the associated object. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">fetch</code> (optional - defaults to <code class="literal">select</code>): chooses between outer-join fetching or sequential select fetching. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">update, insert</code> (optional - defaults to <code class="literal">true</code>): specifies that the mapped columns should be included in SQL <code class="literal">UPDATE</code> and/or <code class="literal">INSERT</code> statements. Setting both to <code class="literal">false</code> allows a pure "derived" association whose value is initialized from another property that maps to the same column(s), or by a trigger or other application. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">property-ref</code> (optional): the name of a property of the associated class that is joined to this foreign key. If not specified, the primary key of the associated class is used. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/9.png" alt="9" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unique</code> (optional): enables the DDL generation of a unique constraint for the foreign-key column. By allowing this to be the target of a <code class="literal">property-ref</code>, you can make the association multiplicity one-to-one. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/10.png" alt="10" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">not-null</code> (optional): enables the DDL generation of a nullability constraint for the foreign key columns. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/11.png" alt="11" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">true</code>): specifies that updates to this property do or do not require acquisition of the optimistic lock. In other words, it determines if a version increment should occur when this property is dirty. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/12.png" alt="12" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional - defaults to <code class="literal">proxy</code>): by default, single point associations are proxied. <code class="literal">lazy="no-proxy"</code> specifies that the property should be fetched lazily when the instance variable is first accessed. This requires build-time bytecode instrumentation. <code class="literal">lazy="false"</code> specifies that the association will always be eagerly fetched. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/13.png" alt="13" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">not-found</code> (optional - defaults to <code class="literal">exception</code>): specifies how foreign keys that reference missing rows will be handled. <code class="literal">ignore</code> will treat a missing row as a null association. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/14.png" alt="14" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">entity-name</code> (optional): the entity name of the associated class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/15.png" alt="15" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">formula</code> (옵션): <span class="emphasis"><em>계산된</em></span> foreign key에 대한 값을 정의하는 SQL 표현식. </p></td></tr></table></div></div><p>Setting a value of the <code class="literal">cascade</code> attribute to any meaningful value other than <code class="literal">none</code> will propagate certain operations to the associated object. The meaningful values are divided into three categories. First, basic operations, which include: <code class="literal">persist, merge, delete, save-update, evict, replicate, lock and refresh</code>; second, special values: <code class="literal">delete-orphan</code>; and third,<code class="literal">all</code> comma-separated combinations of operation names: <code class="literal">cascade="persist,merge,evict"</code> or <code class="literal">cascade="all,delete-orphan"</code>. See <a href="#objectstate-transitive" title="10.11. Transitive persistence(전이 영속)">10.11절. “Transitive persistence(전이 영속)”</a> for a full explanation. Note that single valued, many-to-one and one-to-one, associations do not support orphan delete. </p><p>Here is an example of a typical <code class="literal">many-to-one</code> declaration: </p><pre class="programlisting">&lt;many-to-one name="product" class="Product" column="PRODUCT_ID"/&gt;</pre><p>The <code class="literal">property-ref</code> attribute should only be used for mapping legacy data where a foreign key refers to a unique key of the associated table other than the primary key. This is a complicated and confusing relational model. For example, if the <code class="literal">Product</code> class had a unique serial number that is not the primary key. The <code class="literal">unique</code> attribute controls Hibernate's DDL generation with the SchemaExport tool. </p><pre class="programlisting">&lt;property name="serialNumber" unique="true" type="string" column="SERIAL_NUMBER"/&gt;</pre><p>그런 다음 <code class="literal">OrderItem</code>에 대한 매핑은 다음을 사용할 것이다: </p><pre class="programlisting">&lt;many-to-one name="product" property-ref="serialNumber" column="PRODUCT_SERIAL_NUMBER"/&gt;</pre><p>This is not encouraged, however. </p><p>만일 참조된 유일 키가 연관된 엔티티의 여러 프로퍼티들을 포함할 경우, 당신은 명명된 <code class="literal">&lt;properties&gt;</code> 요소 내부에 참조된 프로퍼티들을 매핑할 것이다. </p><p>If the referenced unique key is the property of a component, you can specify a property path: </p><pre class="programlisting">&lt;many-to-one name="owner" property-ref="identity.ssn" column="OWNER_SSN"/&gt;</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-onetoone"/>5.1.13. One-to-one</h3></div></div></div><p>또 다른 영속 클래스에 대한 one-to-one 연관관계는 <code class="literal">one-to-one</code> 요소를 사용하여 선언된다. </p><div class="programlistingco"><pre class="programlisting">&lt;one-to-one
        name="propertyName"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        class="ClassName"                                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        cascade="cascade_style"                                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        constrained="true|false"                                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        fetch="join|select"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        property-ref="propertyNameFromAssociatedClass"               <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        access="field|property|ClassName"                            <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        formula="any SQL expression"                                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
        lazy="proxy|no-proxy|false"                                  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/9.png" alt="(9)"/></span>
        entity-name="EntityName"                                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/10.png" alt="(10)"/></span>
        node="element-name|@attribute-name|element/@attribute|."
        embed-xml="true|false"
        foreign-key="foreign_key_name"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the name of the property. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">class</code> (optional - defaults to the property type determined by reflection): the name of the associated class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">cascade</code> (optional): specifies which operations should be cascaded from the parent object to the associated object. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">constrained</code> (optional): specifies that a foreign key constraint on the primary key of the mapped table and references the table of the associated class. This option affects the order in which <code class="literal">save()</code> and <code class="literal">delete()</code> are cascaded, and determines whether the association can be proxied. It is also used by the schema export tool. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">fetch</code> (optional - defaults to <code class="literal">select</code>): chooses between outer-join fetching or sequential select fetching. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">property-ref</code> (optional): the name of a property of the associated class that is joined to the primary key of this class. If not specified, the primary key of the associated class is used. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">formula</code> (optional): almost all one-to-one associations map to the primary key of the owning entity. If this is not the case, you can specify another column, columns or expression to join on using an SQL formula. See <code class="literal">org.hibernate.test.onetooneformula</code> for an example. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/9.png" alt="9" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional - defaults to <code class="literal">proxy</code>): by default, single point associations are proxied. <code class="literal">lazy="no-proxy"</code> specifies that the property should be fetched lazily when the instance variable is first accessed. It requires build-time bytecode instrumentation. <code class="literal">lazy="false"</code> specifies that the association will always be eagerly fetched. <span class="emphasis"><em>Note that if <code class="literal">constrained="false"</code>, proxying is impossible and Hibernate will eagerly fetch the association</em></span>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/10.png" alt="10" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">entity-name</code> (optional): the entity name of the associated class. </p></td></tr></table></div></div><p>There are two varieties of one-to-one associations: </p><div class="itemizedlist"><ul><li><p>프라이머리 키 연관관계들 </p></li><li><p>유일 foreign 키 연관관계들 </p></li></ul></div><p>Primary key associations do not need an extra table column. If two rows are related by the association, then the two table rows share the same primary key value. To relate two objects by a primary key association, ensure that they are assigned the same identifier value. </p><p>For a primary key association, add the following mappings to <code class="literal">Employee</code> and <code class="literal">Person</code> respectively: </p><pre class="programlisting">&lt;one-to-one name="person" class="Person"/&gt;</pre><pre class="programlisting">&lt;one-to-one name="employee" class="Employee" constrained="true"/&gt;</pre><p>Ensure that the primary keys of the related rows in the PERSON and EMPLOYEE tables are equal. You use a special Hibernate identifier generation strategy called <code class="literal">foreign</code>: </p><pre class="programlisting">&lt;class name="person" table="PERSON"&gt;
    &lt;id name="id" column="PERSON_ID"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"&gt;employee&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    ...
    &lt;one-to-one name="employee"
        class="Employee"
        constrained="true"/&gt;
&lt;/class&gt;</pre><p>A newly saved instance of <code class="literal">Person</code> is assigned the same primary key value as the <code class="literal">Employee</code> instance referred with the <code class="literal">employee</code> property of that <code class="literal">Person</code>. </p><p>Alternatively, a foreign key with a unique constraint, from <code class="literal">Employee</code> to <code class="literal">Person</code>, can be expressed as: </p><pre class="programlisting">&lt;many-to-one name="person" class="Person" column="PERSON_ID" unique="true"/&gt;</pre><p>This association can be made bidirectional by adding the following to the <code class="literal">Person</code> mapping: </p><pre class="programlisting">&lt;one-to-one name="employee" class="Employee" property-ref="person"/&gt;</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-naturalid"/>5.1.14. Natural-id</h3></div></div></div><pre class="programlisting">&lt;natural-id mutable="true|false"/&gt;
        &lt;property ... /&gt;
        &lt;many-to-one ... /&gt;
        ......
&lt;/natural-id&gt;</pre><p>Although we recommend the use of surrogate keys as primary keys, you should try to identify natural keys for all entities. A natural key is a property or combination of properties that is unique and non-null. It is also immutable. Map the properties of the natural key inside the <code class="literal">&lt;natural-id&gt;</code> element. Hibernate will generate the necessary unique key and nullability constraints and, as a result, your mapping will be more self-documenting. </p><p>It is recommended that you implement <code class="literal">equals()</code> and <code class="literal">hashCode()</code> to compare the natural key properties of the entity. </p><p>This mapping is not intended for use with entities that have natural primary keys. </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">mutable</code> (optional - defaults to <code class="literal">false</code>): by default, natural identifier properties are assumed to be immutable (constant). </p></li></ul></div></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-component"/>5.1.15. Component and dynamic-component</h3></div></div></div><p>The <code class="literal">&lt;component&gt;</code> element maps properties of a child object to columns of the table of a parent class. Components can, in turn, declare their own properties, components or collections. See the "Component" examples below: </p><div class="programlistingco"><pre class="programlisting">&lt;component
        name="propertyName"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        class="className"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        insert="true|false"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        update="true|false"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        access="field|property|ClassName"   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        lazy="true|false"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        optimistic-lock="true|false"        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        unique="true|false"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
        node="element-name|."
&gt;

        &lt;property ...../&gt;
        &lt;many-to-one .... /&gt;
        ........
&lt;/component&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the name of the property. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">class</code> (optional - defaults to the property type determined by reflection): the name of the component (child) class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">insert</code>: do the mapped columns appear in SQL <code class="literal">INSERTs</code>? </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">update</code>: do the mapped columns appear in SQL <code class="literal">UPDATEs</code>? </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional - defaults to <code class="literal">false</code>): specifies that this component should be fetched lazily when the instance variable is first accessed. It requires build-time bytecode instrumentation. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">true</code>): specifies that updates to this component either do or do not require acquisition of the optimistic lock. It determines if a version increment should occur when this property is dirty. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unique</code> (optional - defaults to <code class="literal">false</code>): specifies that a unique constraint exists upon all mapped columns of the component. </p></td></tr></table></div></div><p>자식 <code class="literal">&lt;property&gt;</code> 태그들은 자식 클래스의 프로퍼티들을 테이블 컬럼들로 매핑시킨다. </p><p><code class="literal">&lt;component&gt;</code> 요소는 컴포넌트 클래스의 프로퍼티를 포함하는 엔티티에 대한 참조로서 매핑시키는 <code class="literal">&lt;parent&gt;</code> 서브요소를 허용한다. </p><p>The <code class="literal">&lt;dynamic-component&gt;</code> element allows a <code class="literal">Map</code> to be mapped as a component, where the property names refer to keys of the map. See <a href="#components-dynamic" title="8.5. 동적인 컴포넌트들">8.5절. “동적인 컴포넌트들”</a> for more information. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-properties"/>5.1.16. Properties</h3></div></div></div><p>The <code class="literal">&lt;properties&gt;</code> element allows the definition of a named, logical grouping of the properties of a class. The most important use of the construct is that it allows a combination of properties to be the target of a <code class="literal">property-ref</code>. It is also a convenient way to define a multi-column unique constraint. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;properties
        name="logicalName"                  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        insert="true|false"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        update="true|false"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        optimistic-lock="true|false"        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        unique="true|false"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
&gt;

        &lt;property ...../&gt;
        &lt;many-to-one .... /&gt;
        ........
&lt;/properties&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the logical name of the grouping. It is <span class="emphasis"><em>not</em></span> an actual property name. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">insert</code>: do the mapped columns appear in SQL <code class="literal">INSERTs</code>? </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">update</code>: do the mapped columns appear in SQL <code class="literal">UPDATEs</code>? </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">true</code>): specifies that updates to these properties either do or do not require acquisition of the optimistic lock. It determines if a version increment should occur when these properties are dirty. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unique</code> (optional - defaults to <code class="literal">false</code>): specifies that a unique constraint exists upon all mapped columns of the component. </p></td></tr></table></div></div><p>예를 들어, 만일 우리가 다음 <code class="literal">&lt;properties&gt;</code> 매핑을 가질 경우: </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="personNumber"/&gt;

    ...
    &lt;properties name="name"
            unique="true" update="false"&gt;
        &lt;property name="firstName"/&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="lastName"/&gt;
    &lt;/properties&gt;
&lt;/class&gt;</pre><p>You might have some legacy data association that refers to this unique key of the <code class="literal">Person</code> table, instead of to the primary key: </p><pre class="programlisting">&lt;many-to-one name="person"
         class="Person" property-ref="name"&gt;
    &lt;column name="firstName"/&gt;
    &lt;column name="initial"/&gt;
    &lt;column name="lastName"/&gt;
&lt;/many-to-one&gt;</pre><p>The use of this outside the context of mapping legacy data is not recommended. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-subclass"/>5.1.17. Subclass</h3></div></div></div><p>Polymorphic persistence requires the declaration of each subclass of the root persistent class. For the table-per-class-hierarchy mapping strategy, the <code class="literal">&lt;subclass&gt;</code> declaration is used. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;subclass
        name="ClassName"                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        discriminator-value="discriminator_value"     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        proxy="ProxyInterface"                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        lazy="true|false"                             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        dynamic-update="true|false"
        dynamic-insert="true|false"
        entity-name="EntityName"
        node="element-name"
        extends="SuperclassName"&gt;

        &lt;property .... /&gt;
        .....
&lt;/subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the fully qualified class name of the subclass. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">discriminator-value</code> (optional - defaults to the class name): a value that distinguishes individual subclasses. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">proxy</code> (optional): specifies a class or interface used for lazy initializing proxies. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional - defaults to <code class="literal">true</code>): setting <code class="literal">lazy="false"</code> disables the use of lazy fetching. </p></td></tr></table></div></div><p>Each subclass declares its own persistent properties and subclasses. <code class="literal">&lt;version&gt;</code> and <code class="literal">&lt;id&gt;</code> properties are assumed to be inherited from the root class. Each subclass in a hierarchy must define a unique <code class="literal">discriminator-value</code>. If this is not specified, the fully qualified Java class name is used. </p><p>For information about inheritance mappings see <a href="#inheritance" title="9장. Inheritance mapping">9장. <i xmlns:xlink="http://www.w3.org/1999/xlink">Inheritance mapping</i></a>. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-joinedsubclass"/>5.1.18. Joined-subclass</h3></div></div></div><p>Each subclass can also be mapped to its own table. This is called the table-per-subclass mapping strategy. An inherited state is retrieved by joining with the table of the superclass. To do this you use the <code class="literal">&lt;joined-subclass&gt;</code> element. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;joined-subclass
        name="ClassName"                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        table="tablename"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        proxy="ProxyInterface"              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        lazy="true|false"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        dynamic-update="true|false"
        dynamic-insert="true|false"
        schema="schema"
        catalog="catalog"
        extends="SuperclassName"
        persister="ClassName"
        subselect="SQL expression"
        entity-name="EntityName"
        node="element-name"&gt;

        &lt;key .... &gt;

        &lt;property .... /&gt;
        .....
&lt;/joined-subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the fully qualified class name of the subclass. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">table</code>: the name of the subclass table. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">proxy</code> (optional): specifies a class or interface to use for lazy initializing proxies. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional, defaults to <code class="literal">true</code>): setting <code class="literal">lazy="false"</code> disables the use of lazy fetching. </p></td></tr></table></div></div><p>A discriminator column is not required for this mapping strategy. Each subclass must, however, declare a table column holding the object identifier using the <code class="literal">&lt;key&gt;</code> element. The mapping at the start of the chapter would then be re-written as: </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD//EN"
        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

        &lt;class name="Cat" table="CATS"&gt;
                &lt;id name="id" column="uid" type="long"&gt;
                        &lt;generator class="hilo"/&gt;
                &lt;/id&gt;
                &lt;property name="birthdate" type="date"/&gt;
                &lt;property name="color" not-null="true"/&gt;
                &lt;property name="sex" not-null="true"/&gt;
                &lt;property name="weight"/&gt;
                &lt;many-to-one name="mate"/&gt;
                &lt;set name="kittens"&gt;
                        &lt;key column="MOTHER"/&gt;
                        &lt;one-to-many class="Cat"/&gt;
                &lt;/set&gt;
                &lt;joined-subclass name="DomesticCat" table="DOMESTIC_CATS"&gt;
                    &lt;key column="CAT"/&gt;
                    &lt;property name="name" type="string"/&gt;
                &lt;/joined-subclass&gt;
        &lt;/class&gt;

        &lt;class name="eg.Dog"&gt;
                &lt;!-- mapping for Dog could go here --&gt;
        &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>For information about inheritance mappings see <a href="#inheritance" title="9장. Inheritance mapping">9장. <i xmlns:xlink="http://www.w3.org/1999/xlink">Inheritance mapping</i></a>. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-unionsubclass"/>5.1.19. Union-subclass</h3></div></div></div><p>A third option is to map only the concrete classes of an inheritance hierarchy to tables. This is called the table-per-concrete-class strategy. Each table defines all persistent states of the class, including the inherited state. In Hibernate, it is not necessary to explicitly map such inheritance hierarchies. You can map each class with a separate <code class="literal">&lt;class&gt;</code> declaration. However, if you wish use polymorphic associations (e.g. an association to the superclass of your hierarchy), you need to use the <code class="literal">&lt;union-subclass&gt;</code> mapping. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;union-subclass
        name="ClassName"                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        table="tablename"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        proxy="ProxyInterface"              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        lazy="true|false"                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        dynamic-update="true|false"
        dynamic-insert="true|false"
        schema="schema"
        catalog="catalog"
        extends="SuperclassName"
        abstract="true|false"
        persister="ClassName"
        subselect="SQL expression"
        entity-name="EntityName"
        node="element-name"&gt;

        &lt;property .... /&gt;
        .....
&lt;/union-subclass&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the fully qualified class name of the subclass. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">table</code>: the name of the subclass table. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">proxy</code> (optional): specifies a class or interface to use for lazy initializing proxies. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional, defaults to <code class="literal">true</code>): setting <code class="literal">lazy="false"</code> disables the use of lazy fetching. </p></td></tr></table></div></div><p>이 매핑 방도에는 판별자 컬럼이나 키 컬럼이 필요하지 않다. </p><p>For information about inheritance mappings see <a href="#inheritance" title="9장. Inheritance mapping">9장. <i xmlns:xlink="http://www.w3.org/1999/xlink">Inheritance mapping</i></a>. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-join"/>5.1.20. Join</h3></div></div></div><p>Using the <code class="literal">&lt;join&gt;</code> element, it is possible to map properties of one class to several tables that have a one-to-one relationship. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;join
        table="tablename"                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        schema="owner"                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        catalog="catalog"                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        fetch="join|select"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        inverse="true|false"                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        optional="true|false"&gt;                   <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>

        &lt;key ... /&gt;

        &lt;property ... /&gt;
        ...
&lt;/join&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">table</code>: the name of the joined table. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">schema</code> (optional): overrides the schema name specified by the root <code class="literal">&lt;hibernate-mapping&gt;</code> element. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">catalog</code> (optional): overrides the catalog name specified by the root <code class="literal">&lt;hibernate-mapping&gt;</code> element. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">fetch</code> (optional - defaults to <code class="literal">join</code>): if set to <code class="literal">join</code>, the default, Hibernate will use an inner join to retrieve a <code class="literal">&lt;join&gt;</code> defined by a class or its superclasses. It will use an outer join for a <code class="literal">&lt;join&gt;</code> defined by a subclass. If set to <code class="literal">select</code> then Hibernate will use a sequential select for a <code class="literal">&lt;join&gt;</code> defined on a subclass. This will be issued only if a row represents an instance of the subclass. Inner joins will still be used to retrieve a <code class="literal">&lt;join&gt;</code> defined by the class and its superclasses. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">inverse</code> (optional - defaults to <code class="literal">false</code>): if enabled, Hibernate will not insert or update the properties defined by this join. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optional</code> (optional - defaults to <code class="literal">false</code>): if enabled, Hibernate will insert a row only if the properties defined by this join are non-null. It will always use an outer join to retrieve the properties. </p></td></tr></table></div></div><p>For example, address information for a person can be mapped to a separate table while preserving value type semantics for all properties: </p><pre class="programlisting">&lt;class name="Person"
    table="PERSON"&gt;

    &lt;id name="id" column="PERSON_ID"&gt;...&lt;/id&gt;

    &lt;join table="ADDRESS"&gt;
        &lt;key column="ADDRESS_ID"/&gt;
        &lt;property name="address"/&gt;
        &lt;property name="zip"/&gt;
        &lt;property name="country"/&gt;
    &lt;/join&gt;
    ...</pre><p>This feature is often only useful for legacy data models. We recommend fewer tables than classes and a fine-grained domain model. However, it is useful for switching between inheritance mapping strategies in a single hierarchy, as explained later. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-key"/>5.1.21. Key</h3></div></div></div><p>The <code class="literal">&lt;key&gt;</code> element has featured a few times within this guide. It appears anywhere the parent mapping element defines a join to a new table that references the primary key of the original table. It also defines the foreign key in the joined table: </p><div class="programlistingco"><pre class="programlisting">&lt;key
        column="columnname"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        on-delete="noaction|cascade"             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        property-ref="propertyName"              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        not-null="true|false"                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        update="true|false"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        unique="true|false"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">column</code> (optional): the name of the foreign key column. This can also be specified by nested <code class="literal">&lt;column&gt;</code> element(s). </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">on-delete</code> (optional - defaults to <code class="literal">noaction</code>): specifies whether the foreign key constraint has database-level cascade delete enabled. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">property-ref</code> (optional): specifies that the foreign key refers to columns that are not the primary key of the original table. It is provided for legacy data. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">not-null</code> (optional): specifies that the foreign key columns are not nullable. This is implied whenever the foreign key is also part of the primary key. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">update</code> (optional): specifies that the foreign key should never be updated. This is implied whenever the foreign key is also part of the primary key. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">unique</code> (optional): specifies that the foreign key should have a unique constraint. This is implied whenever the foreign key is also the primary key. </p></td></tr></table></div></div><p>For systems where delete performance is important, we recommend that all keys should be defined <code class="literal">on-delete="cascade"</code>. Hibernate uses a database-level <code class="literal">ON CASCADE DELETE</code> constraint, instead of many individual <code class="literal">DELETE</code> statements. Be aware that this feature bypasses Hibernate's usual optimistic locking strategy for versioned data. </p><p>The <code class="literal">not-null</code> and <code class="literal">update</code> attributes are useful when mapping a unidirectional one-to-many association. If you map a unidirectional one-to-many association to a non-nullable foreign key, you <span class="emphasis"><em>must</em></span> declare the key column using <code class="literal">&lt;key not-null="true"&gt;</code>. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-column"/>5.1.22. Column and formula elements</h3></div></div></div><p>Mapping elements which accept a <code class="literal">column</code> attribute will alternatively accept a <code class="literal">&lt;column&gt;</code> subelement. Likewise, <code class="literal">&lt;formula&gt;</code> is an alternative to the <code class="literal">formula</code> attribute. For example: </p><pre class="programlisting">&lt;column
        name="column_name"
        length="N"
        precision="N"
        scale="N"
        not-null="true|false"
        unique="true|false"
        unique-key="multicolumn_unique_key_name"
        index="index_name"
        sql-type="sql_type_name"
        check="SQL expression"
        default="SQL expression"/&gt;</pre><pre class="programlisting">&lt;formula&gt;SQL expression&lt;/formula&gt;</pre><p><code class="literal">column</code> and <code class="literal">formula</code> attributes can even be combined within the same property or association mapping to express, for example, exotic join conditions. </p><pre class="programlisting">&lt;many-to-one name="homeAddress" class="Address"
        insert="false" update="false"&gt;
    &lt;column name="person_id" not-null="true" length="10"/&gt;
    &lt;formula&gt;'MAILING'&lt;/formula&gt;
&lt;/many-to-one&gt;</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-import"/>5.1.23. Import</h3></div></div></div><p>If your application has two persistent classes with the same name, and you do not want to specify the fully qualified package name in Hibernate queries, classes can be "imported" explicitly, rather than relying upon <code class="literal">auto-import="true"</code>. You can also import classes and interfaces that are not explicitly mapped: </p><pre class="programlisting">&lt;import class="java.lang.Object" rename="Universe"/&gt;</pre><div class="programlistingco"><pre class="programlisting">&lt;import
        class="ClassName"              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        rename="ShortName"             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">class</code>: the fully qualified class name of any Java class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">rename</code> (optional - defaults to the unqualified class name): a name that can be used in the query language. </p></td></tr></table></div></div></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-types-anymapping"/>5.1.24. Any</h3></div></div></div><p>There is one more type of property mapping. The <code class="literal">&lt;any&gt;</code> mapping element defines a polymorphic association to classes from multiple tables. This type of mapping requires more than one column. The first column contains the type of the associated entity. The remaining columns contain the identifier. It is impossible to specify a foreign key constraint for this kind of association. This is not the usual way of mapping polymorphic associations and you should use this only in special cases. For example, for audit logs, user session data, etc. </p><p>The <code class="literal">meta-type</code> attribute allows the application to specify a custom type that maps database column values to persistent classes that have identifier properties of the type specified by <code class="literal">id-type</code>. You must specify the mapping from values of the meta-type to class names. </p><pre class="programlisting">&lt;any name="being" id-type="long" meta-type="string"&gt;
    &lt;meta-value value="TBL_ANIMAL" class="Animal"/&gt;
    &lt;meta-value value="TBL_HUMAN" class="Human"/&gt;
    &lt;meta-value value="TBL_ALIEN" class="Alien"/&gt;
    &lt;column name="table_name"/&gt;
    &lt;column name="id"/&gt;
&lt;/any&gt;</pre><div class="programlistingco"><pre class="programlisting">&lt;any
        name="propertyName"                      <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        id-type="idtypename"                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        meta-type="metatypename"                 <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        cascade="cascade_style"                  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        access="field|property|ClassName"        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        optimistic-lock="true|false"             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
&gt;
        &lt;meta-value ... /&gt;
        &lt;meta-value ... /&gt;
        .....
        &lt;column .... /&gt;
        &lt;column .... /&gt;
        .....
&lt;/any&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: 프로퍼티 이름. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">id-type</code>: 식별자 타입. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">meta-type</code> (optional - defaults to <code class="literal">string</code>): any type that is allowed for a discriminator mapping. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">cascade</code> (optional- defaults to <code class="literal">none</code>): cascade 스타일. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">true</code>): specifies that updates to this property either do or do not require acquisition of the optimistic lock. It defines whether a version increment should occur if this property is dirty. </p></td></tr></table></div></div></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-types"/>5.2. Hibernate types</h2></div></div></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-types-entitiesvalues"/>5.2.1. 엔티티들과 값들</h3></div></div></div><p>In relation to the persistence service, Java language-level objects are classified into two groups: </p><p>An <span class="emphasis"><em>entity</em></span> exists independently of any other objects holding references to the entity. Contrast this with the usual Java model, where an unreferenced object is garbage collected. Entities must be explicitly saved and deleted. Saves and deletions, however, can be <span class="emphasis"><em>cascaded</em></span> from a parent entity to its children. This is different from the ODMG model of object persistence by reachability and corresponds more closely to how application objects are usually used in large systems. Entities support circular and shared references. They can also be versioned. </p><p>An entity's persistent state consists of references to other entities and instances of <span class="emphasis"><em>value</em></span> types. Values are primitives: collections (not what is inside a collection), components and certain immutable objects. Unlike entities, values in particular collections and components, <span class="emphasis"><em>are</em></span> persisted and deleted by reachability. Since value objects and primitives are persisted and deleted along with their containing entity, they cannot be independently versioned. Values have no independent identity, so they cannot be shared by two entities or collections. </p><p>Until now, we have been using the term "persistent class" to refer to entities. We will continue to do that. Not all user-defined classes with a persistent state, however, are entities. A <span class="emphasis"><em>component</em></span> is a user-defined class with value semantics. A Java property of type <code class="literal">java.lang.String</code> also has value semantics. Given this definition, all types (classes) provided by the JDK have value type semantics in Java, while user-defined types can be mapped with entity or value type semantics. This decision is up to the application developer. An entity class in a domain model will normally have shared references to a single instance of that class, while composition or aggregation usually translates to a value type. </p><p>We will revisit both concepts throughout this reference guide. </p><p>The challenge is to map the Java type system, and the developers' definition of entities and value types, to the SQL/database type system. The bridge between both systems is provided by Hibernate. For entities, <code class="literal">&lt;class&gt;</code>, <code class="literal">&lt;subclass&gt;</code> and so on are used. For value types we use <code class="literal">&lt;property&gt;</code>, <code class="literal">&lt;component&gt;</code>etc., that usually have a <code class="literal">type</code> attribute. The value of this attribute is the name of a Hibernate <span class="emphasis"><em>mapping type</em></span>. Hibernate provides a range of mappings for standard JDK value types out of the box. You can write your own mapping types and implement your own custom conversion strategies. </p><p>With the exception of collections, all built-in Hibernate types support null semantics. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-types-basictypes"/>5.2.2. 기본 value 타입들</h3></div></div></div><p>The built-in <span class="emphasis"><em>basic mapping types</em></span> can be roughly categorized into the following: </p><div class="variablelist"><dl><dt><span class="term"><code class="literal">integer, long, short, float, double, character, byte, boolean, yes_no, true_false</code></span></dt><dd><p>자바 원시타입들이나 wrapper 클래스들로부터 적절한(벤더-지정적인) SQL 컬럼 타입들로의 타입 매핑. <code class="literal">boolean, yes_no</code>와 <code class="literal">true_false</code>는 Java <code class="literal">boolean</code>이나 <code class="literal">java.lang.Boolean</code>에 대한 모든 대체적인 인코딩들이다. </p></dd><dt><span class="term"><code class="literal">string</code></span></dt><dd><p><code class="literal">java.lang.String</code>으로부터 <code class="literal">VARCHAR</code> (또는 Oracle <code class="literal">VARCHAR2</code>)로의 타입 매핑. </p></dd><dt><span class="term"><code class="literal">date, time, timestamp</code></span></dt><dd><p><code class="literal">java.util.Date</code>와 그것의 서브클래스로부터 SQL 타입들인 <code class="literal">DATE</code>, <code class="literal">TIME</code>, <code class="literal">TIMESTAMP</code> (또는 등가물)로의 타입 매핑들. </p></dd><dt><span class="term"><code class="literal">calendar, calendar_date</code></span></dt><dd><p><code class="literal">java.util.Calendar</code>로부터 SQL 타입들인 <code class="literal">TIMESTAMP</code>, <code class="literal">DATE</code> (또는 등가물)로의 타입 매핑들. </p></dd><dt><span class="term"><code class="literal">big_decimal, big_integer</code></span></dt><dd><p><code class="literal">java.math.BigDecimal</code>과 <code class="literal">java.math.BigInteger</code>로부터 <code class="literal">NUMERIC</code> (또는 Oracle <code class="literal">NUMBER</code>)로의 타입 매핑들. </p></dd><dt><span class="term"><code class="literal">locale, timezone, currency</code></span></dt><dd><p><code class="literal">java.util.Locale</code>, <code class="literal">java.util.TimeZone</code>, 그리고 <code class="literal">java.util.Currency</code>로부터 <code class="literal">VARCHAR</code>(또는 Oracle <code class="literal">VARCHAR2</code>)로의 타입 매핑. <code class="literal">Locale</code>과 <code class="literal">Currency</code>의 인스턴스들은 그것들의 ISO 코드들로 매핑된다. <code class="literal">TimeZone</code>의 인스턴스들은 그것들의 <code class="literal">ID</code>로 매핑된다. </p></dd><dt><span class="term"><code class="literal">class</code></span></dt><dd><p><code class="literal">java.lang.Class</code>로부터 <code class="literal">VARCHAR</code> (또는 Oracle <code class="literal">VARCHAR2</code>)로의 타입 매핑. <code class="literal">Class</code>는 그것의 전체 수식어가 붙은 이름으로 매핑된다. </p></dd><dt><span class="term"><code class="literal">binary</code></span></dt><dd><p>byte 배열들을 적절한 SQL binary 타입으로 매핑시킨다. </p></dd><dt><span class="term"><code class="literal">text</code></span></dt><dd><p>long Java 문자열을 SQL <code class="literal">CLOB</code> 또는 <code class="literal">TEXT</code> 타입으로 매핑시킨다 </p></dd><dt><span class="term"><code class="literal">serializable</code></span></dt><dd><p>Maps serializable Java types to an appropriate SQL binary type. You can also indicate the Hibernate type <code class="literal">serializable</code> with the name of a serializable Java class or interface that does not default to a basic type. </p></dd><dt><span class="term"><code class="literal">clob, blob</code></span></dt><dd><p>Type mappings for the JDBC classes <code class="literal">java.sql.Clob</code> and <code class="literal">java.sql.Blob</code>. These types can be inconvenient for some applications, since the blob or clob object cannot be reused outside of a transaction. Driver support is patchy and inconsistent. </p></dd><dt><span class="term">
                            <code class="literal">imm_date, imm_time, imm_timestamp, imm_calendar, imm_calendar_date, imm_serializable, imm_binary</code>
                        </span></dt><dd><p>Type mappings for what are considered mutable Java types. This is where Hibernate makes certain optimizations appropriate only for immutable Java types, and the application treats the object as immutable. For example, you should not call <code class="literal">Date.setTime()</code> for an instance mapped as <code class="literal">imm_timestamp</code>. To change the value of the property, and have that change made persistent, the application must assign a new, nonidentical, object to the property. </p></dd></dl></div><p>

            </p><p>Unique identifiers of entities and collections can be of any basic type except <code class="literal">binary</code>, <code class="literal">blob</code> and <code class="literal">clob</code>. Composite identifiers are also allowed. See below for more information. </p><p>기본 value 타입들은 <code class="literal">org.hibernate.Hibernate</code>에 정의되어 있는 대응하는 <code class="literal">Type</code> 상수들을 갖는다. 예를 들어, <code class="literal">Hibernate.STRING</code>은 <code class="literal">string</code> 타입을 표현한다. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-types-custom"/>5.2.3. 맞춤형 value 타입들</h3></div></div></div><p>It is relatively easy for developers to create their own value types. For example, you might want to persist properties of type <code class="literal">java.lang.BigInteger</code> to <code class="literal">VARCHAR</code> columns. Hibernate does not provide a built-in type for this. Custom types are not limited to mapping a property, or collection element, to a single table column. So, for example, you might have a Java property <code class="literal">getName()</code>/<code class="literal">setName()</code> of type <code class="literal">java.lang.String</code> that is persisted to the columns <code class="literal">FIRST_NAME</code>, <code class="literal">INITIAL</code>, <code class="literal">SURNAME</code>. </p><p>To implement a custom type, implement either <code class="literal">org.hibernate.UserType</code> or <code class="literal">org.hibernate.CompositeUserType</code> and declare properties using the fully qualified classname of the type. View <code class="literal">org.hibernate.test.DoubleStringType</code> to see the kind of things that are possible. </p><pre class="programlisting">&lt;property name="twoStrings" type="org.hibernate.test.DoubleStringType"&gt;
    &lt;column name="first_string"/&gt;
    &lt;column name="second_string"/&gt;
&lt;/property&gt;</pre><p>하나의 프로퍼티를 여러 개의 컬럼들로 매핑시키는 <code class="literal">&lt;column&gt;</code> 태그의 사용을 주목하라. </p><p><code class="literal">CompositeUserType</code>, <code class="literal">EnhancedUserType</code>, <code class="literal">UserCollectionType</code>, 그리고 <code class="literal">UserVersionType</code> 인터페이스들은 더 많은 특화된 사용들을 위한 지원을 제공한다. </p><p>You can even supply parameters to a <code class="literal">UserType</code> in the mapping file. To do this, your <code class="literal">UserType</code> must implement the <code class="literal">org.hibernate.usertype.ParameterizedType</code> interface. To supply parameters to your custom type, you can use the <code class="literal">&lt;type&gt;</code> element in your mapping files. </p><pre class="programlisting">&lt;property name="priority"&gt;
    &lt;type name="com.mycompany.usertypes.DefaultValueIntegerType"&gt;
        &lt;param name="default"&gt;0&lt;/param&gt;
    &lt;/type&gt;
&lt;/property&gt;</pre><p><code class="literal">UserType</code>은 이제 그것에 전달된 <code class="literal">Properties</code> 객체로부터 <code class="literal">default</code>로 명명된 파라미터에 대한 값을 검색할 수 있다. </p><p>If you regularly use a certain <code class="literal">UserType</code>, it is useful to define a shorter name for it. You can do this using the <code class="literal">&lt;typedef&gt;</code> element. Typedefs assign a name to a custom type, and can also contain a list of default parameter values if the type is parameterized. </p><pre class="programlisting">&lt;typedef class="com.mycompany.usertypes.DefaultValueIntegerType" name="default_zero"&gt;
    &lt;param name="default"&gt;0&lt;/param&gt;
&lt;/typedef&gt;</pre><pre class="programlisting">&lt;property name="priority" type="default_zero"/&gt;</pre><p>property 매핑 상에 type 파라미터들을 사용함으로써 경우에 맞게 typedef 내에 제공된 파라미터들을 오버라이드 시키는 것이 가능하다. </p><p>Even though Hibernate's rich range of built-in types and support for components means you will rarely need to use a custom type, it is considered good practice to use custom types for non-entity classes that occur frequently in your application. For example, a <code class="literal">MonetaryAmount</code> class is a good candidate for a <code class="literal">CompositeUserType</code>, even though it could be mapped as a component. One reason for this is abstraction. With a custom type, your mapping documents would be protected against changes to the way monetary values are represented. </p></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-entityname"/>5.3. 하나의 클래스를 한 번 이상 매핑하기</h2></div></div></div><p>It is possible to provide more than one mapping for a particular persistent class. In this case, you must specify an <span class="emphasis"><em>entity name</em></span> to disambiguate between instances of the two mapped entities. By default, the entity name is the same as the class name. Hibernate lets you specify the entity name when working with persistent objects, when writing queries, or when mapping associations to the named entity. </p><pre class="programlisting">&lt;class name="Contract" table="Contracts"
        entity-name="CurrentContract"&gt;
    ...
    &lt;set name="history" inverse="true"
            order-by="effectiveEndDate desc"&gt;
        &lt;key column="currentContractId"/&gt;
        &lt;one-to-many entity-name="HistoricalContract"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Contract" table="ContractHistory"
        entity-name="HistoricalContract"&gt;
    ...
    &lt;many-to-one name="currentContract"
            column="currentContractId"
            entity-name="CurrentContract"/&gt;
&lt;/class&gt;</pre><p>Associations are now specified using <code class="literal">entity-name</code> instead of <code class="literal">class</code>. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-quotedidentifiers"/>5.4. SQL 인용부호 표시된 식별자들</h2></div></div></div><p>You can force Hibernate to quote an identifier in the generated SQL by enclosing the table or column name in backticks in the mapping document. Hibernate will use the correct quotation style for the SQL <code class="literal">Dialect</code>. This is usually double quotes, but the SQL Server uses brackets and MySQL uses backticks. </p><pre class="programlisting">&lt;class name="LineItem" table="`Line Item`"&gt;
    &lt;id name="id" column="`Item Id`"/&gt;&lt;generator class="assigned"/&gt;&lt;/id&gt;
    &lt;property name="itemNumber" column="`Item #`"/&gt;
    ...
&lt;/class&gt;</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-alternatives"/>5.5. Metadata 대안들</h2></div></div></div><p>XML does not suit all users so there are some alternative ways to define O/R mapping metadata in Hibernate. </p><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-xdoclet"/>5.5.1. XDoclet 마크업 사용하기</h3></div></div></div><p>Many Hibernate users prefer to embed mapping information directly in sourcecode using XDoclet <code class="literal">@hibernate.tags</code>. We do not cover this approach in this reference guide since it is considered part of XDoclet. However, we include the following example of the <code class="literal">Cat</code> class with XDoclet mappings: </p><pre class="programlisting">package eg;
import java.util.Set;
import java.util.Date;

/**
 * @hibernate.class
 *  table="CATS"
 */
public class Cat {
    private Long id; // identifier
    private Date birthdate;
    private Cat mother;
    private Set kittens
    private Color color;
    private char sex;
    private float weight;

    /*
     * @hibernate.id
     *  generator-class="native"
     *  column="CAT_ID"
     */
    public Long getId() {
        return id;
    }
    private void setId(Long id) {
        this.id=id;
    }

    /**
     * @hibernate.many-to-one
     *  column="PARENT_ID"
     */
    public Cat getMother() {
        return mother;
    }
    void setMother(Cat mother) {
        this.mother = mother;
    }

    /**
     * @hibernate.property
     *  column="BIRTH_DATE"
     */
    public Date getBirthdate() {
        return birthdate;
    }
    void setBirthdate(Date date) {
        birthdate = date;
    }
    /**
     * @hibernate.property
     *  column="WEIGHT"
     */
    public float getWeight() {
        return weight;
    }
    void setWeight(float weight) {
        this.weight = weight;
    }

    /**
     * @hibernate.property
     *  column="COLOR"
     *  not-null="true"
     */
    public Color getColor() {
        return color;
    }
    void setColor(Color color) {
        this.color = color;
    }
    /**
     * @hibernate.set
     *  inverse="true"
     *  order-by="BIRTH_DATE"
     * @hibernate.collection-key
     *  column="PARENT_ID"
     * @hibernate.collection-one-to-many
     */
    public Set getKittens() {
        return kittens;
    }
    void setKittens(Set kittens) {
        this.kittens = kittens;
    }
    // addKitten not needed by Hibernate
    public void addKitten(Cat kitten) {
        kittens.add(kitten);
    }

    /**
     * @hibernate.property
     *  column="SEX"
     *  not-null="true"
     *  update="false"
     */
    public char getSex() {
        return sex;
    }
    void setSex(char sex) {
        this.sex=sex;
    }
}</pre><p>See the Hibernate website for more examples of XDoclet and Hibernate. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-annotations"/>5.5.2. JDK 5.0 Annotations 사용하기</h3></div></div></div><p>JDK 5.0 introduced XDoclet-style annotations at the language level that are type-safe and checked at compile time. This mechanism is more powerful than XDoclet annotations and better supported by tools and IDEs. IntelliJ IDEA, for example, supports auto-completion and syntax highlighting of JDK 5.0 annotations. The new revision of the EJB specification (JSR-220) uses JDK 5.0 annotations as the primary metadata mechanism for entity beans. Hibernate3 implements the <code class="literal">EntityManager</code> of JSR-220 (the persistence API). Support for mapping metadata is available via the <span class="emphasis"><em>Hibernate Annotations</em></span> package as a separate download. Both EJB3 (JSR-220) and Hibernate3 metadata is supported. </p><p>다음은 EJB 엔티티 빈으로서 주석이 붙은 POJO 클래스에 관한 예제이다: </p><pre class="programlisting">@Entity(access = AccessType.FIELD)
public class Customer implements Serializable {

    @Id;
    Long id;

    String firstName;
    String lastName;
    Date birthday;

    @Transient
    Integer age;

    @Embedded
    private Address homeAddress;

    @OneToMany(cascade=CascadeType.ALL)
    @JoinColumn(name="CUSTOMER_ID")
    Set&lt;Order&gt; orders;

    // Getter/setter and business methods
}</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Support for JDK 5.0 Annotations (and JSR-220) is currently under development. Please refer to the Hibernate Annotations module for more details. </p></div></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-generated"/>5.6. Generated properties</h2></div></div></div><p>Generated properties are properties that have their values generated by the database. Typically, Hibernate applications needed to <code class="literal">refresh</code> objects that contain any properties for which the database was generating values. Marking properties as generated, however, lets the application delegate this responsibility to Hibernate. When Hibernate issues an SQL INSERT or UPDATE for an entity that has defined generated properties, it immediately issues a select afterwards to retrieve the generated values. </p><p>Properties marked as generated must additionally be non-insertable and non-updateable. Only <a href="#mapping-declaration-version" title="5.1.9. Version (optional)">versions</a>, <a href="#mapping-declaration-timestamp" title="5.1.10. Timestamp (optional)">timestamps</a>, and <a href="#mapping-declaration-property" title="5.1.11. Property">simple properties</a>, can be marked as generated. </p><p><code class="literal">never</code> (the default): the given property value is not generated within the database. </p><p><code class="literal">insert</code>: the given property value is generated on insert, but is not regenerated on subsequent updates. Properties like created-date fall into this category. Even though <a href="#mapping-declaration-version" title="5.1.9. Version (optional)">version</a> and <a href="#mapping-declaration-timestamp" title="5.1.10. Timestamp (optional)">timestamp</a> properties can be marked as generated, this option is not available. </p><p><code class="literal">always</code>: the property value is generated both on insert and on update. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-database-object"/>5.7. Auxiliary database objects</h2></div></div></div><p>Auxiliary database objects allow for the CREATE and DROP of arbitrary database objects. In conjunction with Hibernate's schema evolution tools, they have the ability to fully define a user schema within the Hibernate mapping files. Although designed specifically for creating and dropping things like triggers or stored procedures, any SQL command that can be run via a <code class="literal">java.sql.Statement.execute()</code> method is valid (for example, ALTERs, INSERTS, etc.). There are essentially two modes for defining auxiliary database objects: </p><p>The first mode is to explicitly list the CREATE and DROP commands in the mapping file: </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    ...
    &lt;database-object&gt;
        &lt;create&gt;CREATE TRIGGER my_trigger ...&lt;/create&gt;
        &lt;drop&gt;DROP TRIGGER my_trigger&lt;/drop&gt;
    &lt;/database-object&gt;
&lt;/hibernate-mapping&gt;</pre><p>The second mode is to supply a custom class that constructs the CREATE and DROP commands. This custom class must implement the <code class="literal">org.hibernate.mapping.AuxiliaryDatabaseObject</code> interface. </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    ...
    &lt;database-object&gt;
        &lt;definition class="MyTriggerDefinition"/&gt;
    &lt;/database-object&gt;
&lt;/hibernate-mapping&gt;</pre><p>Additionally, these database objects can be optionally scoped so that they only apply when certain dialects are used. </p><pre class="programlisting">&lt;hibernate-mapping&gt;
    ...
    &lt;database-object&gt;
        &lt;definition class="MyTriggerDefinition"/&gt;
        &lt;dialect-scope name="org.hibernate.dialect.Oracle9iDialect"/&gt;
        &lt;dialect-scope name="org.hibernate.dialect.Oracle10gDialect"/&gt;
    &lt;/database-object&gt;
&lt;/hibernate-mapping&gt;</pre></div></div><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="collections"/>6장. Collection mapping</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#collections-persistent">6.1. 영속 콜렉션들</a></span></dt><dt><span class="sect1"><a href="#collections-mapping">6.2. 콜렉션 매핑들</a></span></dt><dd><dl><dt><span class="sect2"><a href="#collections-foreignkeys">6.2.1. 콜렉션 foreign 키들</a></span></dt><dt><span class="sect2"><a href="#collections-elements">6.2.2. 콜렉션 요소들</a></span></dt><dt><span class="sect2"><a href="#collections-indexed">6.2.3. 인덱싱 된 콜렉션들</a></span></dt><dt><span class="sect2"><a href="#collections-ofvalues">6.2.4. 값들을 가진 콜렉션들과 many-to-many 연관들</a></span></dt><dt><span class="sect2"><a href="#collections-onetomany">6.2.5. One-to-many 연관들</a></span></dt></dl></dd><dt><span class="sect1"><a href="#collections-advancedmappings">6.3. 개선된 콜렉션 매핑들</a></span></dt><dd><dl><dt><span class="sect2"><a href="#collections-sorted">6.3.1. Sorted 콜렉션들</a></span></dt><dt><span class="sect2"><a href="#collections-bidirectional">6.3.2. 양방향 연관들</a></span></dt><dt><span class="sect2"><a href="#collections-indexedbidirectional">6.3.3. 인덱싱된 콜렉션들을 가진 양방향 연관들</a></span></dt><dt><span class="sect2"><a href="#collections-ternary">6.3.4. Ternary associations(세겹 연관들)</a></span></dt><dt><span class="sect2"><a href="#collections-idbag">6.3.5. <code class="literal"><code class="literal">&lt;idbag&gt;</code> 사용하기</code></a></span></dt></dl></dd><dt><span class="sect1"><a href="#collections-example">6.4. 콜렉션 예제들</a></span></dt></dl></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="collections-persistent"/>6.1. 영속 콜렉션들</h2></div></div></div><p>Hibernate requires that persistent collection-valued fields be declared as an interface type. For example: </p><pre class="programlisting">public class Product {
    private String serialNumber;
    private Set parts = new HashSet();
    
    public Set getParts() { return parts; }
    void setParts(Set parts) { this.parts = parts; }
    public String getSerialNumber() { return serialNumber; }
    void setSerialNumber(String sn) { serialNumber = sn; }
}</pre><p>The actual interface might be <code class="literal">java.util.Set</code>, <code class="literal">java.util.Collection</code>, <code class="literal">java.util.List</code>, <code class="literal">java.util.Map</code>, <code class="literal">java.util.SortedSet</code>, <code class="literal">java.util.SortedMap</code> or anything you like ("anything you like" means you will have to write an implementation of <code class="literal">org.hibernate.usertype.UserCollectionType</code>.) </p><p>Notice how the instance variable was initialized with an instance of <code class="literal">HashSet</code>. This is the best way to initialize collection valued properties of newly instantiated (non-persistent) instances. When you make the instance persistent, by calling <code class="literal">persist()</code> for example, Hibernate will actually replace the <code class="literal">HashSet</code> with an instance of Hibernate's own implementation of <code class="literal">Set</code>. Be aware of the following errors: </p><pre class="programlisting">Cat cat = new DomesticCat();
Cat kitten = new DomesticCat();
....
Set kittens = new HashSet();
kittens.add(kitten);
cat.setKittens(kittens);
session.persist(cat);
kittens = cat.getKittens(); // Okay, kittens collection is a Set
(HashSet) cat.getKittens(); // Error!</pre><p>The persistent collections injected by Hibernate behave like <code class="literal">HashMap</code>, <code class="literal">HashSet</code>, <code class="literal">TreeMap</code>, <code class="literal">TreeSet</code> or <code class="literal">ArrayList</code>, depending on the interface type. </p><p>Collections instances have the usual behavior of value types. They are automatically persisted when referenced by a persistent object and are automatically deleted when unreferenced. If a collection is passed from one persistent object to another, its elements might be moved from one table to another. Two entities cannot share a reference to the same collection instance. Due to the underlying relational model, collection-valued properties do not support null value semantics. Hibernate does not distinguish between a null collection reference and an empty collection. </p><p>Use persistent collections the same way you use ordinary Java collections. However, please ensure you understand the semantics of bidirectional associations (these are discussed later). </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="collections-mapping"/>6.2. 콜렉션 매핑들</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>작은 정보</h2><p>There are quite a range of mappings that can be generated for collections that cover many common relational models. We suggest you experiment with the schema generation tool so that you understand how various mapping declarations translate to database tables. </p></div><p>The Hibernate mapping element used for mapping a collection depends upon the type of interface. For example, a <code class="literal">&lt;set&gt;</code> element is used for mapping properties of type <code class="literal">Set</code>. </p><pre class="programlisting">&lt;class name="Product"&gt;
    &lt;id name="serialNumber" column="productSerialNumber"/&gt;
    &lt;set name="parts"&gt;
        &lt;key column="productSerialNumber" not-null="true"/&gt;
        &lt;one-to-many class="Part"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p><code class="literal">&lt;set&gt;</code>과는 별도로, 또한 <code class="literal">&lt;list&gt;</code>, <code class="literal">&lt;map&gt;</code>, <code class="literal">&lt;bag&gt;</code>, <code class="literal">&lt;array&gt;</code>, 그리고 <code class="literal">&lt;map&gt;</code> 매핑 요소들이 존재한다. <code class="literal">&lt;map&gt;</code> 요소가 대표적이다: </p><div class="programlistingco"><pre class="programlisting">&lt;map
    name="propertyName"                                         <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
    table="table_name"                                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
    schema="schema_name"                                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
    lazy="true|extra|false"                                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
    inverse="true|false"                                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
    cascade="all|none|save-update|delete|all-delete-orphan|delet<span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>e-orphan"
    sort="unsorted|natural|comparatorClass"                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
    order-by="column_name asc|desc"                             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
    where="arbitrary sql where condition"                       <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/9.png" alt="(9)"/></span>
    fetch="join|select|subselect"                               <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/10.png" alt="(10)"/></span>
    batch-size="N"                                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/11.png" alt="(11)"/></span>
    access="field|property|ClassName"                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/12.png" alt="(12)"/></span>
    optimistic-lock="true|false"                                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/13.png" alt="(13)"/></span>
    mutable="true|false"                                        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/14.png" alt="(14)"/></span>
    node="element-name|."
    embed-xml="true|false"
&gt;

    &lt;key .... /&gt;
    &lt;map-key .... /&gt;
    &lt;element .... /&gt;
&lt;/map&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">name</code>: the collection property name </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">table</code> (optional - defaults to property name): the name of the collection table. It is not used for one-to-many associations. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">schema</code> (optional): the name of a table schema to override the schema declared on the root element </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">lazy</code> (optional - defaults to <code class="literal">true</code>): disables lazy fetching and specifies that the association is always eagerly fetched. It can also be used to enable "extra-lazy" fetching where most operations do not initialize the collection. This is suitable for large collections. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">inverse</code> (optional - defaults to <code class="literal">false</code>): marks this collection as the "inverse" end of a bidirectional association. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">cascade</code> (optional - defaults to <code class="literal">none</code>): enables operations to cascade to child entities. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">sort</code> (optional): specifies a sorted collection with <code class="literal">natural</code> sort order or a given comparator class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">order-by</code> (optional, JDK1.4 only): specifies a table column or columns that define the iteration order of the <code class="literal">Map</code>, <code class="literal">Set</code> or bag, together with an optional <code class="literal">asc</code> or <code class="literal">desc</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/9.png" alt="9" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">where</code> (optional): specifies an arbitrary SQL <code class="literal">WHERE</code> condition that is used when retrieving or removing the collection. This is useful if the collection needs to contain only a subset of the available data. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/10.png" alt="10" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">fetch</code> (optional, defaults to <code class="literal">select</code>): chooses between outer-join fetching, fetching by sequential select, and fetching by sequential subselect. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/11.png" alt="11" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">batch-size</code> (optional, defaults to <code class="literal">1</code>): specifies a "batch size" for lazily fetching instances of this collection. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/12.png" alt="12" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">access</code> (optional - defaults to <code class="literal">property</code>): the strategy Hibernate uses for accessing the collection property value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/13.png" alt="13" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code> (optional - defaults to <code class="literal">true</code>): specifies that changes to the state of the collection results in increments of the owning entity's version. For one-to-many associations you may want to disable this setting. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/14.png" alt="14" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">mutable</code> (optional - defaults to <code class="literal">true</code>): a value of <code class="literal">false</code> specifies that the elements of the collection never change. This allows for minor performance optimization in some cases. </p></td></tr></table></div></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="collections-foreignkeys"/>6.2.1. 콜렉션 foreign 키들</h3></div></div></div><p>Collection instances are distinguished in the database by the foreign key of the entity that owns the collection. This foreign key is referred to as the <span class="emphasis"><em>collection key column</em></span>, or columns, of the collection table. The collection key column is mapped by the <code class="literal">&lt;key&gt;</code> element. </p><p>There can be a nullability constraint on the foreign key column. For most collections, this is implied. For unidirectional one-to-many associations, the foreign key column is nullable by default, so you may need to specify <code class="literal">not-null="true"</code>. </p><pre class="programlisting">&lt;key column="productSerialNumber" not-null="true"/&gt;</pre><p>The foreign key constraint can use <code class="literal">ON DELETE CASCADE</code>. </p><pre class="programlisting">&lt;key column="productSerialNumber" on-delete="cascade"/&gt;</pre><p><code class="literal">&lt;key&gt;</code> 요소에 대한 전체 정의는 앞 장을 보라. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="collections-elements"/>6.2.2. 콜렉션 요소들</h3></div></div></div><p>Collections can contain almost any other Hibernate type, including: basic types, custom types, components and references to other entities. This is an important distinction. An object in a collection might be handled with "value" semantics (its life cycle fully depends on the collection owner), or it might be a reference to another entity with its own life cycle. In the latter case, only the "link" between the two objects is considered to be a state held by the collection. </p><p>포함된 타입은 콜렉션 요소 타입으로서 불려진다. 콜렉션 요소들은 <code class="literal">&lt;element&gt;</code> 또는 <code class="literal">&lt;composite-element&gt;</code>에 의해 매핑되거나, 엔티티 참조들의 경우에 <code class="literal">&lt;one-to-many&gt;</code> 또는 <code class="literal">&lt;many-to-many&gt;</code>로서 매핑된다. 앞의 두 개는 value 의미를 가진 요소들을 매핑시키고, 뒤의 두개는 엔티티 연관들을 매핑하는데 사용된다. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="collections-indexed"/>6.2.3. 인덱싱 된 콜렉션들</h3></div></div></div><p>All collection mappings, except those with set and bag semantics, need an <span class="emphasis"><em>index column</em></span> in the collection table. An index column is a column that maps to an array index, or <code class="literal">List</code> index, or <code class="literal">Map</code> key. The index of a <code class="literal">Map</code> may be of any basic type, mapped with <code class="literal">&lt;map-key&gt;</code>. It can be an entity reference mapped with <code class="literal">&lt;map-key-many-to-many&gt;</code>, or it can be a composite type mapped with <code class="literal">&lt;composite-map-key&gt;</code>. The index of an array or list is always of type <code class="literal">integer</code> and is mapped using the <code class="literal">&lt;list-index&gt;</code> element. The mapped column contains sequential integers that are numbered from zero by default. </p><div class="programlistingco"><pre class="programlisting">&lt;list-index 
        column="column_name"                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        base="0|1|..."/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">column_name</code> (required): the name of the column holding the collection index values. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">base</code> (optional - defaults to <code class="literal">0</code>): the value of the index column that corresponds to the first element of the list or array. </p></td></tr></table></div></div><div class="programlistingco"><pre class="programlisting">&lt;map-key 
        column="column_name"                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        formula="any SQL expression"        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        type="type_name"                    <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        node="@attribute-name"
        length="N"/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">column</code> (optional): the name of the column holding the collection index values. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">formula</code> (optional): a SQL formula used to evaluate the key of the map. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">type</code> (required): the type of the map keys. </p></td></tr></table></div></div><div class="programlistingco"><pre class="programlisting">&lt;map-key-many-to-many
        column="column_name"                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        formula="any SQL expression"        <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span><span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        class="ClassName"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">column</code> (optional): the name of the foreign key column for the collection index values. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">formula</code> (optional): a SQ formula used to evaluate the foreign key of the map key. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">class</code> (required): the entity class used as the map key. </p></td></tr></table></div></div><p>If your table does not have an index column, and you still wish to use <code class="literal">List</code> as the property type, you can map the property as a Hibernate <span class="emphasis"><em>&lt;bag&gt;</em></span>. A bag does not retain its order when it is retrieved from the database, but it can be optionally sorted or ordered. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="collections-ofvalues"/>6.2.4. 값들을 가진 콜렉션들과 many-to-many 연관들</h3></div></div></div><p>Any collection of values or many-to-many associations requires a dedicated <span class="emphasis"><em>collection table</em></span> with a foreign key column or columns, <span class="emphasis"><em>collection element column</em></span> or columns, and possibly an index column or columns. </p><p>For a collection of values use the <code class="literal">&lt;element&gt;</code> tag. For example: </p><div class="programlistingco"><pre class="programlisting">&lt;element
        column="column_name"                     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        formula="any SQL expression"             <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        type="typename"                          <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        length="L"
        precision="P"
        scale="S"
        not-null="true|false"
        unique="true|false"
        node="element-name"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">column</code> (optional): the name of the column holding the collection element values. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">formula</code> (optional): an SQL formula used to evaluate the element. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">type</code> (required): the type of the collection element. </p></td></tr></table></div></div><p> A <span class="emphasis"><em>many-to-many association</em></span> is specified using the <code class="literal">&lt;many-to-many&gt;</code> element. </p><div class="programlistingco"><pre class="programlisting">&lt;many-to-many
        column="column_name"                               <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        formula="any SQL expression"                       <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        class="ClassName"                                  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        fetch="select|join"                                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>
        unique="true|false"                                <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>
        not-found="ignore|exception"                       <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>
        entity-name="EntityName"                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>
        property-ref="propertyNameFromAssociatedClass"     <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>
        node="element-name"
        embed-xml="true|false"
    /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">column</code> (optional): the name of the element foreign key column. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">formula</code> (optional): an SQL formula used to evaluate the element foreign key value. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">class</code> (required): the name of the associated class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">fetch</code> (optional - defaults to <code class="literal">join</code>): enables outer-join or sequential select fetching for this association. This is a special case; for full eager fetching in a single <code class="literal">SELECT</code> of an entity and its many-to-many relationships to other entities, you would enable <code class="literal">join</code> fetching,not only of the collection itself, but also with this attribute on the <code class="literal">&lt;many-to-many&gt;</code> nested element. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">unique</code> (optional): enables the DDL generation of a unique constraint for the foreign-key column. This makes the association multiplicity effectively one-to-many. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">not-found</code> (optional - defaults to <code class="literal">exception</code>): specifies how foreign keys that reference missing rows will be handled: <code class="literal">ignore</code> will treat a missing row as a null association. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">entity-name</code> (optional): the entity name of the associated class, as an alternative to <code class="literal">class</code>. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p> <code class="literal">property-ref</code> (optional): the name of a property of the associated class that is joined to this foreign key. If not specified, the primary key of the associated class is used. </p></td></tr></table></div></div><p>Here are some examples. </p><p>A set of strings: </p><pre class="programlisting">&lt;set name="names" table="person_names"&gt;
    &lt;key column="person_id"/&gt;
    &lt;element column="person_name" type="string"/&gt;
&lt;/set&gt;</pre><p>A bag containing integers with an iteration order determined by the <code class="literal">order-by</code> attribute: </p><pre class="programlisting">&lt;bag name="sizes" 
        table="item_sizes" 
        order-by="size asc"&gt;
    &lt;key column="item_id"/&gt;
    &lt;element column="size" type="integer"/&gt;
&lt;/bag&gt;</pre><p>An array of entities, in this case, a many-to-many association: </p><pre class="programlisting">&lt;array name="addresses" 
        table="PersonAddress" 
        cascade="persist"&gt;
    &lt;key column="personId"/&gt;
    &lt;list-index column="sortOrder"/&gt;
    &lt;many-to-many column="addressId" class="Address"/&gt;
&lt;/array&gt;</pre><p>날짜들에 대한 문자열 인덱스들을 가진 map : </p><pre class="programlisting">&lt;map name="holidays" 
        table="holidays" 
        schema="dbo" 
        order-by="hol_name asc"&gt;
    &lt;key column="id"/&gt;
    &lt;map-key column="hol_name" type="string"/&gt;
    &lt;element column="hol_date" type="date"/&gt;
&lt;/map&gt;</pre><p>A list of components (this is discussed in the next chapter): </p><pre class="programlisting">&lt;list name="carComponents" 
        table="CarComponents"&gt;
    &lt;key column="carId"/&gt;
    &lt;list-index column="sortOrder"/&gt;
    &lt;composite-element class="CarComponent"&gt;
        &lt;property name="price"/&gt;
        &lt;property name="type"/&gt;
        &lt;property name="serialNumber" column="serialNum"/&gt;
    &lt;/composite-element&gt;
&lt;/list&gt;</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="collections-onetomany"/>6.2.5. One-to-many 연관들</h3></div></div></div><p>A <span class="emphasis"><em>one-to-many association</em></span> links the tables of two classes via a foreign key with no intervening collection table. This mapping loses certain semantics of normal Java collections: </p><div class="itemizedlist"><ul compact="compact"><li><p>An instance of the contained entity class cannot belong to more than one instance of the collection. </p></li><li><p>An instance of the contained entity class cannot appear at more than one value of the collection index. </p></li></ul></div><p>An association from <code class="literal">Product</code> to <code class="literal">Part</code> requires the existence of a foreign key column and possibly an index column to the <code class="literal">Part</code> table. A <code class="literal">&lt;one-to-many&gt;</code> tag indicates that this is a one-to-many association. </p><div class="programlistingco"><pre class="programlisting">&lt;one-to-many 
        class="ClassName"                                  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
        not-found="ignore|exception"                       <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
        entity-name="EntityName"                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
        node="element-name"
        embed-xml="true|false"
    /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">class</code> (required): the name of the associated class. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">not-found</code> (optional - defaults to <code class="literal">exception</code>): specifies how cached identifiers that reference missing rows will be handled. <code class="literal">ignore</code> will treat a missing row as a null association. </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">entity-name</code> (optional): the entity name of the associated class, as an alternative to <code class="literal">class</code>. </p></td></tr></table></div></div><p>The <code class="literal">&lt;one-to-many&gt;</code> element does not need to declare any columns. Nor is it necessary to specify the <code class="literal">table</code> name anywhere. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>주의</h2><p>If the foreign key column of a <code class="literal">&lt;one-to-many&gt;</code> association is declared <code class="literal">NOT NULL</code>, you must declare the <code class="literal">&lt;key&gt;</code> mapping <code class="literal">not-null="true"</code> or <span class="emphasis"><em>use a bidirectional association</em></span> with the collection mapping marked <code class="literal">inverse="true"</code>. See the discussion of bidirectional associations later in this chapter for more information. </p></div><p>The following example shows a map of <code class="literal">Part</code> entities by name, where <code class="literal">partName</code> is a persistent property of <code class="literal">Part</code>. Notice the use of a formula-based index: </p><pre class="programlisting">&lt;map name="parts"
        cascade="all"&gt;
    &lt;key column="productId" not-null="true"/&gt;
    &lt;map-key formula="partName"/&gt;
    &lt;one-to-many class="Part"/&gt;
&lt;/map&gt;</pre></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="collections-advancedmappings"/>6.3. 개선된 콜렉션 매핑들</h2></div></div></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="collections-sorted"/>6.3.1. Sorted 콜렉션들</h3></div></div></div><p>Hibernate는 <code class="literal">java.util.SortedMap</code>과 <code class="literal">java.util.SortedSet</code>를 구현하는 콜렉션들을 지원한다. 당신은 매핑 파일 속에 하나의 comparator를 지정해야 한다: </p><pre class="programlisting">&lt;set name="aliases" 
            table="person_aliases" 
            sort="natural"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="string"/&gt;
&lt;/set&gt;

&lt;map name="holidays" sort="my.custom.HolidayComparator"&gt;
    &lt;key column="year_id"/&gt;
    &lt;map-key column="hol_name" type="string"/&gt;
    &lt;element column="hol_date" type="date"/&gt;
&lt;/map&gt;</pre><p><code class="literal">sort</code> 속성에 허용되는 값들은 <code class="literal">unsorted</code>, <code class="literal">natural</code>, 그리고 <code class="literal">java.util.Comparator</code>를 구현하는 클래스의 이름이다. </p><p>Sorted 콜렉션들은 <code class="literal">java.util.TreeSet</code> 또는 <code class="literal">java.util.TreeMap</code>처럼 행동한다. </p><p>If you want the database itself to order the collection elements, use the <code class="literal">order-by</code> attribute of <code class="literal">set</code>, <code class="literal">bag</code> or <code class="literal">map</code> mappings. This solution is only available under JDK 1.4 or higher and is implemented using <code class="literal">LinkedHashSet</code> or <code class="literal">LinkedHashMap</code>. This performs the ordering in the SQL query and not in the memory. </p><pre class="programlisting">&lt;set name="aliases" table="person_aliases" order-by="lower(name) asc"&gt;
    &lt;key column="person"/&gt;
    &lt;element column="name" type="string"/&gt;
&lt;/set&gt;

&lt;map name="holidays" order-by="hol_date, hol_name"&gt;
    &lt;key column="year_id"/&gt;
    &lt;map-key column="hol_name" type="string"/&gt;
    &lt;element column="hol_date type="date"/&gt;
&lt;/map&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The value of the <code class="literal">order-by</code> attribute is an SQL ordering, not an HQL ordering. </p></div><p>Associations can even be sorted by arbitrary criteria at runtime using a collection <code class="literal">filter()</code>: </p><pre class="programlisting">sortedUsers = s.createFilter( group.getUsers(), "order by this.name" ).list();</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="collections-bidirectional"/>6.3.2. 양방향 연관들</h3></div></div></div><p>A <span class="emphasis"><em>bidirectional association</em></span> allows navigation from both "ends" of the association. Two kinds of bidirectional association are supported: </p><div class="variablelist"><dl><dt><span class="term">one-to-many</span></dt><dd><p>set or bag valued at one end and single-valued at the other </p></dd><dt><span class="term">many-to-many</span></dt><dd><p>양 끝에서 set 또는 bag 값을 가진 연관 </p></dd></dl></div><p>

        </p><p>You can specify a bidirectional many-to-many association by mapping two many-to-many associations to the same database table and declaring one end as <span class="emphasis"><em>inverse</em></span>. You cannot select an indexed collection. </p><p>Here is an example of a bidirectional many-to-many association that illustrates how each category can have many items and each item can be in many categories: </p><pre class="programlisting">&lt;class name="Category"&gt;
    &lt;id name="id" column="CATEGORY_ID"/&gt;
    ...
    &lt;bag name="items" table="CATEGORY_ITEM"&gt;
        &lt;key column="CATEGORY_ID"/&gt;
        &lt;many-to-many class="Item" column="ITEM_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;

&lt;class name="Item"&gt;
    &lt;id name="id" column="ITEM_ID"/&gt;
    ...

    &lt;!-- inverse end --&gt;
    &lt;bag name="categories" table="CATEGORY_ITEM" inverse="true"&gt;
        &lt;key column="ITEM_ID"/&gt;
        &lt;many-to-many class="Category" column="CATEGORY_ID"/&gt;
    &lt;/bag&gt;
&lt;/class&gt;</pre><p>Changes made only to the inverse end of the association are <span class="emphasis"><em>not</em></span> persisted. This means that Hibernate has two representations in memory for every bidirectional association: one link from A to B and another link from B to A. This is easier to understand if you think about the Java object model and how a many-to-many relationship in Javais created: </p><pre class="programlisting">
category.getItems().add(item);          // The category now "knows" about the relationship
item.getCategories().add(category);     // The item now "knows" about the relationship

session.persist(item);                   // The relationship won't be saved!
session.persist(category);               // The relationship will be saved</pre><p>non-inverse 측은 메모리 내 표상을 데이터베이스로 저장하는데 사용된다. </p><p>You can define a bidirectional one-to-many association by mapping a one-to-many association to the same table column(s) as a many-to-one association and declaring the many-valued end <code class="literal">inverse="true"</code>. </p><pre class="programlisting">&lt;class name="Parent"&gt;
    &lt;id name="id" column="parent_id"/&gt;
    ....
    &lt;set name="children" inverse="true"&gt;
        &lt;key column="parent_id"/&gt;
        &lt;one-to-many class="Child"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Child"&gt;
    &lt;id name="id" column="child_id"/&gt;
    ....
    &lt;many-to-one name="parent" 
        class="Parent" 
        column="parent_id"
        not-null="true"/&gt;
&lt;/class&gt;</pre><p>Mapping one end of an association with <code class="literal">inverse="true"</code> does not affect the operation of cascades as these are orthogonal concepts. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="collections-indexedbidirectional"/>6.3.3. 인덱싱된 콜렉션들을 가진 양방향 연관들</h3></div></div></div><p>A bidirectional association where one end is represented as a <code class="literal">&lt;list&gt;</code> or <code class="literal">&lt;map&gt;</code>, requires special consideration. If there is a property of the child class that maps to the index column you can use <code class="literal">inverse="true"</code> on the collection mapping: </p><pre class="programlisting">&lt;class name="Parent"&gt;
    &lt;id name="id" column="parent_id"/&gt;
    ....
    &lt;map name="children" inverse="true"&gt;
        &lt;key column="parent_id"/&gt;
        &lt;map-key column="name" 
            type="string"/&gt;
        &lt;one-to-many class="Child"/&gt;
    &lt;/map&gt;
&lt;/class&gt;

&lt;class name="Child"&gt;
    &lt;id name="id" column="child_id"/&gt;
    ....
    &lt;property name="name" 
        not-null="true"/&gt;
    &lt;many-to-one name="parent" 
        class="Parent" 
        column="parent_id"
        not-null="true"/&gt;
&lt;/class&gt;</pre><p>If there is no such property on the child class, the association cannot be considered truly bidirectional. That is, there is information available at one end of the association that is not available at the other end. In this case, you cannot map the collection <code class="literal">inverse="true"</code>. Instead, you could use the following mapping: </p><pre class="programlisting">&lt;class name="Parent"&gt;
    &lt;id name="id" column="parent_id"/&gt;
    ....
    &lt;map name="children"&gt;
        &lt;key column="parent_id"
            not-null="true"/&gt;
        &lt;map-key column="name" 
            type="string"/&gt;
        &lt;one-to-many class="Child"/&gt;
    &lt;/map&gt;
&lt;/class&gt;

&lt;class name="Child"&gt;
    &lt;id name="id" column="child_id"/&gt;
    ....
    &lt;many-to-one name="parent" 
        class="Parent" 
        column="parent_id"
        insert="false"
        update="false"
        not-null="true"/&gt;
&lt;/class&gt;</pre><p>Note that in this mapping, the collection-valued end of the association is responsible for updates to the foreign key. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="collections-ternary"/>6.3.4. Ternary associations(세겹 연관들)</h3></div></div></div><p>There are three possible approaches to mapping a ternary association. One approach is to use a <code class="literal">Map</code> with an association as its index: </p><pre class="programlisting">&lt;map name="contracts"&gt;
    &lt;key column="employer_id" not-null="true"/&gt;
    &lt;map-key-many-to-many column="employee_id" class="Employee"/&gt;
    &lt;one-to-many class="Contract"/&gt;
&lt;/map&gt;</pre><pre class="programlisting">&lt;map name="connections"&gt;
    &lt;key column="incoming_node_id"/&gt;
    &lt;map-key-many-to-many column="outgoing_node_id" class="Node"/&gt;
    &lt;many-to-many column="connection_id" class="Connection"/&gt;
&lt;/map&gt;</pre><p>A second approach is to remodel the association as an entity class. This is the most common approach. </p><p>A final alternative is to use composite elements, which will be discussed later. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="collections-idbag"/>6.3.5. <code class="literal"><code class="literal">&lt;idbag&gt;</code> 사용하기</code></h3></div></div></div><p>The majority of the many-to-many associations and collections of values shown previously all map to tables with composite keys, even though it has been have suggested that entities should have synthetic identifiers (surrogate keys). A pure association table does not seem to benefit much from a surrogate key, although a collection of composite values <span class="emphasis"><em>might</em></span>. It is for this reason that Hibernate provides a feature that allows you to map many-to-many associations and collections of values to a table with a surrogate key. </p><p>The <code class="literal">&lt;idbag&gt;</code> element lets you map a <code class="literal">List</code> (or <code class="literal">Collection</code>) with bag semantics. For example: </p><pre class="programlisting">&lt;idbag name="lovers" table="LOVERS"&gt;
    &lt;collection-id column="ID" type="long"&gt;
        &lt;generator class="sequence"/&gt;
    &lt;/collection-id&gt;
    &lt;key column="PERSON1"/&gt;
    &lt;many-to-many column="PERSON2" class="Person" fetch="join"/&gt;
&lt;/idbag&gt;</pre><p>An <code class="literal">&lt;idbag&gt;</code> has a synthetic id generator, just like an entity class. A different surrogate key is assigned to each collection row. Hibernate does not, however, provide any mechanism for discovering the surrogate key value of a particular row. </p><p>The update performance of an <code class="literal">&lt;idbag&gt;</code> supersedes a regular <code class="literal">&lt;bag&gt;</code>. Hibernate can locate individual rows efficiently and update or delete them individually, similar to a list, map or set. </p><p>현재 구현에서, <code class="literal">native</code> 식별자 생성 방도는 <code class="literal">&lt;idbag&gt;</code> 콜렉션 식별자들에 대해 지원되지 않는다. </p></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="collections-example"/>6.4. 콜렉션 예제들</h2></div></div></div><p>This section covers collection examples. </p><p>The following class has a collection of <code class="literal">Child</code> instances: </p><pre class="programlisting">package eg;
import java.util.Set;

public class Parent {
    private long id;
    private Set children;

    public long getId() { return id; }
    private void setId(long id) { this.id=id; }

    private Set getChildren() { return children; }
    private void setChildren(Set children) { this.children=children; }

    ....
    ....
}</pre><p>If each child has, at most, one parent, the most natural mapping is a one-to-many association: </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>이것은 다음 테이블 정의들로 매핑된다: </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null primary key, name varchar(255), parent_id bigint )
alter table child add constraint childfk0 (parent_id) references parent</pre><p>만일 부모가 <span class="emphasis"><em>필수적</em></span>이라면, 양방향 one-to-many 연관관계를 사용하라: </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" inverse="true"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;one-to-many class="Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
        &lt;many-to-one name="parent" class="Parent" column="parent_id" not-null="true"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p><code class="literal">NOT NULL</code> 컨스트레인트를 주목하라: </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null
                     primary key,
                     name varchar(255),
                     parent_id bigint not null )
alter table child add constraint childfk0 (parent_id) references parent</pre><p>Alternatively, if this association must be unidirectional you can declare the <code class="literal">NOT NULL</code> constraint on the <code class="literal">&lt;key&gt;</code> mapping: </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children"&gt;
            &lt;key column="parent_id" not-null="true"/&gt;
            &lt;one-to-many class="Child"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>On the other hand, if a child has multiple parents, a many-to-many association is appropriate: </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Parent"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;set name="children" table="childset"&gt;
            &lt;key column="parent_id"/&gt;
            &lt;many-to-many class="Child" column="child_id"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Child"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>테이블 정의들: </p><pre class="programlisting">create table parent ( id bigint not null primary key )
create table child ( id bigint not null primary key, name varchar(255) )
create table childset ( parent_id bigint not null,
                        child_id bigint not null,
                        primary key ( parent_id, child_id ) )
alter table childset add constraint childsetfk0 (parent_id) references parent
alter table childset add constraint childsetfk1 (child_id) references child</pre><p>For more examples and a complete explanation of a parent/child relationship mapping, see <a href="#example-parentchild" title="21장. 예제: 부모/자식">21장. <i xmlns:xlink="http://www.w3.org/1999/xlink">예제: 부모/자식</i></a> for more information. </p><p>Even more complex association mappings are covered in the next chapter. </p></div></div><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="associations"/>7장. 연관 매핑들</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#assoc-intro">7.1. 개요</a></span></dt><dt><span class="sect1"><a href="#assoc-unidirectional">7.2. 단방향 연관들</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-unidirectional-m21">7.2.1. Many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-121">7.2.2. One-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-12m">7.2.3. One-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-unidirectional-join">7.3. join 테이블들에 대한 단방향 연관들</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-unidirectional-join-12m">7.3.1. One-to-many</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-m21">7.3.2. Many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-121">7.3.3. One-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-unidirectional-join-m2m">7.3.4. Many-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-bidirectional">7.4. 양방향 연관들</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-bidirectional-m21">7.4.1. one-to-many / many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-121">7.4.2. One-to-one</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-bidirectional-join">7.5. join 테이블들에 대한 양방향 연관들</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assoc-bidirectional-join-12m">7.5.1. one-to-many / many-to-one</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-join-121">7.5.2. one to one</a></span></dt><dt><span class="sect2"><a href="#assoc-bidirectional-join-m2m">7.5.3. Many-to-many</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assoc-complex">7.6. 보다 복잡한 연관 매핑들</a></span></dt></dl></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="assoc-intro"/>7.1. 개요</h2></div></div></div><p>Association mappings are often the most difficult thing to implement correctly. In this section we examine some canonical cases one by one, starting with unidirectional mappings and then bidirectional cases. We will use <code class="literal">Person</code> and <code class="literal">Address</code> in all the examples. </p><p>Associations will be classified by multiplicity and whether or not they map to an intervening join table. </p><p>Nullable foreign keys are not considered to be good practice in traditional data modelling, so our examples do not use nullable foreign keys. This is not a requirement of Hibernate, and the mappings will work if you drop the nullability constraints. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="assoc-unidirectional"/>7.2. 단방향 연관들</h2></div></div></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-m21"/>7.2.1. Many-to-one</h3></div></div></div><p><span class="emphasis"><em>단방향 many-to-one 연관</em></span>은 가장 공통적인 종류의 단방향 연관이다. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-121"/>7.2.2. One-to-one</h3></div></div></div><p><span class="emphasis"><em>foreign 키에 대한 단방향 one-to-one 연관은 대개 아주 동일하다.</em></span> 유일한 차이점은 컬럼 유일(unique) 컨스트레인트이다. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId" 
        unique="true"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre><p>A <span class="emphasis"><em>unidirectional one-to-one association on a primary key</em></span> usually uses a special id generator In this example, however, we have reversed the direction of the association: </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"&gt;person&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    &lt;one-to-one name="person" constrained="true"/&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table Address ( personId bigint not null primary key )
        </pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-12m"/>7.2.3. One-to-many</h3></div></div></div><p>A <span class="emphasis"><em>unidirectional one-to-many association on a foreign key</em></span> is an unusual case, and is not recommended. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses"&gt;
        &lt;key column="personId" 
            not-null="true"/&gt;
        &lt;one-to-many class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table Address ( addressId bigint not null primary key, personId bigint not null )
        </pre><p>You should instead use a join table for this kind of association. </p></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="assoc-unidirectional-join"/>7.3. join 테이블들에 대한 단방향 연관들</h2></div></div></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-join-12m"/>7.3.1. One-to-many</h3></div></div></div><p>A <span class="emphasis"><em>unidirectional one-to-many association on a join table</em></span> is the preferred option. Specifying <code class="literal">unique="true"</code>, changes the multiplicity from many-to-many to one-to-many. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses" table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            unique="true"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId not null, addressId bigint not null primary key )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-join-m21"/>7.3.2. Many-to-one</h3></div></div></div><p>A <span class="emphasis"><em>unidirectional many-to-one association on a join table</em></span> is common when the association is optional. For example: </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"&gt;
        &lt;key column="personId" unique="true"/&gt;
        &lt;many-to-one name="address"
            column="addressId" 
            not-null="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null primary key, addressId bigint not null )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-join-121"/>7.3.3. One-to-one</h3></div></div></div><p>A <span class="emphasis"><em>unidirectional one-to-one association on a join table</em></span> is possible, but extremely unusual. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"&gt;
        &lt;key column="personId" 
            unique="true"/&gt;
        &lt;many-to-one name="address"
            column="addressId" 
            not-null="true"
            unique="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-unidirectional-join-m2m"/>7.3.4. Many-to-many</h3></div></div></div><p>Finally, here is an example of a <span class="emphasis"><em>unidirectional many-to-many association</em></span>. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses" table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null, addressId bigint not null, primary key (personId, addressId) )
create table Address ( addressId bigint not null primary key )
        </pre></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="assoc-bidirectional"/>7.4. 양방향 연관들</h2></div></div></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-bidirectional-m21"/>7.4.1. one-to-many / many-to-one</h3></div></div></div><p>A <span class="emphasis"><em>bidirectional many-to-one association</em></span> is the most common kind of association. The following example illustrates the standard parent/child relationship. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="people" inverse="true"&gt;
        &lt;key column="addressId"/&gt;
        &lt;one-to-many class="Person"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null )
create table Address ( addressId bigint not null primary key )
        </pre><p>If you use a <code class="literal">List</code>, or other indexed collection, set the <code class="literal">key</code> column of the foreign key to <code class="literal">not null</code>. Hibernate will manage the association from the collections side to maintain the index of each element, making the other side virtually inverse by setting <code class="literal">update="false"</code> and <code class="literal">insert="false"</code>: </p><pre class="programlisting">&lt;class name="Person"&gt;
   &lt;id name="id"/&gt;
   ...
   &lt;many-to-one name="address"
      column="addressId"
      not-null="true"
      insert="false"
      update="false"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
   &lt;id name="id"/&gt;
   ...
   &lt;list name="people"&gt;
      &lt;key column="addressId" not-null="true"/&gt;
      &lt;list-index column="peopleIdx"/&gt;
      &lt;one-to-many class="Person"/&gt;
   &lt;/list&gt;
&lt;/class&gt;</pre><p>If the underlying foreign key column is <code class="literal">NOT NULL</code>, it is important that you define <code class="literal">not-null="true"</code> on the <code class="literal">&lt;key&gt;</code> element of the collection mapping. Do not only declare <code class="literal">not-null="true"</code> on a possible nested <code class="literal">&lt;column&gt;</code> element, but on the <code class="literal">&lt;key&gt;</code> element. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-bidirectional-121"/>7.4.2. One-to-one</h3></div></div></div><p>A <span class="emphasis"><em>bidirectional one-to-one association on a foreign key</em></span> is common: </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;many-to-one name="address" 
        column="addressId" 
        unique="true"
        not-null="true"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
   &lt;one-to-one name="person" 
        property-ref="address"/&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre><p>A <span class="emphasis"><em>bidirectional one-to-one association on a primary key</em></span> uses the special id generator: </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;one-to-one name="address"/&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="foreign"&gt;
            &lt;param name="property"&gt;person&lt;/param&gt;
        &lt;/generator&gt;
    &lt;/id&gt;
    &lt;one-to-one name="person" 
        constrained="true"/&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table Address ( personId bigint not null primary key )
        </pre></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="assoc-bidirectional-join"/>7.5. join 테이블들에 대한 양방향 연관들</h2></div></div></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-bidirectional-join-12m"/>7.5.1. one-to-many / many-to-one</h3></div></div></div><p>The following is an example of a <span class="emphasis"><em>bidirectional one-to-many association on a join table</em></span>. The <code class="literal">inverse="true"</code> can go on either end of the association, on the collection, or on the join. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses" 
        table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            unique="true"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        inverse="true" 
        optional="true"&gt;
        &lt;key column="addressId"/&gt;
        &lt;many-to-one name="person"
            column="personId"
            not-null="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null, addressId bigint not null primary key )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-bidirectional-join-121"/>7.5.2. one to one</h3></div></div></div><p>A <span class="emphasis"><em>bidirectional one-to-one association on a join table</em></span> is possible, but extremely unusual. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"&gt;
        &lt;key column="personId" 
            unique="true"/&gt;
        &lt;many-to-one name="address"
            column="addressId" 
            not-null="true"
            unique="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;join table="PersonAddress" 
        optional="true"
        inverse="true"&gt;
        &lt;key column="addressId" 
            unique="true"/&gt;
        &lt;many-to-one name="person"
            column="personId" 
            not-null="true"
            unique="true"/&gt;
    &lt;/join&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null primary key, addressId bigint not null unique )
create table Address ( addressId bigint not null primary key )
        </pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="assoc-bidirectional-join-m2m"/>7.5.3. Many-to-many</h3></div></div></div><p>Here is an example of a <span class="emphasis"><em>bidirectional many-to-many association</em></span>. </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id" column="personId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="addresses" table="PersonAddress"&gt;
        &lt;key column="personId"/&gt;
        &lt;many-to-many column="addressId"
            class="Address"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Address"&gt;
    &lt;id name="id" column="addressId"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;set name="people" inverse="true" table="PersonAddress"&gt;
        &lt;key column="addressId"/&gt;
        &lt;many-to-many column="personId"
            class="Person"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><pre class="programlisting">
create table Person ( personId bigint not null primary key )
create table PersonAddress ( personId bigint not null, addressId bigint not null, primary key (personId, addressId) )
create table Address ( addressId bigint not null primary key )
        </pre></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="assoc-complex"/>7.6. 보다 복잡한 연관 매핑들</h2></div></div></div><p>More complex association joins are <span class="emphasis"><em>extremely</em></span> rare. Hibernate handles more complex situations by using SQL fragments embedded in the mapping document. For example, if a table with historical account information data defines <code class="literal">accountNumber</code>, <code class="literal">effectiveEndDate</code> and <code class="literal">effectiveStartDate</code>columns, it would be mapped as follows: </p><pre class="programlisting">&lt;properties name="currentAccountKey"&gt;
    &lt;property name="accountNumber" type="string" not-null="true"/&gt;
    &lt;property name="currentAccount" type="boolean"&gt;
        &lt;formula&gt;case when effectiveEndDate is null then 1 else 0 end&lt;/formula&gt;
    &lt;/property&gt;
&lt;/properties&gt;
&lt;property name="effectiveEndDate" type="date"/&gt;
&lt;property name="effectiveStateDate" type="date" not-null="true"/&gt;</pre><p>You can then map an association to the <span class="emphasis"><em>current</em></span> instance, the one with null <code class="literal">effectiveEndDate</code>, by using: </p><pre class="programlisting">&lt;many-to-one name="currentAccountInfo" 
        property-ref="currentAccountKey"
        class="AccountInfo"&gt;
    &lt;column name="accountNumber"/&gt;
    &lt;formula&gt;'1'&lt;/formula&gt;
&lt;/many-to-one&gt;</pre><p>In a more complex example, imagine that the association between <code class="literal">Employee</code> and <code class="literal">Organization</code> is maintained in an <code class="literal">Employment</code> table full of historical employment data. An association to the employee's <span class="emphasis"><em>most recent</em></span> employer, the one with the most recent <code class="literal">startDate</code>, could be mapped in the following way: </p><pre class="programlisting">&lt;join&gt;
    &lt;key column="employeeId"/&gt;
    &lt;subselect&gt;
        select employeeId, orgId 
        from Employments 
        group by orgId 
        having startDate = max(startDate)
    &lt;/subselect&gt;
    &lt;many-to-one name="mostRecentEmployer" 
            class="Organization" 
            column="orgId"/&gt;
&lt;/join&gt;</pre><p>This functionality allows a degree of creativity and flexibility, but it is more practical to handle these kinds of cases using HQL or a criteria query. </p></div></div><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="components"/>8장. Component 매핑</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#components-dependentobjects">8.1. 종속 객체들</a></span></dt><dt><span class="sect1"><a href="#components-incollections">8.2. 종속 객체들을 가진 콜렉션들</a></span></dt><dt><span class="sect1"><a href="#components-asmapindex">8.3. Map 인덱스들로서 컴포넌트들</a></span></dt><dt><span class="sect1"><a href="#components-compositeid">8.4. composite 식별자들로서 컴포넌트들</a></span></dt><dt><span class="sect1"><a href="#components-dynamic">8.5. 동적인 컴포넌트들</a></span></dt></dl></div><p>The notion of a <span class="emphasis"><em>component</em></span> is re-used in several different contexts and purposes throughout Hibernate. </p><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="components-dependentobjects"/>8.1. 종속 객체들</h2></div></div></div><p>A component is a contained object that is persisted as a value type and not an entity reference. The term "component" refers to the object-oriented notion of composition and not to architecture-level components. For example, you can model a person like this: </p><pre class="programlisting">public class Person {
    private java.util.Date birthday;
    private Name name;
    private String key;
    public String getKey() {
        return key;
    }
    private void setKey(String key) {
        this.key=key;
    }
    public java.util.Date getBirthday() {
        return birthday;
    }
    public void setBirthday(java.util.Date birthday) {
        this.birthday = birthday;
    }
    public Name getName() {
        return name;
    }
    public void setName(Name name) {
        this.name = name;
    }
    ......
    ......
}</pre><pre class="programlisting">public class Name {
    char initial;
    String first;
    String last;
    public String getFirst() {
        return first;
    }
    void setFirst(String first) {
        this.first = first;
    }
    public String getLast() {
        return last;
    }
    void setLast(String last) {
        this.last = last;
    }
    public char getInitial() {
        return initial;
    }
    void setInitial(char initial) {
        this.initial = initial;
    }
}</pre><p>Now <code class="literal">Name</code> can be persisted as a component of <code class="literal">Person</code>. <code class="literal">Name</code> defines getter and setter methods for its persistent properties, but it does not need to declare any interfaces or identifier properties. </p><p>Our Hibernate mapping would look like this: </p><pre class="programlisting">&lt;class name="eg.Person" table="person"&gt;
    &lt;id name="Key" column="pid" type="string"&gt;
        &lt;generator class="uuid"/&gt;
    &lt;/id&gt;
    &lt;property name="birthday" type="date"/&gt;
    &lt;component name="Name" class="eg.Name"&gt; &lt;!-- class attribute optional --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/component&gt;
&lt;/class&gt;</pre><p>person 테이블은 <code class="literal">pid</code>, <code class="literal">birthday</code>, <code class="literal">initial</code>, <code class="literal">first</code>, <code class="literal">last</code> 컬럼들을 가질 것이다. </p><p>Like value types, components do not support shared references. In other words, two persons could have the same name, but the two person objects would contain two independent name objects that were only "the same" by value. The null value semantics of a component are <span class="emphasis"><em>ad hoc</em></span>. When reloading the containing object, Hibernate will assume that if all component columns are null, then the entire component is null. This is suitable for most purposes. </p><p>The properties of a component can be of any Hibernate type (collections, many-to-one associations, other components, etc). Nested components should <span class="emphasis"><em>not</em></span> be considered an exotic usage. Hibernate is intended to support a fine-grained object model. </p><p><code class="literal">&lt;component&gt;</code> 요소는 컴포넌트 클래스의 프로퍼티를 포함되는 엔티티에 대한 역 참조로서 매핑시키는 <code class="literal">&lt;parent&gt;</code> 서브요소를 허용한다. </p><pre class="programlisting">&lt;class name="eg.Person" table="person"&gt;
    &lt;id name="Key" column="pid" type="string"&gt;
        &lt;generator class="uuid"/&gt;
    &lt;/id&gt;
    &lt;property name="birthday" type="date"/&gt;
    &lt;component name="Name" class="eg.Name" unique="true"&gt;
        &lt;parent name="namedPerson"/&gt; &lt;!-- reference back to the Person --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/component&gt;
&lt;/class&gt;</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="components-incollections"/>8.2. 종속 객체들을 가진 콜렉션들</h2></div></div></div><p>Collections of components are supported (e.g. an array of type <code class="literal">Name</code>). Declare your component collection by replacing the <code class="literal">&lt;element&gt;</code> tag with a <code class="literal">&lt;composite-element&gt;</code> tag: </p><pre class="programlisting">&lt;set name="someNames" table="some_names" lazy="true"&gt;
    &lt;key column="id"/&gt;
    &lt;composite-element class="eg.Name"&gt; &lt;!-- class attribute required --&gt;
        &lt;property name="initial"/&gt;
        &lt;property name="first"/&gt;
        &lt;property name="last"/&gt;
    &lt;/composite-element&gt;
&lt;/set&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>중요</h2><p>If you define a <code class="literal">Set</code> of composite elements, it is important to implement <code class="literal">equals()</code> and <code class="literal">hashCode()</code> correctly. </p></div><p>Composite elements can contain components but not collections. If your composite element contains components, use the <code class="literal">&lt;nested-composite-element&gt;</code> tag. This case is a collection of components which themselves have components. You may want to consider if a one-to-many association is more appropriate. Remodel the composite element as an entity, but be aware that even though the Java model is the same, the relational model and persistence semantics are still slightly different. </p><p>A composite element mapping does not support null-able properties if you are using a <code class="literal">&lt;set&gt;</code>. There is no separate primary key column in the composite element table. Hibernate uses each column's value to identify a record when deleting objects, which is not possible with null values. You have to either use only not-null properties in a composite-element or choose a <code class="literal">&lt;list&gt;</code>, <code class="literal">&lt;map&gt;</code>, <code class="literal">&lt;bag&gt;</code> or <code class="literal">&lt;idbag&gt;</code>. </p><p>A special case of a composite element is a composite element with a nested <code class="literal">&lt;many-to-one&gt;</code> element. This mapping allows you to map extra columns of a many-to-many association table to the composite element class. The following is a many-to-many association from <code class="literal">Order</code> to <code class="literal">Item</code>, where <code class="literal">purchaseDate</code>, <code class="literal">price</code> and <code class="literal">quantity</code> are properties of the association: </p><pre class="programlisting">&lt;class name="eg.Order" .... &gt;
    ....
    &lt;set name="purchasedItems" table="purchase_items" lazy="true"&gt;
        &lt;key column="order_id"&gt;
        &lt;composite-element class="eg.Purchase"&gt;
            &lt;property name="purchaseDate"/&gt;
            &lt;property name="price"/&gt;
            &lt;property name="quantity"/&gt;
            &lt;many-to-one name="item" class="eg.Item"/&gt; &lt;!-- class attribute is optional --&gt;
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>There cannot be a reference to the purchase on the other side for bidirectional association navigation. Components are value types and do not allow shared references. A single <code class="literal">Purchase</code> can be in the set of an <code class="literal">Order</code>, but it cannot be referenced by the <code class="literal">Item</code> at the same time. </p><p>심지어 세겹의(또는 네 겹의, 기타) 연관들이 가능하다:</p><pre class="programlisting">&lt;class name="eg.Order" .... &gt;
    ....
    &lt;set name="purchasedItems" table="purchase_items" lazy="true"&gt;
        &lt;key column="order_id"&gt;
        &lt;composite-element class="eg.OrderLine"&gt;
            &lt;many-to-one name="purchaseDetails class="eg.Purchase"/&gt;
            &lt;many-to-one name="item" class="eg.Item"/&gt;
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>Composite elements can appear in queries using the same syntax as associations to other entities. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="components-asmapindex"/>8.3. Map 인덱스들로서 컴포넌트들</h2></div></div></div><p>The <code class="literal">&lt;composite-map-key&gt;</code> element allows you to map a component class as the key of a <code class="literal">Map</code>. Ensure that you override <code class="literal">hashCode()</code> and <code class="literal">equals()</code> correctly on the component class. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="components-compositeid"/>8.4. composite 식별자들로서 컴포넌트들</h2></div></div></div><p>You can use a component as an identifier of an entity class. Your component class must satisfy certain requirements: </p><div class="itemizedlist"><ul compact="compact"><li><p>그것은 <code class="literal">java.io.Serializable</code>을 구현해야 한다. </p></li><li><p>It must re-implement <code class="literal">equals()</code> and <code class="literal">hashCode()</code> consistently with the database's notion of composite key equality. </p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>In Hibernate3, although the second requirement is not an absolutely hard requirement of Hibernate, it is recommended. </p></div><p>You cannot use an <code class="literal">IdentifierGenerator</code> to generate composite keys. Instead the application must assign its own identifiers. </p><p>Use the <code class="literal">&lt;composite-id&gt;</code> tag, with nested <code class="literal">&lt;key-property&gt;</code> elements, in place of the usual <code class="literal">&lt;id&gt;</code> declaration. For example, the <code class="literal">OrderLine</code> class has a primary key that depends upon the (composite) primary key of <code class="literal">Order</code>. </p><pre class="programlisting">&lt;class name="OrderLine"&gt;
    
    &lt;composite-id name="id" class="OrderLineId"&gt;
        &lt;key-property name="lineId"/&gt;
        &lt;key-property name="orderId"/&gt;
        &lt;key-property name="customerId"/&gt;
    &lt;/composite-id&gt;
    
    &lt;property name="name"/&gt;
    
    &lt;many-to-one name="order" class="Order"
            insert="false" update="false"&gt;
        &lt;column name="orderId"/&gt;
        &lt;column name="customerId"/&gt;
    &lt;/many-to-one&gt;
    ....
    
&lt;/class&gt;</pre><p>Any foreign keys referencing the <code class="literal">OrderLine</code> table are now composite. Declare this in your mappings for other classes. An association to <code class="literal">OrderLine</code> is mapped like this: </p><pre class="programlisting">&lt;many-to-one name="orderLine" class="OrderLine"&gt;
&lt;!-- the "class" attribute is optional, as usual --&gt;
    &lt;column name="lineId"/&gt;
    &lt;column name="orderId"/&gt;
    &lt;column name="customerId"/&gt;
&lt;/many-to-one&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>작은 정보</h2><p>The <code class="literal">column</code> element is an alternative to the <code class="literal">column</code> attribute everywhere. Using the <code class="literal">column</code> element just gives more declaration options, which are mostly useful when utilizing <code class="literal">hbm2ddl</code> </p></div><p><code class="literal">OrderLine</code>에 대한 <code class="literal">many-to-many</code> 연관은 또한 composite foreign 키를 사용한다: </p><pre class="programlisting">&lt;set name="undeliveredOrderLines"&gt;
    &lt;key column name="warehouseId"/&gt;
    &lt;many-to-many class="OrderLine"&gt;
        &lt;column name="lineId"/&gt;
        &lt;column name="orderId"/&gt;
        &lt;column name="customerId"/&gt;
    &lt;/many-to-many&gt;
&lt;/set&gt;</pre><p><code class="literal">Order</code>에서 <code class="literal">OrderLine</code>들의 콜렉션이 사용될 것이다: </p><pre class="programlisting">&lt;set name="orderLines" inverse="true"&gt;
    &lt;key&gt;
        &lt;column name="orderId"/&gt;
        &lt;column name="customerId"/&gt;
    &lt;/key&gt;
    &lt;one-to-many class="OrderLine"/&gt;
&lt;/set&gt;</pre><p>The <code class="literal">&lt;one-to-many&gt;</code> element declares no columns. </p><p>만일 <code class="literal">OrderLine</code> 자체가 하나의 콜렉션을 소유할 경우, 그것은 또한 하나의 composite foreign 키를 갖는다. </p><pre class="programlisting">&lt;class name="OrderLine"&gt;
    ....
    ....
    &lt;list name="deliveryAttempts"&gt;
        &lt;key&gt;   &lt;!-- a collection inherits the composite key type --&gt;
            &lt;column name="lineId"/&gt;
            &lt;column name="orderId"/&gt;
            &lt;column name="customerId"/&gt;
        &lt;/key&gt;
        &lt;list-index column="attemptId" base="1"/&gt;
        &lt;composite-element class="DeliveryAttempt"&gt;
            ...
        &lt;/composite-element&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="components-dynamic"/>8.5. 동적인 컴포넌트들</h2></div></div></div><p>You can also map a property of type <code class="literal">Map</code>: </p><pre class="programlisting">&lt;dynamic-component name="userAttributes"&gt;
    &lt;property name="foo" column="FOO" type="string"/&gt;
    &lt;property name="bar" column="BAR" type="integer"/&gt;
    &lt;many-to-one name="baz" class="Baz" column="BAZ_ID"/&gt;
&lt;/dynamic-component&gt;</pre><p>The semantics of a <code class="literal">&lt;dynamic-component&gt;</code> mapping are identical to <code class="literal">&lt;component&gt;</code>. The advantage of this kind of mapping is the ability to determine the actual properties of the bean at deployment time just by editing the mapping document. Runtime manipulation of the mapping document is also possible, using a DOM parser. You can also access, and change, Hibernate's configuration-time metamodel via the <code class="literal">Configuration</code> object. </p></div></div><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="inheritance"/>9장. Inheritance mapping</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#inheritance-strategies">9.1. The three strategies</a></span></dt><dd><dl><dt><span class="sect2"><a href="#inheritance-tableperclass">9.1.1. Table per class hierarchy</a></span></dt><dt><span class="sect2"><a href="#inheritance-tablepersubclass">9.1.2. Table per subclass</a></span></dt><dt><span class="sect2"><a href="#inheritance-tablepersubclass-discriminator">9.1.3. Table per subclass: using a discriminator</a></span></dt><dt><span class="sect2"><a href="#inheritance-mixing-tableperclass-tablepersubclass">9.1.4. table per class hierarchy와 table per subclass를 혼합하기</a></span></dt><dt><span class="sect2"><a href="#inheritance-tableperconcrete">9.1.5. Table per concrete class</a></span></dt><dt><span class="sect2"><a href="#inheritance-tableperconcreate-polymorphism">9.1.6. Table per concrete class using implicit polymorphism</a></span></dt><dt><span class="sect2"><a href="#inheritance-mixingpolymorphism">9.1.7. 함축적인 다형성을 다른 상속 매핑들과 혼합하기</a></span></dt></dl></dd><dt><span class="sect1"><a href="#inheritance-limitations">9.2. 제약들</a></span></dt></dl></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="inheritance-strategies"/>9.1. The three strategies</h2></div></div></div><p>Hibernate는 세 가지 기본적인 상속 매핑 방도들을 지원한다: </p><div class="itemizedlist"><ul><li><p>table per class hierarchy </p></li><li><p>table per subclass </p></li><li><p>table per concrete class </p></li></ul></div><p>게다가 Hibernate는 네 번째의 약간 다른 종류의 다형성을 지원한다: </p><div class="itemizedlist"><ul><li><p>implicit polymorphism(함축적인 다형성) </p></li></ul></div><p>It is possible to use different mapping strategies for different branches of the same inheritance hierarchy. You can then make use of implicit polymorphism to achieve polymorphism across the whole hierarchy. However, Hibernate does not support mixing <code class="literal">&lt;subclass&gt;</code>, <code class="literal">&lt;joined-subclass&gt;</code> and <code class="literal">&lt;union-subclass&gt;</code> mappings under the same root <code class="literal">&lt;class&gt;</code> element. It is possible to mix together the table per hierarchy and table per subclass strategies under the the same <code class="literal">&lt;class&gt;</code> element, by combining the <code class="literal">&lt;subclass&gt;</code> and <code class="literal">&lt;join&gt;</code> elements (see below for an example). </p><p>It is possible to define <code class="literal">subclass</code>, <code class="literal">union-subclass</code>, and <code class="literal">joined-subclass</code> mappings in separate mapping documents directly beneath <code class="literal">hibernate-mapping</code>. This allows you to extend a class hierarchy by adding a new mapping file. You must specify an <code class="literal">extends</code> attribute in the subclass mapping, naming a previously mapped superclass. Previously this feature made the ordering of the mapping documents important. Since Hibernate3, the ordering of mapping files is irrelevant when using the extends keyword. The ordering inside a single mapping file still needs to be defined as superclasses before subclasses. </p><pre class="programlisting">
 &lt;hibernate-mapping&gt;
     &lt;subclass name="DomesticCat" extends="Cat" discriminator-value="D"&gt;
          &lt;property name="name" type="string"/&gt;
     &lt;/subclass&gt;
 &lt;/hibernate-mapping&gt;</pre><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-tableperclass"/>9.1.1. Table per class hierarchy</h3></div></div></div><p>Suppose we have an interface <code class="literal">Payment</code> with the implementors <code class="literal">CreditCardPayment</code>, <code class="literal">CashPayment</code>, and <code class="literal">ChequePayment</code>. The table per hierarchy mapping would display in the following way: </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        &lt;property name="creditCardType" column="CCTYPE"/&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        ...
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>Exactly one table is required. There is a limitation of this mapping strategy: columns declared by the subclasses, such as <code class="literal">CCTYPE</code>, cannot have <code class="literal">NOT NULL</code> constraints. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-tablepersubclass"/>9.1.2. Table per subclass</h3></div></div></div><p>A table per subclass mapping looks like this: </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;joined-subclass name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="creditCardType" column="CCTYPE"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        ...
    &lt;/joined-subclass&gt;
&lt;/class&gt;</pre><p>Four tables are required. The three subclass tables have primary key associations to the superclass table so the relational model is actually a one-to-one association. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-tablepersubclass-discriminator"/>9.1.3. Table per subclass: using a discriminator</h3></div></div></div><p>Hibernate's implementation of table per subclass does not require a discriminator column. Other object/relational mappers use a different implementation of table per subclass that requires a type discriminator column in the superclass table. The approach taken by Hibernate is much more difficult to implement, but arguably more correct from a relational point of view. If you want to use a discriminator column with the table per subclass strategy, you can combine the use of <code class="literal">&lt;subclass&gt;</code> and <code class="literal">&lt;join&gt;</code>, as follows: </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        &lt;join table="CREDIT_PAYMENT"&gt;
            &lt;key column="PAYMENT_ID"/&gt;
            &lt;property name="creditCardType" column="CCTYPE"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        &lt;join table="CASH_PAYMENT"&gt;
            &lt;key column="PAYMENT_ID"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        &lt;join table="CHEQUE_PAYMENT" fetch="select"&gt;
            &lt;key column="PAYMENT_ID"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>선택적인 <code class="literal">fetch="select"</code> 선언은 슈퍼클래스를 질의할 때 outer join을 사용하여 <code class="literal">ChequePayment</code> 서브클래스 데이터를 페치시키지 않도록 Hibernate에게 알려준다. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-mixing-tableperclass-tablepersubclass"/>9.1.4. table per class hierarchy와 table per subclass를 혼합하기</h3></div></div></div><p>You can even mix the table per hierarchy and table per subclass strategies using the following approach: </p><pre class="programlisting">&lt;class name="Payment" table="PAYMENT"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="PAYMENT_TYPE" type="string"/&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;subclass name="CreditCardPayment" discriminator-value="CREDIT"&gt;
        &lt;join table="CREDIT_PAYMENT"&gt;
            &lt;property name="creditCardType" column="CCTYPE"/&gt;
            ...
        &lt;/join&gt;
    &lt;/subclass&gt;
    &lt;subclass name="CashPayment" discriminator-value="CASH"&gt;
        ...
    &lt;/subclass&gt;
    &lt;subclass name="ChequePayment" discriminator-value="CHEQUE"&gt;
        ...
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>이들 매핑 방도들 중 어떤 것에 대해, 루트 <code class="literal">Payment</code> 클래스에 대한 하나의 다형성 연관은 <code class="literal">&lt;many-to-one&gt;</code>을 사용하여 매핑된다. </p><pre class="programlisting">&lt;many-to-one name="payment" column="PAYMENT_ID" class="Payment"/&gt;</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-tableperconcrete"/>9.1.5. Table per concrete class</h3></div></div></div><p>There are two ways we can map the table per concrete class strategy. First, you can use <code class="literal">&lt;union-subclass&gt;</code>. </p><pre class="programlisting">&lt;class name="Payment"&gt;
    &lt;id name="id" type="long" column="PAYMENT_ID"&gt;
        &lt;generator class="sequence"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="AMOUNT"/&gt;
    ...
    &lt;union-subclass name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
        &lt;property name="creditCardType" column="CCTYPE"/&gt;
        ...
    &lt;/union-subclass&gt;
    &lt;union-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        ...
    &lt;/union-subclass&gt;
    &lt;union-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        ...
    &lt;/union-subclass&gt;
&lt;/class&gt;</pre><p>세 개의 테이블들이 슈퍼클래스들에 대해 수반된다. 각각의 테이블은 상속된 프로퍼티들을 포함하여, 그 클래스의 모든 프로퍼티들에 대한 컬럼들을 정의한다. </p><p>The limitation of this approach is that if a property is mapped on the superclass, the column name must be the same on all subclass tables. The identity generator strategy is not allowed in union subclass inheritance. The primary key seed has to be shared across all unioned subclasses of a hierarchy. </p><p>If your superclass is abstract, map it with <code class="literal">abstract="true"</code>. If it is not abstract, an additional table (it defaults to <code class="literal">PAYMENT</code> in the example above), is needed to hold instances of the superclass. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-tableperconcreate-polymorphism"/>9.1.6. Table per concrete class using implicit polymorphism</h3></div></div></div><p>대안적인 접근법은 함축적인 다형성을 사용하는 것이다: </p><pre class="programlisting">&lt;class name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CREDIT_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CREDIT_AMOUNT"/&gt;
    ...
&lt;/class&gt;

&lt;class name="CashPayment" table="CASH_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CASH_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CASH_AMOUNT"/&gt;
    ...
&lt;/class&gt;

&lt;class name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CHEQUE_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="amount" column="CHEQUE_AMOUNT"/&gt;
    ...
&lt;/class&gt;</pre><p>Notice that the <code class="literal">Payment</code> interface is not mentioned explicitly. Also notice that properties of <code class="literal">Payment</code> are mapped in each of the subclasses. If you want to avoid duplication, consider using XML entities (for example, <code class="literal">[ &lt;!ENTITY allproperties SYSTEM "allproperties.xml"&gt; ]</code> in the <code class="literal">DOCTYPE</code> declaration and <code class="literal">&amp;allproperties;</code> in the mapping). </p><p>이 접근법의 단점은 다형성 질의들을 수행할 때 Hibernate가 생성된 SQl <code class="literal">UNION</code>들을 생성시키는 않는다는 점이다. </p><p>이 매핑 방도의 경우, <code class="literal">Payment</code>에 대한 하나의 다형성 연관은 대개 <code class="literal">&lt;any&gt;</code>를 사용하여 매핑된다. </p><pre class="programlisting">&lt;any name="payment" meta-type="string" id-type="long"&gt;
    &lt;meta-value value="CREDIT" class="CreditCardPayment"/&gt;
    &lt;meta-value value="CASH" class="CashPayment"/&gt;
    &lt;meta-value value="CHEQUE" class="ChequePayment"/&gt;
    &lt;column name="PAYMENT_CLASS"/&gt;
    &lt;column name="PAYMENT_ID"/&gt;
&lt;/any&gt;</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="inheritance-mixingpolymorphism"/>9.1.7. 함축적인 다형성을 다른 상속 매핑들과 혼합하기</h3></div></div></div><p>Since the subclasses are each mapped in their own <code class="literal">&lt;class&gt;</code> element, and since <code class="literal">Payment</code> is just an interface), each of the subclasses could easily be part of another inheritance hierarchy. You can still use polymorphic queries against the <code class="literal">Payment</code> interface. </p><pre class="programlisting">&lt;class name="CreditCardPayment" table="CREDIT_PAYMENT"&gt;
    &lt;id name="id" type="long" column="CREDIT_PAYMENT_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;discriminator column="CREDIT_CARD" type="string"/&gt;
    &lt;property name="amount" column="CREDIT_AMOUNT"/&gt;
    ...
    &lt;subclass name="MasterCardPayment" discriminator-value="MDC"/&gt;
    &lt;subclass name="VisaPayment" discriminator-value="VISA"/&gt;
&lt;/class&gt;

&lt;class name="NonelectronicTransaction" table="NONELECTRONIC_TXN"&gt;
    &lt;id name="id" type="long" column="TXN_ID"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    ...
    &lt;joined-subclass name="CashPayment" table="CASH_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="amount" column="CASH_AMOUNT"/&gt;
        ...
    &lt;/joined-subclass&gt;
    &lt;joined-subclass name="ChequePayment" table="CHEQUE_PAYMENT"&gt;
        &lt;key column="PAYMENT_ID"/&gt;
        &lt;property name="amount" column="CHEQUE_AMOUNT"/&gt;
        ...
    &lt;/joined-subclass&gt;
&lt;/class&gt;</pre><p>Once again, <code class="literal">Payment</code> is not mentioned explicitly. If we execute a query against the <code class="literal">Payment</code> interface, for example <code class="literal">from Payment</code>, Hibernate automatically returns instances of <code class="literal">CreditCardPayment</code> (and its subclasses, since they also implement <code class="literal">Payment</code>), <code class="literal">CashPayment</code> and <code class="literal">ChequePayment</code>, but not instances of <code class="literal">NonelectronicTransaction</code>. </p></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="inheritance-limitations"/>9.2. 제약들</h2></div></div></div><p>There are limitations to the "implicit polymorphism" approach to the table per concrete-class mapping strategy. There are somewhat less restrictive limitations to <code class="literal">&lt;union-subclass&gt;</code> mappings. </p><p>다음 표는 Hibernate에서 table per concrete-class 매핑들에 대한 제약들, 그리고 함축적인 다형성에 대한 제약들을 보여준다. </p><div class="table"><a id="d0e9133"/><p class="title"><b>표 9.1. 상속 매핑들의 특징들</b></p><div class="table-contents"><table summary="상속 매핑들의 특징들" border="1"><colgroup><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/></colgroup><thead><tr><th align="left">상속 방도</th><th align="left">다형성 다대일</th><th align="left">다형성 일대일</th><th align="left">다형성 일대다</th><th align="left">다형성 다대다</th><th align="left">Polymorphic <code class="literal">load()/get()</code></th><th align="left">다형성 질의들</th><th align="left">다형성 조인들</th><th align="left">Outer 조인 페칭</th></tr></thead><tbody><tr><td align="left">table per class-hierarchy</td><td align="left"><code class="literal">&lt;many-to-one&gt;</code></td><td align="left"><code class="literal">&lt;one-to-one&gt;</code></td><td align="left"><code class="literal">&lt;one-to-many&gt;</code></td><td align="left"><code class="literal">&lt;many-to-many&gt;</code></td><td align="left"><code class="literal">s.get(Payment.class, id)</code></td><td align="left"><code class="literal">from Payment p</code></td><td align="left"><code class="literal">from Order o join o.payment p</code></td><td align="left"><span class="emphasis"><em>지원됨</em></span></td></tr><tr><td align="left">table per subclass</td><td align="left"><code class="literal">&lt;many-to-one&gt;</code></td><td align="left"><code class="literal">&lt;one-to-one&gt;</code></td><td align="left"><code class="literal">&lt;one-to-many&gt;</code></td><td align="left"><code class="literal">&lt;many-to-many&gt;</code></td><td align="left"><code class="literal">s.get(Payment.class, id)</code></td><td align="left"><code class="literal">from Payment p</code></td><td align="left"><code class="literal">from Order o join o.payment p</code></td><td align="left"><span class="emphasis"><em>지원됨</em></span></td></tr><tr><td align="left">table per concrete-class (union-subclass)</td><td align="left"><code class="literal">&lt;many-to-one&gt;</code></td><td align="left"><code class="literal">&lt;one-to-one&gt;</code></td><td align="left"><code class="literal">&lt;one-to-many&gt;</code> (for <code class="literal">inverse="true"</code> only)</td><td align="left"><code class="literal">&lt;many-to-many&gt;</code></td><td align="left"><code class="literal">s.get(Payment.class, id)</code></td><td align="left"><code class="literal">from Payment p</code></td><td align="left"><code class="literal">from Order o join o.payment p</code></td><td align="left"><span class="emphasis"><em>지원됨</em></span></td></tr><tr><td align="left">table per concrete class (implicit polymorphism)</td><td align="left"><code class="literal">&lt;any&gt;</code></td><td align="left"><span class="emphasis"><em>지원되지 않음</em></span></td><td align="left"><span class="emphasis"><em>지원되지 않음</em></span></td><td align="left"><code class="literal">&lt;many-to-any&gt;</code></td><td align="left"><code class="literal">s.createCriteria(Payment.class).add( Restrictions.idEq(id) ).uniqueResult()</code></td><td align="left"><code class="literal">from Payment p</code></td><td align="left"><span class="emphasis"><em>지원되지 않음</em></span></td><td align="left"><span class="emphasis"><em>지원되지 않음</em></span></td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate"/>10장. 객체들로 작업하기</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#objectstate-overview">10.1. Hibernate 객체 상태들</a></span></dt><dt><span class="sect1"><a href="#objectstate-makingpersistent">10.2. 객체들을 영속화 시키기</a></span></dt><dt><span class="sect1"><a href="#objectstate-loading">10.3. 객체를 로드시키기</a></span></dt><dt><span class="sect1"><a href="#objectstate-querying">10.4. 질의하기</a></span></dt><dd><dl><dt><span class="sect2"><a href="#objectstate-querying-executing">10.4.1. 질의들을 실행하기</a></span></dt><dt><span class="sect2"><a href="#objectstate-filtering">10.4.2. 콜렉션들을 필터링 하기</a></span></dt><dt><span class="sect2"><a href="#objecstate-querying-criteria">10.4.3. Criteria 질의들</a></span></dt><dt><span class="sect2"><a href="#objectstate-querying-nativesql">10.4.4. native SQL에서 질의들</a></span></dt></dl></dd><dt><span class="sect1"><a href="#objectstate-modifying">10.5. 영속 객체들을 변경하기</a></span></dt><dt><span class="sect1"><a href="#objectstate-detached">10.6. detached 객체들을 변경시키기</a></span></dt><dt><span class="sect1"><a href="#objectstate-saveorupdate">10.7. 자동적인 상태 검출</a></span></dt><dt><span class="sect1"><a href="#objectstate-deleting">10.8. 영속 객체들을 삭제하기</a></span></dt><dt><span class="sect1"><a href="#objectstate-replicating">10.9. 두 개의 다른 데이터저장소들 사이에 객체들을 복제하기</a></span></dt><dt><span class="sect1"><a href="#objectstate-flushing">10.10. Session을 flush 시키기</a></span></dt><dt><span class="sect1"><a href="#objectstate-transitive">10.11. Transitive persistence(전이 영속)</a></span></dt><dt><span class="sect1"><a href="#objectstate-metadata">10.12. 메타데이터 사용하기</a></span></dt></dl></div><p>Hibernate is a full object/relational mapping solution that not only shields the developer from the details of the underlying database management system, but also offers <span class="emphasis"><em>state management</em></span> of objects. This is, contrary to the management of SQL <code class="literal">statements</code> in common JDBC/SQL persistence layers, a natural object-oriented view of persistence in Java applications. </p><p>달리 말해, Hibernate 어플리케이션 개발자들은 그들의 객체들의 <span class="emphasis"><em>상태</em></span>에 대해 항상 생각해야 하고, SQL 문장들의 실행에 대해서는 필수적이지 않다. 이 부분은 Hibernate에 의해 처리되고 시스템의 퍼포먼스를 튜닝할 때 어플리케이션 개발자와 유일하게 관련된다. </p><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-overview"/>10.1. Hibernate 객체 상태들</h2></div></div></div><p>Hibernate 다음 객체 상태들을 정의하고 지원한다: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Transient</em></span> - an object is transient if it has just been instantiated using the <code class="literal">new</code> operator, and it is not associated with a Hibernate <code class="literal">Session</code>. It has no persistent representation in the database and no identifier value has been assigned. Transient instances will be destroyed by the garbage collector if the application does not hold a reference anymore. Use the Hibernate <code class="literal">Session</code> to make an object persistent (and let Hibernate take care of the SQL statements that need to be executed for this transition). </p></li><li><p><span class="emphasis"><em>Persistent</em></span> - a persistent instance has a representation in the database and an identifier value. It might just have been saved or loaded, however, it is by definition in the scope of a <code class="literal">Session</code>. Hibernate will detect any changes made to an object in persistent state and synchronize the state with the database when the unit of work completes. Developers do not execute manual <code class="literal">UPDATE</code> statements, or <code class="literal">DELETE</code> statements when an object should be made transient. </p></li><li><p><span class="emphasis"><em>Detached</em></span> - a detached instance is an object that has been persistent, but its <code class="literal">Session</code> has been closed. The reference to the object is still valid, of course, and the detached instance might even be modified in this state. A detached instance can be reattached to a new <code class="literal">Session</code> at a later point in time, making it (and all the modifications) persistent again. This feature enables a programming model for long running units of work that require user think-time. We call them <span class="emphasis"><em>application transactions</em></span>, i.e., a unit of work from the point of view of the user. </p></li></ul></div><p>We will now discuss the states and state transitions (and the Hibernate methods that trigger a transition) in more detail. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-makingpersistent"/>10.2. 객체들을 영속화 시키기</h2></div></div></div><p>하나의 영속 클래스의 새로이 초기화 된 인스턴스들은 Hibernate에 의해 <span class="emphasis"><em>transient</em></span>로 간주된다. 우리는 그것을 세션과 연관지어서 transient 인스턴스를 <span class="emphasis"><em>영속화</em></span> 시킬 수 있다: </p><pre class="programlisting">DomesticCat fritz = new DomesticCat();
fritz.setColor(Color.GINGER);
fritz.setSex('M');
fritz.setName("Fritz");
Long generatedId = (Long) sess.save(fritz);</pre><p>If <code class="literal">Cat</code> has a generated identifier, the identifier is generated and assigned to the <code class="literal">cat</code> when <code class="literal">save()</code> is called. If <code class="literal">Cat</code> has an <code class="literal">assigned</code> identifier, or a composite key, the identifier should be assigned to the <code class="literal">cat</code> instance before calling <code class="literal">save()</code>. You can also use <code class="literal">persist()</code> instead of <code class="literal">save()</code>, with the semantics defined in the EJB3 early draft. </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">persist()</code> makes a transient instance persistent. However, it does not guarantee that the identifier value will be assigned to the persistent instance immediately, the assignment might happen at flush time. <code class="literal">persist()</code> also guarantees that it will not execute an <code class="literal">INSERT</code> statement if it is called outside of transaction boundaries. This is useful in long-running conversations with an extended Session/persistence context. </p></li><li><p><code class="literal">save()</code> does guarantee to return an identifier. If an INSERT has to be executed to get the identifier ( e.g. "identity" generator, not "sequence"), this INSERT happens immediately, no matter if you are inside or outside of a transaction. This is problematic in a long-running conversation with an extended Session/persistence context. </p></li></ul></div><p>Alternatively, you can assign the identifier using an overloaded version of <code class="literal">save()</code>. </p><pre class="programlisting">DomesticCat pk = new DomesticCat();
pk.setColor(Color.TABBY);
pk.setSex('F');
pk.setName("PK");
pk.setKittens( new HashSet() );
pk.addKitten(fritz);
sess.save( pk, new Long(1234) );</pre><p>If the object you make persistent has associated objects (e.g. the <code class="literal">kittens</code> collection in the previous example), these objects can be made persistent in any order you like unless you have a <code class="literal">NOT NULL</code> constraint upon a foreign key column. There is never a risk of violating foreign key constraints. However, you might violate a <code class="literal">NOT NULL</code> constraint if you <code class="literal">save()</code> the objects in the wrong order. </p><p>Usually you do not bother with this detail, as you will normally use Hibernate's <span class="emphasis"><em>transitive persistence</em></span> feature to save the associated objects automatically. Then, even <code class="literal">NOT NULL</code> constraint violations do not occur - Hibernate will take care of everything. Transitive persistence is discussed later in this chapter. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-loading"/>10.3. 객체를 로드시키기</h2></div></div></div><p>The <code class="literal">load()</code> methods of <code class="literal">Session</code> provide a way of retrieving a persistent instance if you know its identifier. <code class="literal">load()</code> takes a class object and loads the state into a newly instantiated instance of that class in a persistent state. </p><pre class="programlisting">Cat fritz = (Cat) sess.load(Cat.class, generatedId);</pre><pre class="programlisting">// you need to wrap primitive identifiers
long id = 1234;
DomesticCat pk = (DomesticCat) sess.load( DomesticCat.class, new Long(id) );</pre><p>다른 방법으로 당신은 주어진 인스턴스 속으로 상태를 로드시킬 수 있다: </p><pre class="programlisting">Cat cat = new DomesticCat();
// load pk's state into cat
sess.load( cat, new Long(pkId) );
Set kittens = cat.getKittens();</pre><p>Be aware that <code class="literal">load()</code> will throw an unrecoverable exception if there is no matching database row. If the class is mapped with a proxy, <code class="literal">load()</code> just returns an uninitialized proxy and does not actually hit the database until you invoke a method of the proxy. This is useful if you wish to create an association to an object without actually loading it from the database. It also allows multiple instances to be loaded as a batch if <code class="literal">batch-size</code> is defined for the class mapping. </p><p>If you are not certain that a matching row exists, you should use the <code class="literal">get()</code> method which hits the database immediately and returns null if there is no matching row. </p><pre class="programlisting">Cat cat = (Cat) sess.get(Cat.class, id);
if (cat==null) {
    cat = new Cat();
    sess.save(cat, id);
}
return cat;</pre><p>You can even load an object using an SQL <code class="literal">SELECT ... FOR UPDATE</code>, using a <code class="literal">LockMode</code>. See the API documentation for more information. </p><pre class="programlisting">Cat cat = (Cat) sess.get(Cat.class, id, LockMode.UPGRADE);</pre><p>Any associated instances or contained collections will <span class="emphasis"><em>not</em></span> be selected <code class="literal">FOR UPDATE</code>, unless you decide to specify <code class="literal">lock</code> or <code class="literal">all</code> as a cascade style for the association. </p><p><code class="literal">refresh()</code> 메소드를 사용하여, 아무때나 하나의 객체와 모든 그것의 콜렉션들을 다시 로드시키는 것이 가능하다. 데이터베이스 트리거들이 그 객체의 프로퍼티들 중 어떤 것을 초기화 시키는데 사용될 때 이것이 유용하다. </p><pre class="programlisting">sess.save(cat);
sess.flush(); //force the SQL INSERT
sess.refresh(cat); //re-read the state (after the trigger executes)</pre><p>How much does Hibernate load from the database and how many SQL <code class="literal">SELECT</code>s will it use? This depends on the <span class="emphasis"><em>fetching strategy</em></span>. This is explained in <a href="#performance-fetching" title="19.1. 페칭 방도들">19.1절. “페칭 방도들”</a>. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-querying"/>10.4. 질의하기</h2></div></div></div><p>If you do not know the identifiers of the objects you are looking for, you need a query. Hibernate supports an easy-to-use but powerful object oriented query language (HQL). For programmatic query creation, Hibernate supports a sophisticated Criteria and Example query feature (QBC and QBE). You can also express your query in the native SQL of your database, with optional support from Hibernate for result set conversion into objects. </p><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="objectstate-querying-executing"/>10.4.1. 질의들을 실행하기</h3></div></div></div><p>HQL 질의와 native SQL 질의는 <code class="literal">org.hibernate.Query</code>의 인스턴스로 표현된다. 이 인터페이스는 파라미터 바인딩, 결과셋 핸들링을 위한, 그리고 실제 질의의 실행을 위한 메소드들을 제공한다. 당신은 항상 현재 <code class="literal">Session</code>을 사용하여 하나의 <code class="literal">Query</code>를 얻는다: </p><pre class="programlisting">List cats = session.createQuery(
    "from Cat as cat where cat.birthdate &lt; ?")
    .setDate(0, date)
    .list();

List mothers = session.createQuery(
    "select mother from Cat as cat join cat.mother as mother where cat.name = ?")
    .setString(0, name)
    .list();

List kittens = session.createQuery(
    "from Cat as cat where cat.mother = ?")
    .setEntity(0, pk)
    .list();

Cat mother = (Cat) session.createQuery(
    "select cat.mother from Cat as cat where cat = ?")
    .setEntity(0, izi)
    .uniqueResult();]]

Query mothersWithKittens = (Cat) session.createQuery(
    "select mother from Cat as mother left join fetch mother.kittens");
Set uniqueMothers = new HashSet(mothersWithKittens.list());</pre><p>A query is usually executed by invoking <code class="literal">list()</code>. The result of the query will be loaded completely into a collection in memory. Entity instances retrieved by a query are in a persistent state. The <code class="literal">uniqueResult()</code> method offers a shortcut if you know your query will only return a single object. Queries that make use of eager fetching of collections usually return duplicates of the root objects, but with their collections initialized. You can filter these duplicates through a <code class="literal">Set</code>. </p><div class="sect3" lang="ko-KR"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-iterate"/>10.4.1.1. 결과들을 반복하기</h4></div></div></div><p>Occasionally, you might be able to achieve better performance by executing the query using the <code class="literal">iterate()</code> method. This will usually be the case if you expect that the actual entity instances returned by the query will already be in the session or second-level cache. If they are not already cached, <code class="literal">iterate()</code> will be slower than <code class="literal">list()</code> and might require many database hits for a simple query, usually <span class="emphasis"><em>1</em></span> for the initial select which only returns identifiers, and <span class="emphasis"><em>n</em></span> additional selects to initialize the actual instances. </p><pre class="programlisting">// fetch ids
Iterator iter = sess.createQuery("from eg.Qux q order by q.likeliness").iterate();
while ( iter.hasNext() ) {
    Qux qux = (Qux) iter.next();  // fetch the object
    // something we couldnt express in the query
    if ( qux.calculateComplicatedAlgorithm() ) {
        // delete the current instance
        iter.remove();
        // dont need to process the rest
        break;
    }
}</pre></div><div class="sect3" lang="ko-KR"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-tuples"/>10.4.1.2. 튜플들을 반환하는 질의들</h4></div></div></div><p>Hibernate queries sometimes return tuples of objects. Each tuple is returned as an array: </p><pre class="programlisting">Iterator kittensAndMothers = sess.createQuery(
            "select kitten, mother from Cat kitten join kitten.mother mother")
            .list()
            .iterator();

while ( kittensAndMothers.hasNext() ) {
    Object[] tuple = (Object[]) kittensAndMothers.next();
    Cat kitten = (Cat) tuple[0];
    Cat mother = (Cat) tuple[1];
    ....
}</pre></div><div class="sect3" lang="ko-KR"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-scalar"/>10.4.1.3. 스칼라 결과들</h4></div></div></div><p>Queries can specify a property of a class in the <code class="literal">select</code> clause. They can even call SQL aggregate functions. Properties or aggregates are considered "scalar" results and not entities in persistent state. </p><pre class="programlisting">Iterator results = sess.createQuery(
        "select cat.color, min(cat.birthdate), count(cat) from Cat cat " +
        "group by cat.color")
        .list()
        .iterator();

while ( results.hasNext() ) {
    Object[] row = (Object[]) results.next();
    Color type = (Color) row[0];
    Date oldest = (Date) row[1];
    Integer count = (Integer) row[2];
    .....
}</pre></div><div class="sect3" lang="ko-KR"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-parameters"/>10.4.1.4. 바인드 프라미터들</h4></div></div></div><p>Methods on <code class="literal">Query</code> are provided for binding values to named parameters or JDBC-style <code class="literal">?</code> parameters. <span class="emphasis"><em>Contrary to JDBC, Hibernate numbers parameters from zero.</em></span> Named parameters are identifiers of the form <code class="literal">:name</code> in the query string. The advantages of named parameters are as follows: </p><div class="itemizedlist"><ul compact="compact"><li><p>명명된 파라미터들은 그것들이 질의 문자열 내에 발생하는 순서에 관계없다 </p></li><li><p>they can occur multiple times in the same query </p></li><li><p>그것은 자기-설명적이다 </p></li></ul></div><pre class="programlisting">//named parameter (preferred)
Query q = sess.createQuery("from DomesticCat cat where cat.name = :name");
q.setString("name", "Fritz");
Iterator cats = q.iterate();</pre><pre class="programlisting">//positional parameter
Query q = sess.createQuery("from DomesticCat cat where cat.name = ?");
q.setString(0, "Izi");
Iterator cats = q.iterate();</pre><pre class="programlisting">//named parameter list
List names = new ArrayList();
names.add("Izi");
names.add("Fritz");
Query q = sess.createQuery("from DomesticCat cat where cat.name in (:namesList)");
q.setParameterList("namesList", names);
List cats = q.list();</pre></div><div class="sect3" lang="ko-KR"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-pagination"/>10.4.1.5. 쪽매김</h4></div></div></div><p>If you need to specify bounds upon your result set, that is, the maximum number of rows you want to retrieve and/or the first row you want to retrieve, you can use methods of the <code class="literal">Query</code> interface: </p><pre class="programlisting">Query q = sess.createQuery("from DomesticCat cat");
q.setFirstResult(20);
q.setMaxResults(10);
List cats = q.list();</pre><p>Hibernate는 이 limit 질의를 당신의 DBMS의 native SQL로 번역하는 방법을 알고 있다. </p></div><div class="sect3" lang="ko-KR"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-scrolling"/>10.4.1.6. 스크롤 가능한 iteration</h4></div></div></div><p>If your JDBC driver supports scrollable <code class="literal">ResultSet</code>s, the <code class="literal">Query</code> interface can be used to obtain a <code class="literal">ScrollableResults</code> object that allows flexible navigation of the query results. </p><pre class="programlisting">Query q = sess.createQuery("select cat.name, cat from DomesticCat cat " +
                            "order by cat.name");
ScrollableResults cats = q.scroll();
if ( cats.first() ) {

    // find the first name on each page of an alphabetical list of cats by name
    firstNamesOfPages = new ArrayList();
    do {
        String name = cats.getString(0);
        firstNamesOfPages.add(name);
    }
    while ( cats.scroll(PAGE_SIZE) );

    // Now get the first page of cats
    pageOfCats = new ArrayList();
    cats.beforeFirst();
    int i=0;
    while( ( PAGE_SIZE &gt; i++ ) &amp;&amp; cats.next() ) pageOfCats.add( cats.get(1) );

}
cats.close()</pre><p>Note that an open database connection and cursor is required for this functionality. Use <code class="literal">setMaxResult()</code>/<code class="literal">setFirstResult()</code> if you need offline pagination functionality. </p></div><div class="sect3" lang="ko-KR"><div class="titlepage"><div><div><h4 class="title"><a id="objectstate-querying-executing-named"/>10.4.1.7. 명명된 질의들을 구체화 시키기</h4></div></div></div><p>You can also define named queries in the mapping document. Remember to use a <code class="literal">CDATA</code> section if your query contains characters that could be interpreted as markup. </p><pre class="programlisting">&lt;query name="ByNameAndMaximumWeight"&gt;&lt;![CDATA[
    from eg.DomesticCat as cat
        where cat.name = ?
        and cat.weight &gt; ?
] ]&gt;&lt;/query&gt;</pre><p>파라미터 바인딩과 실행은 프로그램 상으로 행해진다: </p><pre class="programlisting">Query q = sess.getNamedQuery("ByNameAndMaximumWeight");
q.setString(0, name);
q.setInt(1, minWeight);
List cats = q.list();</pre><p>The actual program code is independent of the query language that is used. You can also define native SQL queries in metadata, or migrate existing queries to Hibernate by placing them in mapping files. </p><p>Also note that a query declaration inside a <code class="literal">&lt;hibernate-mapping&gt;</code> element requires a global unique name for the query, while a query declaration inside a <code class="literal">&lt;class&gt;</code> element is made unique automatically by prepending the fully qualified name of the class. For example <code class="literal">eg.Cat.ByNameAndMaximumWeight</code>. </p></div></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="objectstate-filtering"/>10.4.2. 콜렉션들을 필터링 하기</h3></div></div></div><p>A collection <span class="emphasis"><em>filter</em></span> is a special type of query that can be applied to a persistent collection or array. The query string can refer to <code class="literal">this</code>, meaning the current collection element. </p><pre class="programlisting">Collection blackKittens = session.createFilter(
    pk.getKittens(), 
    "where this.color = ?")
    .setParameter( Color.BLACK, Hibernate.custom(ColorUserType.class) )
    .list()
);</pre><p>The returned collection is considered a bag that is a copy of the given collection. The original collection is not modified. This is contrary to the implication of the name "filter", but consistent with expected behavior. </p><p>Observe that filters do not require a <code class="literal">from</code> clause, although they can have one if required. Filters are not limited to returning the collection elements themselves. </p><pre class="programlisting">Collection blackKittenMates = session.createFilter(
    pk.getKittens(), 
    "select this.mate where this.color = eg.Color.BLACK.intValue")
    .list();</pre><p>Even an empty filter query is useful, e.g. to load a subset of elements in a large collection: </p><pre class="programlisting">Collection tenKittens = session.createFilter(
    mother.getKittens(), "")
    .setFirstResult(0).setMaxResults(10)
    .list();</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="objecstate-querying-criteria"/>10.4.3. Criteria 질의들</h3></div></div></div><p>HQL is extremely powerful, but some developers prefer to build queries dynamically using an object-oriented API, rather than building query strings. Hibernate provides an intuitive <code class="literal">Criteria</code> query API for these cases: </p><pre class="programlisting">Criteria crit = session.createCriteria(Cat.class);
crit.add( Restrictions.eq( "color", eg.Color.BLACK ) );
crit.setMaxResults(10);
List cats = crit.list();</pre><p><code class="literal">Criteria</code>와 연관된 <code class="literal">Example</code> API 는 <a href="#querycriteria" title="15장. Criteria 질의들">15장. <i xmlns:xlink="http://www.w3.org/1999/xlink">Criteria 질의들</i></a>에서 상세하게 논의된다. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="objectstate-querying-nativesql"/>10.4.4. native SQL에서 질의들</h3></div></div></div><p>You can express a query in SQL, using <code class="literal">createSQLQuery()</code> and let Hibernate manage the mapping from result sets to objects. You can at any time call <code class="literal">session.connection()</code> and use the JDBC <code class="literal">Connection</code> directly. If you choose to use the Hibernate API, you must enclose SQL aliases in braces: </p><pre class="programlisting">List cats = session.createSQLQuery("SELECT {cat.*} FROM CAT {cat} WHERE ROWNUM&lt;10")
    .addEntity("cat", Cat.class)
.list();</pre><pre class="programlisting">List cats = session.createSQLQuery(
    "SELECT {cat}.ID AS {cat.id}, {cat}.SEX AS {cat.sex}, " +
           "{cat}.MATE AS {cat.mate}, {cat}.SUBCLASS AS {cat.class}, ... " +
    "FROM CAT {cat} WHERE ROWNUM&lt;10")
    .addEntity("cat", Cat.class)
.list()</pre><p>SQL queries can contain named and positional parameters, just like Hibernate queries. More information about native SQL queries in Hibernate can be found in <a href="#querysql" title="16장. Native SQL">16장. <i xmlns:xlink="http://www.w3.org/1999/xlink">Native SQL</i></a>. </p></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-modifying"/>10.5. 영속 객체들을 변경하기</h2></div></div></div><p><span class="emphasis"><em>Transactional persistent instances</em></span> (i.e. objects loaded, saved, created or queried by the <code class="literal">Session</code>) can be manipulated by the application, and any changes to persistent state will be persisted when the <code class="literal">Session</code> is <span class="emphasis"><em>flushed</em></span>. This is discussed later in this chapter. There is no need to call a particular method (like <code class="literal">update()</code>, which has a different purpose) to make your modifications persistent. The most straightforward way to update the state of an object is to <code class="literal">load()</code> it and then manipulate it directly while the <code class="literal">Session</code> is open: </p><pre class="programlisting">DomesticCat cat = (DomesticCat) sess.load( Cat.class, new Long(69) );
cat.setName("PK");
sess.flush();  // changes to cat are automatically detected and persisted</pre><p>Sometimes this programming model is inefficient, as it requires in the same session both an SQL <code class="literal">SELECT</code> to load an object and an SQL <code class="literal">UPDATE</code> to persist its updated state. Hibernate offers an alternate approach by using detached instances. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>중요</h2><p>Hibernate does not offer its own API for direct execution of <code class="literal">UPDATE</code> or <code class="literal">DELETE</code> statements. Hibernate is a <span class="emphasis"><em>state management</em></span> service, you do not have to think in <span class="emphasis"><em>statements</em></span> to use it. JDBC is a perfect API for executing SQL statements, you can get a JDBC <code class="literal">Connection</code> at any time by calling <code class="literal">session.connection()</code>. Furthermore, the notion of mass operations conflicts with object/relational mapping for online transaction processing-oriented applications. Future versions of Hibernate can, however, provide special mass operation functions. See <a href="#batch" title="13장. Batch ì²ë¦¬">13장. <i xmlns:xlink="http://www.w3.org/1999/xlink">Batch ì²ë¦¬</i></a> for some possible batch operation tricks. </p></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-detached"/>10.6. detached 객체들을 변경시키기</h2></div></div></div><p>많은 어플리케이션들은 하나의 트랜잭션 내에서 하나의 객체를 검색하고, 처리를 위한 UI 계층으로 그것을 전송하고, 그런 다음 새로운 트랜잭션 내에서 변경들을 저장할 필요가 있다. 고도의-동시성 환경에서 이런 종류의 접근법을 사용하는 어플리케이션들은 대개 작업의 "긴" 단위를 확실히 격리시키기 위해 버전화 된 데이터를 사용한다. </p><p>Hibernate는 <code class="literal">Session.update()</code> 메소드 또는 <code class="literal">Session.merge()</code> 메소드를 사용하여 detached 인스턴스들의 재첨부를 제공함으로써 이 모형을 지원한다: </p><pre class="programlisting">// in the first session
Cat cat = (Cat) firstSession.load(Cat.class, catId);
Cat potentialMate = new Cat();
firstSession.save(potentialMate);

// in a higher layer of the application
cat.setMate(potentialMate);

// later, in a new session
secondSession.update(cat);  // update cat
secondSession.update(mate); // update mate</pre><p>만일 <code class="literal">catId</code> 식별자를 가진 <code class="literal">Cat</code>이 <code class="literal">secondSession</code>에 의해 이미 로드되었을 경우에 어플리케이션이 그것을 다시 재첨부하려고 시도할 때, 예외상황이 던져졌을 것이다. </p><p>Use <code class="literal">update()</code> if you are certain that the session does not contain an already persistent instance with the same identifier. Use <code class="literal">merge()</code> if you want to merge your modifications at any time without consideration of the state of the session. In other words, <code class="literal">update()</code> is usually the first method you would call in a fresh session, ensuring that the reattachment of your detached instances is the first operation that is executed. </p><p>The application should individually <code class="literal">update()</code> detached instances that are reachable from the given detached instance <span class="emphasis"><em>only</em></span> if it wants their state to be updated. This can be automated using <span class="emphasis"><em>transitive persistence</em></span>. See <a href="#objectstate-transitive" title="10.11. Transitive persistence(전이 영속)">10.11절. “Transitive persistence(전이 영속)”</a> for more information. </p><p>The <code class="literal">lock()</code> method also allows an application to reassociate an object with a new session. However, the detached instance has to be unmodified. </p><pre class="programlisting">//just reassociate:
sess.lock(fritz, LockMode.NONE);
//do a version check, then reassociate:
sess.lock(izi, LockMode.READ);
//do a version check, using SELECT ... FOR UPDATE, then reassociate:
sess.lock(pk, LockMode.UPGRADE);</pre><p>Note that <code class="literal">lock()</code> can be used with various <code class="literal">LockMode</code>s. See the API documentation and the chapter on transaction handling for more information. Reattachment is not the only usecase for <code class="literal">lock()</code>. </p><p>긴 작업 단위에 대한 다른 모형들은 <a href="#transactions-optimistic" title="11.3. Optimistic 동시성 제어">11.3절. “Optimistic 동시성 제어”</a>에서 논의된다. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-saveorupdate"/>10.7. 자동적인 상태 검출</h2></div></div></div><p>Hibernate 사용자들은 새로운 식별자를 생성시켜서 transient 인스턴스를 저장하거나 그것의 현재 식별자와 연관된 detached 인스턴스들을 업데이트/재첨부 시키는 일반적인 용도의 메소드를 요청했다. <code class="literal">saveOrUpdate()</code> 메소드는 이 기능을 구현한다. </p><pre class="programlisting">// in the first session
Cat cat = (Cat) firstSession.load(Cat.class, catID);

// in a higher tier of the application
Cat mate = new Cat();
cat.setMate(mate);

// later, in a new session
secondSession.saveOrUpdate(cat);   // update existing state (cat has a non-null id)
secondSession.saveOrUpdate(mate);  // save the new instance (mate has a null id)</pre><p><code class="literal">saveOrUpdate()</code>의 사용 예제와 의미는 초심자들에게는 혼동스러워 보인다. 먼저, 하나의 세션에서 온 인스턴스를 또 다른 새로운 세션 내에서 사용하려고 시도하지 않는 한, 당신은 <code class="literal">update()</code>, <code class="literal">saveOrUpdate()</code>, 또는 <code class="literal">merge()</code>를 사용할 필요는 없을 것이다. 몇몇 전체 어플리케이션들은 이들 메소드들 중 어느 것도 결코 사용하지 않을 것이다. </p><p>대개 <code class="literal">update()</code> 또는 <code class="literal">saveOrUpdate()</code>는 다음 시나리오에서 사용된다: </p><div class="itemizedlist"><ul compact="compact"><li><p>어플리케이션이 첫 번째 세션 내에 객체를 로드시킨다 </p></li><li><p>객체가 UI 티어로 전달된다 </p></li><li><p>몇몇 변경들이 그 객체에 행해진다 </p></li><li><p>객체가 비지니스 로직 티어로 전달된다 </p></li><li><p>어플리케이션은 두 번째 세션에서 <code class="literal">update()</code>를 호출함으로써 이들 변경들을 영속화 시킨다 </p></li></ul></div><p><code class="literal">saveOrUpdate()</code>는 다음을 행한다: </p><div class="itemizedlist"><ul compact="compact"><li><p>만일 객체가 이 세션 내에서 이미 영속화 되어 있을 경우, 아무것도 행하지 않는다 </p></li><li><p>만일 그 세션과 연관된 또 다른 객체가 동일한 식별자를 가질 경우, 예외상황을 던진다 </p></li><li><p>만일 그 객체가 식별자 프로퍼티를 갖지 않을 경우, 그것을 <code class="literal">save()</code> 시킨다 </p></li><li><p>만일 객체의 식별자가 새로이 초기화 된 객체에 할당된 값을 가질 경우, 그것을 <code class="literal">save()</code> 시킨다 </p></li><li><p>if the object is versioned by a <code class="literal">&lt;version&gt;</code> or <code class="literal">&lt;timestamp&gt;</code>, and the version property value is the same value assigned to a newly instantiated object, <code class="literal">save()</code> it </p></li><li><p>그 밖의 경우 그 객체를 <code class="literal">update()</code> 시킨다 </p></li></ul></div><p>그리고 <code class="literal">merge()</code>는 매우 다르다: </p><div class="itemizedlist"><ul compact="compact"><li><p>만일 세션과 현재 연관된 동일한 식별자를 가진 영속 인스턴스가 존재할 경우, 주어진 객체의 상태를 영속 인스턴스 상으로 복사한다 </p></li><li><p>만일 세션과 현재 연관된 영속 인스턴스가 존재하지 않을 경우, 데이터베이스로부터 그것을 로드시키려고 시도하거나 새로운 영속 인스턴스를 생성시키려고 시도한다 </p></li><li><p>영속 인스턴스가 반환된다 </p></li><li><p>주어진 인스턴스는 세션과 연관되지 않고, 그것은 detached 상태에 머무른다 </p></li></ul></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-deleting"/>10.8. 영속 객체들을 삭제하기</h2></div></div></div><p><code class="literal">Session.delete()</code> will remove an object's state from the database. Your application, however, can still hold a reference to a deleted object. It is best to think of <code class="literal">delete()</code> as making a persistent instance, transient. </p><pre class="programlisting">sess.delete(cat);</pre><p>You can delete objects in any order, without risk of foreign key constraint violations. It is still possible to violate a <code class="literal">NOT NULL</code> constraint on a foreign key column by deleting objects in the wrong order, e.g. if you delete the parent, but forget to delete the children. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-replicating"/>10.9. 두 개의 다른 데이터저장소들 사이에 객체들을 복제하기</h2></div></div></div><p>It is sometimes useful to be able to take a graph of persistent instances and make them persistent in a different datastore, without regenerating identifier values. </p><pre class="programlisting">//retrieve a cat from one database
Session session1 = factory1.openSession();
Transaction tx1 = session1.beginTransaction();
Cat cat = session1.get(Cat.class, catId);
tx1.commit();
session1.close();

//reconcile with a second database
Session session2 = factory2.openSession();
Transaction tx2 = session2.beginTransaction();
session2.replicate(cat, ReplicationMode.LATEST_VERSION);
tx2.commit();
session2.close();</pre><p>The <code class="literal">ReplicationMode</code> determines how <code class="literal">replicate()</code> will deal with conflicts with existing rows in the database: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">ReplicationMode.IGNORE</code>: ignores the object when there is an existing database row with the same identifier </p></li><li><p><code class="literal">ReplicationMode.OVERWRITE</code>: overwrites any existing database row with the same identifier </p></li><li><p><code class="literal">ReplicationMode.EXCEPTION</code>: throws an exception if there is an existing database row with the same identifier </p></li><li><p><code class="literal">ReplicationMode.LATEST_VERSION</code>: overwrites the row if its version number is earlier than the version number of the object, or ignore the object otherwise </p></li></ul></div><p>이 특징의 쓰임새들은 다른 데이터베이스 인스턴스들 속으로 입력된 데이터 일치시키기, 제품 업그레이드 동안에 시스템 구성 정보 업데이트 하기, non-ACID 트랜잭션들 동안에 행해진 변경들을 롤백시키기 등을 포함한다. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-flushing"/>10.10. Session을 flush 시키기</h2></div></div></div><p>Sometimes the <code class="literal">Session</code> will execute the SQL statements needed to synchronize the JDBC connection's state with the state of objects held in memory. This process, called <span class="emphasis"><em>flush</em></span>, occurs by default at the following points: </p><div class="itemizedlist"><ul compact="compact"><li><p>몇몇 질의들이 실행되기 전에 </p></li><li><p><code class="literal">org.hibernate.Transaction.commit()</code> 시점에서 </p></li><li><p><code class="literal">Session.flush()</code> 시점에서 </p></li></ul></div><p>The SQL statements are issued in the following order: </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>all entity insertions in the same order the corresponding objects were saved using <code class="literal">Session.save()</code> </p></li><li><p>모든 엔티티 업데이트들 </p></li><li><p>모든 콜렉션 삭제들 </p></li><li><p>모든 콜렉션 요소 삭제들, 업데이트들 그리고 삽입들 </p></li><li><p>모든 콜렉션 삽입들 </p></li><li><p>all entity deletions in the same order the corresponding objects were deleted using <code class="literal">Session.delete()</code> </p></li></ol></div><p>An exception is that objects using <code class="literal">native</code> ID generation are inserted when they are saved. </p><p>Except when you explicitly <code class="literal">flush()</code>, there are absolutely no guarantees about <span class="emphasis"><em>when</em></span> the <code class="literal">Session</code> executes the JDBC calls, only the <span class="emphasis"><em>order</em></span> in which they are executed. However, Hibernate does guarantee that the <code class="literal">Query.list(..)</code> will never return stale or incorrect data. </p><p>It is possible to change the default behavior so that flush occurs less frequently. The <code class="literal">FlushMode</code> class defines three different modes: only flush at commit time when the Hibernate <code class="literal">Transaction</code> API is used, flush automatically using the explained routine, or never flush unless <code class="literal">flush()</code> is called explicitly. The last mode is useful for long running units of work, where a <code class="literal">Session</code> is kept open and disconnected for a long time (see <a href="#transactions-optimistic-longsession" title="11.3.2. 확장된 세션과 자동적인 버전화">11.3.2절. “확장된 세션과 자동적인 버전화”</a>). </p><pre class="programlisting">sess = sf.openSession();
Transaction tx = sess.beginTransaction();
sess.setFlushMode(FlushMode.COMMIT); // allow queries to return stale state

Cat izi = (Cat) sess.load(Cat.class, id);
izi.setName(iznizi);

// might return stale data
sess.find("from Cat as cat left outer join cat.kittens kitten");

// change to izi is not flushed!
...
tx.commit(); // flush occurs
sess.close();</pre><p>flush 동안에, 하나의 예외상황이 발생할 수도 있다(예를 들면. 만일 DML 오퍼레이션이 컨스트레인트를 위반할 경우). 예외상황들을 처리하는 것은 Hibernatem의 트랜잭션 특징에 관한 어떤 이해를 수반하며, 우리는 <a href="#transactions" title="11장. Transactions and Concurrency">11장. <i xmlns:xlink="http://www.w3.org/1999/xlink">Transactions and Concurrency</i></a>에서 그것을 논의한다. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-transitive"/>10.11. Transitive persistence(전이 영속)</h2></div></div></div><p>특히 당신이 연관된 객체들의 그래프를 다룰 경우에, 특히 개별 객체들을 저장하고, 삭제하거나, 재첨부시키는 것이 꽤 번거롭다. 공통된 경우는 하나의 부모/자식 관계이다. 다음 예제를 검토하자: </p><p>If the children in a parent/child relationship would be value typed (e.g. a collection of addresses or strings), their life cycle would depend on the parent and no further action would be required for convenient "cascading" of state changes. When the parent is saved, the value-typed child objects are saved and when the parent is deleted, the children will be deleted, etc. This works for operations such as the removal of a child from the collection. Since value-typed objects cannot have shared references, Hibernate will detect this and delete the child from the database. </p><p>Now consider the same scenario with parent and child objects being entities, not value-types (e.g. categories and items, or parent and child cats). Entities have their own life cycle and support shared references. Removing an entity from the collection does not mean it can be deleted), and there is by default no cascading of state from one entity to any other associated entities. Hibernate does not implement <span class="emphasis"><em>persistence by reachability</em></span> by default. </p><p>- <code class="literal">persist(), merge(), saveOrUpdate(), delete(), lock(), refresh(), evict(), replicate()</code>를 포함하는- Hibernate 세션에 대한 각각의 기본 오퍼레이션에 대해서 하나의 대응하는 케스케이딩 스타일이 존재한다. 케스케이드 스타일들 각각은 <code class="literal">create, merge, save-update, delete, lock, refresh, evict, replicate</code>로 명명된다. 만일 당신이 하나의 오퍼레이션이 하나의 연관에 따라 케스케이딩되는 것을 원할 경우, 당신은 매핑 문서 내에 그것을 지시해야 한다. 예를 들면: </p><pre class="programlisting">&lt;one-to-one name="person" cascade="persist"/&gt;</pre><p>케스케이딩 스타일들이 결합될 수도 있다: </p><pre class="programlisting">&lt;one-to-one name="person" cascade="persist,delete,lock"/&gt;</pre><p>You can even use <code class="literal">cascade="all"</code> to specify that <span class="emphasis"><em>all</em></span> operations should be cascaded along the association. The default <code class="literal">cascade="none"</code> specifies that no operations are to be cascaded. </p><p>특정한 케스케이드 스타일인, <code class="literal">delete-orphan</code>은 오직 one-to-many 연관들에만 적용되고, <code class="literal">delete()</code> 오퍼레이션이 그 연관으로부터 제거되는 임의의 자식 객체에 적용되어야 함을 나타낸다. </p><p>권장사항들 : </p><div class="itemizedlist"><ul compact="compact"><li><p>It does not usually make sense to enable cascade on a <code class="literal">&lt;many-to-one&gt;</code> or <code class="literal">&lt;many-to-many&gt;</code> association. Cascade is often useful for <code class="literal">&lt;one-to-one&gt;</code> and <code class="literal">&lt;one-to-many&gt;</code> associations. </p></li><li><p>만일 자식 객체의 수명이 그 부모 객체의 수명에 묶여져 있을 경우, <code class="literal">cascade="all,delete-orphan"</code>을 지정함으로써 그것을 <span class="emphasis"><em>생명 주기 객체</em></span>로 만들어라. </p></li><li><p>그 밖의 경우, 당신은 케스케이드를 전혀 필요로 하지 않을 수 있다. 그러나 만일 당신이 동일한 트랜잭션 내에서 부모와 자식에 대해 자주 함께 작업하게 될 것이라 생각되고, 당신 스스로 타이핑 하는 것을 절약하고자 원할 경우, <code class="literal">cascade="persist,merge,save-update"</code>를 사용하는 것을 고려하라. </p></li></ul></div><p><code class="literal">cascade="all"</code>을 가진 (단일 값 연관이든 하나의 콜렉션이든) 하나의 연관을 매핑시키는 것은 그 연관을 부모의 저장/업데이트/삭제가 자식 또는 자식들의 저장/업데이트/삭제로 귀결되는 <span class="emphasis"><em>부모/자식</em></span> 스타일의 관계로 마크한다. </p><p>Furthermore, a mere reference to a child from a persistent parent will result in save/update of the child. This metaphor is incomplete, however. A child which becomes unreferenced by its parent is <span class="emphasis"><em>not</em></span> automatically deleted, except in the case of a <code class="literal">&lt;one-to-many&gt;</code> association mapped with <code class="literal">cascade="delete-orphan"</code>. The precise semantics of cascading operations for a parent/child relationship are as follows: </p><div class="itemizedlist"><ul compact="compact"><li><p>만일 부모가 <code class="literal">persist()</code>에 전달될 경우, 모든 자식들이 <code class="literal">persist()</code>에 전달된다 </p></li><li><p>만일 부모가 <code class="literal">merge()</code>에 전달될 경우, 모든 자식들이 <code class="literal">merge()</code>에 전달된다 </p></li><li><p>만일 부모가 <code class="literal">save()</code>, <code class="literal">update()</code> 또는 <code class="literal">saveOrUpdate()</code>에 전달될 경우, 모든 자식들이 <code class="literal">saveOrUpdate()</code>에 전달된다 </p></li><li><p>만일 transient 또는 detached 자식이 영속 부모에 의해 참조될 경우, 그것은 <code class="literal">saveOrUpdate()</code>에 전달된다 </p></li><li><p>만일 부모가 삭제될 경우, 모든 자식들이 <code class="literal">delete()</code>에 전달된다 </p></li><li><p>만일 자식이 영속 부모에 의해 참조 해제 될 경우, <code class="literal">cascade="delete-orphan"</code>이 아닌 한, <span class="emphasis"><em>특별한 어떤 것도 발생하지 않는다</em></span> - 어플리케이션은 필요한 경우에 자식을 명시적으로 삭제해야 한다 -, <code class="literal">cascade="delete-orphan"</code>인 경우에 "orphaned(고아)"인 경우 자식이 삭제된다. </p></li></ul></div><p>Finally, note that cascading of operations can be applied to an object graph at <span class="emphasis"><em>call time</em></span> or at <span class="emphasis"><em>flush time</em></span>. All operations, if enabled, are cascaded to associated entities reachable when the operation is executed. However, <code class="literal">save-update</code> and <code class="literal">delete-orphan</code> are transitive for all associated entities reachable during flush of the <code class="literal">Session</code>. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-metadata"/>10.12. 메타데이터 사용하기</h2></div></div></div><p>Hibernate requires a rich meta-level model of all entity and value types. This model can be useful to the application itself. For example, the application might use Hibernate's metadata to implement a "smart" deep-copy algorithm that understands which objects should be copied (eg. mutable value types) and which objects that should not (e.g. immutable value types and, possibly, associated entities). </p><p>Hibernate exposes metadata via the <code class="literal">ClassMetadata</code> and <code class="literal">CollectionMetadata</code> interfaces and the <code class="literal">Type</code> hierarchy. Instances of the metadata interfaces can be obtained from the <code class="literal">SessionFactory</code>. </p><pre class="programlisting">Cat fritz = ......;
ClassMetadata catMeta = sessionfactory.getClassMetadata(Cat.class);

Object[] propertyValues = catMeta.getPropertyValues(fritz);
String[] propertyNames = catMeta.getPropertyNames();
Type[] propertyTypes = catMeta.getPropertyTypes();

// get a Map of all properties which are not collections or associations
Map namedValues = new HashMap();
for ( int i=0; i&lt;propertyNames.length; i++ ) {
    if ( !propertyTypes[i].isEntityType() &amp;&amp; !propertyTypes[i].isCollectionType() ) {
        namedValues.put( propertyNames[i], propertyValues[i] );
    }
}</pre></div></div><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions"/>11장. Transactions and Concurrency</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#transactions-basics">11.1. 세션 영역과 트랜잭션 영역</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-basics-uow">11.1.1. 작업 단위</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-apptx">11.1.2. 장기간의 대화</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-identity">11.1.3. 객체 identity 고려하기</a></span></dt><dt><span class="sect2"><a href="#transactions-basics-issues">11.1.4. 공통된 쟁점들</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-demarcation">11.2. 데이터베이스 트랜잭션 경계 설정</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-demarcation-nonmanaged">11.2.1. 관리되지 않는 환경</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-jta">11.2.2. JTA 사용하기</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-exceptions">11.2.3. 예외상황 처리</a></span></dt><dt><span class="sect2"><a href="#transactions-demarcation-timeout">11.2.4. 트랜잭션 타임아웃</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-optimistic">11.3. Optimistic 동시성 제어</a></span></dt><dd><dl><dt><span class="sect2"><a href="#transactions-optimistic-manual">11.3.1. 어플리케이션 버전 체킹</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-longsession">11.3.2. 확장된 세션과 자동적인 버전화</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-detached">11.3.3. Detached 객체들과 자동적인 버전화</a></span></dt><dt><span class="sect2"><a href="#transactions-optimistic-customizing">11.3.4. 자동적인 버전화를 맞춤화 시키기</a></span></dt></dl></dd><dt><span class="sect1"><a href="#transactions-locking">11.4. Pessimistic locking</a></span></dt><dt><span class="sect1"><a href="#transactions-connection-release">11.5. Connection release modes</a></span></dt></dl></div><p>The most important point about Hibernate and concurrency control is that it is easy to understand. Hibernate directly uses JDBC connections and JTA resources without adding any additional locking behavior. It is recommended that you spend some time with the JDBC, ANSI, and transaction isolation specification of your database management system. </p><p>Hibernate does not lock objects in memory. Your application can expect the behavior as defined by the isolation level of your database transactions. Through <code class="literal">Session</code>, which is also a transaction-scoped cache, Hibernate provides repeatable reads for lookup by identifier and entity queries and not reporting queries that return scalar values. </p><p>In addition to versioning for automatic optimistic concurrency control, Hibernate also offers, using the <code class="literal">SELECT FOR UPDATE</code> syntax, a (minor) API for pessimistic locking of rows. Optimistic concurrency control and this API are discussed later in this chapter. </p><p>The discussion of concurrency control in Hibernate begins with the granularity of <code class="literal">Configuration</code>, <code class="literal">SessionFactory</code>, and <code class="literal">Session</code>, as well as database transactions and long conversations. </p><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-basics"/>11.1. 세션 영역과 트랜잭션 영역</h2></div></div></div><p>A <code class="literal">SessionFactory</code> is an expensive-to-create, threadsafe object, intended to be shared by all application threads. It is created once, usually on application startup, from a <code class="literal">Configuration</code> instance. </p><p>A <code class="literal">Session</code> is an inexpensive, non-threadsafe object that should be used once and then discarded for: a single request, a conversation or a single unit of work. A <code class="literal">Session</code> will not obtain a JDBC <code class="literal">Connection</code>, or a <code class="literal">Datasource</code>, unless it is needed. It will not consume any resources until used. </p><p>In order to reduce lock contention in the database, a database transaction has to be as short as possible. Long database transactions will prevent your application from scaling to a highly concurrent load. It is not recommended that you hold a database transaction open during user think time until the unit of work is complete. </p><p>What is the scope of a unit of work? Can a single Hibernate <code class="literal">Session</code> span several database transactions, or is this a one-to-one relationship of scopes? When should you open and close a <code class="literal">Session</code> and how do you demarcate the database transaction boundaries? These questions are addressed in the following sections. </p><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-uow"/>11.1.1. 작업 단위</h3></div></div></div><p>First, let's define a unit of work. A unit of work is a design pattern described by Martin Fowler as “<span class="quote"> [maintaining] a list of objects affected by a business transaction and coordinates the writing out of changes and the resolution of concurrency problems. </span>”[<a href="#biblio-PoEAA"><span class="citation">PoEAA</span></a>] In other words, its a series of operations we wish to carry out against the database together. Basically, it is a transaction, though fulfilling a unit of work will often span multiple physical database transactions (see <a href="#transactions-basics-apptx" title="11.1.2. 장기간의 대화">11.1.2절. “장기간의 대화”</a>). So really we are talking about a more abstract notion of a transaction. The term "business transaction" is also sometimes used in lieu of unit of work. </p><p>Do not use the <span class="emphasis"><em>session-per-operation</em></span> antipattern: do not open and close a <code class="literal">Session</code> for every simple database call in a single thread. The same is true for database transactions. Database calls in an application are made using a planned sequence; they are grouped into atomic units of work. This also means that auto-commit after every single SQL statement is useless in an application as this mode is intended for ad-hoc SQL console work. Hibernate disables, or expects the application server to disable, auto-commit mode immediately. Database transactions are never optional. All communication with a database has to occur inside a transaction. Auto-commit behavior for reading data should be avoided, as many small transactions are unlikely to perform better than one clearly defined unit of work. The latter is also more maintainable and extensible. </p><p>The most common pattern in a multi-user client/server application is <span class="emphasis"><em>session-per-request</em></span>. In this model, a request from the client is sent to the server, where the Hibernate persistence layer runs. A new Hibernate <code class="literal">Session</code> is opened, and all database operations are executed in this unit of work. On completion of the work, and once the response for the client has been prepared, the session is flushed and closed. Use a single database transaction to serve the clients request, starting and committing it when you open and close the <code class="literal">Session</code>. The relationship between the two is one-to-one and this model is a perfect fit for many applications. </p><p>The challenge lies in the implementation. Hibernate provides built-in management of the "current session" to simplify this pattern. Start a transaction when a server request has to be processed, and end the transaction before the response is sent to the client. Common solutions are <code class="literal">ServletFilter</code>, AOP interceptor with a pointcut on the service methods, or a proxy/interception container. An EJB container is a standardized way to implement cross-cutting aspects such as transaction demarcation on EJB session beans, declaratively with CMT. If you use programmatic transaction demarcation, for ease of use and code portability use the Hibernate <code class="literal">Transaction</code> API shown later in this chapter. </p><p>Your application code can access a "current session" to process the request by calling <code class="literal">sessionFactory.getCurrentSession()</code>. You will always get a <code class="literal">Session</code> scoped to the current database transaction. This has to be configured for either resource-local or JTA environments, see <a href="#architecture-current-session" title="2.5. Contextual sessions">2.5절. “Contextual sessions”</a>. </p><p>You can extend the scope of a <code class="literal">Session</code> and database transaction until the "view has been rendered". This is especially useful in servlet applications that utilize a separate rendering phase after the request has been processed. Extending the database transaction until view rendering, is achieved by implementing your own interceptor. However, this will be difficult if you rely on EJBs with container-managed transactions. A transaction will be completed when an EJB method returns, before rendering of any view can start. See the Hibernate website and forum for tips and examples relating to this <span class="emphasis"><em>Open Session in View</em></span> pattern. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-apptx"/>11.1.2. 장기간의 대화</h3></div></div></div><p>The session-per-request pattern is not the only way of designing units of work. Many business processes require a whole series of interactions with the user that are interleaved with database accesses. In web and enterprise applications, it is not acceptable for a database transaction to span a user interaction. Consider the following example: </p><div class="itemizedlist"><ul><li><p>The first screen of a dialog opens. The data seen by the user has been loaded in a particular <code class="literal">Session</code> and database transaction. The user is free to modify the objects. </p></li><li><p>The user clicks "Save" after 5 minutes and expects their modifications to be made persistent. The user also expects that they were the only person editing this information and that no conflicting modification has occurred. </p></li></ul></div><p>From the point of view of the user, we call this unit of work a long-running <span class="emphasis"><em>conversation</em></span> or <span class="emphasis"><em>application transaction</em></span>. There are many ways to implement this in your application. </p><p>A first naive implementation might keep the <code class="literal">Session</code> and database transaction open during user think time, with locks held in the database to prevent concurrent modification and to guarantee isolation and atomicity. This is an anti-pattern, since lock contention would not allow the application to scale with the number of concurrent users. </p><p>You have to use several database transactions to implement the conversation. In this case, maintaining isolation of business processes becomes the partial responsibility of the application tier. A single conversation usually spans several database transactions. It will be atomic if only one of these database transactions (the last one) stores the updated data. All others simply read data (for example, in a wizard-style dialog spanning several request/response cycles). This is easier to implement than it might sound, especially if you utilize some of Hibernate's features: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Automatic Versioning</em></span>: Hibernate can perform automatic optimistic concurrency control for you. It can automatically detect if a concurrent modification occurred during user think time. Check for this at the end of the conversation. </p></li><li><p><span class="emphasis"><em>Detached Objects</em></span>: if you decide to use the <span class="emphasis"><em>session-per-request</em></span> pattern, all loaded instances will be in the detached state during user think time. Hibernate allows you to reattach the objects and persist the modifications. The pattern is called <span class="emphasis"><em>session-per-request-with-detached-objects</em></span>. Automatic versioning is used to isolate concurrent modifications. </p></li><li><p><span class="emphasis"><em>Extended (or Long) Session</em></span>: the Hibernate <code class="literal">Session</code> can be disconnected from the underlying JDBC connection after the database transaction has been committed and reconnected when a new client request occurs. This pattern is known as <span class="emphasis"><em>session-per-conversation</em></span> and makes even reattachment unnecessary. Automatic versioning is used to isolate concurrent modifications and the <code class="literal">Session</code> will not be allowed to be flushed automatically, but explicitly. </p></li></ul></div><p>Both <span class="emphasis"><em>session-per-request-with-detached-objects</em></span> and <span class="emphasis"><em>session-per-conversation</em></span> have advantages and disadvantages. These disadvantages are discussed later in this chapter in the context of optimistic concurrency control. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-identity"/>11.1.3. 객체 identity 고려하기</h3></div></div></div><p>An application can concurrently access the same persistent state in two different <code class="literal">Session</code>s. However, an instance of a persistent class is never shared between two <code class="literal">Session</code> instances. It is for this reason that there are two different notions of identity: </p><div class="variablelist"><dl><dt><span class="term">데이터베이스 Identity</span></dt><dd><p>
                            <code class="literal">foo.getId().equals( bar.getId() )</code>
                        </p></dd><dt><span class="term">JVM Identity</span></dt><dd><p>
                            <code class="literal">foo==bar</code>
                        </p></dd></dl></div><p>For objects attached to a <span class="emphasis"><em>particular</em></span> <code class="literal">Session</code> (i.e., in the scope of a <code class="literal">Session</code>), the two notions are equivalent and JVM identity for database identity is guaranteed by Hibernate. While the application might concurrently access the "same" (persistent identity) business object in two different sessions, the two instances will actually be "different" (JVM identity). Conflicts are resolved using an optimistic approach and automatic versioning at flush/commit time. </p><p>This approach leaves Hibernate and the database to worry about concurrency. It also provides the best scalability, since guaranteeing identity in single-threaded units of work means that it does not need expensive locking or other means of synchronization. The application does not need to synchronize on any business object, as long as it maintains a single thread per <code class="literal">Session</code>. Within a <code class="literal">Session</code> the application can safely use <code class="literal">==</code> to compare objects. </p><p>However, an application that uses <code class="literal">==</code> outside of a <code class="literal">Session</code> might produce unexpected results. This might occur even in some unexpected places. For example, if you put two detached instances into the same <code class="literal">Set</code>, both might have the same database identity (i.e., they represent the same row). JVM identity, however, is by definition not guaranteed for instances in a detached state. The developer has to override the <code class="literal">equals()</code> and <code class="literal">hashCode()</code> methods in persistent classes and implement their own notion of object equality. There is one caveat: never use the database identifier to implement equality. Use a business key that is a combination of unique, usually immutable, attributes. The database identifier will change if a transient object is made persistent. If the transient instance (usually together with detached instances) is held in a <code class="literal">Set</code>, changing the hashcode breaks the contract of the <code class="literal">Set</code>. Attributes for business keys do not have to be as stable as database primary keys; you only have to guarantee stability as long as the objects are in the same <code class="literal">Set</code>. See the Hibernate website for a more thorough discussion of this issue. Please note that this is not a Hibernate issue, but simply how Java object identity and equality has to be implemented. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-issues"/>11.1.4. 공통된 쟁점들</h3></div></div></div><p>Do not use the anti-patterns <span class="emphasis"><em>session-per-user-session</em></span> or <span class="emphasis"><em>session-per-application</em></span> (there are, however, rare exceptions to this rule). Some of the following issues might also arise within the recommended patterns, so ensure that you understand the implications before making a design decision: </p><div class="itemizedlist"><ul><li><p>A <code class="literal">Session</code> is not thread-safe. Things that work concurrently, like HTTP requests, session beans, or Swing workers, will cause race conditions if a <code class="literal">Session</code> instance is shared. If you keep your Hibernate <code class="literal">Session</code> in your <code class="literal">HttpSession</code> (this is discussed later in the chapter), you should consider synchronizing access to your Http session. Otherwise, a user that clicks reload fast enough can use the same <code class="literal">Session</code> in two concurrently running threads. </p></li><li><p>An exception thrown by Hibernate means you have to rollback your database transaction and close the <code class="literal">Session</code> immediately (this is discussed in more detail later in the chapter). If your <code class="literal">Session</code> is bound to the application, you have to stop the application. Rolling back the database transaction does not put your business objects back into the state they were at the start of the transaction. This means that the database state and the business objects will be out of sync. Usually this is not a problem, because exceptions are not recoverable and you will have to start over after rollback anyway. </p></li><li><p>The <code class="literal">Session</code> caches every object that is in a persistent state (watched and checked for dirty state by Hibernate). If you keep it open for a long time or simply load too much data, it will grow endlessly until you get an OutOfMemoryException. One solution is to call <code class="literal">clear()</code> and <code class="literal">evict()</code> to manage the <code class="literal">Session</code> cache, but you should consider a Stored Procedure if you need mass data operations. Some solutions are shown in <a href="#batch" title="13장. Batch ì²ë¦¬">13장. <i xmlns:xlink="http://www.w3.org/1999/xlink">Batch ì²ë¦¬</i></a>. Keeping a <code class="literal">Session</code> open for the duration of a user session also means a higher probability of stale data. </p></li></ul></div></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-demarcation"/>11.2. 데이터베이스 트랜잭션 경계 설정</h2></div></div></div><p>Database, or system, transaction boundaries are always necessary. No communication with the database can occur outside of a database transaction (this seems to confuse many developers who are used to the auto-commit mode). Always use clear transaction boundaries, even for read-only operations. Depending on your isolation level and database capabilities this might not be required, but there is no downside if you always demarcate transactions explicitly. Certainly, a single database transaction is going to perform better than many small transactions, even for reading data. </p><p>A Hibernate application can run in non-managed (i.e., standalone, simple Web- or Swing applications) and managed J2EE environments. In a non-managed environment, Hibernate is usually responsible for its own database connection pool. The application developer has to manually set transaction boundaries (begin, commit, or rollback database transactions) themselves. A managed environment usually provides container-managed transactions (CMT), with the transaction assembly defined declaratively (in deployment descriptors of EJB session beans, for example). Programmatic transaction demarcation is then no longer necessary. </p><p>However, it is often desirable to keep your persistence layer portable between non-managed resource-local environments, and systems that can rely on JTA but use BMT instead of CMT. In both cases use programmatic transaction demarcation. Hibernate offers a wrapper API called <code class="literal">Transaction</code> that translates into the native transaction system of your deployment environment. This API is actually optional, but we strongly encourage its use unless you are in a CMT session bean. </p><p>Ending a <code class="literal">Session</code> usually involves four distinct phases: </p><div class="itemizedlist"><ul compact="compact"><li><p>세션을 flush 시킨다 </p></li><li><p>트랜잭션을 커밋 시킨다 </p></li><li><p>세션을 닫는다 </p></li><li><p>예외상황들을 처리한다 </p></li></ul></div><p>We discussed Flushing the session earlier, so we will now have a closer look at transaction demarcation and exception handling in both managed and non-managed environments. </p><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-nonmanaged"/>11.2.1. 관리되지 않는 환경</h3></div></div></div><p>If a Hibernate persistence layer runs in a non-managed environment, database connections are usually handled by simple (i.e., non-DataSource) connection pools from which Hibernate obtains connections as needed. The session/transaction handling idiom looks like this: </p><pre class="programlisting">// Non-managed environment idiom
Session sess = factory.openSession();
Transaction tx = null;
try {
    tx = sess.beginTransaction();

    // do some work
    ...

    tx.commit();
}
catch (RuntimeException e) {
    if (tx != null) tx.rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}</pre><p>You do not have to <code class="literal">flush()</code> the <code class="literal">Session</code> explicitly: the call to <code class="literal">commit()</code> automatically triggers the synchronization depending on the <a href="#objectstate-flushing" title="10.10. Session을 flush 시키기">FlushMode</a> for the session. A call to <code class="literal">close()</code> marks the end of a session. The main implication of <code class="literal">close()</code> is that the JDBC connection will be relinquished by the session. This Java code is portable and runs in both non-managed and JTA environments. </p><p>As outlined earlier, a much more flexible solution is Hibernate's built-in "current session" context management: </p><pre class="programlisting">// Non-managed environment idiom with getCurrentSession()
try {
    factory.getCurrentSession().beginTransaction();

    // do some work
    ...

    factory.getCurrentSession().getTransaction().commit();
}
catch (RuntimeException e) {
    factory.getCurrentSession().getTransaction().rollback();
    throw e; // or display error message
}</pre><p>You will not see these code snippets in a regular application; fatal (system) exceptions should always be caught at the "top". In other words, the code that executes Hibernate calls in the persistence layer, and the code that handles <code class="literal">RuntimeException</code> (and usually can only clean up and exit), are in different layers. The current context management by Hibernate can significantly simplify this design by accessing a <code class="literal">SessionFactory</code>. Exception handling is discussed later in this chapter. </p><p>You should select <code class="literal">org.hibernate.transaction.JDBCTransactionFactory</code>, which is the default, and for the second example select <code class="literal">"thread"</code> as your <code class="literal">hibernate.current_session_context_class</code>. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-jta"/>11.2.2. JTA 사용하기</h3></div></div></div><p>If your persistence layer runs in an application server (for example, behind EJB session beans), every datasource connection obtained by Hibernate will automatically be part of the global JTA transaction. You can also install a standalone JTA implementation and use it without EJB. Hibernate offers two strategies for JTA integration. </p><p>If you use bean-managed transactions (BMT), Hibernate will tell the application server to start and end a BMT transaction if you use the <code class="literal">Transaction</code> API. The transaction management code is identical to the non-managed environment. </p><pre class="programlisting">// BMT idiom
Session sess = factory.openSession();
Transaction tx = null;
try {
    tx = sess.beginTransaction();

    // do some work
    ...

    tx.commit();
}
catch (RuntimeException e) {
    if (tx != null) tx.rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}</pre><p>If you want to use a transaction-bound <code class="literal">Session</code>, that is, the <code class="literal">getCurrentSession()</code> functionality for easy context propagation, use the JTA <code class="literal">UserTransaction</code> API directly: </p><pre class="programlisting">// BMT idiom with getCurrentSession()
try {
    UserTransaction tx = (UserTransaction)new InitialContext()
                            .lookup("java:comp/UserTransaction");

    tx.begin();

    // Do some work on Session bound to transaction
    factory.getCurrentSession().load(...);
    factory.getCurrentSession().persist(...);

    tx.commit();
}
catch (RuntimeException e) {
    tx.rollback();
    throw e; // or display error message
}</pre><p>With CMT, transaction demarcation is completed in session bean deployment descriptors, not programmatically. The code is reduced to: </p><pre class="programlisting">// CMT idiom
 Session sess = factory.getCurrentSession();

 // do some work
 ...
</pre><p>In a CMT/EJB, even rollback happens automatically. An unhandled <code class="literal">RuntimeException</code> thrown by a session bean method tells the container to set the global transaction to rollback. <span class="emphasis"><em>You do not need to use the Hibernate <code class="literal">Transaction</code> API at all with BMT or CMT, and you get automatic propagation of the "current" Session bound to the transaction.</em></span> </p><p>When configuring Hibernate's transaction factory, choose <code class="literal">org.hibernate.transaction.JTATransactionFactory</code> if you use JTA directly (BMT), and <code class="literal">org.hibernate.transaction.CMTTransactionFactory</code> in a CMT session bean. Remember to also set <code class="literal">hibernate.transaction.manager_lookup_class</code>. Ensure that your <code class="literal">hibernate.current_session_context_class</code> is either unset (backwards compatibility), or is set to <code class="literal">"jta"</code>. </p><p>The <code class="literal">getCurrentSession()</code> operation has one downside in a JTA environment. There is one caveat to the use of <code class="literal">after_statement</code> connection release mode, which is then used by default. Due to a limitation of the JTA spec, it is not possible for Hibernate to automatically clean up any unclosed <code class="literal">ScrollableResults</code> or <code class="literal">Iterator</code> instances returned by <code class="literal">scroll()</code> or <code class="literal">iterate()</code>. You <span class="emphasis"><em>must</em></span> release the underlying database cursor by calling <code class="literal">ScrollableResults.close()</code> or <code class="literal">Hibernate.close(Iterator)</code> explicitly from a <code class="literal">finally</code> block. Most applications can easily avoid using <code class="literal">scroll()</code> or <code class="literal">iterate()</code> from the JTA or CMT code.) </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-exceptions"/>11.2.3. 예외상황 처리</h3></div></div></div><p>If the <code class="literal">Session</code> throws an exception, including any <code class="literal">SQLException</code>, immediately rollback the database transaction, call <code class="literal">Session.close()</code> and discard the <code class="literal">Session</code> instance. Certain methods of <code class="literal">Session</code> will <span class="emphasis"><em>not</em></span> leave the session in a consistent state. No exception thrown by Hibernate can be treated as recoverable. Ensure that the <code class="literal">Session</code> will be closed by calling <code class="literal">close()</code> in a <code class="literal">finally</code> block. </p><p>The <code class="literal">HibernateException</code>, which wraps most of the errors that can occur in a Hibernate persistence layer, is an unchecked exception. It was not in older versions of Hibernate. In our opinion, we should not force the application developer to catch an unrecoverable exception at a low layer. In most systems, unchecked and fatal exceptions are handled in one of the first frames of the method call stack (i.e., in higher layers) and either an error message is presented to the application user or some other appropriate action is taken. Note that Hibernate might also throw other unchecked exceptions that are not a <code class="literal">HibernateException</code>. These are not recoverable and appropriate action should be taken. </p><p>Hibernate wraps <code class="literal">SQLException</code>s thrown while interacting with the database in a <code class="literal">JDBCException</code>. In fact, Hibernate will attempt to convert the exception into a more meaningful subclass of <code class="literal">JDBCException</code>. The underlying <code class="literal">SQLException</code> is always available via <code class="literal">JDBCException.getCause()</code>. Hibernate converts the <code class="literal">SQLException</code> into an appropriate <code class="literal">JDBCException</code> subclass using the <code class="literal">SQLExceptionConverter</code> attached to the <code class="literal">SessionFactory</code>. By default, the <code class="literal">SQLExceptionConverter</code> is defined by the configured dialect. However, it is also possible to plug in a custom implementation. See the javadocs for the <code class="literal">SQLExceptionConverterFactory</code> class for details. The standard <code class="literal">JDBCException</code> subtypes are: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">JDBCConnectionException</code>: indicates an error with the underlying JDBC communication. </p></li><li><p><code class="literal">SQLGrammarException</code>: indicates a grammar or syntax problem with the issued SQL. </p></li><li><p><code class="literal">ConstraintViolationException</code>: indicates some form of integrity constraint violation. </p></li><li><p><code class="literal">LockAcquisitionException</code>: indicates an error acquiring a lock level necessary to perform the requested operation. </p></li><li><p><code class="literal">GenericJDBCException</code>: a generic exception which did not fall into any of the other categories. </p></li></ul></div></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-timeout"/>11.2.4. 트랜잭션 타임아웃</h3></div></div></div><p>An important feature provided by a managed environment like EJB, that is never provided for non-managed code, is transaction timeout. Transaction timeouts ensure that no misbehaving transaction can indefinitely tie up resources while returning no response to the user. Outside a managed (JTA) environment, Hibernate cannot fully provide this functionality. However, Hibernate can at least control data access operations, ensuring that database level deadlocks and queries with huge result sets are limited by a defined timeout. In a managed environment, Hibernate can delegate transaction timeout to JTA. This functionality is abstracted by the Hibernate <code class="literal">Transaction</code> object. </p><pre class="programlisting">
Session sess = factory.openSession();
try {
    //set transaction timeout to 3 seconds
    sess.getTransaction().setTimeout(3);
    sess.getTransaction().begin();

    // do some work
    ...

    sess.getTransaction().commit()
}
catch (RuntimeException e) {
    sess.getTransaction().rollback();
    throw e; // or display error message
}
finally {
    sess.close();
}</pre><p><code class="literal">setTimeout()</code> cannot be called in a CMT bean, where transaction timeouts must be defined declaratively. </p></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-optimistic"/>11.3. Optimistic 동시성 제어</h2></div></div></div><p>The only approach that is consistent with high concurrency and high scalability, is optimistic concurrency control with versioning. Version checking uses version numbers, or timestamps, to detect conflicting updates and to prevent lost updates. Hibernate provides three possible approaches to writing application code that uses optimistic concurrency. The use cases we discuss are in the context of long conversations, but version checking also has the benefit of preventing lost updates in single database transactions. </p><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-manual"/>11.3.1. 어플리케이션 버전 체킹</h3></div></div></div><p>In an implementation without much help from Hibernate, each interaction with the database occurs in a new <code class="literal">Session</code> and the developer is responsible for reloading all persistent instances from the database before manipulating them. The application is forced to carry out its own version checking to ensure conversation transaction isolation. This approach is the least efficient in terms of database access. It is the approach most similar to entity EJBs. </p><pre class="programlisting">// foo is an instance loaded by a previous Session
session = factory.openSession();
Transaction t = session.beginTransaction();

int oldVersion = foo.getVersion();
session.load( foo, foo.getKey() ); // load the current state
if ( oldVersion != foo.getVersion() ) throw new StaleObjectStateException();
foo.setProperty("bar");

t.commit();
session.close();</pre><p>version 프로퍼티는 <code class="literal">&lt;version&gt;</code>을 사용하여 매핑되고, Hibernate는 만일 엔티티가 dirty일 경우 flush 동안에 그것을 자동적으로 증가시킬 것이다. </p><p>If you are operating in a low-data-concurrency environment, and do not require version checking, you can use this approach and skip the version check. In this case, <span class="emphasis"><em>last commit wins</em></span> is the default strategy for long conversations. Be aware that this might confuse the users of the application, as they might experience lost updates without error messages or a chance to merge conflicting changes. </p><p>Manual version checking is only feasible in trivial circumstances and not practical for most applications. Often not only single instances, but complete graphs of modified objects, have to be checked. Hibernate offers automatic version checking with either an extended <code class="literal">Session</code> or detached instances as the design paradigm. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-longsession"/>11.3.2. 확장된 세션과 자동적인 버전화</h3></div></div></div><p>A single <code class="literal">Session</code> instance and its persistent instances that are used for the whole conversation are known as <span class="emphasis"><em>session-per-conversation</em></span>. Hibernate checks instance versions at flush time, throwing an exception if concurrent modification is detected. It is up to the developer to catch and handle this exception. Common options are the opportunity for the user to merge changes or to restart the business conversation with non-stale data. </p><p>The <code class="literal">Session</code> is disconnected from any underlying JDBC connection when waiting for user interaction. This approach is the most efficient in terms of database access. The application does not version check or reattach detached instances, nor does it have to reload instances in every database transaction. </p><pre class="programlisting">// foo is an instance loaded earlier by the old session
Transaction t = session.beginTransaction(); // Obtain a new JDBC connection, start transaction

foo.setProperty("bar");

session.flush();    // Only for last transaction in conversation
t.commit();         // Also return JDBC connection
session.close();    // Only for last transaction in conversation</pre><p>The <code class="literal">foo</code> object knows which <code class="literal">Session</code> it was loaded in. Beginning a new database transaction on an old session obtains a new connection and resumes the session. Committing a database transaction disconnects a session from the JDBC connection and returns the connection to the pool. After reconnection, to force a version check on data you are not updating, you can call <code class="literal">Session.lock()</code> with <code class="literal">LockMode.READ</code> on any objects that might have been updated by another transaction. You do not need to lock any data that you <span class="emphasis"><em>are</em></span> updating. Usually you would set <code class="literal">FlushMode.MANUAL</code> on an extended <code class="literal">Session</code>, so that only the last database transaction cycle is allowed to actually persist all modifications made in this conversation. Only this last database transaction will include the <code class="literal">flush()</code> operation, and then <code class="literal">close()</code> the session to end the conversation. </p><p>This pattern is problematic if the <code class="literal">Session</code> is too big to be stored during user think time (for example, an <code class="literal">HttpSession</code> should be kept as small as possible). As the <code class="literal">Session</code> is also the first-level cache and contains all loaded objects, we can probably use this strategy only for a few request/response cycles. Use a <code class="literal">Session</code> only for a single conversation as it will soon have stale data. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Earlier versions of Hibernate required explicit disconnection and reconnection of a <code class="literal">Session</code>. These methods are deprecated, as beginning and ending a transaction has the same effect. </p></div><p>Keep the disconnected <code class="literal">Session</code> close to the persistence layer. Use an EJB stateful session bean to hold the <code class="literal">Session</code> in a three-tier environment. Do not transfer it to the web layer, or even serialize it to a separate tier, to store it in the <code class="literal">HttpSession</code>. </p><p>The extended session pattern, or <span class="emphasis"><em>session-per-conversation</em></span>, is more difficult to implement with automatic current session context management. You need to supply your own implementation of the <code class="literal">CurrentSessionContext</code> for this. See the Hibernate Wiki for examples. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-detached"/>11.3.3. Detached 객체들과 자동적인 버전화</h3></div></div></div><p>영속 저장소에 대한 각각의 상호작용은 새로운 <code class="literal">Session</code>에서 일어난다. 하지만 동일한 영속 인스턴스들은 데이터베이스와의 각각의 상호작용에 재사용된다. 어플리케이션은 원래 로드되었던 detached 인스턴스들의 상태를 또 다른 <code class="literal">Session</code> 내에서 처리하고 나서 <code class="literal">Session.update()</code>, <code class="literal">Session.saveOrUpdate()</code>, <code class="literal">Session.merge()</code>를 사용하여 그것들을 다시 첨부시킨다. </p><pre class="programlisting">// foo is an instance loaded by a previous Session
foo.setProperty("bar");
session = factory.openSession();
Transaction t = session.beginTransaction();
session.saveOrUpdate(foo); // Use merge() if "foo" might have been loaded already
t.commit();
session.close();</pre><p>Again, Hibernate will check instance versions during flush, throwing an exception if conflicting updates occurred. </p><p>You can also call <code class="literal">lock()</code> instead of <code class="literal">update()</code>, and use <code class="literal">LockMode.READ</code> (performing a version check and bypassing all caches) if you are sure that the object has not been modified. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-customizing"/>11.3.4. 자동적인 버전화를 맞춤화 시키기</h3></div></div></div><p>You can disable Hibernate's automatic version increment for particular properties and collections by setting the <code class="literal">optimistic-lock</code> mapping attribute to <code class="literal">false</code>. Hibernate will then no longer increment versions if the property is dirty. </p><p>Legacy database schemas are often static and cannot be modified. Or, other applications might access the same database and will not know how to handle version numbers or even timestamps. In both cases, versioning cannot rely on a particular column in a table. To force a version check with a comparison of the state of all fields in a row but without a version or timestamp property mapping, turn on <code class="literal">optimistic-lock="all"</code> in the <code class="literal">&lt;class&gt;</code> mapping. This conceptually only works if Hibernate can compare the old and the new state (i.e., if you use a single long <code class="literal">Session</code> and not session-per-request-with-detached-objects). </p><p>Concurrent modification can be permitted in instances where the changes that have been made do not overlap. If you set <code class="literal">optimistic-lock="dirty"</code> when mapping the <code class="literal">&lt;class&gt;</code>, Hibernate will only compare dirty fields during flush. </p><p>In both cases, with dedicated version/timestamp columns or with a full/dirty field comparison, Hibernate uses a single <code class="literal">UPDATE</code> statement, with an appropriate <code class="literal">WHERE</code> clause, per entity to execute the version check and update the information. If you use transitive persistence to cascade reattachment to associated entities, Hibernate may execute unnecessary updates. This is usually not a problem, but <span class="emphasis"><em>on update</em></span> triggers in the database might be executed even when no changes have been made to detached instances. You can customize this behavior by setting <code class="literal">select-before-update="true"</code> in the <code class="literal">&lt;class&gt;</code> mapping, forcing Hibernate to <code class="literal">SELECT</code> the instance to ensure that changes did occur before updating the row. </p></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-locking"/>11.4. Pessimistic locking</h2></div></div></div><p>It is not intended that users spend much time worrying about locking strategies. It is usually enough to specify an isolation level for the JDBC connections and then simply let the database do all the work. However, advanced users may wish to obtain exclusive pessimistic locks or re-obtain locks at the start of a new transaction. </p><p>Hibernate will always use the locking mechanism of the database; it never lock objects in memory. </p><p>The <code class="literal">LockMode</code> class defines the different lock levels that can be acquired by Hibernate. A lock is obtained by the following mechanisms: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">LockMode.WRITE</code>는 Hibernate가 한 행을 업데이트 하거나 insert 할 때 자동적으로 획득된다. </p></li><li><p><code class="literal">LockMode.UPGRADE</code> can be acquired upon explicit user request using <code class="literal">SELECT ... FOR UPDATE</code> on databases which support that syntax. </p></li><li><p><code class="literal">LockMode.UPGRADE_NOWAIT</code> can be acquired upon explicit user request using a <code class="literal">SELECT ... FOR UPDATE NOWAIT</code> under Oracle. </p></li><li><p><code class="literal">LockMode.READ</code> is acquired automatically when Hibernate reads data under Repeatable Read or Serializable isolation level. It can be re-acquired by explicit user request. </p></li><li><p><code class="literal">LockMode.NONE</code>은 잠금이 없음을 나타낸다. 모든 객체들은 <code class="literal">Transaction</code>의 끝에서 이 잠금 모드로 전환된다. <code class="literal">update()</code> 또는 <code class="literal">saveOrUpdate()</code>에 대한 호출을 통해 세션과 연관된 객체들이 또한 이 잠금 모드로 시작된다. </p></li></ul></div><p>"명시적인 사용자 요청"은 다음 방법들 중 하나로 표현된다: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">LockMode</code>를 지정한 <code class="literal">Session.load()</code>에 대한 호출. </p></li><li><p><code class="literal">Session.lock()</code>에 대한 호출. </p></li><li><p><code class="literal">Query.setLockMode()</code>에 대한 호출. </p></li></ul></div><p>만일 <code class="literal">Session.load()</code>가 <code class="literal">UPGRADE</code> 또는 <code class="literal">UPGRADE_NOWAIT</code> 모드로 호출되고 ,요청된 객체가 아직 이 세션에 의해 로드되지 않았다면, 그 객체는 <code class="literal">SELECT ... FOR UPDATE</code>를 사용하여 로드된다. 만일 요청된 것이 아닌 다소 제한적인 잠금으로 이미 로드되어 있는 객체에 대해 <code class="literal">load()</code>가 호출될 경우, Hibernate는 그 객체에 대해 <code class="literal">lock()</code>을 호출한다. </p><p><code class="literal">Session.lock()</code> performs a version number check if the specified lock mode is <code class="literal">READ</code>, <code class="literal">UPGRADE</code> or <code class="literal">UPGRADE_NOWAIT</code>. In the case of <code class="literal">UPGRADE</code> or <code class="literal">UPGRADE_NOWAIT</code>, <code class="literal">SELECT ... FOR UPDATE</code> is used. </p><p>If the requested lock mode is not supported by the database, Hibernate uses an appropriate alternate mode instead of throwing an exception. This ensures that applications are portable. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-connection-release"/>11.5. Connection release modes</h2></div></div></div><p>One of the legacies of Hibernate 2.x JDBC connection management meant that a <code class="literal">Session</code> would obtain a connection when it was first required and then maintain that connection until the session was closed. Hibernate 3.x introduced the notion of connection release modes that would instruct a session how to handle its JDBC connections. The following discussion is pertinent only to connections provided through a configured <code class="literal">ConnectionProvider</code>. User-supplied connections are outside the breadth of this discussion. The different release modes are identified by the enumerated values of <code class="literal">org.hibernate.ConnectionReleaseMode</code>: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">ON_CLOSE</code>: is the legacy behavior described above. The Hibernate session obtains a connection when it first needs to perform some JDBC access and maintains that connection until the session is closed. </p></li><li><p><code class="literal">AFTER_TRANSACTION</code>: releases connections after a <code class="literal">org.hibernate.Transaction</code> has been completed. </p></li><li><p><code class="literal">AFTER_STATEMENT</code> (also referred to as aggressive release): releases connections after every statement execution. This aggressive releasing is skipped if that statement leaves open resources associated with the given session. Currently the only situation where this occurs is through the use of <code class="literal">org.hibernate.ScrollableResults</code>. </p></li></ul></div><p>The configuration parameter <code class="literal">hibernate.connection.release_mode</code> is used to specify which release mode to use. The possible values are as follows: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">auto</code> (the default): this choice delegates to the release mode returned by the <code class="literal">org.hibernate.transaction.TransactionFactory.getDefaultReleaseMode()</code> method. For JTATransactionFactory, this returns ConnectionReleaseMode.AFTER_STATEMENT; for JDBCTransactionFactory, this returns ConnectionReleaseMode.AFTER_TRANSACTION. Do not change this default behavior as failures due to the value of this setting tend to indicate bugs and/or invalid assumptions in user code. </p></li><li><p><code class="literal">on_close</code>: uses ConnectionReleaseMode.ON_CLOSE. This setting is left for backwards compatibility, but its use is discouraged. </p></li><li><p><code class="literal">after_transaction</code>: uses ConnectionReleaseMode.AFTER_TRANSACTION. This setting should not be used in JTA environments. Also note that with ConnectionReleaseMode.AFTER_TRANSACTION, if a session is considered to be in auto-commit mode, connections will be released as if the release mode were AFTER_STATEMENT. </p></li><li><p><code class="literal">after_statement</code>: uses ConnectionReleaseMode.AFTER_STATEMENT. Additionally, the configured <code class="literal">ConnectionProvider</code> is consulted to see if it supports this setting (<code class="literal">supportsAggressiveRelease()</code>). If not, the release mode is reset to ConnectionReleaseMode.AFTER_TRANSACTION. This setting is only safe in environments where we can either re-acquire the same underlying JDBC connection each time you make a call into <code class="literal">ConnectionProvider.getConnection()</code> or in auto-commit environments where it does not matter if we re-establish the same connection. </p></li></ul></div></div></div><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="events"/>12장. 인터셉터들과 이벤트들</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#objectstate-interceptors">12.1. 인터셉터들</a></span></dt><dt><span class="sect1"><a href="#objectstate-events">12.2. 이벤트 시스템</a></span></dt><dt><span class="sect1"><a href="#objectstate-decl-security">12.3. Hibernate 선언적인 보안</a></span></dt></dl></div><p>It is useful for the application to react to certain events that occur inside Hibernate. This allows for the implementation of generic functionality and the extension of Hibernate functionality. </p><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-interceptors"/>12.1. 인터셉터들</h2></div></div></div><p>The <code class="literal">Interceptor</code> interface provides callbacks from the session to the application, allowing the application to inspect and/or manipulate properties of a persistent object before it is saved, updated, deleted or loaded. One possible use for this is to track auditing information. For example, the following <code class="literal">Interceptor</code> automatically sets the <code class="literal">createTimestamp</code> when an <code class="literal">Auditable</code> is created and updates the <code class="literal">lastUpdateTimestamp</code> property when an <code class="literal">Auditable</code> is updated. </p><p>You can either implement <code class="literal">Interceptor</code> directly or extend <code class="literal">EmptyInterceptor</code>. </p><pre class="programlisting">package org.hibernate.test;

import java.io.Serializable;
import java.util.Date;
import java.util.Iterator;

import org.hibernate.EmptyInterceptor;
import org.hibernate.Transaction;
import org.hibernate.type.Type;

public class AuditInterceptor extends EmptyInterceptor {

    private int updates;
    private int creates;
    private int loads;

    public void onDelete(Object entity,
                         Serializable id,
                         Object[] state,
                         String[] propertyNames,
                         Type[] types) {
        // do nothing
    }

    public boolean onFlushDirty(Object entity,
                                Serializable id,
                                Object[] currentState,
                                Object[] previousState,
                                String[] propertyNames,
                                Type[] types) {

        if ( entity instanceof Auditable ) {
            updates++;
            for ( int i=0; i &lt; propertyNames.length; i++ ) {
                if ( "lastUpdateTimestamp".equals( propertyNames[i] ) ) {
                    currentState[i] = new Date();
                    return true;
                }
            }
        }
        return false;
    }

    public boolean onLoad(Object entity,
                          Serializable id,
                          Object[] state,
                          String[] propertyNames,
                          Type[] types) {
        if ( entity instanceof Auditable ) {
            loads++;
        }
        return false;
    }

    public boolean onSave(Object entity,
                          Serializable id,
                          Object[] state,
                          String[] propertyNames,
                          Type[] types) {

        if ( entity instanceof Auditable ) {
            creates++;
            for ( int i=0; i&lt;propertyNames.length; i++ ) {
                if ( "createTimestamp".equals( propertyNames[i] ) ) {
                    state[i] = new Date();
                    return true;
                }
            }
        }
        return false;
    }

    public void afterTransactionCompletion(Transaction tx) {
        if ( tx.wasCommitted() ) {
            System.out.println("Creations: " + creates + ", Updates: " + updates, "Loads: " + loads);
        }
        updates=0;
        creates=0;
        loads=0;
    }

}</pre><p>There are two kinds of inteceptors: <code class="literal">Session</code>-scoped and <code class="literal">SessionFactory</code>-scoped. </p><p><code class="literal">Session</code>-영역의 인터셉터는 세션이 하나의 <code class="literal">Interceptor</code>를 수용하는 오버로드된 SessionFactory.openSession() 메소드들 중 하나를 사용하여 열릴 때 지정된다. </p><pre class="programlisting">Session session = sf.openSession( new AuditInterceptor() );</pre><p>A <code class="literal">SessionFactory</code>-scoped interceptor is registered with the <code class="literal">Configuration</code> object prior to building the <code class="literal">SessionFactory</code>. Unless a session is opened explicitly specifying the interceptor to use, the supplied interceptor will be applied to all sessions opened from that <code class="literal">SessionFactory</code>. <code class="literal">SessionFactory</code>-scoped interceptors must be thread safe. Ensure that you do not store session-specific states, since multiple sessions will use this interceptor potentially concurrently. </p><pre class="programlisting">new Configuration().setInterceptor( new AuditInterceptor() );</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-events"/>12.2. 이벤트 시스템</h2></div></div></div><p>If you have to react to particular events in your persistence layer, you can also use the Hibernate3 <span class="emphasis"><em>event</em></span> architecture. The event system can be used in addition, or as a replacement, for interceptors. </p><p>All the methods of the <code class="literal">Session</code> interface correlate to an event. You have a <code class="literal">LoadEvent</code>, a <code class="literal">FlushEvent</code>, etc. Consult the XML configuration-file DTD or the <code class="literal">org.hibernate.event</code> package for the full list of defined event types. When a request is made of one of these methods, the Hibernate <code class="literal">Session</code> generates an appropriate event and passes it to the configured event listeners for that type. Out-of-the-box, these listeners implement the same processing in which those methods always resulted. However, you are free to implement a customization of one of the listener interfaces (i.e., the <code class="literal">LoadEvent</code> is processed by the registered implementation of the <code class="literal">LoadEventListener</code> interface), in which case their implementation would be responsible for processing any <code class="literal">load()</code> requests made of the <code class="literal">Session</code>. </p><p>The listeners should be considered singletons. This means they are shared between requests, and should not save any state as instance variables. </p><p>A custom listener implements the appropriate interface for the event it wants to process and/or extend one of the convenience base classes (or even the default event listeners used by Hibernate out-of-the-box as these are declared non-final for this purpose). Custom listeners can either be registered programmatically through the <code class="literal">Configuration</code> object, or specified in the Hibernate configuration XML. Declarative configuration through the properties file is not supported. Here is an example of a custom load event listener: </p><pre class="programlisting">public class MyLoadListener implements LoadEventListener {
    // this is the single method defined by the LoadEventListener interface
    public void onLoad(LoadEvent event, LoadEventListener.LoadType loadType)
            throws HibernateException {
        if ( !MySecurity.isAuthorized( event.getEntityClassName(), event.getEntityId() ) ) {
            throw MySecurityException("Unauthorized access");
        }
    }
}</pre><p>당신은 또한 디폴트 리스너에 덧붙여 그 리스너를 사용하도록 Hibernate에게 알려주는 구성 엔트리를 필요로 한다: </p><pre class="programlisting">&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
        ...
        &lt;event type="load"&gt;
            &lt;listener class="com.eg.MyLoadListener"/&gt;
            &lt;listener class="org.hibernate.event.def.DefaultLoadEventListener"/&gt;
        &lt;/event&gt;
    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;</pre><p>Instead, you can register it programmatically: </p><pre class="programlisting">Configuration cfg = new Configuration();
LoadEventListener[] stack = { new MyLoadListener(), new DefaultLoadEventListener() };
cfg.EventListeners().setLoadEventListeners(stack);</pre><p>Listeners registered declaratively cannot share instances. If the same class name is used in multiple <code class="literal">&lt;listener/&gt;</code> elements, each reference will result in a separate instance of that class. If you need to share listener instances between listener types you must use the programmatic registration approach. </p><p>Why implement an interface and define the specific type during configuration? A listener implementation could implement multiple event listener interfaces. Having the type additionally defined during registration makes it easier to turn custom listeners on or off during configuration. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-decl-security"/>12.3. Hibernate 선언적인 보안</h2></div></div></div><p>Usually, declarative security in Hibernate applications is managed in a session facade layer. Hibernate3 allows certain actions to be permissioned via JACC, and authorized via JAAS. This is an optional functionality that is built on top of the event architecture. </p><p>먼저, 당신은 JAAS authorization 사용을 이용 가능하도록 하기 위해 적절한 이벤트 리스터들을 구성해야 한다. </p><pre class="programlisting">&lt;listener type="pre-delete" class="org.hibernate.secure.JACCPreDeleteEventListener"/&gt;
&lt;listener type="pre-update" class="org.hibernate.secure.JACCPreUpdateEventListener"/&gt;
&lt;listener type="pre-insert" class="org.hibernate.secure.JACCPreInsertEventListener"/&gt;
&lt;listener type="pre-load" class="org.hibernate.secure.JACCPreLoadEventListener"/&gt;</pre><p>Note that <code class="literal">&lt;listener type="..." class="..."/&gt;</code> is shorthand for <code class="literal">&lt;event type="..."&gt;&lt;listener class="..."/&gt;&lt;/event&gt;</code> when there is exactly one listener for a particular event type. </p><p>Next, while still in <code class="literal">hibernate.cfg.xml</code>, bind the permissions to roles: </p><pre class="programlisting">&lt;grant role="admin" entity-name="User" actions="insert,update,read"/&gt;
&lt;grant role="su" entity-name="User" actions="*"/&gt;</pre><p>역할(role) 이름들은 당신의 JACC 프로바이더에 의해 인지된 역할(role)들이다. </p></div></div><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="batch"/>13장. Batch ì²ë¦¬</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#batch-inserts">13.1. Batch inserts</a></span></dt><dt><span class="sect1"><a href="#batch-update">13.2. Batch updates</a></span></dt><dt><span class="sect1"><a href="#batch-statelesssession">13.3. StatelessSession ì¸í°íì´ì¤</a></span></dt><dt><span class="sect1"><a href="#batch-direct">13.4. DML-ì¤íì¼ ì°ì°ë¤</a></span></dt></dl></div><p>A naive approach to inserting 100,000 rows in the database using Hibernate might look like this: </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
for ( int i=0; i&lt;100000; i++ ) {
    Customer customer = new Customer(.....);
    session.save(customer);
}
tx.commit();
session.close();</pre><p>This would fall over with an <code class="literal">OutOfMemoryException</code> somewhere around the 50,000th row. That is because Hibernate caches all the newly inserted <code class="literal">Customer</code> instances in the session-level cache. In this chapter we will show you how to avoid this problem. </p><p>If you are undertaking batch processing you will need to enable the use of JDBC batching. This is absolutely essential if you want to achieve optimal performance. Set the JDBC batch size to a reasonable number (10-50, for example): </p><pre class="programlisting">hibernate.jdbc.batch_size 20</pre><p><a id="disablebatching"/>Hibernate disables insert batching at the JDBC level transparently if you use an <code class="literal">identity</code> identifier generator. </p><p>You can also do this kind of work in a process where interaction with the second-level cache is completely disabled: </p><pre class="programlisting">hibernate.cache.use_second_level_cache false</pre><p>íì§ë§ ì´ê²ì ì ëì ì¼ë¡ íìíì§ ìë¤. ìëíë©´ ì°ë¦¬ë second-level ìºììì ìí¸ìì©ì ë¶ê°ë¥íëë¡ íê¸° ìí´ ëªìì ì¼ë¡ <code class="literal">CacheMode</code>ë¥¼ ì¤ì í  ì ìê¸° ëë¬¸ì´ë¤. </p><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="batch-inserts"/>13.1. Batch inserts</h2></div></div></div><p>When making new objects persistent <code class="literal">flush()</code> and then <code class="literal">clear()</code> the session regularly in order to control the size of the first-level cache. </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
   
for ( int i=0; i&lt;100000; i++ ) {
    Customer customer = new Customer(.....);
    session.save(customer);
    if ( i % 20 == 0 ) { //20, same as the JDBC batch size
        //flush a batch of inserts and release memory:
        session.flush();
        session.clear();
    }
}
   
tx.commit();
session.close();</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="batch-update"/>13.2. Batch updates</h2></div></div></div><p>For retrieving and updating data, the same ideas apply. In addition, you need to use <code class="literal">scroll()</code> to take advantage of server-side cursors for queries that return many rows of data. </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
   
ScrollableResults customers = session.getNamedQuery("GetCustomers")
    .setCacheMode(CacheMode.IGNORE)
    .scroll(ScrollMode.FORWARD_ONLY);
int count=0;
while ( customers.next() ) {
    Customer customer = (Customer) customers.get(0);
    customer.updateStuff(...);
    if ( ++count % 20 == 0 ) {
        //flush a batch of updates and release memory:
        session.flush();
        session.clear();
    }
}
   
tx.commit();
session.close();</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="batch-statelesssession"/>13.3. StatelessSession ì¸í°íì´ì¤</h2></div></div></div><p>Alternatively, Hibernate provides a command-oriented API that can be used for streaming data to and from the database in the form of detached objects. A <code class="literal">StatelessSession</code> has no persistence context associated with it and does not provide many of the higher-level life cycle semantics. In particular, a stateless session does not implement a first-level cache nor interact with any second-level or query cache. It does not implement transactional write-behind or automatic dirty checking. Operations performed using a stateless session never cascade to associated instances. Collections are ignored by a stateless session. Operations performed via a stateless session bypass Hibernate's event model and interceptors. Due to the lack of a first-level cache, Stateless sessions are vulnerable to data aliasing effects. A stateless session is a lower-level abstraction that is much closer to the underlying JDBC. </p><pre class="programlisting">StatelessSession session = sessionFactory.openStatelessSession();
Transaction tx = session.beginTransaction();
   
ScrollableResults customers = session.getNamedQuery("GetCustomers")
    .scroll(ScrollMode.FORWARD_ONLY);
while ( customers.next() ) {
    Customer customer = (Customer) customers.get(0);
    customer.updateStuff(...);
    session.update(customer);
}
   
tx.commit();
session.close();</pre><p>In this code example, the <code class="literal">Customer</code> instances returned by the query are immediately detached. They are never associated with any persistence context. </p><p>The <code class="literal">insert(), update()</code> and <code class="literal">delete()</code> operations defined by the <code class="literal">StatelessSession</code> interface are considered to be direct database row-level operations. They result in the immediate execution of a SQL <code class="literal">INSERT, UPDATE</code> or <code class="literal">DELETE</code> respectively. They have different semantics to the <code class="literal">save(), saveOrUpdate()</code> and <code class="literal">delete()</code> operations defined by the <code class="literal">Session</code> interface. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="batch-direct"/>13.4. DML-ì¤íì¼ ì°ì°ë¤</h2></div></div></div><p>As already discussed, automatic and transparent object/relational mapping is concerned with the management of the object state. The object state is available in memory. This means that manipulating data directly in the database (using the SQL <code class="literal">Data Manipulation Language</code> (DML) the statements: <code class="literal">INSERT</code>, <code class="literal">UPDATE</code>, <code class="literal">DELETE</code>) will not affect in-memory state. However, Hibernate provides methods for bulk SQL-style DML statement execution that is performed through the Hibernate Query Language (<a href="#queryhql" title="14장. HQL: 하이버네이트 질의 언어(Hibernate Query Language)">HQL</a>). </p><p>The pseudo-syntax for <code class="literal">UPDATE</code> and <code class="literal">DELETE</code> statements is: <code class="literal">( UPDATE | DELETE ) FROM? EntityName (WHERE where_conditions)?</code>. </p><p>Some points to note: </p><div class="itemizedlist"><ul compact="compact"><li><p>from-ì ìì, FROM í¤ìëë ìµìì´ë¤ </p></li><li><p>There can only be a single entity named in the from-clause. It can, however, be aliased. If the entity name is aliased, then any property references must be qualified using that alias. If the entity name is not aliased, then it is illegal for any property references to be qualified. </p></li><li><p>No <a href="#queryhql-joins-forms" title="14.4. join 구문의 형식들">joins</a>, either implicit or explicit, can be specified in a bulk HQL query. Sub-queries can be used in the where-clause, where the subqueries themselves may contain joins. </p></li><li><p>where-ì  ëí ìµìì´ë¤. </p></li></ul></div><p>As an example, to execute an HQL <code class="literal">UPDATE</code>, use the <code class="literal">Query.executeUpdate()</code> method. The method is named for those familiar with JDBC's <code class="literal">PreparedStatement.executeUpdate()</code>: </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

String hqlUpdate = "update Customer c set c.name = :newName where c.name = :oldName";
// or String hqlUpdate = "update Customer set name = :newName where name = :oldName";
int updatedEntities = s.createQuery( hqlUpdate )
        .setString( "newName", newName )
        .setString( "oldName", oldName )
        .executeUpdate();
tx.commit();
session.close();</pre><p>In keeping with the EJB3 specification, HQL <code class="literal">UPDATE</code> statements, by default, do not effect the <a href="#mapping-declaration-version" title="5.1.9. Version (optional)">version</a> or the <a href="#mapping-declaration-timestamp" title="5.1.10. Timestamp (optional)">timestamp</a> property values for the affected entities. However, you can force Hibernate to reset the <code class="literal">version</code> or <code class="literal">timestamp</code> property values through the use of a <code class="literal">versioned update</code>. This is achieved by adding the <code class="literal">VERSIONED</code> keyword after the <code class="literal">UPDATE</code> keyword. </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
String hqlVersionedUpdate = "update versioned Customer set name = :newName where name = :oldName";
int updatedEntities = s.createQuery( hqlUpdate )
        .setString( "newName", newName )
        .setString( "oldName", oldName )
        .executeUpdate();
tx.commit();
session.close();</pre><p>Custom version types, <code class="literal">org.hibernate.usertype.UserVersionType</code>, are not allowed in conjunction with a <code class="literal">update versioned</code> statement. </p><p>HQL <code class="literal">DELETE</code>ë¥¼ ì¤ííë ¤ë©´, ê°ì ë©ìë <code class="literal">Query.executeUpdate()</code>ë¥¼ ì¬ì©íë¼: </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

String hqlDelete = "delete Customer c where c.name = :oldName";
// or String hqlDelete = "delete Customer where name = :oldName";
int deletedEntities = s.createQuery( hqlDelete )
        .setString( "oldName", oldName )
        .executeUpdate();
tx.commit();
session.close();</pre><p>The <code class="literal">int</code> value returned by the <code class="literal">Query.executeUpdate()</code> method indicates the number of entities effected by the operation. This may or may not correlate to the number of rows effected in the database. An HQL bulk operation might result in multiple actual SQL statements being executed (for joined-subclass, for example). The returned number indicates the number of actual entities affected by the statement. Going back to the example of joined-subclass, a delete against one of the subclasses may actually result in deletes against not just the table to which that subclass is mapped, but also the "root" table and potentially joined-subclass tables further down the inheritance hierarchy. </p><p>ì¥ëì ë°°í¬ë³¸ë¤ìì ì ë¬ë  ëë HQL ì¤í¼ë ì´ìë¤ì ëí ëª ê°ì§ ì íë¤ì´ íì¬ ì¡´ì¬í¨ì ë¸í¸íë¼; ìì¸í ê²ì JIRA ë¡ëë§µì ì°¸ì¡°íë¼. <code class="literal">INSERT</code> ë¬¸ì¥ë¤ì ìí ì ì¬-êµ¬ë¬¸ì ë¤ìê³¼ ê°ë¤: <code class="literal">INSERT INTO EntityName properties_list select_statement</code>. ë¸í¸í  ëª ê°ì§: </p><div class="itemizedlist"><ul compact="compact"><li><p>ì¤ì§ INSERT INTO ... SELECT ... íì ë§ì¼ ì§ìëë¤; INSERT INTO ... VALUES ... íìì ì§ìëì§ ìëë¤. </p><p>The properties_list is analogous to the <code class="literal">column specification</code> in the SQL <code class="literal">INSERT</code> statement. For entities involved in mapped inheritance, only properties directly defined on that given class-level can be used in the properties_list. Superclass properties are not allowed and subclass properties do not make sense. In other words, <code class="literal">INSERT</code> statements are inherently non-polymorphic. </p></li><li><p>select_statement can be any valid HQL select query, with the caveat that the return types must match the types expected by the insert. Currently, this is checked during query compilation rather than allowing the check to relegate to the database. This might, however, cause problems between Hibernate <code class="literal">Type</code>s which are <span class="emphasis"><em>equivalent</em></span> as opposed to <span class="emphasis"><em>equal</em></span>. This might cause issues with mismatches between a property defined as a <code class="literal">org.hibernate.type.DateType</code> and a property defined as a <code class="literal">org.hibernate.type.TimestampType</code>, even though the database might not make a distinction or might be able to handle the conversion. </p></li><li><p>For the id property, the insert statement gives you two options. You can either explicitly specify the id property in the properties_list, in which case its value is taken from the corresponding select expression, or omit it from the properties_list, in which case a generated value is used. This latter option is only available when using id generators that operate in the database; attempting to use this option with any "in memory" type generators will cause an exception during parsing. For the purposes of this discussion, in-database generators are considered to be <code class="literal">org.hibernate.id.SequenceGenerator</code> (and its subclasses) and any implementers of <code class="literal">org.hibernate.id.PostInsertIdentifierGenerator</code>. The most notable exception here is <code class="literal">org.hibernate.id.TableHiLoGenerator</code>, which cannot be used because it does not expose a selectable way to get its values. </p></li><li><p>For properties mapped as either <code class="literal">version</code> or <code class="literal">timestamp</code>, the insert statement gives you two options. You can either specify the property in the properties_list, in which case its value is taken from the corresponding select expressions, or omit it from the properties_list, in which case the <code class="literal">seed value</code> defined by the <code class="literal">org.hibernate.type.VersionType</code> is used. </p></li></ul></div><p>The following is an example of an HQL <code class="literal">INSERT</code> statement execution: </p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

String hqlInsert = "insert into DelinquentAccount (id, name) select c.id, c.name from Customer c where ...";
int createdEntities = s.createQuery( hqlInsert )
        .executeUpdate();
tx.commit();
session.close();</pre></div></div><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql"/>14장. HQL: 하이버네이트 질의 언어(Hibernate Query Language)</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#queryhql-casesensitivity">14.1. 대소문자 구분</a></span></dt><dt><span class="sect1"><a href="#queryhql-from">14.2. from 절</a></span></dt><dt><span class="sect1"><a href="#queryhql-joins">14.3. 연관들과 조인들</a></span></dt><dt><span class="sect1"><a href="#queryhql-joins-forms">14.4. join 구문의 형식들</a></span></dt><dt><span class="sect1"><a href="#queryhql-identifier-property">14.5. Referring to identifier property</a></span></dt><dt><span class="sect1"><a href="#queryhql-select">14.6. select 절</a></span></dt><dt><span class="sect1"><a href="#queryhql-aggregation">14.7. 집계 함수들</a></span></dt><dt><span class="sect1"><a href="#queryhql-polymorphism">14.8. Polymorphic(다형성) 질의들</a></span></dt><dt><span class="sect1"><a href="#queryhql-where">14.9. where 절</a></span></dt><dt><span class="sect1"><a href="#queryhql-expressions">14.10. 표현식들</a></span></dt><dt><span class="sect1"><a href="#queryhql-ordering">14.11. order by 절</a></span></dt><dt><span class="sect1"><a href="#queryhql-grouping">14.12. group by 절</a></span></dt><dt><span class="sect1"><a href="#queryhql-subqueries">14.13. 서브질의들</a></span></dt><dt><span class="sect1"><a href="#queryhql-examples">14.14. HQL 예제들</a></span></dt><dt><span class="sect1"><a href="#queryhql-bulk">14.15. 대량 update와 delete</a></span></dt><dt><span class="sect1"><a href="#queryhql-tipstricks">14.16. 팁들 &amp; 트릭들</a></span></dt><dt><span class="sect1"><a href="#queryhql-components">14.17. 컴포넌트들</a></span></dt><dt><span class="sect1"><a href="#queryhql-tuple">14.18. Row value constructor 구문</a></span></dt></dl></div><p>Hibernate uses a powerful query language (HQL) that is similar in appearance to SQL. Compared with SQL, however, HQL is fully object-oriented and understands notions like inheritance, polymorphism and association. </p><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-casesensitivity"/>14.1. 대소문자 구분</h2></div></div></div><p>With the exception of names of Java classes and properties, queries are case-insensitive. So <code class="literal">SeLeCT</code> is the same as <code class="literal">sELEct</code> is the same as <code class="literal">SELECT</code>, but <code class="literal">org.hibernate.eg.FOO</code> is not <code class="literal">org.hibernate.eg.Foo</code>, and <code class="literal">foo.barSet</code> is not <code class="literal">foo.BARSET</code>. </p><p>This manual uses lowercase HQL keywords. Some users find queries with uppercase keywords more readable, but this convention is unsuitable for queries embedded in Java code. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-from"/>14.2. from 절</h2></div></div></div><p>가장 간단한 가능한 Hibernate 질의는 다음 형식이다: </p><pre class="programlisting">from eg.Cat</pre><p>This returns all instances of the class <code class="literal">eg.Cat</code>. You do not usually need to qualify the class name, since <code class="literal">auto-import</code> is the default. For example: </p><pre class="programlisting">from Cat</pre><p>In order to refer to the <code class="literal">Cat</code> in other parts of the query, you will need to assign an <span class="emphasis"><em>alias</em></span>. For example: </p><pre class="programlisting">from Cat as cat</pre><p>This query assigns the alias <code class="literal">cat</code> to <code class="literal">Cat</code> instances, so you can use that alias later in the query. The <code class="literal">as</code> keyword is optional. You could also write: </p><pre class="programlisting">from Cat cat</pre><p>Multiple classes can appear, resulting in a cartesian product or "cross" join. </p><pre class="programlisting">from Formula, Parameter</pre><pre class="programlisting">from Formula as form, Parameter as param</pre><p>It is good practice to name query aliases using an initial lowercase as this is consistent with Java naming standards for local variables (e.g. <code class="literal">domesticCat</code>). </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-joins"/>14.3. 연관들과 조인들</h2></div></div></div><p>You can also assign aliases to associated entities or to elements of a collection of values using a <code class="literal">join</code>. For example: </p><pre class="programlisting">from Cat as cat
    inner join cat.mate as mate
    left outer join cat.kittens as kitten</pre><pre class="programlisting">from Cat as cat left join cat.mate.kittens as kittens</pre><pre class="programlisting">from Formula form full join form.parameter param</pre><p>The supported join types are borrowed from ANSI SQL: </p><div class="itemizedlist"><ul compact="compact"><li><p>
                    <code class="literal">inner join</code>
                </p></li><li><p>
                    <code class="literal">left outer join</code>
                </p></li><li><p>
                    <code class="literal">right outer join</code>
                </p></li><li><p><code class="literal">full join</code> (대개 유용하지 않음) </p></li></ul></div><p><code class="literal">inner join</code>, <code class="literal">left outer join</code>, 그리고 <code class="literal">right outer join</code> 구조체들이 약칭될 수 있다. </p><pre class="programlisting">from Cat as cat
    join cat.mate as mate
    left join cat.kittens as kitten</pre><p>당신은 HQL <code class="literal">with</code> 키워드를 사용하여 특별한 조인 조건들을 제공할 수 있다. </p><pre class="programlisting">from Cat as cat
    left join cat.kittens as kitten
        with kitten.bodyWeight &gt; 10.0</pre><p>A "fetch" join allows associations or collections of values to be initialized along with their parent objects using a single select. This is particularly useful in the case of a collection. It effectively overrides the outer join and lazy declarations of the mapping file for associations and collections. See <a href="#performance-fetching" title="19.1. 페칭 방도들">19.1절. “페칭 방도들”</a> for more information. </p><pre class="programlisting">from Cat as cat
    inner join fetch cat.mate
    left join fetch cat.kittens</pre><p>A fetch join does not usually need to assign an alias, because the associated objects should not be used in the <code class="literal">where</code> clause (or any other clause). The associated objects are also not returned directly in the query results. Instead, they may be accessed via the parent object. The only reason you might need an alias is if you are recursively join fetching a further collection: </p><pre class="programlisting">from Cat as cat
    inner join fetch cat.mate
    left join fetch cat.kittens child
    left join fetch child.kittens</pre><p>The <code class="literal">fetch</code> construct cannot be used in queries called using <code class="literal">iterate()</code> (though <code class="literal">scroll()</code> can be used). <code class="literal">Fetch</code> should be used together with <code class="literal">setMaxResults()</code> or <code class="literal">setFirstResult()</code>, as these operations are based on the result rows which usually contain duplicates for eager collection fetching, hence, the number of rows is not what you would expect. <code class="literal">Fetch</code> should also not be used together with impromptu <code class="literal">with</code> condition. It is possible to create a cartesian product by join fetching more than one collection in a query, so take care in this case. Join fetching multiple collection roles can produce unexpected results for bag mappings, so user discretion is advised when formulating queries in this case. Finally, note that <code class="literal">full join fetch</code> and <code class="literal">right join fetch</code> are not meaningful. </p><p>If you are using property-level lazy fetching (with bytecode instrumentation), it is possible to force Hibernate to fetch the lazy properties in the first query immediately using <code class="literal">fetch all properties</code>. </p><pre class="programlisting">from Document fetch all properties order by name</pre><pre class="programlisting">from Document doc fetch all properties where lower(doc.name) like '%cats%'</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-joins-forms"/>14.4. join 구문의 형식들</h2></div></div></div><p>HQL은 두 가지 형식의 연관 조인을 지원한다: <code class="literal">암묵적</code> 그리고 <code class="literal">명시적</code>. </p><p>The queries shown in the previous section all use the <code class="literal">explicit</code> form, that is, where the join keyword is explicitly used in the from clause. This is the recommended form. </p><p><code class="literal">함축적인</code> 형식은 join 키워드를 사용하지 않는다. 대신에, 연관들은 dot(.) 표기를 사용하여 "dot-참조된다(dereferenced)". <code class="literal">함축적인</code> 조인들은 임의의 HQL 절들내에 나타날 수 있다. <code class="literal">함축적인</code> join은 결과되는 SQL 문장에서 inner join으로 귀결된다. </p><pre class="programlisting">from Cat as cat where cat.mate.name like '%s%'</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-identifier-property"/>14.5. Referring to identifier property</h2></div></div></div><p>There are 2 ways to refer to an entity's identifier property: </p><div class="itemizedlist"><ul compact="compact"><li><p>The special property (lowercase) <code class="literal">id</code> may be used to reference the identifier property of an entity <span class="emphasis"><em>provided that the entity does not define a non-identifier property named id</em></span>. </p></li><li><p>If the entity defines a named identifier property, you can use that property name. </p></li></ul></div><p>References to composite identifier properties follow the same naming rules. If the entity has a non-identifier property named id, the composite identifier property can only be referenced by its defined named. Otherwise, the special <code class="literal">id</code> property can be used to reference the identifier property. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>중요</h2><p>Please note that, starting in version 3.2.2, this has changed significantly. In previous versions, <code class="literal">id</code> <span class="emphasis"><em>always</em></span> referred to the identifier property regardless of its actual name. A ramification of that decision was that non-identifier properties named <code class="literal">id</code> could never be referenced in Hibernate queries. </p></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-select"/>14.6. select 절</h2></div></div></div><p>The <code class="literal">select</code> clause picks which objects and properties to return in the query result set. Consider the following: </p><pre class="programlisting">select mate
from Cat as cat
    inner join cat.mate as mate</pre><p>The query will select <code class="literal">mate</code>s of other <code class="literal">Cat</code>s. You can express this query more compactly as: </p><pre class="programlisting">select cat.mate from Cat cat</pre><p>Queries can return properties of any value type including properties of component type: </p><pre class="programlisting">select cat.name from DomesticCat cat
where cat.name like 'fri%'</pre><pre class="programlisting">select cust.name.firstName from Customer as cust</pre><p>Queries can return multiple objects and/or properties as an array of type <code class="literal">Object[]</code>: </p><pre class="programlisting">select mother, offspr, mate.name
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>Or as a <code class="literal">List</code>: </p><pre class="programlisting">select new list(mother, offspr, mate.name)
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>Or - assuming that the class <code class="literal">Family</code> has an appropriate constructor - as an actual typesafe Java object: </p><pre class="programlisting">select new Family(mother, mate, offspr)
from DomesticCat as mother
    join mother.mate as mate
    left join mother.kittens as offspr</pre><p>You can assign aliases to selected expressions using <code class="literal">as</code>: </p><pre class="programlisting">select max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n
from Cat cat</pre><p>다음은 <code class="literal">select new map</code>과 함께 사용될 때 가장 유용하다: </p><pre class="programlisting">select new map( max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n )
from Cat cat</pre><p>이 질의는 select된 값들에 대한 alias로부터 한 개의 <code class="literal">Map</code>을 반환한다. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-aggregation"/>14.7. 집계 함수들</h2></div></div></div><p>HQL queries can even return the results of aggregate functions on properties: </p><pre class="programlisting">select avg(cat.weight), sum(cat.weight), max(cat.weight), count(cat)
from Cat cat</pre><p>The supported aggregate functions are: </p><div class="itemizedlist"><ul compact="compact"><li><p>
                    <code class="literal">avg(...), sum(...), min(...), max(...)</code>
                </p></li><li><p>
                    <code class="literal">count(*)</code>
                </p></li><li><p>
                    <code class="literal">count(...), count(distinct ...), count(all...)</code>
                </p></li></ul></div><p>You can use arithmetic operators, concatenation, and recognized SQL functions in the select clause: </p><pre class="programlisting">select cat.weight + sum(kitten.weight)
from Cat cat
    join cat.kittens kitten
group by cat.id, cat.weight</pre><pre class="programlisting">select firstName||' '||initial||' '||upper(lastName) from Person</pre><p>The <code class="literal">distinct</code> and <code class="literal">all</code> keywords can be used and have the same semantics as in SQL. </p><pre class="programlisting">select distinct cat.name from Cat cat

select count(distinct cat.name), count(cat) from Cat cat</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-polymorphism"/>14.8. Polymorphic(다형성) 질의들</h2></div></div></div><p>다음과 같은 질의: </p><pre class="programlisting">from Cat as cat</pre><p>returns instances not only of <code class="literal">Cat</code>, but also of subclasses like <code class="literal">DomesticCat</code>. Hibernate queries can name <span class="emphasis"><em>any</em></span> Java class or interface in the <code class="literal">from</code> clause. The query will return instances of all persistent classes that extend that class or implement the interface. The following query would return all persistent objects: </p><pre class="programlisting">from java.lang.Object o</pre><p>인터페이스 <code class="literal">Named</code>는 여러 가지 영속 클래스들에 의해 구현될 수도 있다: </p><pre class="programlisting">from Named n, Named m where n.name = m.name</pre><p>These last two queries will require more than one SQL <code class="literal">SELECT</code>. This means that the <code class="literal">order by</code> clause does not correctly order the whole result set. It also means you cannot call these queries using <code class="literal">Query.scroll()</code>. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-where"/>14.9. where 절</h2></div></div></div><p>The <code class="literal">where</code> clause allows you to refine the list of instances returned. If no alias exists, you can refer to properties by name: </p><pre class="programlisting">from Cat where name='Fritz'</pre><p>만일 한 개의 alias가 존재할 경우, 하나의 수식어가 붙은 프로퍼티 이름을 사용하라: </p><pre class="programlisting">from Cat as cat where cat.name='Fritz'</pre><p>This returns instances of <code class="literal">Cat</code> named 'Fritz'. </p><p>The following query: </p><pre class="programlisting">select foo
from Foo foo, Bar bar
where foo.startDate = bar.date</pre><p> returns all instances of <code class="literal">Foo</code> with an instance of <code class="literal">bar</code> with a <code class="literal">date</code> property equal to the <code class="literal">startDate</code> property of the <code class="literal">Foo</code>. Compound path expressions make the <code class="literal">where</code> clause extremely powerful. Consider the following: </p><pre class="programlisting">from Cat cat where cat.mate.name is not null</pre><p>This query translates to an SQL query with a table (inner) join. For example: </p><pre class="programlisting">from Foo foo
where foo.bar.baz.customer.address.city is not null</pre><p>would result in a query that would require four table joins in SQL. </p><p>The <code class="literal">=</code> operator can be used to compare not only properties, but also instances: </p><pre class="programlisting">from Cat cat, Cat rival where cat.mate = rival.mate</pre><pre class="programlisting">select cat, mate
from Cat cat, Cat mate
where cat.mate = mate</pre><p>The special property (lowercase) <code class="literal">id</code> can be used to reference the unique identifier of an object. See <a href="#queryhql-identifier-property" title="14.5. Referring to identifier property">14.5절. “Referring to identifier property”</a> for more information. </p><pre class="programlisting">from Cat as cat where cat.id = 123

from Cat as cat where cat.mate.id = 69</pre><p>The second query is efficient and does not require a table join. </p><p>Properties of composite identifiers can also be used. Consider the following example where <code class="literal">Person</code> has composite identifiers consisting of <code class="literal">country</code> and <code class="literal">medicareNumber</code>: </p><pre class="programlisting">from bank.Person person
where person.id.country = 'AU'
    and person.id.medicareNumber = 123456</pre><pre class="programlisting">from bank.Account account
where account.owner.id.country = 'AU'
    and account.owner.id.medicareNumber = 123456</pre><p>Once again, the second query does not require a table join. </p><p>See <a href="#queryhql-identifier-property" title="14.5. Referring to identifier property">14.5절. “Referring to identifier property”</a> for more information regarding referencing identifier properties) </p><p>The special property <code class="literal">class</code> accesses the discriminator value of an instance in the case of polymorphic persistence. A Java class name embedded in the where clause will be translated to its discriminator value. </p><pre class="programlisting">from Cat cat where cat.class = DomesticCat</pre><p>You can also use components or composite user types, or properties of said component types. See <a href="#queryhql-components" title="14.17. 컴포넌트들">14.17절. “컴포넌트들”</a> for more information. </p><p>An "any" type has the special properties <code class="literal">id</code> and <code class="literal">class</code> that allows you to express a join in the following way (where <code class="literal">AuditLog.item</code> is a property mapped with <code class="literal">&lt;any&gt;</code>): </p><pre class="programlisting">from AuditLog log, Payment payment
where log.item.class = 'Payment' and log.item.id = payment.id</pre><p>The <code class="literal">log.item.class</code> and <code class="literal">payment.class</code> would refer to the values of completely different database columns in the above query. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-expressions"/>14.10. 표현식들</h2></div></div></div><p>Expressions used in the <code class="literal">where</code> clause include the following: </p><div class="itemizedlist"><ul compact="compact"><li><p>mathematical operators: <code class="literal">+, -, *, /</code> </p></li><li><p>binary comparison operators: <code class="literal">=, &gt;=, &lt;=, &lt;&gt;, !=, like</code> </p></li><li><p>논리 연산들 <code class="literal">and, or, not</code> </p></li><li><p>Parentheses <code class="literal">( )</code> that indicates grouping </p></li><li><p><code class="literal">in</code>, <code class="literal">not in</code>, <code class="literal">between</code>, <code class="literal">is null</code>, <code class="literal">is not null</code>, <code class="literal">is empty</code>, <code class="literal">is not empty</code>, <code class="literal">member of</code> and <code class="literal">not member of</code> </p></li><li><p>"간단한" 경우, <code class="literal">case ... when ... then ... else ... end</code>, 그리고 "검색인" 경우, <code class="literal">case when ... then ... else ... end</code> </p></li><li><p>문자열 연결 <code class="literal">...||...</code> or <code class="literal">concat(...,...)</code> </p></li><li><p><code class="literal">current_date()</code>, <code class="literal">current_time()</code>, and <code class="literal">current_timestamp()</code> </p></li><li><p><code class="literal">second(...)</code>, <code class="literal">minute(...)</code>, <code class="literal">hour(...)</code>, <code class="literal">day(...)</code>, <code class="literal">month(...)</code>, and <code class="literal">year(...)</code> </p></li><li><p>EJB-QL 3.0에 의해 정의된 임의의 함수 또는 오퍼레이터: <code class="literal">substring(), trim(), lower(), upper(), length(), locate(), abs(), sqrt(), bit_length(), mod()</code> </p></li><li><p><code class="literal">coalesce()</code> 그리고 <code class="literal">nullif()</code> </p></li><li><p>numeric 값들이나 temporal 값들을 가독성 있는 문자열로 변환시키는 <code class="literal">str()</code> </p></li><li><p><code class="literal">cast(... as ...)</code>, 여기서 두번 째 아규먼트는 Hibernate 타입의 이름이고, ANSI <code class="literal">cast()</code>와 <code class="literal">extract()</code>가 기반 데이터베이스에 의해 지원될 경우에는 <code class="literal">extract(... from ...)</code>. </p></li><li><p>조인된 인덱싱된 콜렉션의 alias들에 적용되는, HQL <code class="literal">index()</code> 함수 </p></li><li><p>HQL functions that take collection-valued path expressions: <code class="literal">size(), minelement(), maxelement(), minindex(), maxindex()</code>, along with the special <code class="literal">elements()</code> and <code class="literal">indices</code> functions that can be quantified using <code class="literal">some, all, exists, any, in</code>. </p></li><li><p>Any database-supported SQL scalar function like <code class="literal">sign()</code>, <code class="literal">trunc()</code>, <code class="literal">rtrim()</code>, and <code class="literal">sin()</code> </p></li><li><p>JDBC-스타일 위치 파라미터들 <code class="literal">?</code> </p></li><li><p>named parameters <code class="literal">:name</code>, <code class="literal">:start_date</code>, and <code class="literal">:x1</code> </p></li><li><p>SQL 리터럴들 <code class="literal">'foo'</code>, <code class="literal">69</code>, <code class="literal">6.66E+2</code>, <code class="literal">'1970-01-01 10:00:01.0'</code> </p></li><li><p>Java <code class="literal">public static final</code> 상수들. <code class="literal">eg.Color.TABBY</code> </p></li></ul></div><p><code class="literal">in</code> and <code class="literal">between</code> can be used as follows: </p><pre class="programlisting">from DomesticCat cat where cat.name between 'A' and 'B'</pre><pre class="programlisting">from DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )</pre><p>The negated forms can be written as follows: </p><pre class="programlisting">from DomesticCat cat where cat.name not between 'A' and 'B'</pre><pre class="programlisting">from DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )</pre><p>Similarly, <code class="literal">is null</code> and <code class="literal">is not null</code> can be used to test for null values. </p><p>Booleans can be easily used in expressions by declaring HQL query substitutions in Hibernate configuration: </p><pre class="programlisting">&lt;property name="hibernate.query.substitutions"&gt;true 1, false 0&lt;/property&gt;</pre><p>이것은 키워드 <code class="literal">true</code>와 <code class="literal">false</code> 키워드들을 이 HQL로부터 번역된 SQL에서 리터럴 <code class="literal">1</code>과 <code class="literal">0</code>으로 대체될 것이다: </p><pre class="programlisting">from Cat cat where cat.alive = true</pre><p>You can test the size of a collection with the special property <code class="literal">size</code> or the special <code class="literal">size()</code> function. </p><pre class="programlisting">from Cat cat where cat.kittens.size &gt; 0</pre><pre class="programlisting">from Cat cat where size(cat.kittens) &gt; 0</pre><p>For indexed collections, you can refer to the minimum and maximum indices using <code class="literal">minindex</code> and <code class="literal">maxindex</code> functions. Similarly, you can refer to the minimum and maximum elements of a collection of basic type using the <code class="literal">minelement</code> and <code class="literal">maxelement</code> functions. For example: </p><pre class="programlisting">from Calendar cal where maxelement(cal.holidays) &gt; current_date</pre><pre class="programlisting">from Order order where maxindex(order.items) &gt; 100</pre><pre class="programlisting">from Order order where minelement(order.items) &gt; 10000</pre><p>The SQL functions <code class="literal">any, some, all, exists, in</code> are supported when passed the element or index set of a collection (<code class="literal">elements</code> and <code class="literal">indices</code> functions) or the result of a subquery (see below): </p><pre class="programlisting">select mother from Cat as mother, Cat as kit
where kit in elements(foo.kittens)</pre><pre class="programlisting">select p from NameList list, Person p
where p.name = some elements(list.names)</pre><pre class="programlisting">from Cat cat where exists elements(cat.kittens)</pre><pre class="programlisting">from Player p where 3 &gt; all elements(p.scores)</pre><pre class="programlisting">from Show show where 'fizard' in indices(show.acts)</pre><p>Note that these constructs - <code class="literal">size</code>, <code class="literal">elements</code>, <code class="literal">indices</code>, <code class="literal">minindex</code>, <code class="literal">maxindex</code>, <code class="literal">minelement</code>, <code class="literal">maxelement</code> - can only be used in the where clause in Hibernate3. </p><p>Elements of indexed collections (arrays, lists, and maps) can be referred to by index in a where clause only: </p><pre class="programlisting">from Order order where order.items[0].id = 1234</pre><pre class="programlisting">select person from Person person, Calendar calendar
where calendar.holidays['national day'] = person.birthDay
    and person.nationality.calendar = calendar</pre><pre class="programlisting">select item from Item item, Order order
where order.items[ order.deliveredItemIndices[0] ] = item and order.id = 11</pre><pre class="programlisting">select item from Item item, Order order
where order.items[ maxindex(order.items) ] = item and order.id = 11</pre><p>The expression inside <code class="literal">[]</code> can even be an arithmetic expression: </p><pre class="programlisting">select item from Item item, Order order
where order.items[ size(order.items) - 1 ] = item</pre><p>HQL also provides the built-in <code class="literal">index()</code> function for elements of a one-to-many association or collection of values. </p><pre class="programlisting">select item, index(item) from Order order
    join order.items item
where index(item) &lt; 5</pre><p>Scalar SQL functions supported by the underlying database can be used: </p><pre class="programlisting">from DomesticCat cat where upper(cat.name) like 'FRI%'</pre><p>Consider how much longer and less readable the following query would be in SQL: </p><pre class="programlisting">select cust
from Product prod,
    Store store
    inner join store.customers cust
where prod.name = 'widget'
    and store.location.name in ( 'Melbourne', 'Sydney' )
    and prod = all elements(cust.currentOrder.lineItems)</pre><p><span class="emphasis"><em>힌트</em></span> : 다음과 같은 어떤 것 </p><pre class="programlisting">SELECT cust.name, cust.address, cust.phone, cust.id, cust.current_order
FROM customers cust,
    stores store,
    locations loc,
    store_customers sc,
    product prod
WHERE prod.name = 'widget'
    AND store.loc_id = loc.id
    AND loc.name IN ( 'Melbourne', 'Sydney' )
    AND sc.store_id = store.id
    AND sc.cust_id = cust.id
    AND prod.id = ALL(
        SELECT item.prod_id
        FROM line_items item, orders o
        WHERE item.order_id = o.id
            AND cust.current_order = o.id
    )</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-ordering"/>14.11. order by 절</h2></div></div></div><p>The list returned by a query can be ordered by any property of a returned class or components: </p><pre class="programlisting">from DomesticCat cat
order by cat.name asc, cat.weight desc, cat.birthdate</pre><p><code class="literal">asc</code> 옵션 또는 <code class="literal">desc</code> 옵션은 각각 오름차순 또는 내림차순 정렬을 나타낸다. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-grouping"/>14.12. group by 절</h2></div></div></div><p>A query that returns aggregate values can be grouped by any property of a returned class or components: </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat)
from Cat cat
group by cat.color</pre><pre class="programlisting">select foo.id, avg(name), max(name)
from Foo foo join foo.names name
group by foo.id</pre><p>또한 <code class="literal">having</code> 절이 허용된다. </p><pre class="programlisting">select cat.color, sum(cat.weight), count(cat)
from Cat cat
group by cat.color
having cat.color in (eg.Color.TABBY, eg.Color.BLACK)</pre><p>SQL functions and aggregate functions are allowed in the <code class="literal">having</code> and <code class="literal">order by</code> clauses if they are supported by the underlying database (i.e., not in MySQL). </p><pre class="programlisting">select cat
from Cat cat
    join cat.kittens kitten
group by cat.id, cat.name, cat.other, cat.properties
having avg(kitten.weight) &gt; 100
order by count(kitten) asc, sum(kitten.weight) desc</pre><p>Neither the <code class="literal">group by</code> clause nor the <code class="literal">order by</code> clause can contain arithmetic expressions. Hibernate also does not currently expand a grouped entity, so you cannot write <code class="literal">group by cat</code> if all properties of <code class="literal">cat</code> are non-aggregated. You have to list all non-aggregated properties explicitly. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-subqueries"/>14.13. 서브질의들</h2></div></div></div><p>subselect들을 지원하는 데이터베이스들의 경우, Hibernate는 질의들 내에 서브질의들을 지원한다. 서브질의는 괄호로 묶여져야 한다(자주 SQL 집계함수 호출에 의해). 심지어 서로 상관된 서브질의들(외부 질의 내에서 alias를 참조하는 서브질의들)이 허용된다. </p><pre class="programlisting">from Cat as fatcat
where fatcat.weight &gt; (
    select avg(cat.weight) from DomesticCat cat
)</pre><pre class="programlisting">from DomesticCat as cat
where cat.name = some (
    select name.nickName from Name as name
)</pre><pre class="programlisting">from Cat as cat
where not exists (
    from Cat as mate where mate.mate = cat
)</pre><pre class="programlisting">from DomesticCat as cat
where cat.name not in (
    select name.nickName from Name as name
)</pre><pre class="programlisting">select cat.id, (select max(kit.weight) from cat.kitten kit)
from Cat as cat</pre><p>Note that HQL subqueries can occur only in the select or where clauses. </p><p>Note that subqueries can also utilize <code class="literal">row value constructor</code> syntax. See <a href="#queryhql-tuple" title="14.18. Row value constructor 구문">14.18절. “Row value constructor 구문”</a> for more information. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-examples"/>14.14. HQL 예제들</h2></div></div></div><p>Hibernate queries can be quite powerful and complex. In fact, the power of the query language is one of Hibernate's main strengths. The following example queries are similar to queries that have been used on recent projects. Please note that most queries you will write will be much simpler than the following examples. </p><p>The following query returns the order id, number of items, the given minimum total value and the total value of the order for all unpaid orders for a particular customer. The results are ordered by total value. In determining the prices, it uses the current catalog. The resulting SQL query, against the <code class="literal">ORDER</code>, <code class="literal">ORDER_LINE</code>, <code class="literal">PRODUCT</code>, <code class="literal">CATALOG</code> and <code class="literal">PRICE</code> tables has four inner joins and an (uncorrelated) subselect. </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog.effectiveDate &lt; sysdate
    and catalog.effectiveDate &gt;= all (
        select cat.effectiveDate
        from Catalog as cat
        where cat.effectiveDate &lt; sysdate
    )
group by order
having sum(price.amount) &gt; :minAmount
order by sum(price.amount) desc</pre><p>괴물 같은 것! 실제로 실 생활에서, 나는 서브질의들을 매우 좋아하지 않아서, 나의 질의는 실제로 다음과 같았다: </p><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog = :currentCatalog
group by order
having sum(price.amount) &gt; :minAmount
order by sum(price.amount) desc</pre><p>다음 질의는 현재 사용자에 의해 가장 최근의 상태 변경이 행해졌던 <code class="literal">AWAITING_APPROVAL</code> 상태에 있는 모든 지불들을 제외한, 각각의 상태에 있는 지불들의 개수를 카운트 한다. 그것은 <code class="literal">PAYMENT</code>, <code class="literal">PAYMENT_STATUS</code>, <code class="literal">PAYMENT_STATUS_CHANGE</code> 테이블들에 대한 두 개의 inner 조인들과 하나의 상관관계 지워진 subselect를 가진 SQL 질의로 변환된다. </p><pre class="programlisting">select count(payment), status.name
from Payment as payment
    join payment.currentStatus as status
    join payment.statusChanges as statusChange
where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL
    or (
        statusChange.timeStamp = (
            select max(change.timeStamp)
            from PaymentStatusChange change
            where change.payment = payment
        )
        and statusChange.user &lt;&gt; :currentUser
    )
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>If the <code class="literal">statusChanges</code> collection was mapped as a list, instead of a set, the query would have been much simpler to write. </p><pre class="programlisting">select count(payment), status.name
from Payment as payment
    join payment.currentStatus as status
where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL
    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user &lt;&gt; :currentUser
group by status.name, status.sortOrder
order by status.sortOrder</pre><p>다음 질의는 현재의 사용자가 속해 있는 조직의 모든 계정들과 지불되지 않은 지불들을 반환하는데 MS SQL Server <code class="literal">isNull()</code> 함수를 사용한다. 그것은 <code class="literal">ACCOUNT</code>, <code class="literal">PAYMENT</code>, <code class="literal">PAYMENT_STATUS</code>, <code class="literal">ACCOUNT_TYPE</code>, <code class="literal">ORGANIZATION</code>, <code class="literal">ORG_USER</code> 테이블들에 대한 세 개의 inner 조인들, 하나의 outer 조인, 그리고 하나의 subselect를 가진 한 개의 SQL 질의로 번역된다. </p><pre class="programlisting">select account, payment
from Account as account
    left outer join account.payments as payment
where :currentUser in elements(account.holder.users)
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre><p>몇몇 데이터베이스들의 경우, 우리는 (상관관계 지워진) subselect를 없앨 필요가 있을 것이다. </p><pre class="programlisting">select account, payment
from Account as account
    join account.holder.users as user
    left outer join account.payments as payment
where :currentUser = user
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-bulk"/>14.15. 대량 update와 delete</h2></div></div></div><p>HQL now supports <code class="literal">update</code>, <code class="literal">delete</code> and <code class="literal">insert ... select ...</code> statements. See <a href="#batch-direct" title="13.4. DML-ì¤íì¼ ì°ì°ë¤">13.4절. “DML-ì¤íì¼ ì°ì°ë¤”</a> for more information. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-tipstricks"/>14.16. 팁들 &amp; 트릭들</h2></div></div></div><p>You can count the number of query results without returning them: </p><pre class="programlisting">( (Integer) session.createQuery("select count(*) from ....").iterate().next() ).intValue()</pre><p>콜렉션의 크기에 따라 결과를 순서(ordering)지우려면, 다음 질의를 사용하라: </p><pre class="programlisting">select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
order by count(msg)</pre><p>만일 당신의 데이터베이스가 subselect들을 지원할 경우, 당신은 당신의 질의의 where 절 내에 selection 사이즈에 대한 조건을 위치지울 수 있다: </p><pre class="programlisting">from User usr where size(usr.messages) &gt;= 1</pre><p>If your database does not support subselects, use the following query: </p><pre class="programlisting">select usr.id, usr.name
from User usr.name
    join usr.messages msg
group by usr.id, usr.name
having count(msg) &gt;= 1</pre><p>As this solution cannot return a <code class="literal">User</code> with zero messages because of the inner join, the following form is also useful: </p><pre class="programlisting">select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
having count(msg) = 0</pre><p>하나의 JavaBean의 프로퍼티들은 명명된 질의 파라미터들에 바인드될 수 있다: </p><pre class="programlisting">Query q = s.createQuery("from foo Foo as foo where foo.name=:name and foo.size=:size");
q.setProperties(fooBean); // fooBean has getName() and getSize()
List foos = q.list();</pre><p>콜렉션들은 필터를 가진 <code class="literal">Query</code> 인터페이스를 사용하여 쪼매김하는 것이 가능하다: </p><pre class="programlisting">Query q = s.createFilter( collection, "" ); // the trivial filter
q.setMaxResults(PAGE_SIZE);
q.setFirstResult(PAGE_SIZE * pageNumber);
List page = q.list();</pre><p>Collection elements can be ordered or grouped using a query filter: </p><pre class="programlisting">Collection orderedCollection = s.filter( collection, "order by this.amount" );
Collection counts = s.filter( collection, "select this.type, count(this) group by this.type" );</pre><p>당신은 콜렉션을 초기화 하지 않고서 그것(콜렉션)의 크기를 찾을 수 있다: </p><pre class="programlisting">( (Integer) session.createQuery("select count(*) from ....").iterate().next() ).intValue();</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-components"/>14.17. 컴포넌트들</h2></div></div></div><p>Components can be used similarly to the simple value types that are used in HQL queries. They can appear in the <code class="literal">select</code> clause as follows: </p><pre class="programlisting">select p.name from Person p</pre><pre class="programlisting">select p.name.first from Person p</pre><p>여기서 Person의 name 속성은 컴포넌트이다. 컴포넌트들은 또한 <code class="literal">where</code> 절 내에 사용될 수 있다: </p><pre class="programlisting">from Person p where p.name = :name</pre><pre class="programlisting">from Person p where p.name.first = :firstName</pre><p>컴포넌트들은 또한 <code class="literal">order by</code> 절 내에 사용될 수 있다: </p><pre class="programlisting">from Person p order by p.name</pre><pre class="programlisting">from Person p order by p.name.first</pre><p>컴포넌트들에 대한 또 다른 공통적인 사용은 <a href="#queryhql-tuple" title="14.18. Row value constructor 구문">14.18절. “Row value constructor 구문”</a>에 있다. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="queryhql-tuple"/>14.18. Row value constructor 구문</h2></div></div></div><p>HQL supports the use of ANSI SQL <code class="literal">row value constructor</code> syntax, sometimes referred to AS <code class="literal">tuple</code> syntax, even though the underlying database may not support that notion. Here, we are generally referring to multi-valued comparisons, typically associated with components. Consider an entity Person which defines a name component: </p><pre class="programlisting">from Person p where p.name.first='John' and p.name.last='Jingleheimer-Schmidt'</pre><p>That is valid syntax although it is a little verbose. You can make this more concise by using <code class="literal">row value constructor</code> syntax: </p><pre class="programlisting">from Person p where p.name=('John', 'Jingleheimer-Schmidt')</pre><p><code class="literal">select</code>절 내에 이것을 지정하는 것이 또한 유용할 수 있다: </p><pre class="programlisting">select p.name from Person p</pre><p>Using <code class="literal">row value constructor</code> syntax can also be beneficial when using subqueries that need to compare against multiple values: </p><pre class="programlisting">from Cat as cat
where not ( cat.name, cat.color ) in (
    select cat.name, cat.color from DomesticCat cat
)</pre><p>One thing to consider when deciding if you want to use this syntax, is that the query will be dependent upon the ordering of the component sub-properties in the metadata. </p></div></div><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria"/>15장. Criteria 질의들</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#querycriteria-creating">15.1. <code class="literal">Criteria</code> 인스턴스 생성하기</a></span></dt><dt><span class="sect1"><a href="#querycriteria-narrowing">15.2. 결과 셋 제한하기</a></span></dt><dt><span class="sect1"><a href="#querycriteria-ordering">15.3. 결과들을 순서지우기(ordering)</a></span></dt><dt><span class="sect1"><a href="#querycriteria-associations">15.4. 연관들</a></span></dt><dt><span class="sect1"><a href="#querycriteria-dynamicfetching">15.5. 동적인 연관 페칭</a></span></dt><dt><span class="sect1"><a href="#querycriteria-examples">15.6. 예제 질의들</a></span></dt><dt><span class="sect1"><a href="#querycriteria-projection">15.7. Projections, aggregation 그리고 grouping</a></span></dt><dt><span class="sect1"><a href="#querycriteria-detachedqueries">15.8. Detached 질의들과 서브질의들</a></span></dt><dt><span class="sect1"><a href="#query-criteria-naturalid">15.9. natural 식별자에 의한 질의들</a></span></dt></dl></div><p>Hibernate는 직관적인, 확장 가능한 criteria query API를 특징 짓는다. </p><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-creating"/>15.1. <code class="literal">Criteria</code> 인스턴스 생성하기</h2></div></div></div><p><code class="literal">org.hibernate.Criteria</code>인터페이스는 특정 영속 클래스에 대한 질의를 표현한다. <code class="literal">Session</code>은 <code class="literal">Criteria</code> 인스턴스들에 대한 팩토리이다. </p><pre class="programlisting">Criteria crit = sess.createCriteria(Cat.class);
crit.setMaxResults(50);
List cats = crit.list();</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-narrowing"/>15.2. 결과 셋 제한하기</h2></div></div></div><p>개별적인 질의 기준은 <code class="literal">org.hibernate.criterion.Criterion</code> 인터페이스의 인스턴스이다. <code class="literal">org.hibernate.criterion.Restrictions</code> 클래스는 어떤 미리 만들어진 <code class="literal">Criterion</code> 타입들을 얻는 팩토리 메소드들을 정의한다. </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "Fritz%") )
    .add( Restrictions.between("weight", minWeight, maxWeight) )
    .list();</pre><p>Restrictions can be grouped logically. </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "Fritz%") )
    .add( Restrictions.or(
        Restrictions.eq( "age", new Integer(0) ),
        Restrictions.isNull("age")
    ) )
    .list();</pre><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.in( "name", new String[] { "Fritz", "Izi", "Pk" } ) )
    .add( Restrictions.disjunction()
        .add( Restrictions.isNull("age") )
        .add( Restrictions.eq("age", new Integer(0) ) )
        .add( Restrictions.eq("age", new Integer(1) ) )
        .add( Restrictions.eq("age", new Integer(2) ) )
    ) )
    .list();</pre><p>There are a range of built-in criterion types (<code class="literal">Restrictions</code> subclasses). One of the most useful allows you to specify SQL directly. </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.sqlRestriction("lower({alias}.name) like lower(?)", "Fritz%", Hibernate.STRING) )
    .list();</pre><p>질의된 엔티티의 행 alias에 의해 대체된 <code class="literal">{alias}</code> placeholder. </p><p>You can also obtain a criterion from a <code class="literal">Property</code> instance. You can create a <code class="literal">Property</code> by calling <code class="literal">Property.forName()</code>: </p><pre class="programlisting">
Property age = Property.forName("age");
List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.disjunction()
        .add( age.isNull() )
        .add( age.eq( new Integer(0) ) )
        .add( age.eq( new Integer(1) ) )
        .add( age.eq( new Integer(2) ) )
    ) )
    .add( Property.forName("name").in( new String[] { "Fritz", "Izi", "Pk" } ) )
    .list();</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-ordering"/>15.3. 결과들을 순서지우기(ordering)</h2></div></div></div><p>You can order the results using <code class="literal">org.hibernate.criterion.Order</code>. </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "F%")
    .addOrder( Order.asc("name") )
    .addOrder( Order.desc("age") )
    .setMaxResults(50)
    .list();</pre><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Property.forName("name").like("F%") )
    .addOrder( Property.forName("name").asc() )
    .addOrder( Property.forName("age").desc() )
    .setMaxResults(50)
    .list();</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-associations"/>15.4. 연관들</h2></div></div></div><p>By navigating associations using <code class="literal">createCriteria()</code> you can specify constraints upon related entities: </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "F%") )
    .createCriteria("kittens")
        .add( Restrictions.like("name", "F%") )
    .list();</pre><p>The second <code class="literal">createCriteria()</code> returns a new instance of <code class="literal">Criteria</code> that refers to the elements of the <code class="literal">kittens</code> collection. </p><p>There is also an alternate form that is useful in certain circumstances: </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .createAlias("kittens", "kt")
    .createAlias("mate", "mt")
    .add( Restrictions.eqProperty("kt.name", "mt.name") )
    .list();</pre><p>(<code class="literal">createAlias()</code>는 <code class="literal">Criteria</code>의 새로운 인스턴스를 생성시키지 않는다.) </p><p>The kittens collections held by the <code class="literal">Cat</code> instances returned by the previous two queries are <span class="emphasis"><em>not</em></span> pre-filtered by the criteria. If you want to retrieve just the kittens that match the criteria, you must use a <code class="literal">ResultTransformer</code>. </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .createCriteria("kittens", "kt")
        .add( Restrictions.eq("name", "F%") )
    .setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP)
    .list();
Iterator iter = cats.iterator();
while ( iter.hasNext() ) {
    Map map = (Map) iter.next();
    Cat cat = (Cat) map.get(Criteria.ROOT_ALIAS);
    Cat kitten = (Cat) map.get("kt");
}</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-dynamicfetching"/>15.5. 동적인 연관 페칭</h2></div></div></div><p>You can specify association fetching semantics at runtime using <code class="literal">setFetchMode()</code>. </p><pre class="programlisting">List cats = sess.createCriteria(Cat.class)
    .add( Restrictions.like("name", "Fritz%") )
    .setFetchMode("mate", FetchMode.EAGER)
    .setFetchMode("kittens", FetchMode.EAGER)
    .list();</pre><p>이 질의는 outer 조인으로 <code class="literal">mate</code>와 <code class="literal">kittens</code> 모두를 페치할 것이다. 추가 정보는 <a href="#performance-fetching" title="19.1. 페칭 방도들">19.1절. “페칭 방도들”</a>을 보라. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-examples"/>15.6. 예제 질의들</h2></div></div></div><p><code class="literal">org.hibernate.criterion.Example</code> 클래스는 주어진 인스턴스로부터 질의 기준(criterion)을 구조화 시키는 것을 당신에게 허용해준다. </p><pre class="programlisting">Cat cat = new Cat();
cat.setSex('F');
cat.setColor(Color.BLACK);
List results = session.createCriteria(Cat.class)
    .add( Example.create(cat) )
    .list();</pre><p>버전 프로퍼티들, 식별자들, 연관관계들이 무시된다. 디폴트로 null 값 프로퍼티들이 제외된다. </p><p>당신은 <code class="literal">Example</code>이 적용되는 방법을 조정할 수 있다. </p><pre class="programlisting">Example example = Example.create(cat)
    .excludeZeroes()           //exclude zero valued properties
    .excludeProperty("color")  //exclude the property named "color"
    .ignoreCase()              //perform case insensitive string comparisons
    .enableLike();             //use like for string comparisons
List results = session.createCriteria(Cat.class)
    .add(example)
    .list();</pre><p>당신은 연관된 객체들에 대한 criteria(기준)을 위치지우는데 examples를 사용할 수 있다. </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .add( Example.create(cat) )
    .createCriteria("mate")
        .add( Example.create( cat.getMate() ) )
    .list();</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-projection"/>15.7. Projections, aggregation 그리고 grouping</h2></div></div></div><p>The class <code class="literal">org.hibernate.criterion.Projections</code> is a factory for <code class="literal">Projection</code> instances. You can apply a projection to a query by calling <code class="literal">setProjection()</code>. </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.rowCount() )
    .add( Restrictions.eq("color", Color.BLACK) )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.projectionList()
        .add( Projections.rowCount() )
        .add( Projections.avg("weight") )
        .add( Projections.max("weight") )
        .add( Projections.groupProperty("color") )
    )
    .list();</pre><p>criteria 질의 내에서는 명시적인 "group by"가 필수적이지 않다. 어떤 projection 타입들은 <span class="emphasis"><em>grouping projections</em></span>들이게끔 정의되고, 그것은 또한 SQL <code class="literal">group by</code> 절 속에 나타난다. </p><p>An alias can be assigned to a projection so that the projected value can be referred to in restrictions or orderings. Here are two different ways to do this: </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.alias( Projections.groupProperty("color"), "colr" ) )
    .addOrder( Order.asc("colr") )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.groupProperty("color").as("colr") )
    .addOrder( Order.asc("colr") )
    .list();</pre><p><code class="literal">alias()</code> 메소드와 <code class="literal">as()</code> 메소드는 또 다른 alias 된 <code class="literal">Projection</code>의 인스턴스 내에 하나의 projection 인스턴스를 간단하게 포장한다. 지름길로서, 당신이 projection을 projection 리스트에 추가할 때 당신은 alias를 할당할 수 있다: </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.projectionList()
        .add( Projections.rowCount(), "catCountByColor" )
        .add( Projections.avg("weight"), "avgWeight" )
        .add( Projections.max("weight"), "maxWeight" )
        .add( Projections.groupProperty("color"), "color" )
    )
    .addOrder( Order.desc("catCountByColor") )
    .addOrder( Order.desc("avgWeight") )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Domestic.class, "cat")
    .createAlias("kittens", "kit")
    .setProjection( Projections.projectionList()
        .add( Projections.property("cat.name"), "catName" )
        .add( Projections.property("kit.name"), "kitName" )
    )
    .addOrder( Order.asc("catName") )
    .addOrder( Order.asc("kitName") )
    .list();</pre><p>당신은 또한 projection들을 표현하는데 <code class="literal">Property.forName()</code>을 사용할 수 있다: </p><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Property.forName("name") )
    .add( Property.forName("color").eq(Color.BLACK) )
    .list();</pre><pre class="programlisting">List results = session.createCriteria(Cat.class)
    .setProjection( Projections.projectionList()
        .add( Projections.rowCount().as("catCountByColor") )
        .add( Property.forName("weight").avg().as("avgWeight") )
        .add( Property.forName("weight").max().as("maxWeight") )
        .add( Property.forName("color").group().as("color" )
    )
    .addOrder( Order.desc("catCountByColor") )
    .addOrder( Order.desc("avgWeight") )
    .list();</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="querycriteria-detachedqueries"/>15.8. Detached 질의들과 서브질의들</h2></div></div></div><p>The <code class="literal">DetachedCriteria</code> class allows you to create a query outside the scope of a session and then execute it using an arbitrary <code class="literal">Session</code>. </p><pre class="programlisting">DetachedCriteria query = DetachedCriteria.forClass(Cat.class)
    .add( Property.forName("sex").eq('F') );
    
Session session = ....;
Transaction txn = session.beginTransaction();
List results = query.getExecutableCriteria(session).setMaxResults(100).list();
txn.commit();
session.close();</pre><p>A <code class="literal">DetachedCriteria</code> can also be used to express a subquery. Criterion instances involving subqueries can be obtained via <code class="literal">Subqueries</code> or <code class="literal">Property</code>. </p><pre class="programlisting">DetachedCriteria avgWeight = DetachedCriteria.forClass(Cat.class)
    .setProjection( Property.forName("weight").avg() );
session.createCriteria(Cat.class)
    .add( Property.forName("weight").gt(avgWeight) )
    .list();</pre><pre class="programlisting">DetachedCriteria weights = DetachedCriteria.forClass(Cat.class)
    .setProjection( Property.forName("weight") );
session.createCriteria(Cat.class)
    .add( Subqueries.geAll("weight", weights) )
    .list();</pre><p>Correlated subqueries are also possible: </p><pre class="programlisting">DetachedCriteria avgWeightForSex = DetachedCriteria.forClass(Cat.class, "cat2")
    .setProjection( Property.forName("weight").avg() )
    .add( Property.forName("cat2.sex").eqProperty("cat.sex") );
session.createCriteria(Cat.class, "cat")
    .add( Property.forName("weight").gt(avgWeightForSex) )
    .list();</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="query-criteria-naturalid"/>15.9. natural 식별자에 의한 질의들</h2></div></div></div><p>For most queries, including criteria queries, the query cache is not efficient because query cache invalidation occurs too frequently. However, there is a special kind of query where you can optimize the cache invalidation algorithm: lookups by a constant natural key. In some applications, this kind of query occurs frequently. The criteria API provides special provision for this use case. </p><p>First, map the natural key of your entity using <code class="literal">&lt;natural-id&gt;</code> and enable use of the second-level cache. </p><pre class="programlisting">&lt;class name="User"&gt;
    &lt;cache usage="read-write"/&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;natural-id&gt;
        &lt;property name="name"/&gt;
        &lt;property name="org"/&gt;
    &lt;/natural-id&gt;
    &lt;property name="password"/&gt;
&lt;/class&gt;</pre><p>This functionality is not intended for use with entities with <span class="emphasis"><em>mutable</em></span> natural keys. </p><p>Once you have enabled the Hibernate query cache, the <code class="literal">Restrictions.naturalId()</code> allows you to make use of the more efficient cache algorithm. </p><pre class="programlisting">session.createCriteria(User.class)
    .add( Restrictions.naturalId()
        .set("name", "gavin")
        .set("org", "hb") 
    ).setCacheable(true)
    .uniqueResult();</pre></div></div><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="querysql"/>16장. Native SQL</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#querysql-creating">16.1. <code class="literal">SQLQuery</code> 사용하기</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e13314">16.1.1. 스칼라 질의들</a></span></dt><dt><span class="sect2"><a href="#d0e13364">16.1.2. Entity 질의들</a></span></dt><dt><span class="sect2"><a href="#d0e13400">16.1.3. 연관들과 콜렉션들을 처리하기</a></span></dt><dt><span class="sect2"><a href="#d0e13431">16.1.4. 여러 개의 엔티티들을 반환하기</a></span></dt><dt><span class="sect2"><a href="#d0e13572">16.1.5. non-managed 엔티티들을 반환하기</a></span></dt><dt><span class="sect2"><a href="#d0e13596">16.1.6. 상속 처리하기</a></span></dt><dt><span class="sect2"><a href="#d0e13601">16.1.7. 파라미터들</a></span></dt></dl></dd><dt><span class="sect1"><a href="#querysql-namedqueries">16.2. 명명된 SQL 질의들</a></span></dt><dd><dl><dt><span class="sect2"><a href="#propertyresults">16.2.1. 명시적으로 column/alias 이름들을 지정하는데 return-property 사용하기</a></span></dt><dt><span class="sect2"><a href="#sp_query">16.2.2. 질의를 위한 내장 프로시저 사용하기</a></span></dt></dl></dd><dt><span class="sect1"><a href="#querysql-cud">16.3. create, update 그리고 delete를 위한 맞춤형 SQL</a></span></dt><dt><span class="sect1"><a href="#querysql-load">16.4. 로딩을 위한 맞춤형 SQL</a></span></dt></dl></div><p>You can also express queries in the native SQL dialect of your database. This is useful if you want to utilize database-specific features such as query hints or the <code class="literal">CONNECT</code> keyword in Oracle. It also provides a clean migration path from a direct SQL/JDBC based application to Hibernate.</p><p>Hibernate3 allows you to specify handwritten SQL, including stored procedures, for all create, update, delete, and load operations.</p><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="querysql-creating"/>16.1. <code class="literal">SQLQuery</code> 사용하기</h2></div></div></div><p>Execution of native SQL queries is controlled via the <code class="literal">SQLQuery</code> interface, which is obtained by calling <code class="literal">Session.createSQLQuery()</code>. The following sections describe how to use this API for querying.</p><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13314"/>16.1.1. 스칼라 질의들</h3></div></div></div><p>가장 기본적인 SQL 질의는 스칼라들(값들)의 목록을 얻는 것이다.</p><pre class="programlisting">sess.createSQLQuery("SELECT * FROM CATS").list();
sess.createSQLQuery("SELECT ID, NAME, BIRTHDATE FROM CATS").list();
</pre><p>These will return a List of Object arrays (Object[]) with scalar values for each column in the CATS table. Hibernate will use ResultSetMetadata to deduce the actual order and types of the returned scalar values.</p><p>To avoid the overhead of using <code class="literal">ResultSetMetadata</code>, or simply to be more explicit in what is returned, one can use <code class="literal">addScalar()</code>:</p><pre class="programlisting">sess.createSQLQuery("SELECT * FROM CATS")
 .addScalar("ID", Hibernate.LONG)
 .addScalar("NAME", Hibernate.STRING)
 .addScalar("BIRTHDATE", Hibernate.DATE)
</pre><p>이 질의는 다음을 지정했다:</p><div class="itemizedlist"><ul><li><p>SQL 질의 문자열</p></li><li><p>반환할 컬럼들과 타입들</p></li></ul></div><p>This will return Object arrays, but now it will not use <code class="literal">ResultSetMetadata</code> but will instead explicitly get the ID, NAME and BIRTHDATE column as respectively a Long, String and a Short from the underlying resultset. This also means that only these three columns will be returned, even though the query is using <code class="literal">*</code> and could return more than the three listed columns.</p><p>스칼라들 중 몇몇 또는 전부에 대한 타입 정보를 남겨두는 것이 가능하다.</p><pre class="programlisting">sess.createSQLQuery("SELECT * FROM CATS")
 .addScalar("ID", Hibernate.LONG)
 .addScalar("NAME")
 .addScalar("BIRTHDATE")
</pre><p>This is essentially the same query as before, but now <code class="literal">ResultSetMetaData</code> is used to determine the type of NAME and BIRTHDATE, where as the type of ID is explicitly specified.</p><p>How the java.sql.Types returned from ResultSetMetaData is mapped to Hibernate types is controlled by the Dialect. If a specific type is not mapped, or does not result in the expected type, it is possible to customize it via calls to <code class="literal">registerHibernateType</code> in the Dialect.</p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13364"/>16.1.2. Entity 질의들</h3></div></div></div><p>위의 질의들은 스칼라 값들을 반환하는 것, 결과셋들로부터 "원래의" 값들을 기본적으로 반환하는 것에 대한 전부였다. 다음은 <code class="literal">addEntity()</code>를 통해 native sql 질의로부터 엔티티 객체들을 얻는 방법을 보여준다.</p><pre class="programlisting">sess.createSQLQuery("SELECT * FROM CATS").addEntity(Cat.class);
sess.createSQLQuery("SELECT ID, NAME, BIRTHDATE FROM CATS").addEntity(Cat.class);
</pre><p>이 질의는 다음을 지정했다:</p><div class="itemizedlist"><ul><li><p>SQL 질의 문자열</p></li><li><p>그 질의에 의해 반환되는 엔티티</p></li></ul></div><p>Cat이 컬럼 ID, NAME 그리고 BIRTHDATE로서 매핑된다고 가정하면, 위의 질의들은 둘다 각각의 요소가 하나의 Cat 엔티티인 하나의 List를 반환할 것이다.</p><p>만일 그 엔티티가 또 다른 엔티티에 대해 <code class="literal">many-to-one</code>로 매핑되어 있다면 또한 native 질의를 실행할 때 이것을 반환하는 것이 필수적고, 그 밖의 경우 데이터베이스 지정적인 "컬럼이 발견되지 않았습니다" 오류가 일어날 것이다. 추가적인 컬럼은 * 표기를 사용할 자동적으로 반환될 것이지만, 우리는 다음 <code class="literal">Dog</code>에 대한 <code class="literal">many-to-one</code> 예제에서처럼 명시적인 것을 더 선호한다:</p><pre class="programlisting">sess.createSQLQuery("SELECT ID, NAME, BIRTHDATE, DOG_ID FROM CATS").addEntity(Cat.class);
</pre><p>이것은 cat.getDog()이 고유하게 기능하는 것을 허용한다.</p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13400"/>16.1.3. 연관들과 콜렉션들을 처리하기</h3></div></div></div><p>프락시를 초기화 시킴에 있어 가능한 특별한 라운드트립을 피하기 위해서 <code class="literal">Dog</code>에서 eagerly join시키는 것이 간으하다. 이것은 <code class="literal">addJoin()</code> 메소드를 통해 행해지는데, 그것은 연관이나 콜렉션 내에서 조인시키는 것을 당신에게 허용해준다.</p><pre class="programlisting">sess.createSQLQuery("SELECT c.ID, NAME, BIRTHDATE, DOG_ID, D_ID, D_NAME FROM CATS c, DOGS d WHERE c.DOG_ID = d.D_ID")
 .addEntity("cat", Cat.class)
 .addJoin("cat.dog");
</pre><p>In this example, the returned <code class="literal">Cat</code>'s will have their <code class="literal">dog</code> property fully initialized without any extra roundtrip to the database. Notice that you added an alias name ("cat") to be able to specify the target property path of the join. It is possible to do the same eager joining for collections, e.g. if the <code class="literal">Cat</code> had a one-to-many to <code class="literal">Dog</code> instead.</p><pre class="programlisting">sess.createSQLQuery("SELECT ID, NAME, BIRTHDATE, D_ID, D_NAME, CAT_ID FROM CATS c, DOGS d WHERE c.ID = d.CAT_ID")
 .addEntity("cat", Cat.class)
 .addJoin("cat.dogs");
</pre><p>At this stage you are reaching the limits of what is possible with native queries, without starting to enhance the sql queries to make them usable in Hibernate. Problems can arise when returning multiple entities of the same type or when the default alias/column names are not enough. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13431"/>16.1.4. 여러 개의 엔티티들을 반환하기</h3></div></div></div><p>Until now, the result set column names are assumed to be the same as the column names specified in the mapping document. This can be problematic for SQL queries that join multiple tables, since the same column names can appear in more than one table.</p><p>컬럼 alias 주입은 다음 질의(아마 실패할 것이다)에서 필요하다:</p><pre class="programlisting">sess.createSQLQuery("SELECT c.*, m.*  FROM CATS c, CATS m WHERE c.MOTHER_ID = c.ID")
 .addEntity("cat", Cat.class)
 .addEntity("mother", Cat.class)
</pre><p>The query was intended to return two Cat instances per row: a cat and its mother. The query will, however, fail because there is a conflict of names; the instances are mapped to the same column names. Also, on some databases the returned column aliases will most likely be on the form "c.ID", "c.NAME", etc. which are not equal to the columns specified in the mappings ("ID" and "NAME"). </p><p>다음 형식은 컬럼 이름 중복 취약점을 갖지 않는다:</p><pre class="programlisting">sess.createSQLQuery("SELECT {cat.*}, {mother.*}  FROM CATS c, CATS m WHERE c.MOTHER_ID = c.ID")
 .addEntity("cat", Cat.class)
 .addEntity("mother", Cat.class)
</pre><p>이 질의는 다음을 지정했다:</p><div class="itemizedlist"><ul><li><p>컬럼 alias들을 주입하기 위한 Hibernate용 placeholder들을 가진 SQL 질의 문자열</p></li><li><p>그 질의에 의해 반환되는 엔티티들</p></li></ul></div><p>The {cat.*} and {mother.*} notation used above is a shorthand for "all properties". Alternatively, you can list the columns explicitly, but even in this case Hibernate injects the SQL column aliases for each property. The placeholder for a column alias is just the property name qualified by the table alias. In the following example, you retrieve Cats and their mothers from a different table (cat_log) to the one declared in the mapping metadata. You can even use the property aliases in the where clause.</p><pre class="programlisting">String sql = "SELECT ID as {c.id}, NAME as {c.name}, " + 
         "BIRTHDATE as {c.birthDate}, MOTHER_ID as {c.mother}, {mother.*} " +
         "FROM CAT_LOG c, CAT_LOG m WHERE {c.mother} = c.ID";

List loggedCats = sess.createSQLQuery(sql)
        .addEntity("cat", Cat.class)
        .addEntity("mother", Cat.class).list()
</pre><div class="sect3" lang="ko-KR"><div class="titlepage"><div><div><h4 class="title"><a id="querysql-aliasreferences"/>16.1.4.1. alias 참조와 프로퍼티 참조</h4></div></div></div><p>In most cases the above alias injection is needed. For queries relating to more complex mappings, like composite properties, inheritance discriminators, collections etc., you can use specific aliases that allow Hibernate to inject the proper aliases.</p><p>The following table shows the different ways you can use the alias injection. Please note that the alias names in the result are simply examples; each alias will have a unique and probably different name when used.</p><div class="table"><a id="aliasinjection-summary"/><p class="title"><b>표 16.1. alias 주입 이름들</b></p><div class="table-contents"><table summary="alias 주입 이름들" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>설명</th><th>구문</th><th>예제</th></tr></thead><tbody><tr><td>간단한 프로퍼티</td><td><code class="literal">{[aliasname].[propertyname]</code></td><td><code class="literal">A_NAME as {item.name}</code></td></tr><tr><td>composite 프로퍼티</td><td><code class="literal">{[aliasname].[componentname].[propertyname]}</code></td><td><code class="literal">CURRENCY as {item.amount.currency}, VALUE as {item.amount.value}</code></td></tr><tr><td>엔티티의 판별자(Discriminator)</td><td><code class="literal">{[aliasname].class}</code></td><td><code class="literal">DISC as {item.class}</code></td></tr><tr><td>엔티티의 모든 프로퍼티들</td><td><code class="literal">{[aliasname].*}</code></td><td><code class="literal">{item.*}</code></td></tr><tr><td>콜렉션 키</td><td><code class="literal">{[aliasname].key}</code></td><td><code class="literal">ORGID as {coll.key}</code></td></tr><tr><td>콜렉션의 id</td><td><code class="literal">{[aliasname].id}</code></td><td><code class="literal">EMPID as {coll.id}</code></td></tr><tr><td>콜렉션의 요소</td><td><code class="literal">{[aliasname].element}</code></td><td><code class="literal">XID as {coll.element}</code></td></tr><tr><td>property of the element in the collection</td><td><code class="literal">{[aliasname].element.[propertyname]}</code></td><td><code class="literal">NAME as {coll.element.name}</code></td></tr><tr><td>콜렉션 내에 있는 요소의 모든 프로퍼티들</td><td><code class="literal">{[aliasname].element.*}</code></td><td><code class="literal">{coll.element.*}</code></td></tr><tr><td>콜렉션의 모든 프로퍼티들</td><td><code class="literal">{[aliasname].*}</code></td><td><code class="literal">{coll.*}</code></td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13572"/>16.1.5. non-managed 엔티티들을 반환하기</h3></div></div></div><p>It is possible to apply a ResultTransformer to native SQL queries, allowing it to return non-managed entities.</p><pre class="programlisting">sess.createSQLQuery("SELECT NAME, BIRTHDATE FROM CATS")
        .setResultTransformer(Transformers.aliasToBean(CatDTO.class))</pre><p>이 질의는 다음을 지정했다:</p><div class="itemizedlist"><ul><li><p>SQL 질의 문자열</p></li><li><p>결과 변환자(transformer)</p></li></ul></div><p>위의 질의는 초기화되어 있고 NAME과 BIRTHNAME의 값들을 <code class="literal">CatDTO</code>의 대응하는 프로퍼티들과 필드들 속으로 주입시킨 <code class="literal">CatDTO</code>의 리스트를 반환할 것이다. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13596"/>16.1.6. 상속 처리하기</h3></div></div></div><p>Native SQL queries which query for entities that are mapped as part of an inheritance must include all properties for the baseclass and all its subclasses.</p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13601"/>16.1.7. 파라미터들</h3></div></div></div><p>Native SQL queries support positional as well as named parameters:</p><pre class="programlisting">Query query = sess.createSQLQuery("SELECT * FROM CATS WHERE NAME like ?").addEntity(Cat.class);
List pusList = query.setString(0, "Pus%").list();
     
query = sess.createSQLQuery("SELECT * FROM CATS WHERE NAME like :name").addEntity(Cat.class);
List pusList = query.setString("name", "Pus%").list();          </pre></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="querysql-namedqueries"/>16.2. 명명된 SQL 질의들</h2></div></div></div><p>Named SQL queries can be defined in the mapping document and called in exactly the same way as a named HQL query. In this case, you do <span class="emphasis"><em>not</em></span> need to call <code class="literal">addEntity()</code>.</p><pre class="programlisting">&lt;sql-query name="persons"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex}
    FROM PERSON person
    WHERE person.NAME LIKE :namePattern
&lt;/sql-query&gt;</pre><pre class="programlisting">List people = sess.getNamedQuery("persons")
    .setString("namePattern", namePattern)
    .setMaxResults(50)
    .list();</pre><p>The <code class="literal">&lt;return-join&gt;</code> element is use to join associations and the <code class="literal">&lt;load-collection&gt;</code> element is used to define queries which initialize collections, </p><pre class="programlisting">&lt;sql-query name="personsWith"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    &lt;return-join alias="address" property="person.mailingAddress"/&gt;
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex},
           address.STREET AS {address.street},
           address.CITY AS {address.city},
           address.STATE AS {address.state},
           address.ZIP AS {address.zip}
    FROM PERSON person
    JOIN ADDRESS address
        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'
    WHERE person.NAME LIKE :namePattern
&lt;/sql-query&gt;</pre><p>명명된 SQL 질의는 스칼라 값을 반환할수도 있다. 당신은 <code class="literal">&lt;return-scalar&gt;</code> 요소를 사용하여 컬럼 alias와 Hibernate 타입을 선언해야 한다:</p><pre class="programlisting">&lt;sql-query name="mySqlQuery"&gt;
    &lt;return-scalar column="name" type="string"/&gt;
    &lt;return-scalar column="age" type="long"/&gt;
    SELECT p.NAME AS name,
           p.AGE AS age,
    FROM PERSON p WHERE p.NAME LIKE 'Hiber%'
&lt;/sql-query&gt;</pre><p>You can externalize the resultset mapping information in a <code class="literal">&lt;resultset&gt;</code> element which will allow you to either reuse them across several named queries or through the <code class="literal">setResultSetMapping()</code> API.</p><pre class="programlisting">&lt;resultset name="personAddress"&gt;
    &lt;return alias="person" class="eg.Person"/&gt;
    &lt;return-join alias="address" property="person.mailingAddress"/&gt;
&lt;/resultset&gt;

&lt;sql-query name="personsWith" resultset-ref="personAddress"&gt;
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex},
           address.STREET AS {address.street},
           address.CITY AS {address.city},
           address.STATE AS {address.state},
           address.ZIP AS {address.zip}
    FROM PERSON person
    JOIN ADDRESS address
        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'
    WHERE person.NAME LIKE :namePattern
&lt;/sql-query&gt;</pre><p>You can, alternatively, use the resultset mapping information in your hbm files directly in java code.</p><pre class="programlisting">List cats = sess.createSQLQuery(
        "select {cat.*}, {kitten.*} from cats cat, cats kitten where kitten.mother = cat.id"
    )
    .setResultSetMapping("catAndKitten")
    .list();</pre><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="propertyresults"/>16.2.1. 명시적으로 column/alias 이름들을 지정하는데 return-property 사용하기</h3></div></div></div><p>You can explicitly tell Hibernate what column aliases to use with <code class="literal">&lt;return-property&gt;</code>, instead of using the <code class="literal">{}</code>-syntax to let Hibernate inject its own aliases.For example:</p><pre class="programlisting">&lt;sql-query name="mySqlQuery"&gt;
    &lt;return alias="person" class="eg.Person"&gt;
        &lt;return-property name="name" column="myName"/&gt;
        &lt;return-property name="age" column="myAge"/&gt;
        &lt;return-property name="sex" column="mySex"/&gt;
    &lt;/return&gt;
    SELECT person.NAME AS myName,
           person.AGE AS myAge,
           person.SEX AS mySex,
    FROM PERSON person WHERE person.NAME LIKE :name
&lt;/sql-query&gt;
</pre><p><code class="literal">&lt;return-property&gt;</code> also works with multiple columns. This solves a limitation with the <code class="literal">{}</code>-syntax which cannot allow fine grained control of multi-column properties.</p><pre class="programlisting">&lt;sql-query name="organizationCurrentEmployments"&gt;
    &lt;return alias="emp" class="Employment"&gt;
        &lt;return-property name="salary"&gt;
            &lt;return-column name="VALUE"/&gt;
            &lt;return-column name="CURRENCY"/&gt;
        &lt;/return-property&gt;
        &lt;return-property name="endDate" column="myEndDate"/&gt;
    &lt;/return&gt;
        SELECT EMPLOYEE AS {emp.employee}, EMPLOYER AS {emp.employer},
        STARTDATE AS {emp.startDate}, ENDDATE AS {emp.endDate},
        REGIONCODE as {emp.regionCode}, EID AS {emp.id}, VALUE, CURRENCY
        FROM EMPLOYMENT
        WHERE EMPLOYER = :id AND ENDDATE IS NULL
        ORDER BY STARTDATE ASC
&lt;/sql-query&gt;</pre><p>In this example <code class="literal">&lt;return-property&gt;</code> was used in combination with the <code class="literal">{}</code>-syntax for injection. This allows users to choose how they want to refer column and properties.</p><p>만일 당신의 매핑이 한 개의 판별자(discriminator )를 가질 경우 당신은 판별자 컬럼을 지정하는데 <code class="literal">&lt;return-discriminator&gt;</code>를 사용해야 한다.</p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="sp_query"/>16.2.2. 질의를 위한 내장 프로시저 사용하기</h3></div></div></div><p>Hibernate3 provides support for queries via stored procedures and functions. Most of the following documentation is equivalent for both. The stored procedure/function must return a resultset as the first out-parameter to be able to work with Hibernate. An example of such a stored function in Oracle 9 and higher is as follows:</p><pre class="programlisting">CREATE OR REPLACE FUNCTION selectAllEmployments
    RETURN SYS_REFCURSOR
AS
    st_cursor SYS_REFCURSOR;
BEGIN
    OPEN st_cursor FOR
 SELECT EMPLOYEE, EMPLOYER,
 STARTDATE, ENDDATE,
 REGIONCODE, EID, VALUE, CURRENCY
 FROM EMPLOYMENT;
      RETURN  st_cursor;
 END;</pre><p>Hibernate에서 이 질의를 사용하기 위해 당신은 하나의 명명된 질의(a named query)를 통해 그것을 매핑할 필요가 있다.</p><pre class="programlisting">&lt;sql-query name="selectAllEmployees_SP" callable="true"&gt;
    &lt;return alias="emp" class="Employment"&gt;
        &lt;return-property name="employee" column="EMPLOYEE"/&gt;
        &lt;return-property name="employer" column="EMPLOYER"/&gt;
        &lt;return-property name="startDate" column="STARTDATE"/&gt;
        &lt;return-property name="endDate" column="ENDDATE"/&gt;
        &lt;return-property name="regionCode" column="REGIONCODE"/&gt;
        &lt;return-property name="id" column="EID"/&gt;
        &lt;return-property name="salary"&gt;
            &lt;return-column name="VALUE"/&gt;
            &lt;return-column name="CURRENCY"/&gt;
        &lt;/return-property&gt;
    &lt;/return&gt;
    { ? = call selectAllEmployments() }
&lt;/sql-query&gt;</pre><p>Stored procedures currently only return scalars and entities. <code class="literal">&lt;return-join&gt;</code> and <code class="literal">&lt;load-collection&gt;</code> are not supported.</p><div class="sect3" lang="ko-KR"><div class="titlepage"><div><div><h4 class="title"><a id="querysql-limits-storedprocedures"/>16.2.2.1. 내장 프로시저들을 사용하는 규칙들/제약들</h4></div></div></div><p>You cannot use stored procedures with Hibernate unless you follow some procedure/function rules. If they do not follow those rules they are not usable with Hibernate. If you still want to use these procedures you have to execute them via <code class="literal">session.connection()</code>. The rules are different for each database, since database vendors have different stored procedure semantics/syntax.</p><p>Stored procedure queries cannot be paged with <code class="literal">setFirstResult()/setMaxResults()</code>.</p><p>The recommended call form is standard SQL92: <code class="literal">{ ? = call functionName(&lt;parameters&gt;) }</code> or <code class="literal">{ ? = call procedureName(&lt;parameters&gt;}</code>. Native call syntax is not supported.</p><p>Oracle의 경우 다음 규칙들이 적용된다:</p><div class="itemizedlist"><ul compact="compact"><li><p>A function must return a result set. The first parameter of a procedure must be an <code class="literal">OUT</code> that returns a result set. This is done by using a <code class="literal">SYS_REFCURSOR</code> type in Oracle 9 or 10. In Oracle you need to define a <code class="literal">REF CURSOR</code> type. See Oracle literature for further information.</p></li></ul></div><p>Sybase 또는 MS SQL server의 경우 다음 규칙들이 적용된다:</p><div class="itemizedlist"><ul compact="compact"><li><p>The procedure must return a result set. Note that since these servers can return multiple result sets and update counts, Hibernate will iterate the results and take the first result that is a result set as its return value. Everything else will be discarded.</p></li><li><p>만일 당신이 당신의 프로시저 내에 <code class="literal">SET NOCOUNT ON</code>을 이용 가능하게 할 수 있다면 그것은 아마 보다 효율적이게 될 것이지만 이것은 필요 조건이 아니다.</p></li></ul></div></div></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="querysql-cud"/>16.3. create, update 그리고 delete를 위한 맞춤형 SQL</h2></div></div></div><p>Hibernate3는 create, update, delete 오퍼레이션들을 위한 맞춤형 문장들을 사용할 수 있다. Hibernate에서 클래스와 콜렉션 영속자들은 구성 시에 생성된 문자열들의 집합(insertsql, deletesql, updatesql 등)을 이미 포함하고 있다. <code class="literal">&lt;sql-insert&gt;</code>, <code class="literal">&lt;sql-delete&gt;</code>, <code class="literal">&lt;sql-update&gt;</code> 매핑 태그들은 이들 문자열들을 오버라이드 시킨다:</p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true"/&gt;
    &lt;sql-insert&gt;INSERT INTO PERSON (NAME, ID) VALUES ( UPPER(?), ? )&lt;/sql-insert&gt;
    &lt;sql-update&gt;UPDATE PERSON SET NAME=UPPER(?) WHERE ID=?&lt;/sql-update&gt;
    &lt;sql-delete&gt;DELETE FROM PERSON WHERE ID=?&lt;/sql-delete&gt;
&lt;/class&gt;</pre><p>The SQL is directly executed in your database, so you can use any dialect you like. This will reduce the portability of your mapping if you use database specific SQL.</p><p>만일 <code class="literal">callable</code> 속성이 설정되면 내장 프로시저들이 지원된다:</p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true"/&gt;
    &lt;sql-insert callable="true"&gt;{call createPerson (?, ?)}&lt;/sql-insert&gt;
    &lt;sql-delete callable="true"&gt;{? = call deletePerson (?)}&lt;/sql-delete&gt;
    &lt;sql-update callable="true"&gt;{? = call updatePerson (?, ?)}&lt;/sql-update&gt;
&lt;/class&gt;</pre><p>The order of the positional parameters is vital, as they must be in the same sequence as Hibernate expects them.</p><p>You can view the expected order by enabling debug logging for the <code class="literal">org.hibernate.persister.entity</code> level. With this level enabled, Hibernate will print out the static SQL that is used to create, update, delete etc. entities. To view the expected sequence, do not include your custom SQL in the mapping files, as this will override the Hibernate generated static SQL.</p><p>The stored procedures are in most cases required to return the number of rows inserted, updated and deleted, as Hibernate has some runtime checks for the success of the statement. Hibernate always registers the first statement parameter as a numeric output parameter for the CUD operations:</p><pre class="programlisting">CREATE OR REPLACE FUNCTION updatePerson (uid IN NUMBER, uname IN VARCHAR2)
    RETURN NUMBER IS
BEGIN

    update PERSON
    set
        NAME = uname,
    where
        ID = uid;

    return SQL%ROWCOUNT;

END updatePerson;</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="querysql-load"/>16.4. 로딩을 위한 맞춤형 SQL</h2></div></div></div><p>You can also declare your own SQL (or HQL) queries for entity loading:</p><pre class="programlisting">&lt;sql-query name="person"&gt;
    &lt;return alias="pers" class="Person" lock-mode="upgrade"/&gt;
    SELECT NAME AS {pers.name}, ID AS {pers.id}
    FROM PERSON
    WHERE ID=?
    FOR UPDATE
&lt;/sql-query&gt;</pre><p>This is just a named query declaration, as discussed earlier. You can reference this named query in a class mapping:</p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="id"&gt;
        &lt;generator class="increment"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true"/&gt;
    &lt;loader query-ref="person"/&gt;
&lt;/class&gt;</pre><p>이것은 심지어 내장 프로시저들에 동작한다.</p><p>You can even define a query for collection loading:</p><pre class="programlisting">&lt;set name="employments" inverse="true"&gt;
    &lt;key/&gt;
    &lt;one-to-many class="Employment"/&gt;
    &lt;loader query-ref="employments"/&gt;
&lt;/set&gt;</pre><pre class="programlisting">&lt;sql-query name="employments"&gt;
    &lt;load-collection alias="emp" role="Person.employments"/&gt;
    SELECT {emp.*}
    FROM EMPLOYMENT emp
    WHERE EMPLOYER = :id
    ORDER BY STARTDATE ASC, EMPLOYEE ASC
&lt;/sql-query&gt;</pre><p>You can also define an entity loader that loads a collection by join fetching:</p><pre class="programlisting">&lt;sql-query name="person"&gt;
    &lt;return alias="pers" class="Person"/&gt;
    &lt;return-join alias="emp" property="pers.employments"/&gt;
    SELECT NAME AS {pers.*}, {emp.*}
    FROM PERSON pers
    LEFT OUTER JOIN EMPLOYMENT emp
        ON pers.ID = emp.PERSON_ID
    WHERE ID=?
&lt;/sql-query&gt;</pre></div></div><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="filters"/>17장. 데이터 필터링하기</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#objectstate-filters">17.1. Hibernate 필터들</a></span></dt></dl></div><p>Hibernate3 provides an innovative new approach to handling data with "visibility" rules. A <span class="emphasis"><em>Hibernate filter</em></span> is a global, named, parameterized filter that can be enabled or disabled for a particular Hibernate session. </p><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="objectstate-filters"/>17.1. Hibernate 필터들</h2></div></div></div><p>Hibernate3 has the ability to pre-define filter criteria and attach those filters at both a class level and a collection level. A filter criteria allows you to define a restriction clause similar to the existing "where" attribute available on the class and various collection elements. These filter conditions, however, can be parameterized. The application can then decide at runtime whether certain filters should be enabled and what their parameter values should be. Filters can be used like database views, but they are parameterized inside the application. </p><p>필터들을 사용하기 위해서, 그것들은 먼저 정의되고 나서 적절한 매핑 요소들에 첨가되어야 한다. 필터를 정의하기 위해, <code class="literal">&lt;hibernate-mapping/&gt;</code> 요소 내부에 <code class="literal">&lt;filter-def/&gt;</code> 요소를 사용하라: </p><pre class="programlisting">&lt;filter-def name="myFilter"&gt;
    &lt;filter-param name="myFilterParam" type="string"/&gt;
&lt;/filter-def&gt;</pre><p>This filter can then be attached to a class: </p><pre class="programlisting">&lt;class name="myClass" ...&gt;
    ...
    &lt;filter name="myFilter" condition=":myFilterParam = MY_FILTERED_COLUMN"/&gt;
&lt;/class&gt;</pre><p>Or, to a collection: </p><pre class="programlisting">&lt;set ...&gt;
    &lt;filter name="myFilter" condition=":myFilterParam = MY_FILTERED_COLUMN"/&gt;
&lt;/set&gt;</pre><p>Or, to both or multiples of each at the same time. </p><p>The methods on <code class="literal">Session</code> are: <code class="literal">enableFilter(String filterName)</code>, <code class="literal">getEnabledFilter(String filterName)</code>, and <code class="literal">disableFilter(String filterName)</code>. By default, filters are <span class="emphasis"><em>not</em></span> enabled for a given session. Filters must be enabled through use of the <code class="literal">Session.enableFilter()</code> method, which returns an instance of the <code class="literal">Filter</code> interface. If you used the simple filter defined above, it would look like this: </p><pre class="programlisting">session.enableFilter("myFilter").setParameter("myFilterParam", "some-value");</pre><p>Methods on the org.hibernate.Filter interface do allow the method-chaining common to much of Hibernate. </p><p>The following is a full example, using temporal data with an effective record date pattern: </p><pre class="programlisting">&lt;filter-def name="effectiveDate"&gt;
    &lt;filter-param name="asOfDate" type="date"/&gt;
&lt;/filter-def&gt;

&lt;class name="Employee" ...&gt;
...
    &lt;many-to-one name="department" column="dept_id" class="Department"/&gt;
    &lt;property name="effectiveStartDate" type="date" column="eff_start_dt"/&gt;
    &lt;property name="effectiveEndDate" type="date" column="eff_end_dt"/&gt;
...
    &lt;!--
        Note that this assumes non-terminal records have an eff_end_dt set to
        a max db date for simplicity-sake
    --&gt;
    &lt;filter name="effectiveDate"
            condition=":asOfDate BETWEEN eff_start_dt and eff_end_dt"/&gt;
&lt;/class&gt;

&lt;class name="Department" ...&gt;
...
    &lt;set name="employees" lazy="true"&gt;
        &lt;key column="dept_id"/&gt;
        &lt;one-to-many class="Employee"/&gt;
        &lt;filter name="effectiveDate"
                condition=":asOfDate BETWEEN eff_start_dt and eff_end_dt"/&gt;
    &lt;/set&gt;
&lt;/class&gt;</pre><p>In order to ensure that you are provided with currently effective records, enable the filter on the session prior to retrieving employee data: </p><pre class="programlisting">Session session = ...;
session.enableFilter("effectiveDate").setParameter("asOfDate", new Date());
List results = session.createQuery("from Employee as e where e.salary &gt; :targetSalary")
         .setLong("targetSalary", new Long(1000000))
         .list();
</pre><p>Even though a salary constraint was mentioned explicitly on the results in the above HQL, because of the enabled filter, the query will return only currently active employees who have a salary greater than one million dollars. </p><p>If you want to use filters with outer joining, either through HQL or load fetching, be careful of the direction of the condition expression. It is safest to set this up for left outer joining. Place the parameter first followed by the column name(s) after the operator. </p><p>After being defined, a filter might be attached to multiple entities and/or collections each with its own condition. This can be problematic when the conditions are the same each time. Using <code class="literal">&lt;filter-def/&gt;</code> allows you to definine a default condition, either as an attribute or CDATA: </p><pre class="programlisting">&lt;filter-def name="myFilter" condition="abc &gt; xyz"&gt;...&lt;/filter-def&gt;
&lt;filter-def name="myOtherFilter"&gt;abc=xyz&lt;/filter-def&gt;</pre><p>This default condition will be used whenever the filter is attached to something without specifying a condition. This means you can give a specific condition as part of the attachment of the filter that overrides the default condition in that particular case. </p></div></div><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="xml"/>18장. XML 매핑</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#xml-intro">18.1. XML 데이터로 작업하기</a></span></dt><dd><dl><dt><span class="sect2"><a href="#xml-intro-mapping">18.1.1. XML과 클래스 매핑을 함께 지정하기</a></span></dt><dt><span class="sect2"><a href="#xml-onlyxml">18.1.2. XML 매핑만을 지정하기</a></span></dt></dl></dd><dt><span class="sect1"><a href="#xml-mapping">18.2. XML 매핑 메타데이터</a></span></dt><dt><span class="sect1"><a href="#xml-manipulation">18.3. XML 데이터 처리하기</a></span></dt></dl></div><p><span class="emphasis"><em>XML Mapping is an experimental feature in Hibernate 3.0 and is currently under active development. </em></span></p><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="xml-intro"/>18.1. XML 데이터로 작업하기</h2></div></div></div><p>Hibernate allows you to work with persistent XML data in much the same way you work with persistent POJOs. A parsed XML tree can be thought of as another way of representing the relational data at the object level, instead of POJOs. </p><p>Hibernate는 XML 트리들을 처리하는 API로서 dom4j를 지원한다. 당신은 데이터베이스로부터 dom4j 트리들을 검색하고 당신이 그 트리를 데이터베이스와 자동적으로 동기화시키기 위해 어떤 변경을 행하도록 하는 질의들을 작성할 수 있다. 당신은 심지어 XML 문서를 취하고, dom4j를 사용하여 그것을 파싱하고, Hibernate의 다음 기본적인 오퍼레이션들 중 어떤 것으로서 그것을 데이터베이스에 저장시킬 수 있다: <code class="literal">persist(), saveOrUpdate(), merge(), delete(), replicate()</code>(merging(병합)은 아직 지원되지 않는다). </p><p>이 특징은 데이터 가져오기/내보내기,JMS 또는 SOAP 그리고 XSLT-기반의 레포팅을 통한 엔티티 데이터의 구체화를 포함하는 많은 어플리케이션들을 갖는다. </p><p>A single mapping can be used to simultaneously map properties of a class and nodes of an XML document to the database, or, if there is no class to map, it can be used to map just the XML. </p><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="xml-intro-mapping"/>18.1.1. XML과 클래스 매핑을 함께 지정하기</h3></div></div></div><p>다음은 POJO와 XML을 동시에 매핑시키는 예제이다 : </p><pre class="programlisting">&lt;class name="Account" 
        table="ACCOUNTS" 
        node="account"&gt;
        
    &lt;id name="accountId" 
            column="ACCOUNT_ID" 
            node="@id"/&gt;
            
    &lt;many-to-one name="customer" 
            column="CUSTOMER_ID" 
            node="customer/@id" 
            embed-xml="false"/&gt;
            
    &lt;property name="balance" 
            column="BALANCE" 
            node="balance"/&gt;
            
    ...
    
&lt;/class&gt;</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="xml-onlyxml"/>18.1.2. XML 매핑만을 지정하기</h3></div></div></div><p>다음은 POJO 클래스가 존재하지 않는 예제이다: </p><pre class="programlisting">&lt;class entity-name="Account" 
        table="ACCOUNTS" 
        node="account"&gt;
        
    &lt;id name="id" 
            column="ACCOUNT_ID" 
            node="@id" 
            type="string"/&gt;
            
    &lt;many-to-one name="customerId" 
            column="CUSTOMER_ID" 
            node="customer/@id" 
            embed-xml="false" 
            entity-name="Customer"/&gt;
            
    &lt;property name="balance" 
            column="BALANCE" 
            node="balance" 
            type="big_decimal"/&gt;
            
    ...
    
&lt;/class&gt;</pre><p>This mapping allows you to access the data as a dom4j tree, or as a graph of property name/value pairs or java <code class="literal">Map</code>s. The property names are purely logical constructs that can be referred to in HQL queries. </p></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="xml-mapping"/>18.2. XML 매핑 메타데이터</h2></div></div></div><p>A range of Hibernate mapping elements accept the <code class="literal">node</code> attribute. This lets you specify the name of an XML attribute or element that holds the property or entity data. The format of the <code class="literal">node</code> attribute must be one of the following: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">"element-name"</code>: map to the named XML element</p></li><li><p><code class="literal">"@attribute-name"</code>: map to the named XML attribute</p></li><li><p><code class="literal">"."</code>: map to the parent element</p></li><li><p><code class="literal">"element-name/@attribute-name"</code>: map to the named attribute of the named element </p></li></ul></div><p>For collections and single valued associations, there is an additional <code class="literal">embed-xml</code> attribute. If <code class="literal">embed-xml="true"</code>, the default, the XML tree for the associated entity (or collection of value type) will be embedded directly in the XML tree for the entity that owns the association. Otherwise, if <code class="literal">embed-xml="false"</code>, then only the referenced identifier value will appear in the XML for single point associations and collections will not appear at all. </p><p>Do not leave <code class="literal">embed-xml="true"</code> for too many associations, since XML does not deal well with circularity. </p><pre class="programlisting">&lt;class name="Customer" 
        table="CUSTOMER" 
        node="customer"&gt;
        
    &lt;id name="id" 
            column="CUST_ID" 
            node="@id"/&gt;
            
    &lt;map name="accounts" 
            node="." 
            embed-xml="true"&gt;
        &lt;key column="CUSTOMER_ID" 
                not-null="true"/&gt;
        &lt;map-key column="SHORT_DESC" 
                node="@short-desc" 
                type="string"/&gt;
        &lt;one-to-many entity-name="Account"
                embed-xml="false" 
                node="account"/&gt;
    &lt;/map&gt;
    
    &lt;component name="name" 
            node="name"&gt;
        &lt;property name="firstName" 
                node="first-name"/&gt;
        &lt;property name="initial" 
                node="initial"/&gt;
        &lt;property name="lastName" 
                node="last-name"/&gt;
    &lt;/component&gt;
    
    ...
    
&lt;/class&gt;</pre><p>In this case, the collection of account ids is embedded, but not the actual account data. The following HQL query: </p><pre class="programlisting">from Customer c left join fetch c.accounts where c.lastName like :lastName</pre><p>would return datasets such as this: </p><pre class="programlisting">&lt;customer id="123456789"&gt;
    &lt;account short-desc="Savings"&gt;987632567&lt;/account&gt;
    &lt;account short-desc="Credit Card"&gt;985612323&lt;/account&gt;
    &lt;name&gt;
        &lt;first-name&gt;Gavin&lt;/first-name&gt;
        &lt;initial&gt;A&lt;/initial&gt;
        &lt;last-name&gt;King&lt;/last-name&gt;
    &lt;/name&gt;
    ...
&lt;/customer&gt;</pre><p>만일 당신이 <code class="literal">&lt;one-to-many&gt;</code> 매핑에 대해 <code class="literal">embed-xml="true"</code>를 설정할 경우, 데이터는 다음과 같이 보일 수도 있다: </p><pre class="programlisting">&lt;customer id="123456789"&gt;
    &lt;account id="987632567" short-desc="Savings"&gt;
        &lt;customer id="123456789"/&gt;
        &lt;balance&gt;100.29&lt;/balance&gt;
    &lt;/account&gt;
    &lt;account id="985612323" short-desc="Credit Card"&gt;
        &lt;customer id="123456789"/&gt;
        &lt;balance&gt;-2370.34&lt;/balance&gt;
    &lt;/account&gt;
    &lt;name&gt;
        &lt;first-name&gt;Gavin&lt;/first-name&gt;
        &lt;initial&gt;A&lt;/initial&gt;
        &lt;last-name&gt;King&lt;/last-name&gt;
    &lt;/name&gt;
    ...
&lt;/customer&gt;</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="xml-manipulation"/>18.3. XML 데이터 처리하기</h2></div></div></div><p>You can also re-read and update XML documents in the application. You can do this by obtaining a dom4j session: </p><pre class="programlisting">Document doc = ....;
       
Session session = factory.openSession();
Session dom4jSession = session.getSession(EntityMode.DOM4J);
Transaction tx = session.beginTransaction();

List results = dom4jSession
    .createQuery("from Customer c left join fetch c.accounts where c.lastName like :lastName")
    .list();
for ( int i=0; i&lt;results.size(); i++ ) {
    //add the customer data to the XML document
    Element customer = (Element) results.get(i);
    doc.add(customer);
}

tx.commit();
session.close();</pre><pre class="programlisting">Session session = factory.openSession();
Session dom4jSession = session.getSession(EntityMode.DOM4J);
Transaction tx = session.beginTransaction();

Element cust = (Element) dom4jSession.get("Customer", customerId);
for ( int i=0; i&lt;results.size(); i++ ) {
    Element customer = (Element) results.get(i);
    //change the customer name in the XML and database
    Element name = customer.element("name");
    name.element("first-name").setText(firstName);
    name.element("initial").setText(initial);
    name.element("last-name").setText(lastName);
}

tx.commit();
session.close();</pre><p>When implementing XML-based data import/export, it is useful to combine this feature with Hibernate's <code class="literal">replicate()</code> operation. </p></div></div><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="performance"/>19장. 퍼포먼스 개선하기</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#performance-fetching">19.1. 페칭 방도들</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-fetching-lazy">19.1.1. lazy 연관들로 작업하기</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-custom">19.1.2. 페치 방도들을 튜닝하기</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-proxies">19.1.3. Single-ended 연관 프락시</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-initialization">19.1.4. 콜렉션들과 프락시들을 초기화 시키기</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-batch">19.1.5. batch 페칭 사용하기</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-subselect">19.1.6. subselect 페칭 사용하기</a></span></dt><dt><span class="sect2"><a href="#performance-fetching-lazyproperties">19.1.7. lazy 프로퍼티 페칭 사용하기</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-cache">19.2. 두번째 레벨 캐시</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-cache-mapping">19.2.1. Cache 매핑들</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readonly">19.2.2. 방도: 읽기 전용</a></span></dt><dt><span class="sect2"><a href="#performance-cache-readwrite">19.2.3. 방도: 읽기/쓰기</a></span></dt><dt><span class="sect2"><a href="#performance-cache-nonstrict">19.2.4. 방도: 엄격하지 않은 읽기/쓰기</a></span></dt><dt><span class="sect2"><a href="#performance-cache-transactional">19.2.5. 방도: transactional</a></span></dt><dt><span class="sect2"><a href="#performance-cache-compat-matrix">19.2.6. Cache-provider/concurrency-strategy compatibility</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-sessioncache">19.3. 캐시들을 관리하기</a></span></dt><dt><span class="sect1"><a href="#performance-querycache">19.4. 질의 캐시</a></span></dt><dt><span class="sect1"><a href="#performance-collections">19.5. 콜렉션 퍼포먼스 이해하기</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-collections-taxonomy">19.5.1. 분류</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficientupdate">19.5.2. List, map, idbag, set들은 update에 가장 효율적인 콜렉션들이다</a></span></dt><dt><span class="sect2"><a href="#performance-collections-mostefficentinverse">19.5.3. Bag들과 list들은 가장 효율적인 inverse 콜렉션들이다</a></span></dt><dt><span class="sect2"><a href="#performance-collections-oneshotdelete">19.5.4. 원 샷 delete</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-monitoring">19.6. 퍼포먼스 모니터링하기</a></span></dt><dd><dl><dt><span class="sect2"><a href="#performance-monitoring-sf">19.6.1. SessionFactory 모니터링 하기</a></span></dt><dt><span class="sect2"><a href="#performance-monitoring-metrics">19.6.2. Metrics</a></span></dt></dl></dd></dl></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-fetching"/>19.1. 페칭 방도들</h2></div></div></div><p>Hibernate uses a <span class="emphasis"><em>fetching strategy</em></span> to retrieve associated objects if the application needs to navigate the association. Fetch strategies can be declared in the O/R mapping metadata, or over-ridden by a particular HQL or <code class="literal">Criteria</code> query. </p><p>Hibernate3는 다음 페칭 방도들을 정의한다: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Join fetching</em></span>: Hibernate retrieves the associated instance or collection in the same <code class="literal">SELECT</code>, using an <code class="literal">OUTER JOIN</code>. </p></li><li><p><span class="emphasis"><em>Select fetching</em></span>: a second <code class="literal">SELECT</code> is used to retrieve the associated entity or collection. Unless you explicitly disable lazy fetching by specifying <code class="literal">lazy="false"</code>, this second select will only be executed when you access the association. </p></li><li><p><span class="emphasis"><em>Subselect fetching</em></span>: a second <code class="literal">SELECT</code> is used to retrieve the associated collections for all entities retrieved in a previous query or fetch. Unless you explicitly disable lazy fetching by specifying <code class="literal">lazy="false"</code>, this second select will only be executed when you access the association. </p></li><li><p><span class="emphasis"><em>Batch fetching</em></span>: an optimization strategy for select fetching. Hibernate retrieves a batch of entity instances or collections in a single <code class="literal">SELECT</code> by specifying a list of primary or foreign keys. </p></li></ul></div><p>Hibernate는 또한 다음 사이를 구별 짓는다: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Immediate fetching</em></span>: an association, collection or attribute is fetched immediately when the owner is loaded. </p></li><li><p><span class="emphasis"><em>Lazy collection fetching</em></span>: a collection is fetched when the application invokes an operation upon that collection. This is the default for collections. </p></li><li><p><span class="emphasis"><em>"Extra-lazy" collection fetching</em></span>: individual elements of the collection are accessed from the database as needed. Hibernate tries not to fetch the whole collection into memory unless absolutely needed. It is suitable for large collections. </p></li><li><p><span class="emphasis"><em>Proxy fetching</em></span>: a single-valued association is fetched when a method other than the identifier getter is invoked upon the associated object. </p></li><li><p><span class="emphasis"><em>"No-proxy" fetching</em></span>: a single-valued association is fetched when the instance variable is accessed. Compared to proxy fetching, this approach is less lazy; the association is fetched even when only the identifier is accessed. It is also more transparent, since no proxy is visible to the application. This approach requires buildtime bytecode instrumentation and is rarely necessary. </p></li><li><p><span class="emphasis"><em>Lazy attribute fetching</em></span>: an attribute or single valued association is fetched when the instance variable is accessed. This approach requires buildtime bytecode instrumentation and is rarely necessary. </p></li></ul></div><p>We have two orthogonal notions here: <span class="emphasis"><em>when</em></span> is the association fetched and <span class="emphasis"><em>how</em></span> is it fetched. It is important that you do not confuse them. We use <code class="literal">fetch</code> to tune performance. We can use <code class="literal">lazy</code> to define a contract for what data is always available in any detached instance of a particular class. </p><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-lazy"/>19.1.1. lazy 연관들로 작업하기</h3></div></div></div><p>By default, Hibernate3 uses lazy select fetching for collections and lazy proxy fetching for single-valued associations. These defaults make sense for most associations in the majority of applications. </p><p>If you set <code class="literal">hibernate.default_batch_fetch_size</code>, Hibernate will use the batch fetch optimization for lazy fetching. This optimization can also be enabled at a more granular level. </p><p>Please be aware that access to a lazy association outside of the context of an open Hibernate session will result in an exception. For example: </p><pre class="programlisting">s = sessions.openSession();
Transaction tx = s.beginTransaction();
            
User u = (User) s.createQuery("from User u where u.name=:userName")
    .setString("userName", userName).uniqueResult();
Map permissions = u.getPermissions();

tx.commit();
s.close();

Integer accessLevel = (Integer) permissions.get("accounts");  // Error!</pre><p>Since the permissions collection was not initialized when the <code class="literal">Session</code> was closed, the collection will not be able to load its state. <span class="emphasis"><em>Hibernate does not support lazy initialization for detached objects</em></span>. This can be fixed by moving the code that reads from the collection to just before the transaction is committed. </p><p>Alternatively, you can use a non-lazy collection or association, by specifying <code class="literal">lazy="false"</code> for the association mapping. However, it is intended that lazy initialization be used for almost all collections and associations. If you define too many non-lazy associations in your object model, Hibernate will fetch the entire database into memory in every transaction. </p><p>On the other hand, you can use join fetching, which is non-lazy by nature, instead of select fetching in a particular transaction. We will now explain how to customize the fetching strategy. In Hibernate3, the mechanisms for choosing a fetch strategy are identical for single-valued associations and collections. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-custom"/>19.1.2. 페치 방도들을 튜닝하기</h3></div></div></div><p>select 페칭(디폴트)은 N+1 selects 문제점들에 매우 취약해서, 우리는 매핑 문서에서 join 페칭을 사용 가능하게 하기를 원할 수도 있다: </p><pre class="programlisting">&lt;set name="permissions" 
            fetch="join"&gt;
    &lt;key column="userId"/&gt;
    &lt;one-to-many class="Permission"/&gt;
&lt;/set</pre><pre class="programlisting">&lt;many-to-one name="mother" class="Cat" fetch="join"/&gt;</pre><p>매핑 문서 내에 정의된 <code class="literal">fetch</code> 방도는 다음에 영향을 준다: </p><div class="itemizedlist"><ul><li><p><code class="literal">get()</code> 또는 <code class="literal">load()</code>를 통한 검색 </p></li><li><p>연관이 네비게이트될 때 함축적으로 발생하는 검색 </p></li><li><p><code class="literal">Criteria</code> 질의들 </p></li><li><p><code class="literal">subselect</code> 페칭이 사용될 경우에 HQL 질의들 </p></li></ul></div><p>Irrespective of the fetching strategy you use, the defined non-lazy graph is guaranteed to be loaded into memory. This might, however, result in several immediate selects being used to execute a particular HQL query. </p><p>Usually, the mapping document is not used to customize fetching. Instead, we keep the default behavior, and override it for a particular transaction, using <code class="literal">left join fetch</code> in HQL. This tells Hibernate to fetch the association eagerly in the first select, using an outer join. In the <code class="literal">Criteria</code> query API, you would use <code class="literal">setFetchMode(FetchMode.JOIN)</code>. </p><p>If you want to change the fetching strategy used by <code class="literal">get()</code> or <code class="literal">load()</code>, you can use a <code class="literal">Criteria</code> query. For example: </p><pre class="programlisting">User user = (User) session.createCriteria(User.class)
                .setFetchMode("permissions", FetchMode.JOIN)
                .add( Restrictions.idEq(userId) )
                .uniqueResult();</pre><p>This is Hibernate's equivalent of what some ORM solutions call a "fetch plan". </p><p>A completely different approach to problems with N+1 selects is to use the second-level cache. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-proxies"/>19.1.3. Single-ended 연관 프락시</h3></div></div></div><p>Lazy fetching for collections is implemented using Hibernate's own implementation of persistent collections. However, a different mechanism is needed for lazy behavior in single-ended associations. The target entity of the association must be proxied. Hibernate implements lazy initializing proxies for persistent objects using runtime bytecode enhancement which is accessed via the CGLIB library. </p><p>At startup, Hibernate3 generates proxies by default for all persistent classes and uses them to enable lazy fetching of <code class="literal">many-to-one</code> and <code class="literal">one-to-one</code> associations. </p><p>The mapping file may declare an interface to use as the proxy interface for that class, with the <code class="literal">proxy</code> attribute. By default, Hibernate uses a subclass of the class. <span class="emphasis"><em>The proxied class must implement a default constructor with at least package visibility. This constructor is recommended for all persistent classes</em></span>. </p><p>There are potential problems to note when extending this approach to polymorphic classes.For example: </p><pre class="programlisting">&lt;class name="Cat" proxy="Cat"&gt;
    ......
    &lt;subclass name="DomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>첫 번째로, 심지어 기본 인스턴스가 <code class="literal">DomesticCat</code>의 인스턴스인 경우조차도, <code class="literal">Cat</code>의 인스턴스들은 결코 <code class="literal">DomesticCat</code>으로 타입캐스트가 가능하지 않을 것이다: </p><pre class="programlisting">Cat cat = (Cat) session.load(Cat.class, id);  // instantiate a proxy (does not hit the db)
if ( cat.isDomesticCat() ) {                  // hit the db to initialize the proxy
    DomesticCat dc = (DomesticCat) cat;       // Error!
    ....
}</pre><p>Secondly, it is possible to break proxy <code class="literal">==</code>: </p><pre class="programlisting">Cat cat = (Cat) session.load(Cat.class, id);            // instantiate a Cat proxy
DomesticCat dc = 
        (DomesticCat) session.load(DomesticCat.class, id);  // acquire new DomesticCat proxy!
System.out.println(cat==dc);                            // false</pre><p>하지만, 그 경우는 보이는 만큼 그렇게 나쁘지는 않다. 심지어 우리가 이제 다른 프락시 객체들에 대한 두 개의 참조를 가질지라도, 기본 인스턴스는 여전히 동일한 객체들일 것이다: </p><pre class="programlisting">cat.setWeight(11.0);  // hit the db to initialize the proxy
System.out.println( dc.getWeight() );  // 11.0</pre><p>Third, you cannot use a CGLIB proxy for a <code class="literal">final</code> class or a class with any <code class="literal">final</code> methods. </p><p>Finally, if your persistent object acquires any resources upon instantiation (e.g. in initializers or default constructor), then those resources will also be acquired by the proxy. The proxy class is an actual subclass of the persistent class. </p><p>These problems are all due to fundamental limitations in Java's single inheritance model. To avoid these problems your persistent classes must each implement an interface that declares its business methods. You should specify these interfaces in the mapping file where <code class="literal">CatImpl</code> implements the interface <code class="literal">Cat</code> and <code class="literal">DomesticCatImpl</code> implements the interface <code class="literal">DomesticCat</code>. For example: </p><pre class="programlisting">&lt;class name="CatImpl" proxy="Cat"&gt;
    ......
    &lt;subclass name="DomesticCatImpl" proxy="DomesticCat"&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;</pre><p>Then proxies for instances of <code class="literal">Cat</code> and <code class="literal">DomesticCat</code> can be returned by <code class="literal">load()</code> or <code class="literal">iterate()</code>. </p><pre class="programlisting">Cat cat = (Cat) session.load(CatImpl.class, catid);
Iterator iter = session.createQuery("from CatImpl as cat where cat.name='fritz'").iterate();
Cat fritz = (Cat) iter.next();</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p><code class="literal">list()</code> does not usually return proxies. </p></div><p>관계들은 또한 lazy 초기화 된다. 이것은 당신이 임의의 프로퍼티들을 <code class="literal">CatImpl</code> 타입이 아닌 <code class="literal">Cat</code> 타입으로 선언해야 함을 의미한다. </p><p>Certain operations do <span class="emphasis"><em>not</em></span> require proxy initialization: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">equals()</code>: if the persistent class does not override <code class="literal">equals()</code> </p></li><li><p><code class="literal">hashCode()</code>: if the persistent class does not override <code class="literal">hashCode()</code> </p></li><li><p>식별자 getter 메소드 </p></li></ul></div><p>Hibernate는 <code class="literal">equals()</code> 또는 <code class="literal">hashCode()</code>를 오버라이드 시키는 영속 클래스들을 검출할 것이다. </p><p>By choosing <code class="literal">lazy="no-proxy"</code> instead of the default <code class="literal">lazy="proxy"</code>, you can avoid problems associated with typecasting. However, buildtime bytecode instrumentation is required, and all operations will result in immediate proxy initialization. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-initialization"/>19.1.4. 콜렉션들과 프락시들을 초기화 시키기</h3></div></div></div><p>A <code class="literal">LazyInitializationException</code> will be thrown by Hibernate if an uninitialized collection or proxy is accessed outside of the scope of the <code class="literal">Session</code>, i.e., when the entity owning the collection or having the reference to the proxy is in the detached state. </p><p>Sometimes a proxy or collection needs to be initialized before closing the <code class="literal">Session</code>. You can force initialization by calling <code class="literal">cat.getSex()</code> or <code class="literal">cat.getKittens().size()</code>, for example. However, this can be confusing to readers of the code and it is not convenient for generic code. </p><p>The static methods <code class="literal">Hibernate.initialize()</code> and <code class="literal">Hibernate.isInitialized()</code>, provide the application with a convenient way of working with lazily initialized collections or proxies. <code class="literal">Hibernate.initialize(cat)</code> will force the initialization of a proxy, <code class="literal">cat</code>, as long as its <code class="literal">Session</code> is still open. <code class="literal">Hibernate.initialize( cat.getKittens() )</code> has a similar effect for the collection of kittens. </p><p>Another option is to keep the <code class="literal">Session</code> open until all required collections and proxies have been loaded. In some application architectures, particularly where the code that accesses data using Hibernate, and the code that uses it are in different application layers or different physical processes, it can be a problem to ensure that the <code class="literal">Session</code> is open when a collection is initialized. There are two basic ways to deal with this issue: </p><div class="itemizedlist"><ul><li><p>In a web-based application, a servlet filter can be used to close the <code class="literal">Session</code> only at the end of a user request, once the rendering of the view is complete (the <span class="emphasis"><em>Open Session in View</em></span> pattern). Of course, this places heavy demands on the correctness of the exception handling of your application infrastructure. It is vitally important that the <code class="literal">Session</code> is closed and the transaction ended before returning to the user, even when an exception occurs during rendering of the view. See the Hibernate Wiki for examples of this "Open Session in View" pattern. </p></li><li><p>In an application with a separate business tier, the business logic must "prepare" all collections that the web tier needs before returning. This means that the business tier should load all the data and return all the data already initialized to the presentation/web tier that is required for a particular use case. Usually, the application calls <code class="literal">Hibernate.initialize()</code> for each collection that will be needed in the web tier (this call must occur before the session is closed) or retrieves the collection eagerly using a Hibernate query with a <code class="literal">FETCH</code> clause or a <code class="literal">FetchMode.JOIN</code> in <code class="literal">Criteria</code>. This is usually easier if you adopt the <span class="emphasis"><em>Command</em></span> pattern instead of a <span class="emphasis"><em>Session Facade</em></span>. </p></li><li><p>You can also attach a previously loaded object to a new <code class="literal">Session</code> with <code class="literal">merge()</code> or <code class="literal">lock()</code> before accessing uninitialized collections or other proxies. Hibernate does not, and certainly <span class="emphasis"><em>should</em></span> not, do this automatically since it would introduce impromptu transaction semantics. </p></li></ul></div><p>Sometimes you do not want to initialize a large collection, but still need some information about it, like its size, for example, or a subset of the data. </p><p>당신은 그것을 초기화 시키지 않고서 콜렉션의 사이즈를 얻는데 콜렉션 필터를 사용할 수 있다: </p><pre class="programlisting">( (Integer) s.createFilter( collection, "select count(*)" ).list().get(0) ).intValue()</pre><p><code class="literal">createFilter()</code> 메소드는 또한 전체 콜렉션을 초기화 시킬 필요 없이 콜렉션의 부분집합들을 효율적으로 검색하는데 사용된다: </p><pre class="programlisting">s.createFilter( lazyCollection, "").setFirstResult(0).setMaxResults(10).list();</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-batch"/>19.1.5. batch 페칭 사용하기</h3></div></div></div><p>Using batch fetching, Hibernate can load several uninitialized proxies if one proxy is accessed. Batch fetching is an optimization of the lazy select fetching strategy. There are two ways you can configure batch fetching: on the class level and the collection level. </p><p>Batch fetching for classes/entities is easier to understand. Consider the following example: at runtime you have 25 <code class="literal">Cat</code> instances loaded in a <code class="literal">Session</code>, and each <code class="literal">Cat</code> has a reference to its <code class="literal">owner</code>, a <code class="literal">Person</code>. The <code class="literal">Person</code> class is mapped with a proxy, <code class="literal">lazy="true"</code>. If you now iterate through all cats and call <code class="literal">getOwner()</code> on each, Hibernate will, by default, execute 25 <code class="literal">SELECT</code> statements to retrieve the proxied owners. You can tune this behavior by specifying a <code class="literal">batch-size</code> in the mapping of <code class="literal">Person</code>: </p><pre class="programlisting">&lt;class name="Person" batch-size="10"&gt;...&lt;/class&gt;</pre><p>Hibernate will now execute only three queries: the pattern is 10, 10, 5. </p><p>You can also enable batch fetching of collections. For example, if each <code class="literal">Person</code> has a lazy collection of <code class="literal">Cat</code>s, and 10 persons are currently loaded in the <code class="literal">Session</code>, iterating through all persons will generate 10 <code class="literal">SELECT</code>s, one for every call to <code class="literal">getCats()</code>. If you enable batch fetching for the <code class="literal">cats</code> collection in the mapping of <code class="literal">Person</code>, Hibernate can pre-fetch collections: </p><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;set name="cats" batch-size="3"&gt;
        ...
    &lt;/set&gt;
&lt;/class&gt;</pre><p><code class="literal">batch-size</code> 8로서, Hibernate는 4개의 SELECT들에서 3, 3, 3, 1 개의 콜렉션들을 로드시킬 것이다. 다시 그 속성의 값은 특정 <code class="literal">Session</code> 내에서 초기화 되지 않은 콜렉션들의 예상되는 개수에 의존한다. </p><p>Batch fetching of collections is particularly useful if you have a nested tree of items, i.e. the typical bill-of-materials pattern. However, a <span class="emphasis"><em>nested set</em></span> or a <span class="emphasis"><em>materialized path</em></span> might be a better option for read-mostly trees. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-subselect"/>19.1.6. subselect 페칭 사용하기</h3></div></div></div><p>If one lazy collection or single-valued proxy has to be fetched, Hibernate will load all of them, re-running the original query in a subselect. This works in the same way as batch-fetching but without the piecemeal loading. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-fetching-lazyproperties"/>19.1.7. lazy 프로퍼티 페칭 사용하기</h3></div></div></div><p>Hibernate3 supports the lazy fetching of individual properties. This optimization technique is also known as <span class="emphasis"><em>fetch groups</em></span>. Please note that this is mostly a marketing feature; optimizing row reads is much more important than optimization of column reads. However, only loading some properties of a class could be useful in extreme cases. For example, when legacy tables have hundreds of columns and the data model cannot be improved. </p><p>lazy 프로퍼티 로딩을 이용가능하게 하려면, 당신의 특정 property 매핑들에 대해 <code class="literal">lazy</code> 속성을 설정하라: </p><pre class="programlisting">&lt;class name="Document"&gt;
       &lt;id name="id"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    &lt;property name="name" not-null="true" length="50"/&gt;
    &lt;property name="summary" not-null="true" length="200" lazy="true"/&gt;
    &lt;property name="text" not-null="true" length="2000" lazy="true"/&gt;
&lt;/class&gt;</pre><p>Lazy property loading requires buildtime bytecode instrumentation. If your persistent classes are not enhanced, Hibernate will ignore lazy property settings and return to immediate fetching. </p><p>bytecode 수단으로, 다음 Ant 태스크를 사용하라: </p><pre class="programlisting">&lt;target name="instrument" depends="compile"&gt;
    &lt;taskdef name="instrument" classname="org.hibernate.tool.instrument.InstrumentTask"&gt;
        &lt;classpath path="${jar.path}"/&gt;
        &lt;classpath path="${classes.dir}"/&gt;
        &lt;classpath refid="lib.class.path"/&gt;
    &lt;/taskdef&gt;

    &lt;instrument verbose="true"&gt;
        &lt;fileset dir="${testclasses.dir}/org/hibernate/auction/model"&gt;
            &lt;include name="*.class"/&gt;
        &lt;/fileset&gt;
    &lt;/instrument&gt;
&lt;/target&gt;</pre><p>A different way of avoiding unnecessary column reads, at least for read-only transactions, is to use the projection features of HQL or Criteria queries. This avoids the need for buildtime bytecode processing and is certainly a preferred solution. </p><p>You can force the usual eager fetching of properties using <code class="literal">fetch all properties</code> in HQL. </p></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-cache"/>19.2. 두번째 레벨 캐시</h2></div></div></div><p>A Hibernate <code class="literal">Session</code> is a transaction-level cache of persistent data. It is possible to configure a cluster or JVM-level (<code class="literal">SessionFactory</code>-level) cache on a class-by-class and collection-by-collection basis. You can even plug in a clustered cache. Be aware that caches are not aware of changes made to the persistent store by another application. They can, however, be configured to regularly expire cached data. </p><p>You have the option to tell Hibernate which caching implementation to use by specifying the name of a class that implements <code class="literal">org.hibernate.cache.CacheProvider</code> using the property <code class="literal">hibernate.cache.provider_class</code>. Hibernate is bundled with a number of built-in integrations with the open-source cache providers that are listed below. You can also implement your own and plug it in as outlined above. Note that versions prior to 3.2 use EhCache as the default cache provider. </p><div class="table"><a id="cacheproviders"/><p class="title"><b>표 19.1. 캐시 프로바이더들</b></p><div class="table-contents"><table summary="캐시 프로바이더들" border="1"><colgroup><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/></colgroup><thead><tr><th align="left">캐시</th><th align="left">프로바이더 클래스</th><th align="left">타입</th><th align="left">클러스터 안전</th><th align="left">질의 캐시 지원</th></tr></thead><tbody><tr><td align="left">Hashtable (not intended for production use)</td><td align="left"><code class="literal">org.hibernate.cache.HashtableCacheProvider</code></td><td align="left">memory</td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">EHCache</td><td align="left"><code class="literal">org.hibernate.cache.EhCacheProvider</code></td><td align="left">memory, disk</td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">OSCache</td><td align="left"><code class="literal">org.hibernate.cache.OSCacheProvider</code></td><td align="left">memory, disk</td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">SwarmCache</td><td align="left"><code class="literal">org.hibernate.cache.SwarmCacheProvider</code></td><td align="left">clustered (ip multicast)</td><td align="left">yes (clustered invalidation)</td><td align="left"> </td></tr><tr><td align="left">JBoss Cache 1.x</td><td align="left"><code class="literal">org.hibernate.cache.TreeCacheProvider</code></td><td align="left">clustered (ip multicast), transactional</td><td align="left">yes (replication)</td><td align="left">yes (clock sync req.)</td></tr><tr><td align="left">JBoss Cache 2</td><td align="left"><code class="literal">org.hibernate.cache.jbc2.JBossCacheRegionFactory</code></td><td align="left">clustered (ip multicast), transactional</td><td align="left">yes (replication or invalidation)</td><td align="left">yes (clock sync req.)</td></tr></tbody></table></div></div><br class="table-break"/><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-mapping"/>19.2.1. Cache 매핑들</h3></div></div></div><p>클래스 또는 콜렉션 매핑의 <code class="literal">&lt;cache&gt;</code> 요소는 다음 형식을 갖는다: </p><div class="programlistingco"><pre class="programlisting">&lt;cache 
    usage="transactional|read-write|nonstrict-read-write|read-only"  <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>
    region="RegionName"                                              <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>
    include="all|non-lazy"                                           <span xmlns="" class="co"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">usage</code>(필수) 캐싱 방도를 지정한다: <code class="literal">transactional</code>, <code class="literal">read-write</code>, <code class="literal">nonstrict-read-write</code> 또는 <code class="literal">read-only</code> </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">region</code> (optional: defaults to the class or collection role name): specifies the name of the second level cache region </p></td></tr><tr><td width="5%" valign="top" align="left"><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></td><td valign="top" align="left"><p><code class="literal">include</code> (optional: defaults to <code class="literal">all</code>) <code class="literal">non-lazy</code>: specifies that properties of the entity mapped with <code class="literal">lazy="true"</code> cannot be cached when attribute-level lazy fetching is enabled </p></td></tr></table></div></div><p>Alternatively, you can specify <code class="literal">&lt;class-cache&gt;</code> and <code class="literal">&lt;collection-cache&gt;</code> elements in <code class="literal">hibernate.cfg.xml</code>. </p><p><code class="literal">usage</code> 속성은 <span class="emphasis"><em> 캐시 동시성 방도</em></span>를 지정한다. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-readonly"/>19.2.2. 방도: 읽기 전용</h3></div></div></div><p>If your application needs to read, but not modify, instances of a persistent class, a <code class="literal">read-only</code> cache can be used. This is the simplest and optimal performing strategy. It is even safe for use in a cluster. </p><pre class="programlisting">&lt;class name="eg.Immutable" mutable="false"&gt;
    &lt;cache usage="read-only"/&gt;
    ....
&lt;/class&gt;</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-readwrite"/>19.2.3. 방도: 읽기/쓰기</h3></div></div></div><p>If the application needs to update data, a <code class="literal">read-write</code> cache might be appropriate. This cache strategy should never be used if serializable transaction isolation level is required. If the cache is used in a JTA environment, you must specify the property <code class="literal">hibernate.transaction.manager_lookup_class</code> and naming a strategy for obtaining the JTA <code class="literal">TransactionManager</code>. In other environments, you should ensure that the transaction is completed when <code class="literal">Session.close()</code> or <code class="literal">Session.disconnect()</code> is called. If you want to use this strategy in a cluster, you should ensure that the underlying cache implementation supports locking. The built-in cache providers <span class="emphasis"><em>do not</em></span> support locking. </p><pre class="programlisting">&lt;class name="eg.Cat" .... &gt;
    &lt;cache usage="read-write"/&gt;
    ....
    &lt;set name="kittens" ... &gt;
        &lt;cache usage="read-write"/&gt;
        ....
    &lt;/set&gt;
&lt;/class&gt;</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-nonstrict"/>19.2.4. 방도: 엄격하지 않은 읽기/쓰기</h3></div></div></div><p>If the application only occasionally needs to update data (i.e. if it is extremely unlikely that two transactions would try to update the same item simultaneously), and strict transaction isolation is not required, a <code class="literal">nonstrict-read-write</code> cache might be appropriate. If the cache is used in a JTA environment, you must specify <code class="literal">hibernate.transaction.manager_lookup_class</code>. In other environments, you should ensure that the transaction is completed when <code class="literal">Session.close()</code> or <code class="literal">Session.disconnect()</code> is called. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-transactional"/>19.2.5. 방도: transactional</h3></div></div></div><p>The <code class="literal">transactional</code> cache strategy provides support for fully transactional cache providers such as JBoss TreeCache. Such a cache can only be used in a JTA environment and you must specify <code class="literal">hibernate.transaction.manager_lookup_class</code>. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-cache-compat-matrix"/>19.2.6. Cache-provider/concurrency-strategy compatibility</h3></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>중요</h2><p>None of the cache providers support all of the cache concurrency strategies. </p></div><p>The following table shows which providers are compatible with which concurrency strategies. </p><div class="table"><a id="d0e14846"/><p class="title"><b>표 19.2. 캐시 동시성 방도 지원</b></p><div class="table-contents"><table summary="캐시 동시성 방도 지원" border="1"><colgroup><col align="left"/><col align="left"/><col align="left"/><col align="left"/><col align="left"/></colgroup><thead><tr><th align="left">캐시</th><th align="left">읽기 전용</th><th align="left">엄격하지 않은 읽기-쓰기</th><th align="left">읽기-쓰기</th><th align="left">transactional</th></tr></thead><tbody><tr><td align="left">Hashtable (not intended for production use)</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td></tr><tr><td align="left">EHCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td></tr><tr><td align="left">OSCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td></tr><tr><td align="left">SwarmCache</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">JBoss Cache 1.x</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">JBoss Cache 2</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td><td align="left">yes</td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-sessioncache"/>19.3. 캐시들을 관리하기</h2></div></div></div><p>Whenever you pass an object to <code class="literal">save()</code>, <code class="literal">update()</code> or <code class="literal">saveOrUpdate()</code>, and whenever you retrieve an object using <code class="literal">load()</code>, <code class="literal">get()</code>, <code class="literal">list()</code>, <code class="literal">iterate()</code> or <code class="literal">scroll()</code>, that object is added to the internal cache of the <code class="literal">Session</code>. </p><p>When <code class="literal">flush()</code> is subsequently called, the state of that object will be synchronized with the database. If you do not want this synchronization to occur, or if you are processing a huge number of objects and need to manage memory efficiently, the <code class="literal">evict()</code> method can be used to remove the object and its collections from the first-level cache. </p><pre class="programlisting">ScrollableResult cats = sess.createQuery("from Cat as cat").scroll(); //a huge result set
while ( cats.next() ) {
    Cat cat = (Cat) cats.get(0);
    doSomethingWithACat(cat);
    sess.evict(cat);
}</pre><p><code class="literal">Session</code>은 또한 인스턴스가 세션 캐시에 속하는지 여부를 결정하는데 <code class="literal">contains()</code> 메소드를 제공한다. </p><p>To evict all objects from the session cache, call <code class="literal">Session.clear()</code> </p><p>second-level 캐시의 경우, 하나의 인스턴스, 전체 클래스, 콜렉션 인스턴스 또는 전체 콜렉션 role의 캐시된 상태를 퇴거시키는 <code class="literal">SessionFactory</code> 상에 정의된 메소드들이 존재한다. </p><pre class="programlisting">sessionFactory.evict(Cat.class, catId); //evict a particular Cat
sessionFactory.evict(Cat.class);  //evict all Cats
sessionFactory.evictCollection("Cat.kittens", catId); //evict a particular collection of kittens
sessionFactory.evictCollection("Cat.kittens"); //evict all kitten collections</pre><p>The <code class="literal">CacheMode</code> controls how a particular session interacts with the second-level cache: </p><div class="itemizedlist"><ul><li><p><code class="literal">CacheMode.NORMAL</code>: will read items from and write items to the second-level cache </p></li><li><p><code class="literal">CacheMode.GET</code>: will read items from the second-level cache. Do not write to the second-level cache except when updating data </p></li><li><p><code class="literal">CacheMode.PUT</code>: will write items to the second-level cache. Do not read from the second-level cache </p></li><li><p><code class="literal">CacheMode.REFRESH</code>: will write items to the second-level cache. Do not read from the second-level cache. Bypass the effect of <code class="literal">hibernate.cache.use_minimal_puts</code> forcing a refresh of the second-level cache for all items read from the database </p></li></ul></div><p>second-level 캐시 또는 질의 캐시 영역의 내용물을 브라우징하려면 <code class="literal">Statistics</code> API를 사용하라: </p><pre class="programlisting">Map cacheEntries = sessionFactory.getStatistics()
        .getSecondLevelCacheStatistics(regionName)
        .getEntries();</pre><p>You will need to enable statistics and, optionally, force Hibernate to keep the cache entries in a more readable format: </p><pre class="programlisting">hibernate.generate_statistics true
hibernate.cache.use_structured_entries true</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-querycache"/>19.4. 질의 캐시</h2></div></div></div><p>Query result sets can also be cached. This is only useful for queries that are run frequently with the same parameters. You will first need to enable the query cache: </p><pre class="programlisting">hibernate.cache.use_query_cache true</pre><p>This setting creates two new cache regions: one holding cached query result sets (<code class="literal">org.hibernate.cache.StandardQueryCache</code>), the other holding timestamps of the most recent updates to queryable tables (<code class="literal">org.hibernate.cache.UpdateTimestampsCache</code>). Note that the query cache does not cache the state of the actual entities in the result set; it caches only identifier values and results of value type. The query cache should always be used in conjunction with the second-level cache. </p><p>Most queries do not benefit from caching, so by default, queries are not cached. To enable caching, call <code class="literal">Query.setCacheable(true)</code>. This call allows the query to look for existing cache results or add its results to the cache when it is executed. </p><p>If you require fine-grained control over query cache expiration policies, you can specify a named cache region for a particular query by calling <code class="literal">Query.setCacheRegion()</code>. </p><pre class="programlisting">List blogs = sess.createQuery("from Blog blog where blog.blogger = :blogger")
    .setEntity("blogger", blogger)
    .setMaxResults(15)
    .setCacheable(true)
    .setCacheRegion("frontpages")
    .list();</pre><p>만일 질의가 그것의 질의 캐시 영역의 갱신을 강제시켜야 하는 경우에, 당신은 <code class="literal">Query.setCacheMode(CacheMode.REFRESH)</code>를 호출해야 한다. 이것은 기본 데이터가 별도의 프로세스를 통해 업데이트되었고(예를 들면, Hibernate를 통해 변경되지 않았고) 특정 질의 결과 셋들을 선택적으로 갱신하는 것을 어플리케이션에게 허용해주는 경우들에서 특별히 유용하다. 이것은 <code class="literal">SessionFactory.evictQueries()</code>를 통해 질의 캐시 영역을 퇴거시키는 보다 효과적인 대안이다. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-collections"/>19.5. 콜렉션 퍼포먼스 이해하기</h2></div></div></div><p>In the previous sections we have covered collections and their applications. In this section we explore some more issues in relation to collections at runtime. </p><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-taxonomy"/>19.5.1. 분류</h3></div></div></div><p>Hibernate는 세 가지 기본적인 종류의 콜렉션들을 정의한다:</p><div class="itemizedlist"><ul><li><p>값들을 가진 콜렉션들</p></li><li><p>one-to-many associations</p></li><li><p>many-to-many associations</p></li></ul></div><p>이 분류는 여러 가지 테이블과 foreign key 관계들을 구별짓지만 우리가 관계형 모형에 대해 알 필요가 있는 모든 것을 우리에게 말해주지 않는다. 관계형 구조와 퍼포먼스 특징들을 완전하게 이해하기 위해, 우리는 또한 콜렉션 행들을 업데이트하거나 삭제하기 위해 Hibernate에 의해 사용되는 프라이머리 키의 구조를 검토해야 한다. 이것은 다음 분류를 제안한다: </p><div class="itemizedlist"><ul><li><p>인덱싱 된 콜렉션들</p></li><li><p>set들</p></li><li><p>bag들</p></li></ul></div><p>All indexed collections (maps, lists, and arrays) have a primary key consisting of the <code class="literal">&lt;key&gt;</code> and <code class="literal">&lt;index&gt;</code> columns. In this case, collection updates are extremely efficient. The primary key can be efficiently indexed and a particular row can be efficiently located when Hibernate tries to update or delete it. </p><p>Sets have a primary key consisting of <code class="literal">&lt;key&gt;</code> and element columns. This can be less efficient for some types of collection element, particularly composite elements or large text or binary fields, as the database may not be able to index a complex primary key as efficiently. However, for one-to-many or many-to-many associations, particularly in the case of synthetic identifiers, it is likely to be just as efficient. If you want <code class="literal">SchemaExport</code> to actually create the primary key of a <code class="literal">&lt;set&gt;</code>, you must declare all columns as <code class="literal">not-null="true"</code>. </p><p><code class="literal">&lt;idbag&gt;</code> mappings define a surrogate key, so they are efficient to update. In fact, they are the best case. </p><p>Bags are the worst case since they permit duplicate element values and, as they have no index column, no primary key can be defined. Hibernate has no way of distinguishing between duplicate rows. Hibernate resolves this problem by completely removing in a single <code class="literal">DELETE</code> and recreating the collection whenever it changes. This can be inefficient. </p><p>For a one-to-many association, the "primary key" may not be the physical primary key of the database table. Even in this case, the above classification is still useful. It reflects how Hibernate "locates" individual rows of the collection. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-mostefficientupdate"/>19.5.2. List, map, idbag, set들은 update에 가장 효율적인 콜렉션들이다</h3></div></div></div><p>From the discussion above, it should be clear that indexed collections and sets allow the most efficient operation in terms of adding, removing and updating elements. </p><p>There is, arguably, one more advantage that indexed collections have over sets for many-to-many associations or collections of values. Because of the structure of a <code class="literal">Set</code>, Hibernate does not <code class="literal">UPDATE</code> a row when an element is "changed". Changes to a <code class="literal">Set</code> always work via <code class="literal">INSERT</code> and <code class="literal">DELETE</code> of individual rows. Once again, this consideration does not apply to one-to-many associations. </p><p>After observing that arrays cannot be lazy, you can conclude that lists, maps and idbags are the most performant (non-inverse) collection types, with sets not far behind. You can expect sets to be the most common kind of collection in Hibernate applications. This is because the "set" semantics are most natural in the relational model. </p><p>However, in well-designed Hibernate domain models, most collections are in fact one-to-many associations with <code class="literal">inverse="true"</code>. For these associations, the update is handled by the many-to-one end of the association, and so considerations of collection update performance simply do not apply. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-mostefficentinverse"/>19.5.3. Bag들과 list들은 가장 효율적인 inverse 콜렉션들이다</h3></div></div></div><p>There is a particular case, however, in which bags, and also lists, are much more performant than sets. For a collection with <code class="literal">inverse="true"</code>, the standard bidirectional one-to-many relationship idiom, for example, we can add elements to a bag or list without needing to initialize (fetch) the bag elements. This is because, unlike a <code class="literal">set</code>, <code class="literal">Collection.add()</code> or <code class="literal">Collection.addAll()</code> must always return true for a bag or <code class="literal">List</code>. This can make the following common code much faster: </p><pre class="programlisting">Parent p = (Parent) sess.load(Parent.class, id);
Child c = new Child();
c.setParent(p);
p.getChildren().add(c);  //no need to fetch the collection!
sess.flush();</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-collections-oneshotdelete"/>19.5.4. 원 샷 delete</h3></div></div></div><p>Deleting collection elements one by one can sometimes be extremely inefficient. Hibernate knows not to do that in the case of an newly-empty collection (if you called <code class="literal">list.clear()</code>, for example). In this case, Hibernate will issue a single <code class="literal">DELETE</code>. </p><p>Suppose you added a single element to a collection of size twenty and then remove two elements. Hibernate will issue one <code class="literal">INSERT</code> statement and two <code class="literal">DELETE</code> statements, unless the collection is a bag. This is certainly desirable. </p><p>하지만, 우리가 두 개의 요소들을 남겨둔채 18 개의 요소들을 제거하고 나서 세 개의 새로운 요소들을 추가한다고 가정하자. 두 가지 가능한 처리 방법들이 존재한다. </p><div class="itemizedlist"><ul><li><p>하나씩 열 여덟 개의 행들을 삭제한 다음에 세 개의 행들을 삽입시킨다</p></li><li><p>remove the whole collection in one SQL <code class="literal">DELETE</code> and insert all five current elements one by one</p></li></ul></div><p>Hibernate cannot know that the second option is probably quicker. It would probably be undesirable for Hibernate to be that intuitive as such behavior might confuse database triggers, etc. </p><p>Fortunately, you can force this behavior (i.e. the second strategy) at any time by discarding (i.e. dereferencing) the original collection and returning a newly instantiated collection with all the current elements. </p><p>One-shot-delete does not apply to collections mapped <code class="literal">inverse="true"</code>. </p></div></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="performance-monitoring"/>19.6. 퍼포먼스 모니터링하기</h2></div></div></div><p>최적화는 퍼포먼스 관련 숫자들에 대한 모니터링과 접근 없이는 많이 사용되지 않는다. Hibernate는 그것의 내부적인 오퍼레이션들에 대한 전체 영역의 특징들을 제공한다. Hibernate에서 Statistics는 <code class="literal">SessionFactory</code>에 대해 이용 가능하다. </p><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-monitoring-sf"/>19.6.1. SessionFactory 모니터링 하기</h3></div></div></div><p>당신은 두 가지 방법들로 <code class="literal">SessionFactory</code> metrics에 접근할 수 있다. 당신의 첫 번째 옵션은 <code class="literal">sessionFactory.getStatistics()</code>를 호출하고 당신 스스로 <code class="literal">Statistics</code>를 읽거나 디스플레이 하는 것이다. </p><p>Hibernate can also use JMX to publish metrics if you enable the <code class="literal">StatisticsService</code> MBean. You can enable a single MBean for all your <code class="literal">SessionFactory</code> or one per factory. See the following code for minimalistic configuration examples: </p><pre class="programlisting">// MBean service registration for a specific SessionFactory
Hashtable tb = new Hashtable();
tb.put("type", "statistics");
tb.put("sessionFactory", "myFinancialApp");
ObjectName on = new ObjectName("hibernate", tb); // MBean object name

StatisticsService stats = new StatisticsService(); // MBean implementation
stats.setSessionFactory(sessionFactory); // Bind the stats to a SessionFactory
server.registerMBean(stats, on); // Register the Mbean on the server</pre><pre class="programlisting">// MBean service registration for all SessionFactory's
Hashtable tb = new Hashtable();
tb.put("type", "statistics");
tb.put("sessionFactory", "all");
ObjectName on = new ObjectName("hibernate", tb); // MBean object name

StatisticsService stats = new StatisticsService(); // MBean implementation
server.registerMBean(stats, on); // Register the MBean on the server</pre><p>You can activate and deactivate the monitoring for a <code class="literal">SessionFactory</code>: </p><div class="itemizedlist"><ul><li><p>구성 시 : <code class="literal">hibernate.generate_statistics</code>, 디폴트는 <code class="literal">false</code> </p></li></ul></div><div class="itemizedlist"><ul><li><p>실행 시 : <code class="literal">sf.getStatistics().setStatisticsEnabled(true)</code> 또는 <code class="literal">hibernateStatsBean.setStatisticsEnabled(true)</code> </p></li></ul></div><p>Statistics can be reset programmatically using the <code class="literal">clear()</code> method. A summary can be sent to a logger (info level) using the <code class="literal">logSummary()</code> method. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="performance-monitoring-metrics"/>19.6.2. Metrics</h3></div></div></div><p>Hibernate provides a number of metrics, from basic information to more specialized information that is only relevant in certain scenarios. All available counters are described in the <code class="literal">Statistics</code> interface API, in three categories: </p><div class="itemizedlist"><ul><li><p>열려진 세션들의 개수, 검색된 JDBC 커넥션들의 개수 등과 같은 일반적인 <code class="literal">Session</code> 사용에 관련된 metrics. </p></li><li><p>Metrics related to the entities, collections, queries, and caches as a whole (aka global metrics). </p></li><li><p>특정한 엔티티, 콜렉션, 질의 또는 캐시 영역에 관련된 상세 metrics. </p></li></ul></div><p>For example, you can check the cache hit, miss, and put ratio of entities, collections and queries, and the average time a query needs. Be aware that the number of milliseconds is subject to approximation in Java. Hibernate is tied to the JVM precision and on some platforms this might only be accurate to 10 seconds. </p><p>Simple getters are used to access the global metrics (i.e. not tied to a particular entity, collection, cache region, etc.). You can access the metrics of a particular entity, collection or cache region through its name, and through its HQL or SQL representation for queries. Please refer to the <code class="literal">Statistics</code>, <code class="literal">EntityStatistics</code>, <code class="literal">CollectionStatistics</code>, <code class="literal">SecondLevelCacheStatistics</code>, and <code class="literal">QueryStatistics</code> API Javadoc for more information. The following code is a simple example: </p><pre class="programlisting">Statistics stats = HibernateUtil.sessionFactory.getStatistics();

double queryCacheHitCount  = stats.getQueryCacheHitCount();
double queryCacheMissCount = stats.getQueryCacheMissCount();
double queryCacheHitRatio =
  queryCacheHitCount / (queryCacheHitCount + queryCacheMissCount);

log.info("Query Hit ratio:" + queryCacheHitRatio);

EntityStatistics entityStats =
  stats.getEntityStatistics( Cat.class.getName() );
long changes =
        entityStats.getInsertCount()
        + entityStats.getUpdateCount()
        + entityStats.getDeleteCount();
log.info(Cat.class.getName() + " changed " + changes + "times"  );</pre><p>You can work on all entities, collections, queries and region caches, by retrieving the list of names of entities, collections, queries and region caches using the following methods: <code class="literal">getQueries()</code>, <code class="literal">getEntityNames()</code>, <code class="literal">getCollectionRoleNames()</code>, and <code class="literal">getSecondLevelCacheRegionNames()</code>. </p></div></div></div><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="toolsetguide"/>20장. 도구셋 안내</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#toolsetguide-s1">20.1. 자동적인 스키마 생성</a></span></dt><dd><dl><dt><span class="sect2"><a href="#toolsetguide-s1-2">20.1.1. 스키마 맞춤화 시키기</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-3">20.1.2. 도구 실행하기</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-4">20.1.3. 프로퍼티들</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-5">20.1.4. Ant 사용하기</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-6">20.1.5. 점증하는 스키마 업데이트들</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-7">20.1.6. 점증하는 스키마 업데이트들에 Ant 사용하기</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-8">20.1.7. 스키마 유효성 검사</a></span></dt><dt><span class="sect2"><a href="#toolsetguide-s1-9">20.1.8. 스키마 유효성 검사를 위해 Ant 사용하기</a></span></dt></dl></dd></dl></div><p>Roundtrip engineering with Hibernate is possible using a set of Eclipse plugins, commandline tools, and Ant tasks. </p><p><span class="emphasis"><em>Hibernate Tools</em></span> currently include plugins for the Eclipse IDE as well as Ant tasks for reverse engineering of existing databases: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Mapping Editor:</em></span> an editor for Hibernate XML mapping files that supports auto-completion and syntax highlighting. It also supports semantic auto-completion for class names and property/field names, making it more versatile than a normal XML editor. </p></li><li><p><span class="emphasis"><em>Console:</em></span> the console is a new view in Eclipse. In addition to a tree overview of your console configurations, you are also provided with an interactive view of your persistent classes and their relationships. The console allows you to execute HQL queries against your database and browse the result directly in Eclipse. </p></li><li><p><span class="emphasis"><em>Development Wizards:</em></span> several wizards are provided with the Hibernate Eclipse tools. You can use a wizard to quickly generate Hibernate configuration (cfg.xml) files, or to reverse engineer an existing database schema into POJO source files and Hibernate mapping files. The reverse engineering wizard supports customizable templates. </p></li><li><p>

        </p></li></ul></div><p>Please refer to the <span class="emphasis"><em>Hibernate Tools</em></span> package documentation for more information. </p><p>However, the Hibernate main package comes bundled with an integrated tool : <span class="emphasis"><em>SchemaExport</em></span> aka <code class="literal">hbm2ddl</code>.It can even be used from "inside" Hibernate. </p><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="toolsetguide-s1"/>20.1. 자동적인 스키마 생성</h2></div></div></div><p>DDL can be generated from your mapping files by a Hibernate utility. The generated schema includes referential integrity constraints, primary and foreign keys, for entity and collection tables. Tables and sequences are also created for mapped identifier generators. </p><p>You <span class="emphasis"><em>must</em></span> specify a SQL <code class="literal">Dialect</code> via the <code class="literal">hibernate.dialect</code> property when using this tool, as DDL is highly vendor-specific. </p><p>First, you must customize your mapping files to improve the generated schema. The next section covers schema customization. </p><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-2"/>20.1.1. 스키마 맞춤화 시키기</h3></div></div></div><p>Many Hibernate mapping elements define optional attributes named <code class="literal">length</code>, <code class="literal">precision</code> and <code class="literal">scale</code>. You can set the length, precision and scale of a column with this attribute. </p><pre class="programlisting">&lt;property name="zip" length="5"/&gt;</pre><pre class="programlisting">&lt;property name="balance" precision="12" scale="2"/&gt;</pre><p>Some tags also accept a <code class="literal">not-null</code> attribute for generating a <code class="literal">NOT NULL</code> constraint on table columns, and a <code class="literal">unique</code> attribute for generating <code class="literal">UNIQUE</code> constraint on table columns. </p><pre class="programlisting">&lt;many-to-one name="bar" column="barId" not-null="true"/&gt;</pre><pre class="programlisting">&lt;element column="serialNumber" type="long" not-null="true" unique="true"/&gt;</pre><p>A <code class="literal">unique-key</code> attribute can be used to group columns in a single, unique key constraint. Currently, the specified value of the <code class="literal">unique-key</code> attribute is <span class="emphasis"><em>not</em></span> used to name the constraint in the generated DDL. It is only used to group the columns in the mapping file. </p><pre class="programlisting">&lt;many-to-one name="org" column="orgId" unique-key="OrgEmployeeId"/&gt;
&lt;property name="employeeId" unique-key="OrgEmployee"/&gt;</pre><p>An <code class="literal">index</code> attribute specifies the name of an index that will be created using the mapped column or columns. Multiple columns can be grouped into the same index by simply specifying the same index name. </p><pre class="programlisting">&lt;property name="lastName" index="CustName"/&gt;
&lt;property name="firstName" index="CustName"/&gt;</pre><p>A <code class="literal">foreign-key</code> attribute can be used to override the name of any generated foreign key constraint. </p><pre class="programlisting">&lt;many-to-one name="bar" column="barId" foreign-key="FKFooBar"/&gt;</pre><p>많은 매핑 요소들은 또한 하나의 자식 <code class="literal">&lt;column&gt;</code> 요소를 허용한다. 이것은 특히 다중 컬럼 타입들을 매핑하는데 유용하다: </p><pre class="programlisting">&lt;property name="name" type="my.customtypes.Name"/&gt;
    &lt;column name="last" not-null="true" index="bar_idx" length="30"/&gt;
    &lt;column name="first" not-null="true" index="bar_idx" length="20"/&gt;
    &lt;column name="initial"/&gt;
&lt;/property&gt;</pre><p>The <code class="literal">default</code> attribute allows you to specify a default value for a column.You should assign the same value to the mapped property before saving a new instance of the mapped class. </p><pre class="programlisting">&lt;property name="credits" type="integer" insert="false"&gt;
    &lt;column name="credits" default="10"/&gt;
&lt;/property&gt;</pre><pre class="programlisting">&lt;version name="version" type="integer" insert="false"&gt;
    &lt;column name="version" default="0"/&gt;
&lt;/property&gt;</pre><p><code class="literal">sql-type</code> 속성은 SQL 데이터타입에 대한 Hibernate 타입의 디폴트 매핑을 오버라이드 시키는 것을 사용자에게 허용해준다. </p><pre class="programlisting">&lt;property name="balance" type="float"&gt;
    &lt;column name="balance" sql-type="decimal(13,3)"/&gt;
&lt;/property&gt;</pre><p><code class="literal">check</code> 속성은 check 컨스트레인트를 지정하는 것을 당신에게 허용해준다. </p><pre class="programlisting">&lt;property name="foo" type="integer"&gt;
    &lt;column name="foo" check="foo &gt; 10"/&gt;
&lt;/property&gt;</pre><pre class="programlisting">&lt;class name="Foo" table="foos" check="bar &lt; 100.0"&gt;
    ...
    &lt;property name="bar" type="float"/&gt;
&lt;/class&gt;</pre><p>The following table summarizes these optional attributes.</p><div class="table"><a id="schemattributes-summary"/><p class="title"><b>표 20.1. 요약</b></p><div class="table-contents"><table summary="요약" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>속성</th><th>값들</th><th>해석</th></tr></thead><tbody><tr><td><code class="literal">length</code></td><td>number</td><td>컬럼 길이</td></tr><tr><td><code class="literal">precision</code></td><td>number</td><td>컬럼 decimal 정밀도</td></tr><tr><td><code class="literal">scale</code></td><td>number</td><td>컬럼 decimal 크기</td></tr><tr><td><code class="literal">not-null</code></td><td><code class="literal">true|false</code></td><td>specifies that the column should be non-nullable</td></tr><tr><td><code class="literal">unique</code></td><td><code class="literal">true|false</code></td><td>컬럼이 하나의 유일 컨스트레인트를 가져야함을 지정한다</td></tr><tr><td><code class="literal">index</code></td><td><code class="literal">index_name</code></td><td>(다중-컬럼) 인덱스의 이름을 지정한다</td></tr><tr><td><code class="literal">unique-key</code></td><td><code class="literal">unique_key_name</code></td><td>다중-컬럼 유일 컨스트레인트의 이름을 지정한다</td></tr><tr><td><code class="literal">foreign-key</code></td><td><code class="literal">foreign_key_name</code></td><td>specifies the name of the foreign key constraint generated for an association, for a <code class="literal">&lt;one-to-one&gt;</code>, <code class="literal">&lt;many-to-one&gt;</code>, <code class="literal">&lt;key&gt;</code>, or <code class="literal">&lt;many-to-many&gt;</code> mapping element. Note that <code class="literal">inverse="true"</code> sides will not be considered by <code class="literal">SchemaExport</code>. </td></tr><tr><td><code class="literal">sql-type</code></td><td><code class="literal">SQL column type</code></td><td>overrides the default column type (attribute of <code class="literal">&lt;column&gt;</code> element only) </td></tr><tr><td><code class="literal">default</code></td><td>SQL expression</td><td>컬럼에 대한 디폴트 값을 지정한다 </td></tr><tr><td><code class="literal">check</code></td><td>SQL expression</td><td>컬럼 또는 테이블에 대한 SQL check 컨스트레인트를 생성시킨다 </td></tr></tbody></table></div></div><br class="table-break"/><p><code class="literal">&lt;comment&gt;</code> 요소는 생성된 스키마에 대한 주석들을 지정하는 것을 당신에게 허용해준다. </p><pre class="programlisting">&lt;class name="Customer" table="CurCust"&gt;
    &lt;comment&gt;Current customers only&lt;/comment&gt;
    ...
&lt;/class&gt;</pre><pre class="programlisting">&lt;property name="balance"&gt;
    &lt;column name="bal"&gt;
        &lt;comment&gt;Balance in USD&lt;/comment&gt;
    &lt;/column&gt;
&lt;/property&gt;</pre><p>This results in a <code class="literal">comment on table</code> or <code class="literal">comment on column</code> statement in the generated DDL where supported. </p></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-3"/>20.1.2. 도구 실행하기</h3></div></div></div><p><code class="literal">SchemaExport</code> 도구는 DDL 스크립트를 표준 출력으로 기록 하고/하거나 DDL 문장들을 실행시킨다. </p><p>The following table displays the <code class="literal">SchemaExport</code> command line options</p><p><code class="literal">java -cp </code><span class="emphasis"><em>hibernate_classpaths</em></span> <code class="literal">org.hibernate.tool.hbm2ddl.SchemaExport</code> <span class="emphasis"><em>options mapping_files</em></span> </p><div class="table"><a id="d0e15669"/><p class="title"><b>표 20.2. <code class="literal">SchemaExport</code> 명령 라인 옵션들</b></p><div class="table-contents"><table summary="SchemaExport 명령 라인 옵션들" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>옵션</th><th>설명</th></tr></thead><tbody><tr><td><code class="literal">--quiet</code></td><td>do not output the script to stdout</td></tr><tr><td><code class="literal">--drop</code></td><td>오직 테이블들을 드롭시킨다</td></tr><tr><td><code class="literal">--create</code></td><td>오직 테이블들을 생성시킨다</td></tr><tr><td><code class="literal">--text</code></td><td>do not export to the database</td></tr><tr><td><code class="literal">--output=my_schema.ddl</code></td><td>ddl 스크립트를 파일로 출력한다</td></tr><tr><td><code class="literal">--naming=eg.MyNamingStrategy</code></td><td>select a <code class="literal">NamingStrategy</code></td></tr><tr><td><code class="literal">--config=hibernate.cfg.xml</code></td><td>XML 파일로부터 Hibernate 구성을 읽어들인다</td></tr><tr><td><code class="literal">--properties=hibernate.properties</code></td><td>read database properties from a file</td></tr><tr><td><code class="literal">--format</code></td><td>생성된 SQL을 스크립트 내에 좋게 형식지운다</td></tr><tr><td><code class="literal">--delimiter=;</code></td><td>스크립트를 위한 라인 경계의 끝을 설정한다</td></tr></tbody></table></div></div><br class="table-break"/><p>You can even embed <code class="literal">SchemaExport</code> in your application: </p><pre class="programlisting">Configuration cfg = ....;
new SchemaExport(cfg).create(false, true);</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-4"/>20.1.3. 프로퍼티들</h3></div></div></div><p>Database properties can be specified: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">-D</code><span class="emphasis"><em>&lt;property&gt;</em></span>를 가진 시스템 프로퍼티로서</p></li><li><p><code class="literal">hibernate.properties</code> 내에서</p></li><li><p><code class="literal">--properties</code>를 가진 명명된 프로퍼티들 내에서</p></li></ul></div><p>필요한 프로퍼티들은 다음과 같다: </p><div class="table"><a id="d0e15778"/><p class="title"><b>표 20.3. SchemaExport 커넥션 프로퍼티들</b></p><div class="table-contents"><table summary="SchemaExport 커넥션 프로퍼티들" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>프로퍼티 이름</th><th>설명</th></tr></thead><tbody><tr><td><code class="literal">hibernate.connection.driver_class</code></td><td>jdbc 드라이버 클래스</td></tr><tr><td><code class="literal">hibernate.connection.url</code></td><td>jdbc url</td></tr><tr><td><code class="literal">hibernate.connection.username</code></td><td>데이터베이스 사용자</td></tr><tr><td><code class="literal">hibernate.connection.password</code></td><td>사용자 패스워드</td></tr><tr><td><code class="literal">hibernate.dialect</code></td><td>dialect</td></tr></tbody></table></div></div><br class="table-break"/></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-5"/>20.1.4. Ant 사용하기</h3></div></div></div><p>당신은 당신의 Ant 빌드 스크립트에서 <code class="literal">SchemaExport</code>를 호출할 수 있다: </p><pre class="programlisting">&lt;target name="schemaexport"&gt;
    &lt;taskdef name="schemaexport"
        classname="org.hibernate.tool.hbm2ddl.SchemaExportTask"
        classpathref="class.path"/&gt;
    
    &lt;schemaexport
        properties="hibernate.properties"
        quiet="no"
        text="no"
        drop="no"
        delimiter=";"
        output="schema-export.sql"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemaexport&gt;
&lt;/target&gt;</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-6"/>20.1.5. 점증하는 스키마 업데이트들</h3></div></div></div><p>The <code class="literal">SchemaUpdate</code> tool will update an existing schema with "incremental" changes. The <code class="literal">SchemaUpdate</code> depends upon the JDBC metadata API and, as such, will not work with all JDBC drivers. </p><p><code class="literal">java -cp </code><span class="emphasis"><em>hibernate_classpaths</em></span> <code class="literal">org.hibernate.tool.hbm2ddl.SchemaUpdate</code> <span class="emphasis"><em>options mapping_files</em></span> </p><div class="table"><a id="d0e15854"/><p class="title"><b>표 20.4. <code class="literal">SchemaUpdate</code> 명령 라인 옵션들</b></p><div class="table-contents"><table summary="SchemaUpdate 명령 라인 옵션들" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>옵션</th><th>설명</th></tr></thead><tbody><tr><td><code class="literal">--quiet</code></td><td>do not output the script to stdout</td></tr><tr><td><code class="literal">--text</code></td><td>do not export the script to the database</td></tr><tr><td><code class="literal">--naming=eg.MyNamingStrategy</code></td><td>select a <code class="literal">NamingStrategy</code></td></tr><tr><td><code class="literal">--properties=hibernate.properties</code></td><td>read database properties from a file</td></tr><tr><td><code class="literal">--config=hibernate.cfg.xml</code></td><td>specify a <code class="literal">.cfg.xml</code> file</td></tr></tbody></table></div></div><br class="table-break"/><p>You can embed <code class="literal">SchemaUpdate</code> in your application: </p><pre class="programlisting">Configuration cfg = ....;
new SchemaUpdate(cfg).execute(false);</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-7"/>20.1.6. 점증하는 스키마 업데이트들에 Ant 사용하기</h3></div></div></div><p>당신은 Ant 스크립트에서<code class="literal">SchemaUpdate</code>를 호출할 수 있다: </p><pre class="programlisting">&lt;target name="schemaupdate"&gt;
    &lt;taskdef name="schemaupdate"
        classname="org.hibernate.tool.hbm2ddl.SchemaUpdateTask"
        classpathref="class.path"/&gt;
    
    &lt;schemaupdate
        properties="hibernate.properties"
        quiet="no"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemaupdate&gt;
&lt;/target&gt;</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-8"/>20.1.7. 스키마 유효성 검사</h3></div></div></div><p>The <code class="literal">SchemaValidator</code> tool will validate that the existing database schema "matches" your mapping documents. The <code class="literal">SchemaValidator</code> depends heavily upon the JDBC metadata API and, as such, will not work with all JDBC drivers. This tool is extremely useful for testing. </p><p><code class="literal">java -cp </code><span class="emphasis"><em>hibernate_classpaths</em></span> <code class="literal">org.hibernate.tool.hbm2ddl.SchemaValidator</code> <span class="emphasis"><em>options mapping_files</em></span> </p><div class="table"><a id="d0e15944"/><p class="title"><b>표 20.5. <code class="literal">SchemaValidator</code> 명령 라인 옵션들</b></p><div class="table-contents"><table summary="SchemaValidator 명령 라인 옵션들" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>옵션</th><th>설명</th></tr></thead><tbody><tr><td><code class="literal">--naming=eg.MyNamingStrategy</code></td><td>select a <code class="literal">NamingStrategy</code></td></tr><tr><td><code class="literal">--properties=hibernate.properties</code></td><td>read database properties from a file</td></tr><tr><td><code class="literal">--config=hibernate.cfg.xml</code></td><td>specify a <code class="literal">.cfg.xml</code> file</td></tr></tbody></table></div></div><br class="table-break"/><p>You can embed <code class="literal">SchemaValidator</code> in your application: </p><pre class="programlisting">Configuration cfg = ....;
new SchemaValidator(cfg).validate();</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="toolsetguide-s1-9"/>20.1.8. 스키마 유효성 검사를 위해 Ant 사용하기</h3></div></div></div><p>당신은 Ant 스크립트에서 <code class="literal">SchemaValidator</code>를 호출할 수 있다: </p><pre class="programlisting">&lt;target name="schemavalidate"&gt;
    &lt;taskdef name="schemavalidator"
        classname="org.hibernate.tool.hbm2ddl.SchemaValidatorTask"
        classpathref="class.path"/&gt;
    
    &lt;schemavalidator
        properties="hibernate.properties"&gt;
        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.hbm.xml"/&gt;
        &lt;/fileset&gt;
    &lt;/schemavalidator&gt;
&lt;/target&gt;</pre></div></div></div><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild"/>21장. 예제: 부모/자식</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#example-parentchild-collections">21.1. 콜렉션들에 관한 노트</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-bidir">21.2. 양방향 one-to-many</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-cascades">21.3. 케스케이딩 생명주기</a></span></dt><dt><span class="sect1"><a href="#example-parentchild-update">21.4. 케스케이드들과 <code class="literal">unsaved-value</code></a></span></dt><dt><span class="sect1"><a href="#example-parentchild-conclusion">21.5. 결론</a></span></dt></dl></div><p>One of the first things that new users want to do with Hibernate is to model a parent/child type relationship. There are two different approaches to this. The most convenient approach, especially for new users, is to model both <code class="literal">Parent</code> and <code class="literal">Child</code> as entity classes with a <code class="literal">&lt;one-to-many&gt;</code> association from <code class="literal">Parent</code> to <code class="literal">Child</code>. The alternative approach is to declare the <code class="literal">Child</code> as a <code class="literal">&lt;composite-element&gt;</code>. The default semantics of a one-to-many association in Hibernate are much less close to the usual semantics of a parent/child relationship than those of a composite element mapping. We will explain how to use a <span class="emphasis"><em>bidirectional one-to-many association with cascades</em></span> to model a parent/child relationship efficiently and elegantly. </p><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-collections"/>21.1. 콜렉션들에 관한 노트</h2></div></div></div><p>Hibernate collections are considered to be a logical part of their owning entity and not of the contained entities. Be aware that this is a critical distinction that has the following consequences: </p><div class="itemizedlist"><ul><li><p>When you remove/add an object from/to a collection, the version number of the collection owner is incremented. </p></li><li><p>If an object that was removed from a collection is an instance of a value type (e.g. a composite element), that object will cease to be persistent and its state will be completely removed from the database. Likewise, adding a value type instance to the collection will cause its state to be immediately persistent. </p></li><li><p>Conversely, if an entity is removed from a collection (a one-to-many or many-to-many association), it will not be deleted by default. This behavior is completely consistent; a change to the internal state of another entity should not cause the associated entity to vanish. Likewise, adding an entity to a collection does not cause that entity to become persistent, by default. </p></li></ul></div><p>Adding an entity to a collection, by default, merely creates a link between the two entities. Removing the entity will remove the link. This is appropriate for all sorts of cases. However, it is not appropriate in the case of a parent/child relationship. In this case, the life of the child is bound to the life cycle of the parent. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-bidir"/>21.2. 양방향 one-to-many</h2></div></div></div><p><code class="literal">Parent</code>로부터 <code class="literal">Child</code>로의 간단한 <code class="literal">&lt;one-to-many&gt;</code> 연관관계로 시작한다고 가정하자. </p><pre class="programlisting">&lt;set name="children"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>If we were to execute the following code: </p><pre class="programlisting">Parent p = .....;
Child c = new Child();
p.getChildren().add(c);
session.save(c);
session.flush();</pre><p>Hibernate는 두 개의 SQL 문장들을 실행할 것이다: </p><div class="itemizedlist"><ul><li><p><code class="literal">c</code>에 대한 레코드를 생성시키는 <code class="literal">INSERT</code></p></li><li><p><code class="literal">p</code>로부터 <code class="literal">c</code>로의 링크를 생성시키는 <code class="literal">UPDATE</code> </p></li></ul></div><p>This is not only inefficient, but also violates any <code class="literal">NOT NULL</code> constraint on the <code class="literal">parent_id</code> column. You can fix the nullability constraint violation by specifying <code class="literal">not-null="true"</code> in the collection mapping: </p><pre class="programlisting">&lt;set name="children"&gt;
    &lt;key column="parent_id" not-null="true"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>하지만 이것은 권장되는 해결책이 아니다. </p><p>The underlying cause of this behavior is that the link (the foreign key <code class="literal">parent_id</code>) from <code class="literal">p</code> to <code class="literal">c</code> is not considered part of the state of the <code class="literal">Child</code> object and is therefore not created in the <code class="literal">INSERT</code>. The solution is to make the link part of the <code class="literal">Child</code> mapping. </p><pre class="programlisting">&lt;many-to-one name="parent" column="parent_id" not-null="true"/&gt;</pre><p>You also need to add the <code class="literal">parent</code> property to the <code class="literal">Child</code> class. </p><p>Now that the <code class="literal">Child</code> entity is managing the state of the link, we tell the collection not to update the link. We use the <code class="literal">inverse</code> attribute to do this: </p><pre class="programlisting">&lt;set name="children" inverse="true"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>The following code would be used to add a new <code class="literal">Child</code>: </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
c.setParent(p);
p.getChildren().add(c);
session.save(c);
session.flush();</pre><p>Only one SQL <code class="literal">INSERT</code> would now be issued. </p><p>You could also create an <code class="literal">addChild()</code> method of <code class="literal">Parent</code>. </p><pre class="programlisting">public void addChild(Child c) {
    c.setParent(this);
    children.add(c);
}</pre><p>The code to add a <code class="literal">Child</code> looks like this: </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
p.addChild(c);
session.save(c);
session.flush();</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-cascades"/>21.3. 케스케이딩 생명주기</h2></div></div></div><p>You can address the frustrations of the explicit call to <code class="literal">save()</code> by using cascades. </p><pre class="programlisting">&lt;set name="children" inverse="true" cascade="all"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>This simplifies the code above to: </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = new Child();
p.addChild(c);
session.flush();</pre><p>Similarly, we do not need to iterate over the children when saving or deleting a <code class="literal">Parent</code>. The following removes <code class="literal">p</code> and all its children from the database. </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
session.delete(p);
session.flush();</pre><p>However, the following code: </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = (Child) p.getChildren().iterator().next();
p.getChildren().remove(c);
c.setParent(null);
session.flush();</pre><p>will not remove <code class="literal">c</code> from the database. In this case, it will only remove the link to <code class="literal">p</code> and cause a <code class="literal">NOT NULL</code> constraint violation. You need to explicitly <code class="literal">delete()</code> the <code class="literal">Child</code>. </p><pre class="programlisting">Parent p = (Parent) session.load(Parent.class, pid);
Child c = (Child) p.getChildren().iterator().next();
p.getChildren().remove(c);
session.delete(c);
session.flush();</pre><p>In our case, a <code class="literal">Child</code> cannot exist without its parent. So if we remove a <code class="literal">Child</code> from the collection, we do want it to be deleted. To do this, we must use <code class="literal">cascade="all-delete-orphan"</code>. </p><pre class="programlisting">&lt;set name="children" inverse="true" cascade="all-delete-orphan"&gt;
    &lt;key column="parent_id"/&gt;
    &lt;one-to-many class="Child"/&gt;
&lt;/set&gt;</pre><p>Even though the collection mapping specifies <code class="literal">inverse="true"</code>, cascades are still processed by iterating the collection elements. If you need an object be saved, deleted or updated by cascade, you must add it to the collection. It is not enough to simply call <code class="literal">setParent()</code>. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-update"/>21.4. 케스케이드들과 <code class="literal">unsaved-value</code></h2></div></div></div><p>Suppose we loaded up a <code class="literal">Parent</code> in one <code class="literal">Session</code>, made some changes in a UI action and wanted to persist these changes in a new session by calling <code class="literal">update()</code>. The <code class="literal">Parent</code> will contain a collection of children and, since the cascading update is enabled, Hibernate needs to know which children are newly instantiated and which represent existing rows in the database. We will also assume that both <code class="literal">Parent</code> and <code class="literal">Child</code> have generated identifier properties of type <code class="literal">Long</code>. Hibernate will use the identifier and version/timestamp property value to determine which of the children are new. (See <a href="#objectstate-saveorupdate" title="10.7. 자동적인 상태 검출">10.7절. “자동적인 상태 검출”</a>.) <span class="emphasis"><em>In Hibernate3, it is no longer necessary to specify an <code class="literal">unsaved-value</code> explicitly.</em></span> </p><p>The following code will update <code class="literal">parent</code> and <code class="literal">child</code> and insert <code class="literal">newChild</code>: </p><pre class="programlisting">//parent and child were both loaded in a previous session
parent.addChild(child);
Child newChild = new Child();
parent.addChild(newChild);
session.update(parent);
session.flush();</pre><p>This may be suitable for the case of a generated identifier, but what about assigned identifiers and composite identifiers? This is more difficult, since Hibernate cannot use the identifier property to distinguish between a newly instantiated object, with an identifier assigned by the user, and an object loaded in a previous session. In this case, Hibernate will either use the timestamp or version property, or will actually query the second-level cache or, worst case, the database, to see if the row exists. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="example-parentchild-conclusion"/>21.5. 결론</h2></div></div></div><p>The sections we have just covered can be a bit confusing. However, in practice, it all works out nicely. Most Hibernate applications use the parent/child pattern in many places. </p><p>We mentioned an alternative in the first paragraph. None of the above issues exist in the case of <code class="literal">&lt;composite-element&gt;</code> mappings, which have exactly the semantics of a parent/child relationship. Unfortunately, there are two big limitations with composite element classes: composite elements cannot own collections and they should not be the child of any entity other than the unique parent. </p></div></div><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="example-weblog"/>22장. 예제: Weblog 어플리케이션</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#example-weblog-classes">22.1. 영속 클래스들</a></span></dt><dt><span class="sect1"><a href="#example-weblog-mappings">22.2. Hibernate 매핑들</a></span></dt><dt><span class="sect1"><a href="#example-weblog-code">22.3. Hibernate 코드</a></span></dt></dl></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="example-weblog-classes"/>22.1. 영속 클래스들</h2></div></div></div><p>The persistent classes here represent a weblog and an item posted in a weblog. They are to be modelled as a standard parent/child relationship, but we will use an ordered bag, instead of a set: </p><pre class="programlisting">package eg;

import java.util.List;

public class Blog {
    private Long _id;
    private String _name;
    private List _items;

    public Long getId() {
        return _id;
    }
    public List getItems() {
        return _items;
    }
    public String getName() {
        return _name;
    }
    public void setId(Long long1) {
        _id = long1;
    }
    public void setItems(List list) {
        _items = list;
    }
    public void setName(String string) {
        _name = string;
    }
}</pre><pre class="programlisting">package eg;

import java.text.DateFormat;
import java.util.Calendar;

public class BlogItem {
    private Long _id;
    private Calendar _datetime;
    private String _text;
    private String _title;
    private Blog _blog;

    public Blog getBlog() {
        return _blog;
    }
    public Calendar getDatetime() {
        return _datetime;
    }
    public Long getId() {
        return _id;
    }
    public String getText() {
        return _text;
    }
    public String getTitle() {
        return _title;
    }
    public void setBlog(Blog blog) {
        _blog = blog;
    }
    public void setDatetime(Calendar calendar) {
        _datetime = calendar;
    }
    public void setId(Long long1) {
        _id = long1;
    }
    public void setText(String string) {
        _text = string;
    }
    public void setTitle(String string) {
        _title = string;
    }
}</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="example-weblog-mappings"/>22.2. Hibernate 매핑들</h2></div></div></div><p>The XML mappings are now straightforward. For example: </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

    &lt;class
        name="Blog"
        table="BLOGS"&gt;

        &lt;id
            name="id"
            column="BLOG_ID"&gt;

            &lt;generator class="native"/&gt;

        &lt;/id&gt;

        &lt;property
            name="name"
            column="NAME"
            not-null="true"
            unique="true"/&gt;

        &lt;bag
            name="items"
            inverse="true"
            order-by="DATE_TIME"
            cascade="all"&gt;

            &lt;key column="BLOG_ID"/&gt;
            &lt;one-to-many class="BlogItem"/&gt;

        &lt;/bag&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;

&lt;hibernate-mapping package="eg"&gt;

    &lt;class
        name="BlogItem"
        table="BLOG_ITEMS"
        dynamic-update="true"&gt;

        &lt;id
            name="id"
            column="BLOG_ITEM_ID"&gt;

            &lt;generator class="native"/&gt;

        &lt;/id&gt;

        &lt;property
            name="title"
            column="TITLE"
            not-null="true"/&gt;

        &lt;property
            name="text"
            column="TEXT"
            not-null="true"/&gt;

        &lt;property
            name="datetime"
            column="DATE_TIME"
            not-null="true"/&gt;

        &lt;many-to-one
            name="blog"
            column="BLOG_ID"
            not-null="true"/&gt;

    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="example-weblog-code"/>22.3. Hibernate 코드</h2></div></div></div><p>The following class demonstrates some of the kinds of things we can do with these classes using Hibernate: </p><pre class="programlisting">package eg;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Iterator;
import java.util.List;

import org.hibernate.HibernateException;
import org.hibernate.Query;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;
import org.hibernate.tool.hbm2ddl.SchemaExport;

public class BlogMain {
    
    private SessionFactory _sessions;
    
    public void configure() throws HibernateException {
        _sessions = new Configuration()
            .addClass(Blog.class)
            .addClass(BlogItem.class)
            .buildSessionFactory();
    }
    
    public void exportTables() throws HibernateException {
        Configuration cfg = new Configuration()
            .addClass(Blog.class)
            .addClass(BlogItem.class);
        new SchemaExport(cfg).create(true, true);
    }
    
    public Blog createBlog(String name) throws HibernateException {
        
        Blog blog = new Blog();
        blog.setName(name);
        blog.setItems( new ArrayList() );
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.persist(blog);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return blog;
    }
    
    public BlogItem createBlogItem(Blog blog, String title, String text)
                        throws HibernateException {
        
        BlogItem item = new BlogItem();
        item.setTitle(title);
        item.setText(text);
        item.setBlog(blog);
        item.setDatetime( Calendar.getInstance() );
        blog.getItems().add(item);
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.update(blog);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return item;
    }
    
    public BlogItem createBlogItem(Long blogid, String title, String text)
                        throws HibernateException {
        
        BlogItem item = new BlogItem();
        item.setTitle(title);
        item.setText(text);
        item.setDatetime( Calendar.getInstance() );
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            Blog blog = (Blog) session.load(Blog.class, blogid);
            item.setBlog(blog);
            blog.getItems().add(item);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return item;
    }
    
    public void updateBlogItem(BlogItem item, String text)
                    throws HibernateException {
        
        item.setText(text);
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            session.update(item);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
    }
    
    public void updateBlogItem(Long itemid, String text)
                    throws HibernateException {
    
        Session session = _sessions.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            BlogItem item = (BlogItem) session.load(BlogItem.class, itemid);
            item.setText(text);
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
    }
    
    public List listAllBlogNamesAndItemCounts(int max)
                    throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        List result = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "select blog.id, blog.name, count(blogItem) " +
                "from Blog as blog " +
                "left outer join blog.items as blogItem " +
                "group by blog.name, blog.id " +
                "order by max(blogItem.datetime)"
            );
            q.setMaxResults(max);
            result = q.list();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return result;
    }
    
    public Blog getBlogAndAllItems(Long blogid)
                    throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        Blog blog = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "from Blog as blog " +
                "left outer join fetch blog.items " +
                "where blog.id = :blogid"
            );
            q.setParameter("blogid", blogid);
            blog  = (Blog) q.uniqueResult();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return blog;
    }
    
    public List listBlogsAndRecentItems() throws HibernateException {
        
        Session session = _sessions.openSession();
        Transaction tx = null;
        List result = null;
        try {
            tx = session.beginTransaction();
            Query q = session.createQuery(
                "from Blog as blog " +
                "inner join blog.items as blogItem " +
                "where blogItem.datetime &gt; :minDate"
            );

            Calendar cal = Calendar.getInstance();
            cal.roll(Calendar.MONTH, false);
            q.setCalendar("minDate", cal);
            
            result = q.list();
            tx.commit();
        }
        catch (HibernateException he) {
            if (tx!=null) tx.rollback();
            throw he;
        }
        finally {
            session.close();
        }
        return result;
    }
}</pre></div></div><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="example-mappings"/>23장. 예제: 여러 가지 매핑들</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#example-mappings-emp">23.1. Employer/Employee</a></span></dt><dt><span class="sect1"><a href="#example-mappings-authorwork">23.2. Author/Work</a></span></dt><dt><span class="sect1"><a href="#example-mappings-customerorderproduct">23.3. Customer/Order/Product</a></span></dt><dt><span class="sect1"><a href="#misc">23.4. 기타 예제 매핑들</a></span></dt><dd><dl><dt><span class="sect2"><a href="#example-mappings-typed-onetone">23.4.1. "형식화된(Typed)" one-to-one 연관</a></span></dt><dt><span class="sect2"><a href="#example-mappings-composite-key">23.4.2. Composite 키 예제</a></span></dt><dt><span class="sect2"><a href="#example-mappings-composite-key-manytomany">23.4.3. 공유된 합성 키 속성을 가진 Many-to-many</a></span></dt><dt><span class="sect2"><a href="#example-mappings-content-discrimination">23.4.4. 내용 기반 판별</a></span></dt><dt><span class="sect2"><a href="#example-mappings-association-alternatekeys">23.4.5. 대체 키들에 대한 연관들</a></span></dt></dl></dd></dl></div><p>This chapters explores some more complex association mappings. </p><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="example-mappings-emp"/>23.1. Employer/Employee</h2></div></div></div><p>The following model of the relationship between <code class="literal">Employer</code> and <code class="literal">Employee</code> uses an entity class (<code class="literal">Employment</code>) to represent the association. You can do this when there might be more than one period of employment for the same two parties. Components are used to model monetary values and employee names. </p><div class="mediaobject" align="center"><img src="../images/EmployerEmployee.png" align="middle"/></div><p>Here is a possible mapping document: </p><pre class="programlisting">&lt;hibernate-mapping&gt;
        
    &lt;class name="Employer" table="employers"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employer_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

    &lt;class name="Employment" table="employment_periods"&gt;

        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employment_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="startDate" column="start_date"/&gt;
        &lt;property name="endDate" column="end_date"/&gt;

        &lt;component name="hourlyRate" class="MonetaryAmount"&gt;
            &lt;property name="amount"&gt;
                &lt;column name="hourly_rate" sql-type="NUMERIC(12, 2)"/&gt;
            &lt;/property&gt;
            &lt;property name="currency" length="12"/&gt;
        &lt;/component&gt;

        &lt;many-to-one name="employer" column="employer_id" not-null="true"/&gt;
        &lt;many-to-one name="employee" column="employee_id" not-null="true"/&gt;

    &lt;/class&gt;

    &lt;class name="Employee" table="employees"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="sequence"&gt;
                &lt;param name="sequence"&gt;employee_id_seq&lt;/param&gt;
            &lt;/generator&gt;
        &lt;/id&gt;
        &lt;property name="taxfileNumber"/&gt;
        &lt;component name="name" class="Name"&gt;
            &lt;property name="firstName"/&gt;
            &lt;property name="initial"/&gt;
            &lt;property name="lastName"/&gt;
        &lt;/component&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>Here is the table schema generated by <code class="literal">SchemaExport</code>. </p><pre class="programlisting">create table employers (
    id BIGINT not null, 
    name VARCHAR(255), 
    primary key (id)
)

create table employment_periods (
    id BIGINT not null,
    hourly_rate NUMERIC(12, 2),
    currency VARCHAR(12), 
    employee_id BIGINT not null, 
    employer_id BIGINT not null, 
    end_date TIMESTAMP, 
    start_date TIMESTAMP, 
    primary key (id)
)

create table employees (
    id BIGINT not null, 
    firstName VARCHAR(255), 
    initial CHAR(1), 
    lastName VARCHAR(255), 
    taxfileNumber VARCHAR(255), 
    primary key (id)
)

alter table employment_periods 
    add constraint employment_periodsFK0 foreign key (employer_id) references employers
alter table employment_periods 
    add constraint employment_periodsFK1 foreign key (employee_id) references employees
create sequence employee_id_seq
create sequence employment_id_seq
create sequence employer_id_seq</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="example-mappings-authorwork"/>23.2. Author/Work</h2></div></div></div><p>Consider the following model of the relationships between <code class="literal">Work</code>, <code class="literal">Author</code> and <code class="literal">Person</code>. In the example, the relationship between <code class="literal">Work</code> and <code class="literal">Author</code> is represented as a many-to-many association and the relationship between <code class="literal">Author</code> and <code class="literal">Person</code> is represented as one-to-one association. Another possibility would be to have <code class="literal">Author</code> extend <code class="literal">Person</code>. </p><div class="mediaobject" align="center"><img src="../images/AuthorWork.png" align="middle"/></div><p>다음 매핑 문서는 이들 관계들을 정확하게 표현한다: </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Work" table="works" discriminator-value="W"&gt;

        &lt;id name="id" column="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;discriminator column="type" type="character"/&gt;

        &lt;property name="title"/&gt;
        &lt;set name="authors" table="author_work"&gt;
            &lt;key column name="work_id"/&gt;
            &lt;many-to-many class="Author" column name="author_id"/&gt;
        &lt;/set&gt;

        &lt;subclass name="Book" discriminator-value="B"&gt;
            &lt;property name="text"/&gt;
        &lt;/subclass&gt;

        &lt;subclass name="Song" discriminator-value="S"&gt;
            &lt;property name="tempo"/&gt;
            &lt;property name="genre"/&gt;
        &lt;/subclass&gt;

    &lt;/class&gt;

    &lt;class name="Author" table="authors"&gt;

        &lt;id name="id" column="id"&gt;
            &lt;!-- The Author must have the same identifier as the Person --&gt;
            &lt;generator class="assigned"/&gt; 
        &lt;/id&gt;

        &lt;property name="alias"/&gt;
        &lt;one-to-one name="person" constrained="true"/&gt;

        &lt;set name="works" table="author_work" inverse="true"&gt;
            &lt;key column="author_id"/&gt;
            &lt;many-to-many class="Work" column="work_id"/&gt;
        &lt;/set&gt;

    &lt;/class&gt;

    &lt;class name="Person" table="persons"&gt;
        &lt;id name="id" column="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p>There are four tables in this mapping: <code class="literal">works</code>, <code class="literal">authors</code> and <code class="literal">persons</code> hold work, author and person data respectively. <code class="literal">author_work</code> is an association table linking authors to works. Here is the table schema, as generated by <code class="literal">SchemaExport</code>: </p><pre class="programlisting">create table works (
    id BIGINT not null generated by default as identity, 
    tempo FLOAT, 
    genre VARCHAR(255), 
    text INTEGER, 
    title VARCHAR(255), 
    type CHAR(1) not null, 
    primary key (id)
)

create table author_work (
    author_id BIGINT not null, 
    work_id BIGINT not null, 
    primary key (work_id, author_id)
)

create table authors (
    id BIGINT not null generated by default as identity, 
    alias VARCHAR(255), 
    primary key (id)
)

create table persons (
    id BIGINT not null generated by default as identity, 
    name VARCHAR(255), 
    primary key (id)
)

alter table authors 
    add constraint authorsFK0 foreign key (id) references persons
alter table author_work 
    add constraint author_workFK0 foreign key (author_id) references authors
alter table author_work
    add constraint author_workFK1 foreign key (work_id) references works</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="example-mappings-customerorderproduct"/>23.3. Customer/Order/Product</h2></div></div></div><p>In this section we consider a model of the relationships between <code class="literal">Customer</code>, <code class="literal">Order</code>, <code class="literal">Line Item</code> and <code class="literal">Product</code>. There is a one-to-many association between <code class="literal">Customer</code> and <code class="literal">Order</code>, but how can you represent <code class="literal">Order</code> / <code class="literal">LineItem</code> / <code class="literal">Product</code>? In the example, <code class="literal">LineItem</code> is mapped as an association class representing the many-to-many association between <code class="literal">Order</code> and <code class="literal">Product</code>. In Hibernate this is called a composite element. </p><div class="mediaobject" align="center"><img src="../images/CustomerOrderProduct.png" align="middle"/></div><p>The mapping document will look like this: </p><pre class="programlisting">&lt;hibernate-mapping&gt;

    &lt;class name="Customer" table="customers"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="name"/&gt;
        &lt;set name="orders" inverse="true"&gt;
            &lt;key column="customer_id"/&gt;
            &lt;one-to-many class="Order"/&gt;
        &lt;/set&gt;
    &lt;/class&gt;

    &lt;class name="Order" table="orders"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="date"/&gt;
        &lt;many-to-one name="customer" column="customer_id"/&gt;
        &lt;list name="lineItems" table="line_items"&gt;
            &lt;key column="order_id"/&gt;
            &lt;list-index column="line_number"/&gt;
            &lt;composite-element class="LineItem"&gt;
                &lt;property name="quantity"/&gt;
                &lt;many-to-one name="product" column="product_id"/&gt;
            &lt;/composite-element&gt;
        &lt;/list&gt;
    &lt;/class&gt;

    &lt;class name="Product" table="products"&gt;
        &lt;id name="id"&gt;
            &lt;generator class="native"/&gt;
        &lt;/id&gt;
        &lt;property name="serialNumber"/&gt;
    &lt;/class&gt;

&lt;/hibernate-mapping&gt;</pre><p><code class="literal">customers</code>, <code class="literal">orders</code>, <code class="literal">line_items</code> 그리고 <code class="literal">products</code>는 각각 고객 데이터, 주문 데이터, 주문 라인 아이템 데이터, 그리고 제품 데이터를 보관한다. <code class="literal">line_items</code>는 또한 주문들을 제품들과 연결시키는 연관 테이블로서 동작한다. </p><pre class="programlisting">create table customers (
    id BIGINT not null generated by default as identity, 
    name VARCHAR(255), 
    primary key (id)
)

create table orders (
    id BIGINT not null generated by default as identity, 
    customer_id BIGINT, 
    date TIMESTAMP, 
    primary key (id)
)

create table line_items (
    line_number INTEGER not null, 
    order_id BIGINT not null, 
    product_id BIGINT, 
    quantity INTEGER, 
    primary key (order_id, line_number)
)

create table products (
    id BIGINT not null generated by default as identity, 
    serialNumber VARCHAR(255), 
    primary key (id)
)

alter table orders 
    add constraint ordersFK0 foreign key (customer_id) references customers
alter table line_items
    add constraint line_itemsFK0 foreign key (product_id) references products
alter table line_items
    add constraint line_itemsFK1 foreign key (order_id) references orders</pre></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="misc"/>23.4. 기타 예제 매핑들</h2></div></div></div><p>These examples are available from the Hibernate test suite. You will find many other useful example mappings there by searching in the <code class="literal">test</code> folder of the Hibernate distribution. </p><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="example-mappings-typed-onetone"/>23.4.1. "형식화된(Typed)" one-to-one 연관</h3></div></div></div><pre class="programlisting">&lt;class name="Person"&gt;
    &lt;id name="name"/&gt;
    &lt;one-to-one name="address" 
            cascade="all"&gt;
        &lt;formula&gt;name&lt;/formula&gt;
        &lt;formula&gt;'HOME'&lt;/formula&gt;
    &lt;/one-to-one&gt;
    &lt;one-to-one name="mailingAddress" 
            cascade="all"&gt;
        &lt;formula&gt;name&lt;/formula&gt;
        &lt;formula&gt;'MAILING'&lt;/formula&gt;
    &lt;/one-to-one&gt;
&lt;/class&gt;

&lt;class name="Address" batch-size="2" 
        check="addressType in ('MAILING', 'HOME', 'BUSINESS')"&gt;
    &lt;composite-id&gt;
        &lt;key-many-to-one name="person" 
                column="personName"/&gt;
        &lt;key-property name="type" 
                column="addressType"/&gt;
    &lt;/composite-id&gt;
    &lt;property name="street" type="text"/&gt;
    &lt;property name="state"/&gt;
    &lt;property name="zip"/&gt;
&lt;/class&gt;</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="example-mappings-composite-key"/>23.4.2. Composite 키 예제</h3></div></div></div><pre class="programlisting">&lt;class name="Customer"&gt;

    &lt;id name="customerId"
        length="10"&gt;
        &lt;generator class="assigned"/&gt;
    &lt;/id&gt;

    &lt;property name="name" not-null="true" length="100"/&gt;
    &lt;property name="address" not-null="true" length="200"/&gt;

    &lt;list name="orders"
            inverse="true"
            cascade="save-update"&gt;
        &lt;key column="customerId"/&gt;
        &lt;index column="orderNumber"/&gt;
        &lt;one-to-many class="Order"/&gt;
    &lt;/list&gt;

&lt;/class&gt;

&lt;class name="Order" table="CustomerOrder" lazy="true"&gt;
    &lt;synchronize table="LineItem"/&gt;
    &lt;synchronize table="Product"/&gt;
    
    &lt;composite-id name="id" 
            class="Order$Id"&gt;
        &lt;key-property name="customerId" length="10"/&gt;
        &lt;key-property name="orderNumber"/&gt;
    &lt;/composite-id&gt;
    
    &lt;property name="orderDate" 
            type="calendar_date"
            not-null="true"/&gt;
    
    &lt;property name="total"&gt;
        &lt;formula&gt;
            ( select sum(li.quantity*p.price) 
            from LineItem li, Product p 
            where li.productId = p.productId 
                and li.customerId = customerId 
                and li.orderNumber = orderNumber )
        &lt;/formula&gt;
    &lt;/property&gt;
    
    &lt;many-to-one name="customer"
            column="customerId"
            insert="false"
            update="false" 
            not-null="true"/&gt;
        
    &lt;bag name="lineItems"
            fetch="join" 
            inverse="true"
            cascade="save-update"&gt;
        &lt;key&gt;
            &lt;column name="customerId"/&gt;
            &lt;column name="orderNumber"/&gt;
        &lt;/key&gt;
        &lt;one-to-many class="LineItem"/&gt;
    &lt;/bag&gt;
    
&lt;/class&gt;
    
&lt;class name="LineItem"&gt;
    
    &lt;composite-id name="id" 
            class="LineItem$Id"&gt;
        &lt;key-property name="customerId" length="10"/&gt;
        &lt;key-property name="orderNumber"/&gt;
        &lt;key-property name="productId" length="10"/&gt;
    &lt;/composite-id&gt;
    
    &lt;property name="quantity"/&gt;
    
    &lt;many-to-one name="order"
            insert="false"
            update="false" 
            not-null="true"&gt;
        &lt;column name="customerId"/&gt;
        &lt;column name="orderNumber"/&gt;
    &lt;/many-to-one&gt;
    
    &lt;many-to-one name="product"
            insert="false"
            update="false" 
            not-null="true"
            column="productId"/&gt;
        
&lt;/class&gt;

&lt;class name="Product"&gt;
    &lt;synchronize table="LineItem"/&gt;

    &lt;id name="productId"
        length="10"&gt;
        &lt;generator class="assigned"/&gt;
    &lt;/id&gt;
    
    &lt;property name="description" 
        not-null="true" 
        length="200"/&gt;
    &lt;property name="price" length="3"/&gt;
    &lt;property name="numberAvailable"/&gt;
    
    &lt;property name="numberOrdered"&gt;
        &lt;formula&gt;
            ( select sum(li.quantity) 
            from LineItem li 
            where li.productId = productId )
        &lt;/formula&gt;
    &lt;/property&gt;
    
&lt;/class&gt;</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="example-mappings-composite-key-manytomany"/>23.4.3. 공유된 합성 키 속성을 가진 Many-to-many</h3></div></div></div><pre class="programlisting">&lt;class name="User" table="`User`"&gt;
    &lt;composite-id&gt;
        &lt;key-property name="name"/&gt;
        &lt;key-property name="org"/&gt;
    &lt;/composite-id&gt;
    &lt;set name="groups" table="UserGroup"&gt;
        &lt;key&gt;
            &lt;column name="userName"/&gt;
            &lt;column name="org"/&gt;
        &lt;/key&gt;
        &lt;many-to-many class="Group"&gt;
            &lt;column name="groupName"/&gt;
            &lt;formula&gt;org&lt;/formula&gt;
        &lt;/many-to-many&gt;
    &lt;/set&gt;
&lt;/class&gt;
    
&lt;class name="Group" table="`Group`"&gt;
    &lt;composite-id&gt;
        &lt;key-property name="name"/&gt;
        &lt;key-property name="org"/&gt;
    &lt;/composite-id&gt;
    &lt;property name="description"/&gt;
    &lt;set name="users" table="UserGroup" inverse="true"&gt;
        &lt;key&gt;
            &lt;column name="groupName"/&gt;
            &lt;column name="org"/&gt;
        &lt;/key&gt;
        &lt;many-to-many class="User"&gt;
            &lt;column name="userName"/&gt;
            &lt;formula&gt;org&lt;/formula&gt;
        &lt;/many-to-many&gt;
    &lt;/set&gt;
&lt;/class&gt;
</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="example-mappings-content-discrimination"/>23.4.4. 내용 기반 판별</h3></div></div></div><pre class="programlisting">&lt;class name="Person"
    discriminator-value="P"&gt;
    
    &lt;id name="id" 
        column="person_id" 
        unsaved-value="0"&gt;
        &lt;generator class="native"/&gt;
    &lt;/id&gt;
    
            
    &lt;discriminator 
        type="character"&gt;
        &lt;formula&gt;
            case 
                when title is not null then 'E' 
                when salesperson is not null then 'C' 
                else 'P' 
            end
        &lt;/formula&gt;
    &lt;/discriminator&gt;

    &lt;property name="name" 
        not-null="true"
        length="80"/&gt;
        
    &lt;property name="sex" 
        not-null="true"
        update="false"/&gt;
    
    &lt;component name="address"&gt;
        &lt;property name="address"/&gt;
        &lt;property name="zip"/&gt;
        &lt;property name="country"/&gt;
    &lt;/component&gt;
    
    &lt;subclass name="Employee" 
        discriminator-value="E"&gt;
            &lt;property name="title"
                length="20"/&gt;
            &lt;property name="salary"/&gt;
            &lt;many-to-one name="manager"/&gt;
    &lt;/subclass&gt;
    
    &lt;subclass name="Customer" 
        discriminator-value="C"&gt;
            &lt;property name="comments"/&gt;
            &lt;many-to-one name="salesperson"/&gt;
    &lt;/subclass&gt;
    
&lt;/class&gt;</pre></div><div class="sect2" lang="ko-KR"><div class="titlepage"><div><div><h3 class="title"><a id="example-mappings-association-alternatekeys"/>23.4.5. 대체 키들에 대한 연관들</h3></div></div></div><pre class="programlisting">&lt;class name="Person"&gt;
    
    &lt;id name="id"&gt;
        &lt;generator class="hilo"/&gt;
    &lt;/id&gt;
    
    &lt;property name="name" length="100"/&gt;
    
    &lt;one-to-one name="address" 
        property-ref="person"
        cascade="all"
        fetch="join"/&gt;
    
    &lt;set name="accounts" 
        inverse="true"&gt;
        &lt;key column="userId"
            property-ref="userId"/&gt;
        &lt;one-to-many class="Account"/&gt;
    &lt;/set&gt;
    
    &lt;property name="userId" length="8"/&gt;

&lt;/class&gt;

&lt;class name="Address"&gt;

    &lt;id name="id"&gt;
        &lt;generator class="hilo"/&gt;
    &lt;/id&gt;

    &lt;property name="address" length="300"/&gt;
    &lt;property name="zip" length="5"/&gt;
    &lt;property name="country" length="25"/&gt;
    &lt;many-to-one name="person" unique="true" not-null="true"/&gt;

&lt;/class&gt;

&lt;class name="Account"&gt;
    &lt;id name="accountId" length="32"&gt;
        &lt;generator class="uuid"/&gt;
    &lt;/id&gt;
    
    &lt;many-to-one name="user"
        column="userId"
        property-ref="userId"/&gt;
    
    &lt;property name="type" not-null="true"/&gt;
    
&lt;/class&gt;</pre></div></div></div><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="best-practices"/>24장. 최상의 실전 경험들</h2></div></div></div><div class="variablelist"><dl><dt><span class="term">Write fine-grained classes and map them using <code class="literal">&lt;component&gt;</code>:</span></dt><dd><p><code class="literal">street</code>, <code class="literal">suburb</code>, <code class="literal">state</code>, <code class="literal">postcode</code>를 캡슐화 시키는데 <code class="literal">Address</code> 클래스를 사용하라. 이것은 코드 재사용성을 촉진시키고 리팩토링을 단순화 시킨다. </p></dd><dt><span class="term">Declare identifier properties on persistent classes:</span></dt><dd><p>Hibernate makes identifier properties optional. There are a range of reasons why you should use them. We recommend that identifiers be 'synthetic', that is, generated with no business meaning. </p></dd><dt><span class="term">Identify natural keys:</span></dt><dd><p>모든 엔티티들에 대해 고유 키들을 식별하고, <code class="literal">&lt;natural-id&gt;</code>를 사용하여 그것들을 매핑하라. 고유 키를 구성하는 프로퍼티들을 비교하기 위해 <code class="literal">equals()</code>와 <code class="literal">hashCode()</code>를 구현하라. </p></dd><dt><span class="term">Place each class mapping in its own file:</span></dt><dd><p>Do not use a single monolithic mapping document. Map <code class="literal">com.eg.Foo</code> in the file <code class="literal">com/eg/Foo.hbm.xml</code>. This makes sense, particularly in a team environment. </p></dd><dt><span class="term">Load mappings as resources:</span></dt><dd><p>그것들이 매핑하는 클래스들에 따라서 매핑들을 배치하라 </p></dd><dt><span class="term">Consider externalizing query strings:</span></dt><dd><p>This is recommended if your queries call non-ANSI-standard SQL functions. Externalizing the query strings to mapping files will make the application more portable. </p></dd><dt><span class="term">바인드 변수들을 사용하라.</span></dt><dd><p>As in JDBC, always replace non-constant values by "?". Do not use string manipulation to bind a non-constant value in a query. You should also consider using named parameters in queries. </p></dd><dt><span class="term">Do not manage your own JDBC connections:</span></dt><dd><p>Hibernate allows the application to manage JDBC connections, but his approach should be considered a last-resort. If you cannot use the built-in connection providers, consider providing your own implementation of <code class="literal">org.hibernate.connection.ConnectionProvider</code>. </p></dd><dt><span class="term">Consider using a custom type:</span></dt><dd><p>Suppose you have a Java type from a library that needs to be persisted but does not provide the accessors needed to map it as a component. You should consider implementing <code class="literal">org.hibernate.UserType</code>. This approach frees the application code from implementing transformations to/from a Hibernate type. </p></dd><dt><span class="term">Use hand-coded JDBC in bottlenecks:</span></dt><dd><p>In performance-critical areas of the system, some kinds of operations might benefit from direct JDBC. Do not assume, however, that JDBC is necessarily faster. Please wait until you <span class="emphasis"><em>know</em></span> something is a bottleneck. If you need to use direct JDBC, you can open a Hibernate <code class="literal">Session</code> and usingfile:///usr/share/doc/HTML/en-US/index.html that JDBC connection. This way you can still use the same transaction strategy and underlying connection provider. </p></dd><dt><span class="term">Understand <code class="literal">Session</code> flushing:</span></dt><dd><p>Sometimes the Session synchronizes its persistent state with the database. Performance will be affected if this process occurs too often. You can sometimes minimize unnecessary flushing by disabling automatic flushing, or even by changing the order of queries and other operations within a particular transaction. </p></dd><dt><span class="term">In a three tiered architecture, consider using detached objects:</span></dt><dd><p>When using a servlet/session bean architecture, you can pass persistent objects loaded in the session bean to and from the servlet/JSP layer. Use a new session to service each request. Use <code class="literal">Session.merge()</code> or <code class="literal">Session.saveOrUpdate()</code> to synchronize objects with the database. </p></dd><dt><span class="term">In a two tiered architecture, consider using long persistence contexts:</span></dt><dd><p>Database Transactions have to be as short as possible for best scalability. However, it is often necessary to implement long running <span class="emphasis"><em>application transactions</em></span>, a single unit-of-work from the point of view of a user. An application transaction might span several client request/response cycles. It is common to use detached objects to implement application transactions. An appropriate alternative in a two tiered architecture, is to maintain a single open persistence contact session for the whole life cycle of the application transaction. Then simply disconnect from the JDBC connection at the end of each request and reconnect at the beginning of the subsequent request. Never share a single session across more than one application transaction or you will be working with stale data. </p></dd><dt><span class="term">Do not treat exceptions as recoverable:</span></dt><dd><p>This is more of a necessary practice than a "best" practice. When an exception occurs, roll back the <code class="literal">Transaction</code> and close the <code class="literal">Session</code>. If you do not do this, Hibernate cannot guarantee that in-memory state accurately represents the persistent state. For example, do not use <code class="literal">Session.load()</code> to determine if an instance with the given identifier exists on the database; use <code class="literal">Session.get()</code> or a query instead. </p></dd><dt><span class="term">Prefer lazy fetching for associations:</span></dt><dd><p>Use eager fetching sparingly. Use proxies and lazy collections for most associations to classes that are not likely to be completely held in the second-level cache. For associations to cached classes, where there is an a extremely high probability of a cache hit, explicitly disable eager fetching using <code class="literal">lazy="false"</code>. When join fetching is appropriate to a particular use case, use a query with a <code class="literal">left join fetch</code>. </p></dd><dt><span class="term">Use the <span class="emphasis"><em>open session in view</em></span> pattern, or a disciplined <span class="emphasis"><em>assembly phase</em></span> to avoid problems with unfetched data: </span></dt><dd><p>Hibernate frees the developer from writing tedious <span class="emphasis"><em>Data Transfer Objects</em></span> (DTO). In a traditional EJB architecture, DTOs serve dual purposes: first, they work around the problem that entity beans are not serializable; second, they implicitly define an assembly phase where all data to be used by the view is fetched and marshalled into the DTOs before returning control to the presentation tier. Hibernate eliminates the first purpose. Unless you are prepared to hold the persistence context (the session) open across the view rendering process, you will still need an assembly phase. Think of your business methods as having a strict contract with the presentation tier about what data is available in the detached objects. This is not a limitation of Hibernate. It is a fundamental requirement of safe transactional data access. </p></dd><dt><span class="term">Consider abstracting your business logic from Hibernate:</span></dt><dd><p>Hide Hibernate data-access code behind an interface. Combine the <span class="emphasis"><em>DAO</em></span> and <span class="emphasis"><em>Thread Local Session</em></span> patterns. You can even have some classes persisted by handcoded JDBC associated to Hibernate via a <code class="literal">UserType</code>. This advice is, however, intended for "sufficiently large" applications. It is not appropriate for an application with five tables. </p></dd><dt><span class="term">Do not use exotic association mappings:</span></dt><dd><p>Practical test cases for real many-to-many associations are rare. Most of the time you need additional information stored in the "link table". In this case, it is much better to use two one-to-many associations to an intermediate link class. In fact, most associations are one-to-many and many-to-one. For this reason, you should proceed cautiously when using any other association style. </p></dd><dt><span class="term">Prefer bidirectional associations:</span></dt><dd><p>단방향 연관들은 질의하기가 더 어렵다. 많은 어플리케이션에서, 거의 모든 연관들은 질의들 내에서 양 방향으로 네비게이트 가능해야 한다. </p></dd></dl></div></div><div class="chapter" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="portability"/>25장. Database Portability Considerations</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#portability-basics">25.1. Portability Basics</a></span></dt><dt><span class="sect1"><a href="#portability-dialect">25.2. Dialect</a></span></dt><dt><span class="sect1"><a href="#portability-dialectresolver">25.3. Dialect resolution</a></span></dt><dt><span class="sect1"><a href="#portability-idgen">25.4. Identifier generation</a></span></dt><dt><span class="sect1"><a href="#portability-functions">25.5. Database functions</a></span></dt><dt><span class="sect1"><a href="#portability-types">25.6. Type mappings</a></span></dt></dl></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="portability-basics"/>25.1. Portability Basics</h2></div></div></div><p>One of the selling points of Hibernate (and really Object/Relational Mapping as a whole) is the notion of database portability. This could mean an internal IT user migrating from one database vendor to another, or it could mean a framework or deployable application consuming Hibernate to simultaneously target multiple database products by their users. Regardless of the exact scenario, the basic idea is that you want Hibernate to help you run against any number of databases without changes to your code, and ideally without any changes to the mapping metadata. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="portability-dialect"/>25.2. Dialect</h2></div></div></div><p>The first line of portability for Hibernate is the dialect, which is a specialization of the <code class="classname">org.hibernate.dialect.Dialect</code> contract. A dialect encapsulates all the differences in how Hibernate must communicate with a particular database to accomplish some task like getting a sequence value or structuring a SELECT query. Hibernate bundles a wide range of dialects for many of the most popular databases. If you find that your particular database is not among them, it is not terribly difficult to write your own. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="portability-dialectresolver"/>25.3. Dialect resolution</h2></div></div></div><p>Originally, Hibernate would always require that users specify which dialect to use. In the case of users looking to simultaneously target multiple databases with their build that was problematic. Generally this required their users to configure the Hibernate dialect or defining their own method of setting that value. </p><p>Starting with version 3.2, Hibernate introduced the notion of automatically detecting the dialect to use based on the <code class="interfacename">java.sql.DatabaseMetaData</code> obtained from a <code class="interfacename">java.sql.Connection</code> to that database. This was much better, expect that this resolution was limited to databases Hibernate know about ahead of time and was in no way configurable or overrideable. </p><p>Starting with version 3.3, Hibernate has a fare more powerful way to automatically determine which dialect to should be used by relying on a series of delegates which implement the <code class="interfacename">org.hibernate.dialect.resolver.DialectResolver</code> which defines only a single method:</p><pre class="programlisting">public Dialect resolveDialect(DatabaseMetaData metaData) throws JDBCConnectionException</pre><p>. The basic contract here is that if the resolver 'understands' the given database metadata then it returns the corresponding Dialect; if not it returns null and the process continues to the next resolver. The signature also identifies <code class="exceptionname">org.hibernate.exception.JDBCConnectionException</code> as possibly being thrown. A JDBCConnectionException here is interpreted to imply a "non transient" (aka non-recoverable) connection problem and is used to indicate an immediate stop to resolution attempts. All other exceptions result in a warning and continuing on to the next resolver. </p><p>The cool part about these resolvers is that users can also register their own custom resolvers which will be processed ahead of the built-in Hibernate ones. This might be useful in a number of different situations: it allows easy integration for auto-detection of dialects beyond those shipped with HIbernate itself; it allows you to specify to use a custom dialect when a particular database is recognized; etc. To register one or more resolvers, simply specify them (seperated by commas, tabs or spaces) using the 'hibernate.dialect_resolvers' configuration setting (see the <code class="constant">DIALECT_RESOLVERS</code> constant on <code class="classname">org.hibernate.cfg.Environment</code>). </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="portability-idgen"/>25.4. Identifier generation</h2></div></div></div><p>When considering portability between databases, another important decision is selecting the identifier generation stratagy you want to use. Originally Hibernate provided the <span class="emphasis"><em>native</em></span> generator for this purpose, which was intended to select between a <span class="emphasis"><em>sequence</em></span>, <span class="emphasis"><em>identity</em></span>, or <span class="emphasis"><em>table</em></span> strategy depending on the capability of the underlying database. However, an insidious implication of this approach comes about when targtetting some databases which support <span class="emphasis"><em>identity</em></span> generation and some which do not. <span class="emphasis"><em>identity</em></span> generation relies on the SQL definition of an IDENTITY (or auto-increment) column to manage the identifier value; it is what is known as a post-insert generation strategy becauase the insert must actually happen before we can know the identifier value. Because Hibernate relies on this identifier value to uniquely reference entities within a persistence context it must then issue the insert immediately when the users requests the entitiy be associated with the session (like via save() e.g.) regardless of current transactional semantics. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>참고</h2><p> Hibernate was changed slightly once the implication of this was better understood so that the insert is delayed in cases where that is feasible. </p></div><p> The underlying issue is that the actual semanctics of the application itself changes in these cases. </p><p>Starting with version 3.2.3, Hibernate comes with a set of <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://in.relation.to/2082.lace">enhanced</a> identifier generators targetting portability in a much different way. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>참고</h2><p> There are specifically 2 bundled <span class="emphasis"><em>enhanced</em></span>generators: </p><div class="itemizedlist"><ul><li><p> <code class="classname">org.hibernate.id.enhanced.SequenceStyleGenerator</code> </p></li><li><p> <code class="classname">org.hibernate.id.enhanced.TableGenerator</code> </p></li></ul></div><p> </p></div><p> The idea behind these generators is to port the actual semantics of the identifer value generation to the different databases. For example, the <code class="classname">org.hibernate.id.enhanced.SequenceStyleGenerator</code> mimics the behavior of a sequence on databases which do not support sequences by using a table. </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="portability-functions"/>25.5. Database functions</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>주의</h2><p>This is an area in Hibernate in need of improvement. In terms of portability concerns, this function handling currently works pretty well from HQL; however, it is quite lacking in all other aspects. </p></div><p>SQL functions can be referenced in many ways by users. However, not all databases support the same set of functions. Hibernate, provides a means of mapping a <span class="emphasis"><em>logical</em></span> function name to a a delegate which knows how to render that particular function, perhaps even using a totally different physical function call. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>중요</h2><p>Technically this function registration is handled through the <code class="classname">org.hibernate.dialect.function.SQLFunctionRegistry</code> class which is intended to allow users to provide custom function definitions without having to provide a custom dialect. This specific behavior is not fully completed as of yet. </p><p>It is sort of implemented such that users can programatically register functions with the <code class="classname">org.hibernate.cfg.Configuration</code> and those functions will be recognized for HQL. </p></div><p>
        </p></div><div class="sect1" lang="ko-KR"><div class="titlepage"><div><div><h2 class="title"><a id="portability-types"/>25.6. Type mappings</h2></div></div></div><p>This section scheduled for completion at a later date... </p></div></div><div class="bibliography"><div class="titlepage"><div><div><h2 class="title"><a id="d0e16873"/>References</h2></div></div></div><div class="biblioentry"><a id="biblio-PoEAA"/><p>[<abbr class="abbrev">PoEAA</abbr>] <span class="title"><i>Patterns of Enterprise Application Architecture</i>. </span><span class="isbn">0-321-12742-0. </span><span class="authorgroup">지은이 <span class="firstname">Martin</span> <span class="surname">Fowler</span>. </span><span class="copyright">저작권 © 2003 Pearson Education, Inc.. </span><span class="publisher"><span class="publishername">Addison-Wesley Publishing Company. </span></span></p></div><div class="biblioentry"><a id="biblio-JPwH"/><p>[<abbr class="abbrev">JPwH</abbr>] <span class="title"><i>Java Persistence with Hibernate</i>. </span><span class="subtitle">Second Edition of Hibernate in Action. </span><span class="isbn">1-932394-88-5. </span><span class="bibliomisc">
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.manning.com/bauer2">http://www.manning.com/bauer2</a>
        . </span><span class="authorgroup">지은이 <span class="firstname">Christian</span> <span class="surname">Bauer</span> 그리고 <span class="firstname">Gavin</span> <span class="surname">King</span>. </span><span class="copyright">저작권 © 2007 Manning Publications Co.. </span><span class="publisher"><span class="publishername">Manning Publications Co.. </span></span></p></div></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">저작권 © 2004 Red Hat Middleware, LLC.</p></a></body></html>