msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2009-06-23 18:41+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: tutorial.xml:31
#, no-c-format
msgid "Tutorial"
msgstr ""

#. Tag: para
#: tutorial.xml:33
#, no-c-format
msgid ""
"Intended for new users, this chapter provides an step-by-step introduction "
"to Hibernate, starting with a simple application using an in-memory "
"database. The tutorial is based on an earlier tutorial developed by Michael "
"Gloegl. All code is contained in the <filename>tutorials/web</filename> "
"directory of the project source."
msgstr ""

#. Tag: para
#: tutorial.xml:42
#, no-c-format
msgid ""
"This tutorial expects the user have knowledge of both Java and SQL. If you "
"have a limited knowledge of JAVA or SQL, it is advised that you start with a "
"good introduction to that technology prior to attempting to learn Hibernate."
msgstr ""

#. Tag: para
#: tutorial.xml:51
#, no-c-format
msgid ""
"The distribution contains another example application under the "
"<filename>tutorial/eg</filename> project source directory."
msgstr ""

#. Tag: title
#: tutorial.xml:59
#, no-c-format
msgid "Part 1 - The first Hibernate Application"
msgstr "パート1 - 初めてのHibernateアプリケーション"

#. Tag: para
#: tutorial.xml:61
#, fuzzy, no-c-format
msgid ""
"For this example, we will set up a small database application that can store "
"events we want to attend and information about the host(s) of these events."
msgstr ""
"仮に小さなデータベースアプリケーションが必要だとしましょう。 そのアプリケー"
"ションには出席したいイベントと、 そのイベントのホストについての情報を格納する"
"ものとします。"

#. Tag: para
#: tutorial.xml:67
#, no-c-format
msgid ""
"Although you can use whatever database you feel comfortable using, we will "
"use <ulink url=\"http://hsqldb.org/\">HSQLDB</ulink> (an in-memory, Java "
"database) to avoid describing installation/setup of any particular database "
"servers."
msgstr ""

#. Tag: title
#: tutorial.xml:76
#, no-c-format
msgid "Setup"
msgstr ""

#. Tag: para
#: tutorial.xml:78
#, no-c-format
msgid ""
"The first thing we need to do is to set up the development environment. We "
"will be using the \"standard layout\" advocated by alot of build tools such "
"as <ulink url=\"http://maven.org\">Maven</ulink>. Maven, in particular, has "
"a good resource describing this <ulink url=\"http://maven.apache.org/guides/"
"introduction/introduction-to-the-standard-directory-layout.html\">layout</"
"ulink>. As this tutorial is to be a web application, we will be creating and "
"making use of <filename>src/main/java</filename>, <filename>src/main/"
"resources</filename> and <filename>src/main/webapp</filename> directories."
msgstr ""

#. Tag: para
#: tutorial.xml:88
#, no-c-format
msgid ""
"We will be using Maven in this tutorial, taking advantage of its transitive "
"dependency management capabilities as well as the ability of many IDEs to "
"automatically set up a project for us based on the maven descriptor."
msgstr ""

#. Tag: programlisting
#: tutorial.xml:94
#, no-c-format
msgid ""
"<![CDATA[<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n"
"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven."
"apache.org/xsd/maven-4.0.0.xsd\">\n"
"\n"
"    <modelVersion>4.0.0</modelVersion>\n"
"\n"
"    <groupId>org.hibernate.tutorials</groupId>\n"
"    <artifactId>hibernate-tutorial</artifactId>\n"
"    <version>1.0.0-SNAPSHOT</version>\n"
"    <name>First Hibernate Tutorial</name>\n"
"\n"
"    <build>\n"
"         <!-- we dont want the version to be part of the generated war file "
"name -->\n"
"         <finalName>${artifactId}</finalName>\n"
"    </build>\n"
"\n"
"    <dependencies>\n"
"        <dependency>\n"
"            <groupId>org.hibernate</groupId>\n"
"            <artifactId>hibernate-core</artifactId>\n"
"        </dependency>\n"
"\n"
"        <!-- Because this is a web app, we also have a dependency on the "
"servlet api. -->\n"
"        <dependency>\n"
"            <groupId>javax.servlet</groupId>\n"
"            <artifactId>servlet-api</artifactId>\n"
"        </dependency>\n"
"\n"
"        <!-- Hibernate uses slf4j for logging, for our purposes here use the "
"simple backend -->\n"
"        <dependency>\n"
"            <groupId>org.slf4j</groupId>\n"
"            <artifactId>slf4j-simple</artifactId>\n"
"        </dependency>\n"
"\n"
"        <!-- Hibernate gives you a choice of bytecode providers between "
"cglib and javassist -->\n"
"        <dependency>\n"
"            <groupId>javassist</groupId>\n"
"            <artifactId>javassist</artifactId>\n"
"        </dependency>\n"
"    </dependencies>\n"
"\n"
"</project>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:97
#, no-c-format
msgid ""
"It is not a requirement to use Maven. If you wish to use something else to "
"build this tutoial (such as Ant), the layout will remain the same. The only "
"change is that you will need to manually account for all the needed "
"dependencies. If you use something like <ulink url=\"http://ant.apache.org/"
"ivy/\">Ivy</ulink> providing transitive dependency management you would "
"still use the dependencies mentioned below. Otherwise, you'd need to grab "
"<emphasis>all</emphasis> dependencies, both explicit and transitive, and add "
"them to the project's classpath. If working from the Hibernate distribution "
"bundle, this would mean <filename>hibernate3.jar</filename>, all artifacts "
"in the <filename>lib/required</filename> directory and all files from either "
"the <filename>lib/bytecode/cglib</filename> or <filename>lib/bytecode/"
"javassist</filename> directory; additionally you will need both the servlet-"
"api jar and one of the slf4j logging backends."
msgstr ""

#. Tag: para
#: tutorial.xml:114
#, no-c-format
msgid ""
"Save this file as <filename>pom.xml</filename> in the project root directory."
msgstr ""

#. Tag: title
#: tutorial.xml:121
#, no-c-format
msgid "The first class"
msgstr "最初のクラス"

#. Tag: para
#: tutorial.xml:123
#, fuzzy, no-c-format
msgid ""
"Next, we create a class that represents the event we want to store in the "
"database; it is a simple JavaBean class with some properties:"
msgstr "次にデータベースに格納するイベントを表すクラスを作成します。"

#. Tag: programlisting
#: tutorial.xml:128
#, no-c-format
msgid ""
"<![CDATA[package org.hibernate.tutorial.domain;\n"
"\n"
"import java.util.Date;\n"
"\n"
"public class Event {\n"
"    private Long id;\n"
"\n"
"    private String title;\n"
"    private Date date;\n"
"\n"
"    public Event() {}\n"
"\n"
"    public Long getId() {\n"
"        return id;\n"
"    }\n"
"\n"
"    private void setId(Long id) {\n"
"        this.id = id;\n"
"    }\n"
"\n"
"    public Date getDate() {\n"
"        return date;\n"
"    }\n"
"\n"
"    public void setDate(Date date) {\n"
"        this.date = date;\n"
"    }\n"
"\n"
"    public String getTitle() {\n"
"        return title;\n"
"    }\n"
"\n"
"    public void setTitle(String title) {\n"
"        this.title = title;\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:130
#, fuzzy, no-c-format
msgid ""
"This class uses standard JavaBean naming conventions for property getter and "
"setter methods, as well as private visibility for the fields. Although this "
"is the recommended design, it is not required. Hibernate can also access "
"fields directly, the benefit of accessor methods is robustness for "
"refactoring."
msgstr ""
"ご覧のとおり、このクラスはフィールドがprivateの可視性を持っているのと同時"
"に、 JavaBean標準のゲッター、セッターメソッドの命名規約に従っています。 この"
"ような設計は推奨されていますが必須ではありません。 アクセサメソッドを設けるの"
"はリファクタリングを考えた頑健性のためで、 Hibernateはフィールドに直接アクセ"
"スすることも可能です。 引数のないコンストラクタは、リフレクションでこのクラス"
"のインスタンスを作成するために 必要です。"

#. Tag: para
#: tutorial.xml:138
#, fuzzy, no-c-format
msgid ""
"The <literal>id</literal> property holds a unique identifier value for a "
"particular event. All persistent entity classes (there are less important "
"dependent classes as well) will need such an identifier property if we want "
"to use the full feature set of Hibernate. In fact, most applications, "
"especially web applications, need to distinguish objects by identifier, so "
"you should consider this a feature rather than a limitation. However, we "
"usually do not manipulate the identity of an object, hence the setter method "
"should be private. Only Hibernate will assign identifiers when an object is "
"saved. Hibernate can access public, private, and protected accessor methods, "
"as well as public, private and protected fields directly. The choice is up "
"to you and you can match it to fit your application design."
msgstr ""
"<literal>id</literal> プロパティは、ある特定のイベントに対するユニークな識別"
"子の値を保持します。 Hibernateの完全な機能を使いたければ、すべての永続エン"
"ティティクラス （それほど重要ではない依存クラスというものもあります） にこの"
"ような識別子プロパティが必要になります。 事実上ほとんどのアプリケーション（特"
"にwebアプリケーション）では、 識別子でオブジェクトを区別する必要があるため、"
"これは制限というよりも特徴であると考えるべきです。 しかし通常オブジェクトのID"
"を操作するようなことはしません。 そのためセッターメソッドはprivateにするべき"
"です。 Hibernateだけがオブジェクトがセーブされたときに識別子へ値を代入しま"
"す。 Hibernateが（public, private, protected）フィールドに直接アクセスできる"
"のと同様に、 public, private, protectedのアクセサメソッドにアクセスできるとい"
"うことがわかるでしょう。 選択はあなたに任されているので、あなたのアプリケー"
"ションの設計に合わせることができます。"

#. Tag: para
#: tutorial.xml:153
#, fuzzy, no-c-format
msgid ""
"The no-argument constructor is a requirement for all persistent classes; "
"Hibernate has to create objects for you, using Java Reflection. The "
"constructor can be private, however package or public visibility is required "
"for runtime proxy generation and efficient data retrieval without bytecode "
"instrumentation."
msgstr ""
"引数のないコンストラクタはすべての永続クラスに必須です。 これはHibernateが"
"Javaのリフレクションを使って、オブジェクトを作成しなければならないためです。 "
"コンストラクタをprivateにすることは可能ですが、 実行時のプロキシ生成と、バイ"
"トコード操作なしの効率的なデータの抽出には、 package可視性が必要です。"

#. Tag: para
#: tutorial.xml:161
#, no-c-format
msgid ""
"Save this file to the <filename>src/main/java/org/hibernate/tutorial/domain</"
"filename> directory."
msgstr ""

#. Tag: title
#: tutorial.xml:168
#, no-c-format
msgid "The mapping file"
msgstr "マッピングファイル"

#. Tag: para
#: tutorial.xml:170
#, no-c-format
msgid ""
"Hibernate needs to know how to load and store objects of the persistent "
"class. This is where the Hibernate mapping file comes into play. The mapping "
"file tells Hibernate what table in the database it has to access, and what "
"columns in that table it should use."
msgstr ""
"Hibernateは、どのように永続クラスのオブジェクトをロードし格納すればよいかを知"
"る必要があります。 ここでHibernateマッピングファイルが登場します。 マッピング"
"ファイルは、データベース内のどのテーブルにアクセスしなければならないか、 その"
"テーブルのどのカラムを使うべきかを、Hibernateに教えます。"

#. Tag: para
#: tutorial.xml:178
#, no-c-format
msgid "The basic structure of a mapping file looks like this:"
msgstr "マッピングファイルの基本的な構造はこのようになります："

#. Tag: programlisting
#: tutorial.xml:182
#, no-c-format
msgid ""
"<![CDATA[<?xml version=\"1.0\"?>\n"
"<!DOCTYPE hibernate-mapping PUBLIC\n"
"        \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n"
"        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\">\n"
"\n"
"<hibernate-mapping package=\"org.hibernate.tutorial.domain\">\n"
"[...]\n"
"</hibernate-mapping>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:184
#, fuzzy, no-c-format
msgid ""
"Hibernate DTD is sophisticated. You can use it for auto-completion of XML "
"mapping elements and attributes in your editor or IDE. Opening up the DTD "
"file in your text editor is the easiest way to get an overview of all "
"elements and attributes, and to view the defaults, as well as some comments. "
"Hibernate will not load the DTD file from the web, but first look it up from "
"the classpath of the application. The DTD file is included in "
"<filename>hibernate-core.jar</filename> (it is also included in the "
"<filename>hibernate3.jar</filename>, if using the distribution bundle)."
msgstr ""
"Hibernate DTDが非常に洗練されていることに注目してください。 このDTDは、エディ"
"タやIDEでのXMLマッピング要素と属性のオートコンプリーション機能に利用できま"
"す。 またDTDファイルをテキストエディタで開けてみてください。 というのも、すべ"
"ての要素と属性を概観し、 コメントやデフォルトの値を見るには一番簡単な方法だか"
"らです。 Hibernateは、webからDTDファイルをロードせずに、 まずアプリケーション"
"のクラスパスからこれを探し出そうとすることに注意してください。 DTDファイルは"
"Hibernateディストリビューションの <literal>src/</literal> ディレクトリと同"
"様、<literal>hibernate3.jar</literal> にも含まれています。"

#. Tag: para
#: tutorial.xml:197
#, fuzzy, no-c-format
msgid ""
"We will omit the DTD declaration in future examples to shorten the code. It "
"is, of course, not optional."
msgstr ""
"以降の例ではコードを短くするためにDTD宣言を省略します。 当然ですがこれはオプ"
"ションではありません。"

#. Tag: para
#: tutorial.xml:203
#, fuzzy, no-c-format
msgid ""
"Between the two <literal>hibernate-mapping</literal> tags, include a "
"<literal>class</literal> element. All persistent entity classes (again, "
"there might be dependent classes later on, which are not first-class "
"entities) need a mapping to a table in the SQL database:"
msgstr ""
"2つの <literal>hibernate-mapping</literal> タグの間に <literal>class</"
"literal> 要素を含めてください。 すべての永続エンティティクラス（念を押します"
"が、 ファーストクラスのエンティティではない依存クラスというものが後ほど登場し"
"ます） はSQLデータベース内のテーブルへのこのようなマッピングを必要とします。"

#. Tag: programlisting
#: tutorial.xml:210
#, no-c-format
msgid ""
"<![CDATA[<hibernate-mapping package=\"org.hibernate.tutorial.domain\">\n"
"\n"
"    <class name=\"Event\" table=\"EVENTS\">\n"
"\n"
"    </class>\n"
"\n"
"</hibernate-mapping>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:212
#, fuzzy, no-c-format
msgid ""
"So far we have told Hibernate how to persist and load object of class "
"<literal>Event</literal> to the table <literal>EVENTS</literal>. Each "
"instance is now represented by a row in that table. Now we can continue by "
"mapping the unique identifier property to the tables primary key. As we do "
"not want to care about handling this identifier, we configure Hibernate's "
"identifier generation strategy for a surrogate primary key column:"
msgstr ""
"これまで私たちは、<literal>Event</literal> クラスのオブジェクトを "
"<literal>EVENTS</literal> テーブルに対して、どのように永続化したりロードした"
"りするのかを Hibernateに教えてきました。そして個々のインスタンスはテーブルの"
"行として表現されます。 それでは引き続きテーブルの主キーに対するユニークな識別"
"子プロパティをマッピングしていきます。 さらに、この識別子の扱いに気を使いたく"
"なかったのと同様に、 代理の主キーカラムに対するHibernateの識別子生成戦略を設"
"定します。"

#. Tag: programlisting
#: tutorial.xml:222
#, no-c-format
msgid ""
"<![CDATA[<hibernate-mapping package=\"org.hibernate.tutorial.domain\">\n"
"\n"
"    <class name=\"Event\" table=\"EVENTS\">\n"
"        <id name=\"id\" column=\"EVENT_ID\">\n"
"            <generator class=\"native\"/>\n"
"        </id>\n"
"    </class>\n"
"\n"
"</hibernate-mapping>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:224
#, no-c-format
msgid ""
"The <literal>id</literal> element is the declaration of the identifier "
"property. The <literal>name=\"id\"</literal> mapping attribute declares the "
"name of the JavaBean property and tells Hibernate to use the <literal>getId()"
"</literal> and <literal>setId()</literal> methods to access the property. "
"The column attribute tells Hibernate which column of the <literal>EVENTS</"
"literal> table holds the primary key value."
msgstr ""

#. Tag: para
#: tutorial.xml:234
#, no-c-format
msgid ""
"The nested <literal>generator</literal> element specifies the identifier "
"generation strategy (aka how are identifier values generated?). In this case "
"we choose <literal>native</literal>, which offers a level of portability "
"depending on the configured database dialect. Hibernate supports database "
"generated, globally unique, as well as application assigned, identifiers. "
"Identifier value generation is also one of Hibernate's many extension points "
"and you can plugin in your own strategy."
msgstr ""

#. Tag: para
#: tutorial.xml:246
#, no-c-format
msgid ""
"<literal>native</literal> is no longer consider the best strategy in terms "
"of portability. for further discussion, see"
msgstr ""

#. Tag: para
#: tutorial.xml:252
#, fuzzy, no-c-format
msgid ""
"Lastly, we need to tell Hibernate about the remaining entity class "
"properties. By default, no properties of the class are considered persistent:"
msgstr ""
"最後にクラスの永続プロパティの宣言をマッピングファイルに含めます。 デフォルト"
"では、クラスのプロパティは永続と見なされません："

#. Tag: programlisting
#: tutorial.xml:258
#, no-c-format
msgid ""
"<![CDATA[\n"
"<hibernate-mapping package=\"org.hibernate.tutorial.domain\">\n"
"\n"
"    <class name=\"Event\" table=\"EVENTS\">\n"
"        <id name=\"id\" column=\"EVENT_ID\">\n"
"            <generator class=\"native\"/>\n"
"        </id>\n"
"        <property name=\"date\" type=\"timestamp\" column=\"EVENT_DATE\"/>\n"
"        <property name=\"title\"/>\n"
"    </class>\n"
"\n"
"</hibernate-mapping>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:260
#, fuzzy, no-c-format
msgid ""
"Similar to the <literal>id</literal> element, the <literal>name</literal> "
"attribute of the <literal>property</literal> element tells Hibernate which "
"getter and setter methods to use. In this case, Hibernate will search for "
"<literal>getDate()</literal>, <literal>setDate()</literal>, <literal>getTitle"
"()</literal> and <literal>setTitle()</literal> methods."
msgstr ""
"<literal>id</literal> 要素の場合と同様に、 <literal>property</literal> 要素"
"の <literal>name</literal> 属性で、どのゲッターとセッターメソッドを使うべきか"
"をHibernateに教えます。 この例では、Hibernateは <literal>getDate()/setDate()"
"</literal> と <literal>getTitle()/setTitle()</literal> を 探します。"

#. Tag: para
#: tutorial.xml:271
#, fuzzy, no-c-format
msgid ""
"Why does the <literal>date</literal> property mapping include the "
"<literal>column</literal> attribute, but the <literal>title</literal> does "
"not? Without the <literal>column</literal> attribute, Hibernate by default "
"uses the property name as the column name. This works for <literal>title</"
"literal>, however, <literal>date</literal> is a reserved keyword in most "
"databases so you will need to map it to a different name."
msgstr ""
"なぜ <literal>date</literal> プロパティのマッピングには <literal>column</"
"literal> 属性があり、<literal>title</literal> プロパティにはないのでしょう"
"か？ <literal>column</literal> 属性がなければ、Hibernateはプロパティ名をカラ"
"ム名として使います。 これは <literal>title</literal> では上手く行きます。 し"
"かし <literal>date</literal> はほとんどのデータベースで予約語なので、 違う名"
"前でマッピングした方がよいのです。"

#. Tag: para
#: tutorial.xml:281
#, fuzzy, no-c-format
msgid ""
"The <literal>title</literal> mapping also lacks a <literal>type</literal> "
"attribute. The types declared and used in the mapping files are not Java "
"data types; they are not SQL database types either. These types are called "
"<emphasis>Hibernate mapping types</emphasis>, converters which can translate "
"from Java to SQL data types and vice versa. Again, Hibernate will try to "
"determine the correct conversion and mapping type itself if the "
"<literal>type</literal> attribute is not present in the mapping. In some "
"cases this automatic detection using Reflection on the Java class might not "
"have the default you expect or need. This is the case with the "
"<literal>date</literal> property. Hibernate cannot know if the property, "
"which is of <literal>java.util.Date</literal>, should map to a SQL "
"<literal>date</literal>, <literal>timestamp</literal>, or <literal>time</"
"literal> column. Full date and time information is preserved by mapping the "
"property with a <literal>timestamp</literal> converter."
msgstr ""
"次に興味深いのは <literal>title</literal> マッピングが <literal>type</"
"literal> 属性をも欠いている点です。 マッピングファイルで宣言して使うtypeは、"
"おわかりかもしれませんがJavaのデータ型ではありません。 SQLデータベースの型で"
"もありません。 これは <emphasis>Hibernateマッピング型</emphasis> と呼ばれ"
"る、 JavaからSQLデータの型へまたはSQLからJavaデータ型へ翻訳するコンバータで"
"す。 繰り返しになりますが、Hibernateは <literal>type</literal> 属性がマッピン"
"グファイル内になければ、 正しいコンバージョンとマッピング型を自分で解決しよう"
"とします。 （Javaクラスのリフレクションを使った）この自動検知は、 場合によっ"
"てはあなたが期待または必要とするデフォルト値にならないかもしれません。 "
"<literal>date</literal> プロパティの場合がそうでした。 Hibernateはこの"
"（ <literal>java.util.Date</literal> の）プロパティを SQLの <literal>date</"
"literal> , <literal>timestamp</literal> , <literal>time</literal> のうち、ど"
"のカラムにマッピングするべきなのかわかりません。 <literal>timestamp</"
"literal> コンバータでプロパティをマッピングすることにより、完全な日時を保存し"
"ます。"

#. Tag: para
#: tutorial.xml:297
#, no-c-format
msgid ""
"Hibernate makes this mapping type determination using reflection when the "
"mapping files are processed. This can take time and resources, so if startup "
"performance is important you should consider explicitly defining the type to "
"use."
msgstr ""

#. Tag: para
#: tutorial.xml:304
#, no-c-format
msgid ""
"Save this mapping file as <filename>src/main/resources/org/hibernate/"
"tutorial/domain/Event.hbm.xml</filename>."
msgstr ""

#. Tag: title
#: tutorial.xml:312
#, no-c-format
msgid "Hibernate configuration"
msgstr "Hibernateの設定"

#. Tag: para
#: tutorial.xml:314
#, no-c-format
msgid ""
"At this point, you should have the persistent class and its mapping file in "
"place. It is now time to configure Hibernate. First let's set up HSQLDB to "
"run in \"server mode\""
msgstr ""

#. Tag: para
#: tutorial.xml:321
#, no-c-format
msgid "We do this do that the data remains between runs."
msgstr ""

#. Tag: para
#: tutorial.xml:326
#, fuzzy, no-c-format
msgid ""
"We will utilize the Maven exec plugin to launch the HSQLDB server by "
"running: <command> mvn exec:java -Dexec.mainClass=\"org.hsqldb.Server\" -"
"Dexec.args=\"-database.0 file:target/data/tutorial\"</command> You will see "
"it start up and bind to a TCP/IP socket; this is where our application will "
"connect later. If you want to start with a fresh database during this "
"tutorial, shutdown HSQLDB, delete all files in the <filename>target/data</"
"filename> directory, and start HSQLDB again."
msgstr ""
"<literal>data</literal> というディレクトリを開発ディレクトリのルートに作成し"
"てください。 HSQL DBはここにデータファイルを格納します。 このデータディレクト"
"リにおいて <literal>java -classpath lib/hsqldb.jar org.hsqldb.Server</"
"literal> を実行し、 データベースを起動させてください。 動作の開始と、TCP/IPソ"
"ケットのバインドが確認できます。 後ほど作成するアプリケーションはここに接続し"
"ます。 もしこのチュートリアル中にデータベースを初期化したければ、 HSQL DBを"
"シャットダウンして（作業ウィンドウで <literal>CTRL + C</literal> を押しま"
"す） <literal>data/</literal> ディレクトリ内のファイルを全て消去した後、 "
"HSQL DBを再起動します。"

#. Tag: para
#: tutorial.xml:337
#, no-c-format
msgid ""
"Hibernate will be connecting to the database on behalf of your application, "
"so it needs to know how to obtain connections. For this tutorial we will be "
"using a standalone connection pool (as opposed to a <interfacename>javax.sql."
"DataSource</interfacename>). Hibernate comes with support for two third-"
"party open source JDBC connection pools: <ulink url=\"https://sourceforge."
"net/projects/c3p0\">c3p0</ulink> and <ulink url=\"http://proxool.sourceforge."
"net/\">proxool</ulink>. However, we will be using the Hibernate built-in "
"connection pool for this tutorial."
msgstr ""

#. Tag: para
#: tutorial.xml:348
#, no-c-format
msgid ""
"The built-in Hibernate connection pool is in no way intended for production "
"use. It lacks several features found on any decent connection pool."
msgstr ""

#. Tag: para
#: tutorial.xml:354
#, fuzzy, no-c-format
msgid ""
"For Hibernate's configuration, we can use a simple <literal>hibernate."
"properties</literal> file, a more sophisticated <literal>hibernate.cfg.xml</"
"literal> file, or even complete programmatic setup. Most users prefer the "
"XML configuration file:"
msgstr ""
"Hibernateの設定では、単純な <literal>hibernate.properties</literal> ファイ"
"ル、 それより少し洗練されている <literal>hibernate.cfg.xml</literal> ファイ"
"ル、 または完全にプログラム上でセットアップする方法が利用できます。 ほとんど"
"のユーザが好むのはXML設定ファイルです："

#. Tag: programlisting
#: tutorial.xml:360
#, no-c-format
msgid ""
"<![CDATA[<?xml version='1.0' encoding='utf-8'?>\n"
"<!DOCTYPE hibernate-configuration PUBLIC\n"
"        \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n"
"        \"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"
"\">\n"
"\n"
"<hibernate-configuration>\n"
"\n"
"    <session-factory>\n"
"\n"
"        <!-- Database connection settings -->\n"
"        <property name=\"connection.driver_class\">org.hsqldb.jdbcDriver</"
"property>\n"
"        <property name=\"connection.url\">jdbc:hsqldb:hsql://localhost</"
"property>\n"
"        <property name=\"connection.username\">sa</property>\n"
"        <property name=\"connection.password\"></property>\n"
"\n"
"        <!-- JDBC connection pool (use the built-in) -->\n"
"        <property name=\"connection.pool_size\">1</property>\n"
"\n"
"        <!-- SQL dialect -->\n"
"        <property name=\"dialect\">org.hibernate.dialect.HSQLDialect</"
"property>\n"
"\n"
"        <!-- Enable Hibernate's automatic session context management -->\n"
"        <property name=\"current_session_context_class\">thread</property>\n"
"\n"
"        <!-- Disable the second-level cache  -->\n"
"        <property name=\"cache.provider_class\">org.hibernate.cache."
"NoCacheProvider</property>\n"
"\n"
"        <!-- Echo all executed SQL to stdout -->\n"
"        <property name=\"show_sql\">true</property>\n"
"\n"
"        <!-- Drop and re-create the database schema on startup -->\n"
"        <property name=\"hbm2ddl.auto\">update</property>\n"
"\n"
"        <mapping resource=\"org/hibernate/tutorial/domain/Event.hbm.xml\"/>\n"
"\n"
"    </session-factory>\n"
"\n"
"</hibernate-configuration>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:363
#, no-c-format
msgid "Notice that this configuration file specifies a different DTD"
msgstr ""

#. Tag: para
#: tutorial.xml:366
#, fuzzy, no-c-format
msgid ""
"You configure Hibernate's <literal>SessionFactory</literal>. SessionFactory "
"is a global factory responsible for a particular database. If you have "
"several databases, for easier startup you should use several <literal>&lt;"
"session-factory&gt;</literal> configurations in several configuration files."
msgstr ""
"このXMLの設定が異なるDTDを使うことに注意してください。 特定のデータベースを受"
"け持つグローバルファクトリであるHibernateの <literal>SessionFactory</"
"literal> を設定します。 もし複数のデータベースがある場合には、 （スタートアッ"
"プを簡単にするため）通常いくつかの設定ファイル内で、 いくつかの <literal>&lt;"
"session-factory&gt;</literal> を使う設定にしてください。"

#. Tag: para
#: tutorial.xml:373
#, no-c-format
msgid ""
"The first four <literal>property</literal> elements contain the necessary "
"configuration for the JDBC connection. The dialect <literal>property</"
"literal> element specifies the particular SQL variant Hibernate generates."
msgstr ""

#. Tag: para
#: tutorial.xml:380
#, no-c-format
msgid ""
"In most cases, Hibernate is able to properly determine which dialect to use. "
"See <xref linkend=\"portability-dialectresolver\"/> for more information."
msgstr ""

#. Tag: para
#: tutorial.xml:386
#, fuzzy, no-c-format
msgid ""
"Hibernate's automatic session management for persistence contexts is "
"particularly useful in this context. The <literal>hbm2ddl.auto</literal> "
"option turns on automatic generation of database schemas directly into the "
"database. This can also be turned off by removing the configuration option, "
"or redirected to a file with the help of the <literal>SchemaExport</literal> "
"Ant task. Finally, add the mapping file(s) for persistent classes to the "
"configuration."
msgstr ""
"最初の4つの <literal>property</literal> 要素はJDBCコネクションに必要な設定を"
"含んでいます。 dialectという名前の <literal>property</literal> 要素は、"
"Hibernateが生成する特定のSQL方言を指定します。 永続的なコンテキストに対する"
"Hibernateのセッションの自動管理は、後の例ですぐにわかるように、役に立つことで"
"しょう。 <literal>hbm2ddl.auto</literal> オプションはデータベーススキーマの自"
"動生成をonにします。 これは直接データベースに対して生成されます。 当然"
"（configオプションを削除して）offにしたり、 <literal>SchemaExport</literal> "
"というAntタスクの助けを借りてファイルにリダイレクトしたりできます。 最後に永"
"続クラスのためのマッピングファイルを設定に追加します。"

#. Tag: para
#: tutorial.xml:395
#, no-c-format
msgid ""
"Save this file as <filename>hibernate.cfg.xml</filename> into the "
"<filename>src/main/resources</filename> directory."
msgstr ""

#. Tag: title
#: tutorial.xml:403
#, fuzzy, no-c-format
msgid "Building with Maven"
msgstr "Antによるビルド"

#. Tag: para
#: tutorial.xml:405
#, no-c-format
msgid ""
"We will now build the tutorial with Maven. You will need to have Maven "
"installed; it is available from the <ulink url=\"http://maven.apache.org/"
"download.html\">Maven download page</ulink>. Maven will read the <filename>/"
"pom.xml</filename> file we created earlier and know how to perform some "
"basic project tasks. First, lets run the <literal>compile</literal> goal to "
"make sure we can compile everything so far:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:415
#, no-c-format
msgid ""
"<![CDATA[[hibernateTutorial]$ mvn compile\n"
"[INFO] Scanning for projects...\n"
"[INFO] "
"------------------------------------------------------------------------\n"
"[INFO] Building First Hibernate Tutorial\n"
"[INFO]    task-segment: [compile]\n"
"[INFO] "
"------------------------------------------------------------------------\n"
"[INFO] [resources:resources]\n"
"[INFO] Using default encoding to copy filtered resources.\n"
"[INFO] [compiler:compile]\n"
"[INFO] Compiling 1 source file to /home/steve/projects/sandbox/"
"hibernateTutorial/target/classes\n"
"[INFO] "
"------------------------------------------------------------------------\n"
"[INFO] BUILD SUCCESSFUL\n"
"[INFO] "
"------------------------------------------------------------------------\n"
"[INFO] Total time: 2 seconds\n"
"[INFO] Finished at: Tue Jun 09 12:25:25 CDT 2009\n"
"[INFO] Final Memory: 5M/547M\n"
"[INFO] "
"------------------------------------------------------------------------]]>"
msgstr ""

#. Tag: title
#: tutorial.xml:420
#, no-c-format
msgid "Startup and helpers"
msgstr "スタートアップとヘルパ"

#. Tag: para
#: tutorial.xml:422
#, fuzzy, no-c-format
msgid ""
"It is time to load and store some <literal>Event</literal> objects, but "
"first you have to complete the setup with some infrastructure code. You have "
"to startup Hibernate by building a global <interfacename>org.hibernate."
"SessionFactory</interfacename> object and storing it somewhere for easy "
"access in application code. A <interfacename>org.hibernate.SessionFactory</"
"interfacename> is used to obtain <interfacename>org.hibernate.Session</"
"interfacename> instances. A <interfacename>org.hibernate.Session</"
"interfacename> represents a single-threaded unit of work. The "
"<interfacename>org.hibernate.SessionFactory</interfacename> is a thread-safe "
"global object that is instantiated once."
msgstr ""
"さて <literal>Event</literal> オブジェクトをロードしたり格納したりする準備が"
"できました。 しかしまずはインフラストラクチャのコードを書いて、セットアップを"
"完了する必要があります。 まずはHibernateをスタートアップしなければなりませ"
"ん。 このスタートアップには、グローバルの <literal>SessionFactory</literal> "
"オブジェクトを生成して、 それをアプリケーションのコードでアクセスしやすい場所"
"に格納することが含まれます。 <literal>SessionFactory</literal> は新しく "
"<literal>Session</literal> をオープンすることができます。 <literal>Session</"
"literal> はシングルスレッドの作業単位(Unit of Work)を表現します。 それに対し"
"<literal>SessionFactory</literal> はスレッドセーフのグローバルオブジェクトで"
"あり、 一度だけインスタンス化されます。"

#. Tag: para
#: tutorial.xml:436
#, fuzzy, no-c-format
msgid ""
"We will create a <literal>HibernateUtil</literal> helper class that takes "
"care of startup and makes accessing the <interfacename>org.hibernate."
"SessionFactory</interfacename> more convenient."
msgstr ""
"ここでスタートアップを行い、 便利に <literal>SessionFactory</literal> へアク"
"セスする <literal>HibernateUtil</literal> ヘルパクラスを作成します。 実装を見"
"てみましょう："

#. Tag: programlisting
#: tutorial.xml:442
#, no-c-format
msgid ""
"<![CDATA[package org.hibernate.tutorial.util;\n"
"\n"
"import org.hibernate.SessionFactory;\n"
"import org.hibernate.cfg.Configuration;\n"
"\n"
"public class HibernateUtil {\n"
"\n"
"    private static final SessionFactory sessionFactory = buildSessionFactory"
"();\n"
"\n"
"    private static SessionFactory buildSessionFactory() {\n"
"        try {\n"
"            // Create the SessionFactory from hibernate.cfg.xml\n"
"            return new Configuration().configure().buildSessionFactory();\n"
"        }\n"
"        catch (Throwable ex) {\n"
"            // Make sure you log the exception, as it might be swallowed\n"
"            System.err.println(\"Initial SessionFactory creation failed.\" + "
"ex);\n"
"            throw new ExceptionInInitializerError(ex);\n"
"        }\n"
"    }\n"
"\n"
"    public static SessionFactory getSessionFactory() {\n"
"        return sessionFactory;\n"
"    }\n"
"\n"
"}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:444
#, no-c-format
msgid ""
"Save this code as <filename>src/main/java/org/hibernate/tutorial/util/"
"HibernateUtil.java</filename>"
msgstr ""

#. Tag: para
#: tutorial.xml:449
#, fuzzy, no-c-format
msgid ""
"This class not only produces the global <interfacename>org.hibernate."
"SessionFactory</interfacename> reference in its static initializer; it also "
"hides the fact that it uses a static singleton. We might just as well have "
"looked up the <interfacename>org.hibernate.SessionFactory</interfacename> "
"reference from JNDI in an application server or any other location for that "
"matter."
msgstr ""
"このクラスは静的初期化ブロック（クラスがロードされるときにJVMによって一度だけ"
"呼ばれる） でグローバルの <literal>SessionFactory</literal> を生成するだけで"
"はなく、 静的シングルトンの使用を隠蔽します。 アプリケーションサーバーのJNDI"
"から <literal>SessionFactory</literal> を ルックアップするのと同様です。"

#. Tag: para
#: tutorial.xml:458
#, fuzzy, no-c-format
msgid ""
"If you give the <interfacename>org.hibernate.SessionFactory</interfacename> "
"a name in your configuration, Hibernate will try to bind it to JNDI under "
"that name after it has been built. Another, better option is to use a JMX "
"deployment and let the JMX-capable container instantiate and bind a "
"<literal>HibernateService</literal> to JNDI. Such advanced options are "
"discussed later."
msgstr ""
"設定ファイル内で <literal>SessionFactory</literal> に名前を与えると、 "
"Hibernateは <literal>SessionFactory</literal> 構築後にJNDIに対しバインドを行"
"おうとします。 このコードを完全に排除するためには、 JMXデプロイメントを利用し"
"て JMXを利用できるコンテナをインスタンス化し、 <literal>HibernateService</"
"literal> をJNDIへバインドすることもできます。 これらの高度なオプションは、"
"Hibernateのリファレンスドキュメントで説明されています。"

#. Tag: para
#: tutorial.xml:467
#, fuzzy, no-c-format
msgid ""
"You now need to configure a logging system. Hibernate uses commons logging "
"and provides two choices: Log4j and JDK 1.4 logging. Most developers prefer "
"Log4j: copy <literal>log4j.properties</literal> from the Hibernate "
"distribution in the <literal>etc/</literal> directory to your <literal>src</"
"literal> directory, next to <literal>hibernate.cfg.xml</literal>. If you "
"prefer to have more verbose output than that provided in the example "
"configuration, you can change the settings. By default, only the Hibernate "
"startup message is shown on stdout."
msgstr ""
"これは問題なく再コンパイルできるはずです。 最後にロギングシステムを設定する必"
"要があります。 Hibernateはcommons loggingを使うため、Log4jとJDK 1.4 loggingの"
"選択をする必要がありません。 ほとんどの開発者が好むのはLog4jです。 Hibernate"
"ディストリビューション（の<literal>etc/</literal> ディレクトリ）から "
"<literal>log4j.properties</literal> をあなたの <literal>src</literal> ディレ"
"クトリ内の <literal>hibernate.cfg.xml</literal> の隣にコピーしてください。 設"
"定例を見て、冗長な出力がよければ設定を変更してください。 デフォルトでは"
"Hibernateのスタートアップメッセージだけが標準出力に表示されます。"

#. Tag: para
#: tutorial.xml:477
#, fuzzy, no-c-format
msgid ""
"The tutorial infrastructure is complete and you are now ready to do some "
"real work with Hibernate."
msgstr ""
"チュートリアルのインフラは完全です。 Hibernateを使って実際の作業をする準備が"
"整いました。"

#. Tag: title
#: tutorial.xml:485
#, no-c-format
msgid "Loading and storing objects"
msgstr "オブジェクトのロードと格納"

#. Tag: para
#: tutorial.xml:487
#, fuzzy, no-c-format
msgid ""
"We are now ready to start doing some real worjk with Hibernate. Let's start "
"by writing an <literal>EventManager</literal> class with a <literal>main()</"
"literal> method:"
msgstr ""
"ついにオブジェクトのロードと格納にHibernateを使うことができます。 "
"<literal>main()</literal> メソッドを持つ <literal>EventManager</literal> クラ"
"スを書きます："

#. Tag: programlisting
#: tutorial.xml:493
#, no-c-format
msgid ""
"<![CDATA[package org.hibernate.tutorial;\n"
"\n"
"import org.hibernate.Session;\n"
"\n"
"import java.util.*;\n"
"\n"
"import org.hibernate.tutorial.domain.Event;\n"
"import org.hibernate.tutorial.util.HibernateUtil;\n"
"\n"
"public class EventManager {\n"
"\n"
"    public static void main(String[] args) {\n"
"        EventManager mgr = new EventManager();\n"
"\n"
"        if (args[0].equals(\"store\")) {\n"
"            mgr.createAndStoreEvent(\"My Event\", new Date());\n"
"        }\n"
"\n"
"        HibernateUtil.getSessionFactory().close();\n"
"    }\n"
"\n"
"    private void createAndStoreEvent(String title, Date theDate) {\n"
"        Session session = HibernateUtil.getSessionFactory().getCurrentSession"
"();\n"
"        session.beginTransaction();\n"
"\n"
"        Event theEvent = new Event();\n"
"        theEvent.setTitle(title);\n"
"        theEvent.setDate(theDate);\n"
"        session.save(theEvent);\n"
"\n"
"        session.getTransaction().commit();\n"
"    }\n"
"\n"
"}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:495
#, fuzzy, no-c-format
msgid ""
"In <literal>createAndStoreEvent()</literal> we created a new <literal>Event</"
"literal> object and handed it over to Hibernate. At that point, Hibernate "
"takes care of the SQL and executes an <literal>INSERT</literal> on the "
"database."
msgstr ""
"新しい <literal>Event</literal> オブジェクトを生成し、それをHibernateに渡しま"
"す。 今ではHibernateがSQLを処理し、データベースで <literal>INSERT</literal> "
"を実行します。 実行前に <literal>Session</literal> と <literal>Transaction</"
"literal> を処理するコードを確認してください。"

#. Tag: para
#: tutorial.xml:502
#, fuzzy, no-c-format
msgid ""
"A <interface>org.hibernate.Session</interface> is designed to represent a "
"single unit of work (a single atmoic piece of work to be performed). For now "
"we will keep things simple and assume a one-to-one granularity between a "
"Hibernate <interface>org.hibernate.Session</interface> and a database "
"transaction. To shield our code from the actual underlying transaction "
"system we use the Hibernate <interfacename>org.hibernate.Transaction</"
"interfacename> API. In this particular case we are using JDBC-based "
"transactional semantics, but it could also run with JTA."
msgstr ""
"<literal>Session</literal> は1つの作業単位(Unit of Work)です。 当分の間、話を"
"簡単にするために、 <literal>Session</literal> と <literal>Transaction</"
"literal> の対応を一対一と仮定します。 使用しているトランザクション・システム"
"（このケースではJTAと共存できる単純なJDBC）からコードを保護するために、 "
"Hibernate <literal>Session</literal> 上で利用可能な <literal>Transaction</"
"literal> APIを使用します。"

#. Tag: para
#: tutorial.xml:515
#, fuzzy, no-c-format
msgid ""
"What does <literal>sessionFactory.getCurrentSession()</literal> do? First, "
"you can call it as many times and anywhere you like once you get hold of "
"your <interfacename>org.hibernate.SessionFactory</interfacename>. The "
"<literal>getCurrentSession()</literal> method always returns the \"current\" "
"unit of work. Remember that we switched the configuration option for this "
"mechanism to \"thread\" in our <filename>src/main/resources/hibernate.cfg."
"xml</filename>? Due to that setting, the context of a current unit of work "
"is bound to the current Java thread that executes the application."
msgstr ""
"<literal>sessionFactory.getCurrentSession()</literal> はなにをするのでしょう"
"か？ まず、いったん <literal>SessionFactory</literal> を取得し保持すれば "
"（ <literal>HibernateUtil</literal> のおかげで簡単です）、このメソッドを何度"
"でも、 どこからでも呼び出すことが出来ます。 <literal>getCurrentSession()</"
"literal> メソッドは常に「現在の」作業単位(Unit of Work)を返します。 "
"<literal>hibernate.cfg.xml</literal> のこの機能の設定で、\"thread\"を指定した"
"ことを思い出してください。 このため現在の作業単位のスコープは、このアプリケー"
"ションを実行する現在のJavaスレッドです。 しかしこれで全てではありません。"

#. Tag: para
#: tutorial.xml:529
#, no-c-format
msgid ""
"Hibernate offers three methods of current session tracking. The \"thread\" "
"based method is not intended for production use; it is merely useful for "
"prototyping and tutorials such as this one. Current session tracking is "
"discussed in more detail later on."
msgstr ""

#. Tag: para
#: tutorial.xml:538
#, fuzzy, no-c-format
msgid ""
"A <interface>org.hibernate.Session</interface> begins when the first call to "
"<literal>getCurrentSession()</literal> is made for the current thread. It is "
"then bound by Hibernate to the current thread. When the transaction ends, "
"either through commit or rollback, Hibernate automatically unbinds the "
"<interface>org.hibernate.Session</interface> from the thread and closes it "
"for you. If you call <literal>getCurrentSession()</literal> again, you get a "
"new <interface>org.hibernate.Session</interface> and can start a new unit of "
"work."
msgstr ""
"<literal>Session</literal> は最初に必要となったとき、つまり最初に "
"<literal>getCurrentSession()</literal> が 呼ばれたときに開始します。 そのとき"
"Hibernateにより現在のスレッドに結び付けられます。 トランザクションが終了（コ"
"ミットもしくはロールバック）したとき、 Hibernateもスレッドから "
"<literal>Session</literal> を切り離し、クローズします。 再び "
"<literal>getCurrentSession()</literal> を呼ぶと、 新しい <literal>Session</"
"literal> を取得して新しい作業単位をスタートできます。 この <emphasis>thread-"
"bound</emphasis> プログラミング・モデルはHibernateを利用する上で最も人気があ"
"ります。"

#. Tag: para
#: tutorial.xml:551
#, fuzzy, no-c-format
msgid ""
"Related to the unit of work scope, should the Hibernate <interface>org."
"hibernate.Session</interface> be used to execute one or several database "
"operations? The above example uses one <interface>org.hibernate.Session</"
"interface> for one operation. However this is pure coincidence; the example "
"is just not complex enough to show any other approach. The scope of a "
"Hibernate <interface>org.hibernate.Session</interface> is flexible but you "
"should never design your application to use a new Hibernate <interface>org."
"hibernate.Session</interface> for <emphasis>every</emphasis> database "
"operation. Even though it is used in the following examples, consider "
"<emphasis>session-per-operation</emphasis> an anti-pattern. A real web "
"application is shown later in the tutorial which will help illustrate this."
msgstr ""
"Related to the unit of work scope, should the Hibernate <literal>Session</"
"literal> be used to execute one or several database operations? The above "
"example uses one <literal>Session</literal> for one operation. This is pure "
"coincidence, the example is just not complex enough to show any other "
"approach. The scope of a Hibernate <literal>Session</literal> is flexible "
"but you should never design your application to use a new Hibernate "
"<literal>Session</literal> for <emphasis>every</emphasis> database "
"operation. So even if you see it a few more times in the following (very "
"trivial) examples, consider <emphasis>session-per-operation</emphasis> an "
"anti-pattern. A real (web) application is shown later in this tutorial."

#. Tag: para
#: tutorial.xml:568
#, fuzzy, no-c-format
msgid ""
"See <xref linkend=\"transactions\"/> for more information about transaction "
"handling and demarcation. The previous example also skipped any error "
"handling and rollback."
msgstr ""
"トランザクションの扱いと境界の詳しい情報については、 <xref linkend="
"\"transactions\"/> を見てください。 この例ではエラー処理やロールバックも割愛"
"します。"

#. Tag: para
#: tutorial.xml:574
#, no-c-format
msgid ""
"To run this, we will make use of the Maven exec plugin to call our class "
"with the necessary classpath setup: <command>mvn exec:java -Dexec.mainClass="
"\"org.hibernate.tutorial.EventManager\" -Dexec.args=\"store\"</command>"
msgstr ""

#. Tag: para
#: tutorial.xml:581
#, no-c-format
msgid "You may need to perform <command>mvn compile</command> first."
msgstr ""

#. Tag: para
#: tutorial.xml:586
#, fuzzy, no-c-format
msgid ""
"You should see Hibernate starting up and, depending on your configuration, "
"lots of log output. Towards the end, the following line will be displayed:"
msgstr ""
"コンパイルすると、Hibernateがスタートし、あなたの設定によりますが、 多くのロ"
"グ出力があるはずです。 その最後には以下の行があるでしょう："

#. Tag: programlisting
#: tutorial.xml:591
#, no-c-format
msgid ""
"<![CDATA[[java] Hibernate: insert into EVENTS (EVENT_DATE, title, EVENT_ID) "
"values (?, ?, ?)]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:593
#, no-c-format
msgid "This is the <literal>INSERT</literal> executed by Hibernate."
msgstr ""

#. Tag: para
#: tutorial.xml:597
#, fuzzy, no-c-format
msgid "To list stored events an option is added to the main method:"
msgstr ""
"それでは同じように格納されたイベントの一覧を見ようと思います。 そのためメイン"
"メソッドにオプションを追加します："

#. Tag: programlisting
#: tutorial.xml:601
#, no-c-format
msgid ""
"<![CDATA[        if (args[0].equals(\"store\")) {\n"
"            mgr.createAndStoreEvent(\"My Event\", new Date());\n"
"        }\n"
"        else if (args[0].equals(\"list\")) {\n"
"            List events = mgr.listEvents();\n"
"            for (int i = 0; i < events.size(); i++) {\n"
"                Event theEvent = (Event) events.get(i);\n"
"                System.out.println(\n"
"                        \"Event: \" + theEvent.getTitle() + \" Time: \" + "
"theEvent.getDate()\n"
"                );\n"
"            }\n"
"        }]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:603
#, fuzzy, no-c-format
msgid "A new <literal>listEvents() method is also added</literal>:"
msgstr "新しい <literal>listEvents()メソッド</literal> も追加します。"

#. Tag: programlisting
#: tutorial.xml:607
#, no-c-format
msgid ""
"<![CDATA[    private List listEvents() {\n"
"        Session session = HibernateUtil.getSessionFactory().getCurrentSession"
"();\n"
"        session.beginTransaction();\n"
"        List result = session.createQuery(\"from Event\").list();\n"
"        session.getTransaction().commit();\n"
"        return result;\n"
"    }]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:609
#, fuzzy, no-c-format
msgid ""
"Here, we are using a Hibernate Query Language (HQL) query to load all "
"existing <literal>Event</literal> objects from the database. Hibernate will "
"generate the appropriate SQL, send it to the database and populate "
"<literal>Event</literal> objects with the data. You can create more complex "
"queries with HQL. See <xref linkend=\"queryhql\"/> for more information."
msgstr ""
"ここですることは、データベースから存在するすべての <literal>Event</literal> "
"オブジェクトをロードするHQL (Hibernate Query Language) クエリを使うことで"
"す。 Hibernateは適切なSQLを生成し、それをデータベースに送り、 そのデータを"
"使って <literal>Event</literal> オブジェクトを生成します。 当然HQLでさらに複"
"雑なクエリを作成できます。"

#. Tag: para
#: tutorial.xml:617
#, no-c-format
msgid ""
"Now we can call our new functionality, again using the Maven exec plugin: "
"<command>mvn exec:java -Dexec.mainClass=\"org.hibernate.tutorial.EventManager"
"\" -Dexec.args=\"list\"</command>"
msgstr ""

#. Tag: title
#: tutorial.xml:627
#, no-c-format
msgid "Part 2 - Mapping associations"
msgstr "パート2 - 関連のマッピング"

#. Tag: para
#: tutorial.xml:629
#, fuzzy, no-c-format
msgid ""
"So far we have mapped a single persistent entity class to a table in "
"isolation. Let's expand on that a bit and add some class associations. We "
"will add people to the application and store a list of events in which they "
"participate."
msgstr ""
"永続エンティティクラスをテーブルにマッピングしました。 さらにこの上にいくつか"
"のクラスの関連を追加しましょう。 まず初めにアプリケーションに人々を追加し、彼"
"らが参加するイベントのリストを格納します。"

#. Tag: title
#: tutorial.xml:637
#, no-c-format
msgid "Mapping the Person class"
msgstr "Personクラスのマッピング"

#. Tag: para
#: tutorial.xml:639
#, fuzzy, no-c-format
msgid "The first cut of the <literal>Person</literal> class looks like this:"
msgstr "最初の <literal>Person</literal> クラスは単純です："

#. Tag: programlisting
#: tutorial.xml:643
#, no-c-format
msgid ""
"<![CDATA[package org.hibernate.tutorial.domain;\n"
"\n"
"public class Person {\n"
"\n"
"    private Long id;\n"
"    private int age;\n"
"    private String firstname;\n"
"    private String lastname;\n"
"\n"
"    public Person() {}\n"
"\n"
"    // Accessor methods for all properties, private setter for 'id'\n"
"\n"
"}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:645
#, no-c-format
msgid ""
"Save this to a file named <filename>src/main/java/org/hibernate/tutorial/"
"domain/Person.java</filename>"
msgstr ""

#. Tag: para
#: tutorial.xml:650
#, no-c-format
msgid ""
"Next, create the new mapping file as <filename>src/main/resources/org/"
"hibernate/tutorial/domain/Person.hbm.xml</filename>"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:655
#, no-c-format
msgid ""
"<![CDATA[<hibernate-mapping package=\"org.hibernate.tutorial.domain\">\n"
"\n"
"    <class name=\"Person\" table=\"PERSON\">\n"
"        <id name=\"id\" column=\"PERSON_ID\">\n"
"            <generator class=\"native\"/>\n"
"        </id>\n"
"        <property name=\"age\"/>\n"
"        <property name=\"firstname\"/>\n"
"        <property name=\"lastname\"/>\n"
"    </class>\n"
"\n"
"</hibernate-mapping>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:657
#, no-c-format
msgid "Finally, add the new mapping to Hibernate's configuration:"
msgstr "最後にHibernateの設定に新しいマッピングを追加してください："

#. Tag: programlisting
#: tutorial.xml:661
#, no-c-format
msgid ""
"<![CDATA[<mapping resource=\"events/Event.hbm.xml\"/>\n"
"<mapping resource=\"events/Person.hbm.xml\"/>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:663
#, fuzzy, no-c-format
msgid ""
"Create an association between these two entities. Persons can participate in "
"events, and events have participants. The design questions you have to deal "
"with are: directionality, multiplicity, and collection behavior."
msgstr ""
"それではこれら2つのエンティティ間の関連を作成します。 人々がイベントに参加で"
"き、イベントが参加者を持つのは明らかです。 扱わなければならない設計の問題は、"
"方向、多重度、コレクションの振る舞いです。"

#. Tag: title
#: tutorial.xml:673
#, no-c-format
msgid "A unidirectional Set-based association"
msgstr "単方向Setベース関連"

#. Tag: para
#: tutorial.xml:675
#, fuzzy, no-c-format
msgid ""
"By adding a collection of events to the <literal>Person</literal> class, you "
"can easily navigate to the events for a particular person, without executing "
"an explicit query - by calling <literal>Person#getEvents</literal>. Multi-"
"valued associations are represented in Hibernate by one of the Java "
"Collection Framework contracts; here we choose a <interfacename>java.util."
"Set</interfacename> because the collection will not contain duplicate "
"elements and the ordering is not relevant to our examples:"
msgstr ""
"イベントのコレクションを <literal>Person</literal> クラスに追加します。 こう"
"しておくと、明示的なクエリ、つまりわざわざ<literal>aPerson.getEvents()</"
"literal>を呼び出さずに、 特定の人に紐付くイベントを簡単にナビゲートすることが"
"できます。 私たちはJavaのコレクション、<literal>Set</literal> を使います。 コ"
"レクションは重複要素を持たないし、順番は私たちには意味がないからです。"

#. Tag: programlisting
#: tutorial.xml:686
#, no-c-format
msgid ""
"<![CDATA[public class Person {\n"
"\n"
"    private Set events = new HashSet();\n"
"\n"
"    public Set getEvents() {\n"
"        return events;\n"
"    }\n"
"\n"
"    public void setEvents(Set events) {\n"
"        this.events = events;\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:688
#, fuzzy, no-c-format
msgid ""
"Before mapping this association, let's consider the other side. We could "
"just keep this unidirectional or create another collection on the "
"<literal>Event</literal>, if we wanted to be able to navigate it from both "
"directions. This is not necessary, from a functional perspective. You can "
"always execute an explicit query to retrieve the participants for a "
"particular event. This is a design choice left to you, but what is clear "
"from this discussion is the multiplicity of the association: \"many\" valued "
"on both sides is called a <emphasis>many-to-many</emphasis> association. "
"Hence, we use Hibernate's many-to-many mapping:"
msgstr ""
"この関連をマッピングする前に、反対側について考えてください。 明らかなことです"
"が、今はこれを単方向にしただけです。 逆に、 <literal>Event</literal> 側にも別"
"のコレクションを作ることもできます。 例えば <literal>anEvent.getParticipants"
"()</literal> のように、 双方向にナビゲートしたければ、そうすることもできま"
"す。 これは機能的にみて必要ではありません。 特定のイベントに関係するデータを"
"取得する明確なクエリを、いつでも実行することが出来ました。 この設計の選択は開"
"発者に任されていて、この議論により明らかなのは関連の多重度です。 つまり両側を"
"「多」値にする、 <emphasis>多対多</emphasis> と呼ばれる関連です。 そのため"
"Hibernateのmany-to-manyマッピングを使います："

#. Tag: programlisting
#: tutorial.xml:701
#, no-c-format
msgid ""
"<![CDATA[<class name=\"Person\" table=\"PERSON\">\n"
"    <id name=\"id\" column=\"PERSON_ID\">\n"
"        <generator class=\"native\"/>\n"
"    </id>\n"
"    <property name=\"age\"/>\n"
"    <property name=\"firstname\"/>\n"
"    <property name=\"lastname\"/>\n"
"\n"
"    <set name=\"events\" table=\"PERSON_EVENT\">\n"
"        <key column=\"PERSON_ID\"/>\n"
"        <many-to-many column=\"EVENT_ID\" class=\"Event\"/>\n"
"    </set>\n"
"\n"
"</class>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:703
#, fuzzy, no-c-format
msgid ""
"Hibernate supports a broad range of collection mappings, a <literal>set</"
"literal> being most common. For a many-to-many association, or <emphasis>n:"
"m</emphasis> entity relationship, an association table is required. Each row "
"in this table represents a link between a person and an event. The table "
"name is decalred using the <literal>table</literal> attribute of the "
"<literal>set</literal> element. The identifier column name in the "
"association, for the person side, is defined with the <literal>key</literal> "
"element, the column name for the event's side with the <literal>column</"
"literal> attribute of the <literal>many-to-many</literal>. You also have to "
"tell Hibernate the class of the objects in your collection (the class on the "
"other side of the collection of references)."
msgstr ""
"Hibernateはありとあらゆる種類のコレクションマッピングをサポートしています"
"が、 最も一般的なものが <literal>&lt;set&gt;</literal> です。 多対多関連（ま"
"たは <emphasis>n:m</emphasis> エンティティリレーションシップ）には、 関連テー"
"ブルが必要です。 このテーブルのそれぞれの行は、人とイベント間のリンクを表現し"
"ます。 テーブル名は <literal>set</literal> 要素の <literal>table</literal> 属"
"性で設定します。 人側の関連の識別子カラム名は <literal>&lt;key&gt;</literal> "
"要素で、 イベント側のカラム名は <literal>&lt;many-to-many&gt;</literal> の "
"<literal>column</literal> 属性で定義します。 Hibernateにコレクションのオブ"
"ジェクトのクラス （正確には、参照のコレクションの反対側のクラス）を教えなけれ"
"ばなりません。"

#. Tag: para
#: tutorial.xml:719
#, no-c-format
msgid "The database schema for this mapping is therefore:"
msgstr "そのためこのマッピングのデータベーススキーマは以下のようになります。："

#. Tag: programlisting
#: tutorial.xml:723
#, no-c-format
msgid ""
"<![CDATA[\n"
"    _____________        __________________\n"
"   |             |      |                  |       _____________\n"
"   |   EVENTS    |      |   PERSON_EVENT   |      |             |\n"
"   |_____________|      |__________________|      |    PERSON   |\n"
"   |             |      |                  |      |_____________|\n"
"   | *EVENT_ID   | <--> | *EVENT_ID        |      |             |\n"
"   |  EVENT_DATE |      | *PERSON_ID       | <--> | *PERSON_ID  |\n"
"   |  TITLE      |      |__________________|      |  AGE        |\n"
"   |_____________|                                |  FIRSTNAME  |\n"
"                                                  |  LASTNAME   |\n"
"                                                  |_____________|\n"
" ]]>"
msgstr ""

#. Tag: title
#: tutorial.xml:728
#, no-c-format
msgid "Working the association"
msgstr "関連を働かせる"

#. Tag: para
#: tutorial.xml:730
#, fuzzy, no-c-format
msgid ""
"Now we will bring some people and events together in a new method in "
"<literal>EventManager</literal>:"
msgstr ""
"<literal>EventManager</literal> の新しいメソッドで人々とイベントを一緒にしま"
"しょう："

#. Tag: programlisting
#: tutorial.xml:734
#, no-c-format
msgid ""
"<![CDATA[    private void addPersonToEvent(Long personId, Long eventId) {\n"
"        Session session = HibernateUtil.getSessionFactory().getCurrentSession"
"();\n"
"        session.beginTransaction();\n"
"\n"
"        Person aPerson = (Person) session.load(Person.class, personId);\n"
"        Event anEvent = (Event) session.load(Event.class, eventId);\n"
"        aPerson.getEvents().add(anEvent);\n"
"\n"
"        session.getTransaction().commit();\n"
"    }]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:736
#, fuzzy, no-c-format
msgid ""
"After loading a <literal>Person</literal> and an <literal>Event</literal>, "
"simply modify the collection using the normal collection methods. There is "
"no explicit call to <literal>update()</literal> or <literal>save()</"
"literal>; Hibernate automatically detects that the collection has been "
"modified and needs to be updated. This is called <emphasis>automatic dirty "
"checking</emphasis>. You can also try it by modifying the name or the date "
"property of any of your objects. As long as they are in "
"<emphasis>persistent</emphasis> state, that is, bound to a particular "
"Hibernate <interfacename>org.hibernate.Session</interfacename>, Hibernate "
"monitors any changes and executes SQL in a write-behind fashion. The process "
"of synchronizing the memory state with the database, usually only at the end "
"of a unit of work, is called <emphasis>flushing</emphasis>. In our code, the "
"unit of work ends with a commit, or rollback, of the database transaction."
msgstr ""
"<literal>Person</literal> と <literal>Event</literal> をロードした後、 普通の"
"コレクションメソッドを使って単純にそのコレクションを修正してください。 ご覧の"
"とおり <literal>update()</literal> や <literal>save()</literal> の明示的な呼"
"び出しはありません。 Hibernateは、修正されたことにより更新する必要のあるコレ"
"クションを自動的に検知します。 これは <emphasis>自動ダーティチェック</"
"emphasis> と呼ばれ、 オブジェクトの名前やdateプロパティを修正することで試すこ"
"とも可能です。 それらが <emphasis>永続</emphasis> 状態にある限り、 つまり特定"
"のHibernate <literal>Session</literal> にバインドされている限り （例えば作業"
"単位(Unit of Work)の中で単にロードまたはセーブされた）、 Hibernateはどんな変"
"更もモニターし、遅延書き込み(write-behind)でSQLを実行します。 通常、作業単位"
"(Unit of Work)の最後にだけ行われるデータベースとメモリの状態を同期させる処理"
"は、 <emphasis>フラッシュ</emphasis> と呼ばれます。 このコードでは、作業単位"
"(Unit of Work)はデータベーストランザクションのコミット（もしくはロールバッ"
"ク）で終了します。 これは、 <literal>CurrentSessionContext</literal> クラスに"
"対して <literal>thread</literal> を設定したためです。"

#. Tag: para
#: tutorial.xml:755
#, fuzzy, no-c-format
msgid ""
"You can load person and event in different units of work. Or you can modify "
"an object outside of a <interfacename>org.hibernate.Session</interfacename>, "
"when it is not in persistent state (if it was persistent before, this state "
"is called <emphasis>detached</emphasis>). You can even modify a collection "
"when it is detached:"
msgstr ""
"異なる作業単位(Unit of Work)で人々とイベントをロードすることも当然できます。 "
"そうでなければ、永続状態にないとき（以前に永続であったなら、この状態を "
"<emphasis>分離（detached）</emphasis> と呼びます）、 <literal>Session</"
"literal> の外部でオブジェクトを修正します。 分離されるときにはコレクションを"
"変更することも可能です："

#. Tag: programlisting
#: tutorial.xml:764
#, no-c-format
msgid ""
"<![CDATA[    private void addPersonToEvent(Long personId, Long eventId) {\n"
"        Session session = HibernateUtil.getSessionFactory().getCurrentSession"
"();\n"
"        session.beginTransaction();\n"
"\n"
"        Person aPerson = (Person) session\n"
"                .createQuery(\"select p from Person p left join fetch p."
"events where p.id = :pid\")\n"
"                .setParameter(\"pid\", personId)\n"
"                .uniqueResult(); // Eager fetch the collection so we can use "
"it detached\n"
"        Event anEvent = (Event) session.load(Event.class, eventId);\n"
"\n"
"        session.getTransaction().commit();\n"
"\n"
"        // End of first unit of work\n"
"\n"
"        aPerson.getEvents().add(anEvent); // aPerson (and its collection) is "
"detached\n"
"\n"
"        // Begin second unit of work\n"
"\n"
"        Session session2 = HibernateUtil.getSessionFactory()."
"getCurrentSession();\n"
"        session2.beginTransaction();\n"
"        session2.update(aPerson); // Reattachment of aPerson\n"
"\n"
"        session2.getTransaction().commit();\n"
"    }]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:766
#, fuzzy, no-c-format
msgid ""
"The call to <literal>update</literal> makes a detached object persistent "
"again by binding it to a new unit of work, so any modifications you made to "
"it while detached can be saved to the database. This includes any "
"modifications (additions/deletions) you made to a collection of that entity "
"object."
msgstr ""
"<literal>update</literal> の呼び出しは分離オブジェクトを再び永続化します。 こ"
"れは、新しい作業単位(Unit of Work)にバインドすると言えるでしょう。 そのため分"
"離の間に加えられたどのような修正もデータベースにセーブできます。 エンティティ"
"オブジェクトのコレクションへの修正（追加･削除）も同様にセーブできます。"

#. Tag: para
#: tutorial.xml:775
#, fuzzy, no-c-format
msgid ""
"This is not much use in our example, but it is an important concept you can "
"incorporate into your own application. Complete this exercise by adding a "
"new action to the main method of the <literal>EventManager</literal> and "
"call it from the command line. If you need the identifiers of a person and "
"an event - the <literal>save()</literal> method returns it (you might have "
"to modify some of the previous methods to return that identifier):"
msgstr ""
"これは今はあまり使いみちがありませんが、 自分のアプリケーションの設計に組み込"
"むことができる重要なコンセプトです。 それではこのエクササイズの最後に、 "
"<literal>EventManager</literal> のメインメソッドに新しいアクションを追加して "
"コマンドラインから呼び出してみましょう。 人やイベントの識別子が必要なら、 "
"<literal>save()</literal> メソッドが返してくれます （場合によっては識別子を返"
"すためにメソッドを修正する必要があるかもしれません）。"

#. Tag: programlisting
#: tutorial.xml:783
#, no-c-format
msgid ""
"<![CDATA[        else if (args[0].equals(\"addpersontoevent\")) {\n"
"            Long eventId = mgr.createAndStoreEvent(\"My Event\", new Date"
"());\n"
"            Long personId = mgr.createAndStorePerson(\"Foo\", \"Bar\");\n"
"            mgr.addPersonToEvent(personId, eventId);\n"
"            System.out.println(\"Added person \" + personId + \" to event \" "
"+ eventId);\n"
"        }]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:785
#, fuzzy, no-c-format
msgid ""
"This is an example of an association between two equally important classes : "
"two entities. As mentioned earlier, there are other classes and types in a "
"typical model, usually \"less important\". Some you have already seen, like "
"an <literal>int</literal> or a <classname>java.lang.String</classname>. We "
"call these classes <emphasis>value types</emphasis>, and their instances "
"<emphasis>depend</emphasis> on a particular entity. Instances of these types "
"do not have their own identity, nor are they shared between entities. Two "
"persons do not reference the same <literal>firstname</literal> object, even "
"if they have the same first name. Value types cannot only be found in the "
"JDK , but you can also write dependent classes yourself such as an "
"<literal>Address</literal> or <literal>MonetaryAmount</literal> class. In "
"fact, in a Hibernate application all JDK classes are considered value types."
msgstr ""
"これは同じように重要な2つのクラス、つまり2つのエンティティ間の関連の例でし"
"た。 前に述べたように、典型的なモデルには、普通「比較的重要ではない」他のクラ"
"スと型があります。 これまでに見たような <literal>int</literal> や "
"<literal>String</literal> のようなものです。 このようなクラスを <emphasis>値"
"型</emphasis> と言います。 このインスタンスは特定のエンティティに <emphasis>"
"依存</emphasis> します。 この型のインスタンスは独自のIDを持ちませんし、 エン"
"ティティ間で共有されることもありません （ファーストネームが同じだったとして"
"も、2人の人は同じ <literal>firstname</literal> オブジェクトを参照しませ"
"ん）。 値型はもちろんJDK内に見つかりますが、それだけではなく （実際、"
"HibernateアプリケーションにおいてすべてのJDKクラスは値型と見なせます）、 例え"
"ば <literal>Address</literal> や <literal>MonetaryAmount</literal> のような独"
"自の依存クラスを書くこともできます。"

#. Tag: para
#: tutorial.xml:803
#, fuzzy, no-c-format
msgid ""
"You can also design a collection of value types. This is conceptually "
"different from a collection of references to other entities, but looks "
"almost the same in Java."
msgstr ""
"値型のコレクションを設計することもできます。 これは他のエンティティへの参照の"
"コレクションとは概念的に非常に異なりますが、 Javaではほとんど同じように見えま"
"す。"

#. Tag: title
#: tutorial.xml:812
#, no-c-format
msgid "Collection of values"
msgstr "値のコレクション"

#. Tag: para
#: tutorial.xml:814
#, no-c-format
msgid ""
"Let's add a collection of email addresses to the <literal>Person</literal> "
"entity. This will be represented as a <interfacename>java.util.Set</"
"interfacename> of <classname>java.lang.String</classname> instances:"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:820
#, no-c-format
msgid ""
"<![CDATA[    private Set emailAddresses = new HashSet();\n"
"\n"
"    public Set getEmailAddresses() {\n"
"        return emailAddresses;\n"
"    }\n"
"\n"
"    public void setEmailAddresses(Set emailAddresses) {\n"
"        this.emailAddresses = emailAddresses;\n"
"    }]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:822
#, fuzzy, no-c-format
msgid "The mapping of this <literal>Set</literal> is as follows:"
msgstr "この <literal>Set</literal> のマッピングです："

#. Tag: programlisting
#: tutorial.xml:826
#, no-c-format
msgid ""
"<![CDATA[        <set name=\"emailAddresses\" table=\"PERSON_EMAIL_ADDR\">\n"
"            <key column=\"PERSON_ID\"/>\n"
"            <element type=\"string\" column=\"EMAIL_ADDR\"/>\n"
"        </set>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:828
#, fuzzy, no-c-format
msgid ""
"The difference compared with the earlier mapping is the use of the "
"<literal>element</literal> part which tells Hibernate that the collection "
"does not contain references to another entity, but is rather a collection "
"whose elements are values types, here specifically of type <literal>string</"
"literal>. The lowercase name tells you it is a Hibernate mapping type/"
"converter. Again the <literal>table</literal> attribute of the <literal>set</"
"literal> element determines the table name for the collection. The "
"<literal>key</literal> element defines the foreign-key column name in the "
"collection table. The <literal>column</literal> attribute in the "
"<literal>element</literal> element defines the column name where the email "
"address values will actually be stored."
msgstr ""
"前のマッピングと比べて違うのは <literal>element</literal> の部分ですが、 "
"Hibernateにこのコレクションが他のエンティティへの参照を含まず、 "
"<literal>String</literal> 型の要素のコレクションを含むことを教えます。 （小文"
"字の名前(string)はHibernateのマッピング型またはコンバータであるということで"
"す）。 繰り返しますが、<literal>set</literal> 要素の <literal>table</"
"literal> 属性は、 コレクションのためのテーブル名を指定します。 <literal>key</"
"literal> 要素はコレクションテーブルの外部キーカラム名を定義します。 "
"<literal>element</literal> 要素の <literal>column</literal> 属性は "
"<literal>String</literal> の値が実際に格納されるカラムの名前を定義します。"

#. Tag: para
#: tutorial.xml:844
#, fuzzy, no-c-format
msgid "Here is the updated schema:"
msgstr "更新したスキーマを見てください："

#. Tag: programlisting
#: tutorial.xml:848
#, no-c-format
msgid ""
"<![CDATA[\n"
"  _____________        __________________\n"
" |             |      |                  |       _____________\n"
" |   EVENTS    |      |   PERSON_EVENT   |      |             |       "
"___________________\n"
" |_____________|      |__________________|      |    PERSON   |      "
"|                   |\n"
" |             |      |                  |      |_____________|      | "
"PERSON_EMAIL_ADDR |\n"
" | *EVENT_ID   | <--> | *EVENT_ID        |      |             |      |"
"___________________|\n"
" |  EVENT_DATE |      | *PERSON_ID       | <--> | *PERSON_ID  | <--> |  "
"*PERSON_ID       |\n"
" |  TITLE      |      |__________________|      |  AGE        |      |  "
"*EMAIL_ADDR      |\n"
" |_____________|                                |  FIRSTNAME  |      |"
"___________________|\n"
"                                                |  LASTNAME   |\n"
"                                                |_____________|\n"
" ]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:850
#, fuzzy, no-c-format
msgid ""
"You can see that the primary key of the collection table is in fact a "
"composite key that uses both columns. This also implies that there cannot be "
"duplicate email addresses per person, which is exactly the semantics we need "
"for a set in Java."
msgstr ""
"コレクションテーブルの主キーは、実際は両方のカラムを使った複合キーであること"
"がわかります。 これは人ごとにEメールアドレスが重複できないということで、 Java"
"のsetに要求されるセマンティクスそのものです。"

#. Tag: para
#: tutorial.xml:856
#, fuzzy, no-c-format
msgid ""
"You can now try to add elements to this collection, just like we did before "
"by linking persons and events. It is the same code in Java:"
msgstr ""
"以前人とイベントを関連づけたときと全く同じように、 今や試しにコレクションに要"
"素を追加することができるようになりました。 両方ともJavaでは同じコードです。"

#. Tag: programlisting
#: tutorial.xml:861
#, no-c-format
msgid ""
"<![CDATA[    private void addEmailToPerson(Long personId, String "
"emailAddress) {\n"
"        Session session = HibernateUtil.getSessionFactory().getCurrentSession"
"();\n"
"        session.beginTransaction();\n"
"\n"
"        Person aPerson = (Person) session.load(Person.class, personId);\n"
"        // adding to the emailAddress collection might trigger a lazy load "
"of the collection\n"
"        aPerson.getEmailAddresses().add(emailAddress);\n"
"\n"
"        session.getTransaction().commit();\n"
"    }]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:863
#, fuzzy, no-c-format
msgid ""
"This time we did not use a <emphasis>fetch</emphasis> query to initialize "
"the collection. Monitor the SQL log and try to optimize this with an eager "
"fetch."
msgstr ""
"今回、コレクションの初期化に <emphasis>fetch</emphasis> クエリを使用しません"
"でした。 そのため、getterメソッドの呼び出しによってコレクションを初期化するた"
"めのSELECTが 実行されるので、コレクションに要素を追加できます。 SQLのログを監"
"視して、即時フェッチを使って最適化してください。"

#. Tag: title
#: tutorial.xml:872
#, no-c-format
msgid "Bi-directional associations"
msgstr "双方向関連"

#. Tag: para
#: tutorial.xml:874
#, fuzzy, no-c-format
msgid ""
"Next you will map a bi-directional association. You will make the "
"association between person and event work from both sides in Java. The "
"database schema does not change, so you will still have many-to-many "
"multiplicity."
msgstr ""
"次に双方向関連をマッピングします。 Javaで両側から人とイベントの関連を動作させ"
"ます。 もちろん、データベーススキーマは変わりませんが、多重度は多対多のままで"
"す。 リレーショナルデータベースはネットワークプログラミング言語よりも柔軟なの"
"で、 ナビゲーションの方向のようなものを必要としません。 データはあらゆるの方"
"法で見たり復元できるということです。"

#. Tag: para
#: tutorial.xml:882
#, no-c-format
msgid ""
"A relational database is more flexible than a network programming language, "
"in that it does not need a navigation direction; data can be viewed and "
"retrieved in any possible way."
msgstr ""

#. Tag: para
#: tutorial.xml:890
#, fuzzy, no-c-format
msgid ""
"First, add a collection of participants to the <literal>Event</literal> "
"class:"
msgstr ""
"まず <literal>Event</literal> イベントクラスに参加者のコレクションを追加しま"
"す："

#. Tag: programlisting
#: tutorial.xml:895
#, no-c-format
msgid ""
"<![CDATA[    private Set participants = new HashSet();\n"
"\n"
"    public Set getParticipants() {\n"
"        return participants;\n"
"    }\n"
"\n"
"    public void setParticipants(Set participants) {\n"
"        this.participants = participants;\n"
"    }]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:897
#, fuzzy, no-c-format
msgid ""
"Now map this side of the association in <literal>Event.hbm.xml</literal>."
msgstr ""
"それでは <literal>Event.hbm.xml</literal> で関連のこちら側をマッピングしてく"
"ださい。"

#. Tag: programlisting
#: tutorial.xml:901
#, no-c-format
msgid ""
"<![CDATA[        <set name=\"participants\" table=\"PERSON_EVENT\" inverse="
"\"true\">\n"
"            <key column=\"EVENT_ID\"/>\n"
"            <many-to-many column=\"PERSON_ID\" class=\"events.Person\"/>\n"
"        </set>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:903
#, fuzzy, no-c-format
msgid ""
"These are normal <literal>set</literal> mappings in both mapping documents. "
"Notice that the column names in <literal>key</literal> and <literal>many-to-"
"many</literal> swap in both mapping documents. The most important addition "
"here is the <literal>inverse=\"true\"</literal> attribute in the "
"<literal>set</literal> element of the <literal>Event</literal>'s collection "
"mapping."
msgstr ""
"ご覧のとおり、いずれのマッピングドキュメント(XMLファイル)でも、普通の "
"<literal>set</literal> マッピングを使っています。 <literal>key</literal> と "
"<literal>many-to-many</literal> のカラム名が、 両方のマッピングドキュメントで"
"入れ替えになっていることに注目してください。 ここで最も重要な追加項目は、 "
"<literal>Event</literal> のコレクションマッピングの <literal>set</literal> 要"
"素にある <literal>inverse=\"true\"</literal> 属性です。"

#. Tag: para
#: tutorial.xml:911
#, fuzzy, no-c-format
msgid ""
"What this means is that Hibernate should take the other side, the "
"<literal>Person</literal> class, when it needs to find out information about "
"the link between the two. This will be a lot easier to understand once you "
"see how the bi-directional link between our two entities is created."
msgstr ""
"この指定の意味は、2つの間のエンティティ間のリンクについての情報を探す必要があ"
"るとき、 Hibernateは反対側のエンティティ、つまり <literal>Person</literal> ク"
"ラスから探すということです。 一度2つのエンティティ間の双方向リンクがどのよう"
"に作成されるかがわかれば、 これを理解することはとても簡単です。"

#. Tag: title
#: tutorial.xml:920
#, no-c-format
msgid "Working bi-directional links"
msgstr "双方向リンクの動作"

#. Tag: para
#: tutorial.xml:922
#, fuzzy, no-c-format
msgid ""
"First, keep in mind that Hibernate does not affect normal Java semantics. "
"How did we create a link between a <literal>Person</literal> and an "
"<literal>Event</literal> in the unidirectional example? You add an instance "
"of <literal>Event</literal> to the collection of event references, of an "
"instance of <literal>Person</literal>. If you want to make this link bi-"
"directional, you have to do the same on the other side by adding a "
"<literal>Person</literal> reference to the collection in an <literal>Event</"
"literal>. This process of \"setting the link on both sides\" is absolutely "
"necessary with bi-directional links."
msgstr ""
"まず、Hibernateが通常のJavaのセマンティクスに影響を及ぼさないことを心に留めて"
"おいてください。 私たちは、単方向の例としてどのように <literal>Person</"
"literal> と <literal>Event</literal> の間のリンクを作成したでしょうか？ "
"<literal>Person</literal> のインスタンスのイベントへの参照のコレクションに "
"<literal>Event</literal> のインスタンスを追加しました。 そのためこのリンクを"
"双方向にしたければ、 当たり前ですが反対側にも同じことをしなければなりませ"
"ん。 <literal>Event</literal> のコレクションに <literal>Person</literal> へ"
"の 参照を追加するということです。 この「両側でリンクを設定すること」は絶対に"
"必要なので、決して忘れないでください。"

#. Tag: para
#: tutorial.xml:932
#, fuzzy, no-c-format
msgid ""
"Many developers program defensively and create link management methods to "
"correctly set both sides (for example, in <literal>Person</literal>):"
msgstr ""
"多くの開発者は慎重にプログラムするので、 エンティティの両側に正しく関連を設定"
"するリンク管理メソッドを作成します。 例えば <literal>Person</literal> では以"
"下のようになります。："

#. Tag: programlisting
#: tutorial.xml:937
#, no-c-format
msgid ""
"<![CDATA[    protected Set getEvents() {\n"
"        return events;\n"
"    }\n"
"\n"
"    protected void setEvents(Set events) {\n"
"        this.events = events;\n"
"    }\n"
"\n"
"    public void addToEvent(Event event) {\n"
"        this.getEvents().add(event);\n"
"        event.getParticipants().add(this);\n"
"    }\n"
"\n"
"    public void removeFromEvent(Event event) {\n"
"        this.getEvents().remove(event);\n"
"        event.getParticipants().remove(this);\n"
"    }]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:939
#, fuzzy, no-c-format
msgid ""
"The get and set methods for the collection are now protected. This allows "
"classes in the same package and subclasses to still access the methods, but "
"prevents everybody else from altering the collections directly. Repeat the "
"steps for the collection on the other side."
msgstr ""
"コレクションのゲットとセットメソッドが現在protectedになっていることに注意して"
"ください。 これは同じパッケージのクラスやサブクラスのメソッドは依然アクセスが"
"可能ですが、 （ほとんど）そのパッケージ外のどのクラスでも直接そのコレクション"
"を台無しにすることを防ぎます。 おそらく反対側のコレクションにも同じことをした"
"方がいいでしょう。"

#. Tag: para
#: tutorial.xml:946
#, fuzzy, no-c-format
msgid ""
"What about the <literal>inverse</literal> mapping attribute? For you, and "
"for Java, a bi-directional link is simply a matter of setting the references "
"on both sides correctly. Hibernate, however, does not have enough "
"information to correctly arrange SQL <literal>INSERT</literal> and "
"<literal>UPDATE</literal> statements (to avoid constraint violations). "
"Making one side of the association <literal>inverse</literal> tells "
"Hibernate to consider it a <emphasis>mirror</emphasis> of the other side. "
"That is all that is necessary for Hibernate to resolve any issues that arise "
"when transforming a directional navigation model to a SQL database schema. "
"The rules are straightforward: all bi-directional associations need one side "
"as <literal>inverse</literal>. In a one-to-many association it has to be the "
"many-side, and in many-to-many association you can select either side."
msgstr ""
"<literal>inverse</literal> マッピング属性とはいったい何でしょうか？ 開発者と"
"Javaにとっては、双方向リンクは単に両側の参照を正しく設定するということです。 "
"しかしHibernateは（制約違反を避けるために）SQLの <literal>INSERT</literal> "
"と <literal>UPDATE</literal> 文を正確に変更するための十分な情報を持っていない"
"ので、 双方向関連プロパティを扱うための何らかの助けを必要とします。 関連の片"
"側を <literal>inverse</literal> に設定することで、Hibernateは基本的には設定し"
"た側を無視し、 反対側の <emphasis>鏡</emphasis> として考えます。 これだけで、"
"Hibernateは方向を持つナビゲーションモデルをSQLデータベーススキーマへ変換する"
"ときの すべての問題にうまく対処できます。 覚えておかなければならないルールは"
"簡単です。 双方向関連は必ず片側を <literal>inverse</literal> にする必要がある"
"ということです。 一対多関連ではそれは多側でなければなりません。 多対多関連で"
"はどちら側でも構いません。どちらでも違いはありません。"

#. Tag: title
#: tutorial.xml:962
#, no-c-format
msgid "Part 3 - The EventManager web application"
msgstr "パート3 - EventManager Webアプリケーション"

#. Tag: para
#: tutorial.xml:964
#, fuzzy, no-c-format
msgid ""
"A Hibernate web application uses <literal>Session</literal> and "
"<literal>Transaction</literal> almost like a standalone application. "
"However, some common patterns are useful. You can now write an "
"<literal>EventManagerServlet</literal>. This servlet can list all events "
"stored in the database, and it provides an HTML form to enter new events."
msgstr ""
"HibernateのWebアプリケーションは、スタンドアローンのアプリケーションのように "
"<literal>Session</literal> と <literal>Transaction</literal> を使用します。 "
"しかしいくつかの一般的なパターンが役立ちます。 ここで "
"<literal>EventManagerServlet</literal> を作成します。このサーブレットは、 "
"データベースに格納した全てのイベントをリストにでき、さらにHTMLフォームから新"
"しいイベントを入力できるものです。"

#. Tag: title
#: tutorial.xml:972
#, no-c-format
msgid "Writing the basic servlet"
msgstr "基本的なServletの記述"

#. Tag: para
#: tutorial.xml:974
#, fuzzy, no-c-format
msgid ""
"First we need create our basic processing servlet. Since our servlet only "
"handles HTTP <literal>GET</literal> requests, we will only implement the "
"<literal>doGet()</literal> method:"
msgstr ""
"ServletはHTTPの <literal>GET</literal> リクエストのみを処理するので、 "
"<literal>doGet()</literal> を実装します。"

#. Tag: programlisting
#: tutorial.xml:980
#, no-c-format
msgid ""
"<![CDATA[package org.hibernate.tutorial.web;\n"
"\n"
"// Imports\n"
"\n"
"public class EventManagerServlet extends HttpServlet {\n"
"\n"
"    protected void doGet(\n"
"            HttpServletRequest request,\n"
"            HttpServletResponse response) throws ServletException, "
"IOException {\n"
"\n"
"        SimpleDateFormat dateFormatter = new SimpleDateFormat( \"dd.MM.yyyy"
"\" );\n"
"\n"
"        try {\n"
"            // Begin unit of work\n"
"            HibernateUtil.getSessionFactory().getCurrentSession()."
"beginTransaction();\n"
"\n"
"            // Process request and render page...\n"
"\n"
"            // End unit of work\n"
"            HibernateUtil.getSessionFactory().getCurrentSession()."
"getTransaction().commit();\n"
"        }\n"
"        catch (Exception ex) {\n"
"            HibernateUtil.getSessionFactory().getCurrentSession()."
"getTransaction().rollback();\n"
"            if ( ServletException.class.isInstance( ex ) ) {\n"
"                throw ( ServletException ) ex;\n"
"            }\n"
"            else {\n"
"                throw new ServletException( ex );\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"}]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:982
#, no-c-format
msgid ""
"Save this servlet as <filename>src/main/java/org/hibernate/tutorial/web/"
"EventManagerServlet.java</filename>"
msgstr ""

#. Tag: para
#: tutorial.xml:987
#, fuzzy, no-c-format
msgid ""
"The pattern applied here is called <emphasis>session-per-request</emphasis>. "
"When a request hits the servlet, a new Hibernate <literal>Session</literal> "
"is opened through the first call to <literal>getCurrentSession()</literal> "
"on the <literal>SessionFactory</literal>. A database transaction is then "
"started. All data access occurs inside a transaction irrespective of whether "
"the data is read or written. Do not use the auto-commit mode in applications."
msgstr ""
"これは <emphasis>session-per-request</emphasis> というパターンです。 Servlet"
"がリクエストを受け取ると、 <literal>SessionFactory</literal> の "
"<literal>getCurrentSession()</literal> の最初の呼び出しで、 Hibernateの新し"
"い <literal>Session</literal> が開かれます。 そのときデータベーストランザク"
"ションが開始されます。 データの読み書きに関わらず、すべてのデータアクセスはト"
"ランザクション内で行います。 （アプリケーション内ではオートコミットモードを使"
"用しません）。"

#. Tag: para
#: tutorial.xml:996
#, no-c-format
msgid ""
"Do <emphasis>not</emphasis> use a new Hibernate <literal>Session</literal> "
"for every database operation. Use one Hibernate <literal>Session</literal> "
"that is scoped to the whole request. Use <literal>getCurrentSession()</"
"literal>, so that it is automatically bound to the current Java thread."
msgstr ""
"Do <emphasis>not</emphasis> use a new Hibernate <literal>Session</literal> "
"for every database operation. Use one Hibernate <literal>Session</literal> "
"that is scoped to the whole request. Use <literal>getCurrentSession()</"
"literal>, so that it is automatically bound to the current Java thread."

#. Tag: para
#: tutorial.xml:1003
#, fuzzy, no-c-format
msgid ""
"Next, the possible actions of the request are processed and the response "
"HTML is rendered. We will get to that part soon."
msgstr ""
"次に、リクエストのアクションは処理され、レスポンスであるHTMLが描画されます。 "
"これについてはすぐに説明します。"

#. Tag: para
#: tutorial.xml:1008
#, fuzzy, no-c-format
msgid ""
"Finally, the unit of work ends when processing and rendering are complete. "
"If any problems occurred during processing or rendering, an exception will "
"be thrown and the database transaction rolled back. This completes the "
"<literal>session-per-request</literal> pattern. Instead of the transaction "
"demarcation code in every servlet, you could also write a servlet filter. "
"See the Hibernate website and Wiki for more information about this pattern "
"called <emphasis>Open Session in View</emphasis>. You will need it as soon "
"as you consider rendering your view in JSP, not in a servlet."
msgstr ""
"最後にリクエストの処理とHTML描画が完了したときに、作業単位(Unit of Work)を終"
"了します。 もし処理や描画中に問題が発生した場合、exceptionが投げられてデータ"
"ベーストランザクションをロールバックします。 これで <literal>session-per-"
"request</literal> パターンが完了します。 全てのサーブレットにトランザクション"
"境界のコードを書く代わりに、サーブレットフィルタに記述することも可能です。 "
"<emphasis>Open Session in View</emphasis> と呼ばれるこのパターンについては、 "
"HibernateのWebサイトやWikiを参照してください。 サーブレットではなくJSPでHTML"
"描画をしようとすると、すぐにこのパターンについての情報が必要になるでしょう。"

#. Tag: title
#: tutorial.xml:1022
#, no-c-format
msgid "Processing and rendering"
msgstr "処理と描画"

#. Tag: para
#: tutorial.xml:1024
#, fuzzy, no-c-format
msgid ""
"Now you can implement the processing of the request and the rendering of the "
"page."
msgstr "では、リクエストの処理とページの描画を実装します。"

#. Tag: programlisting
#: tutorial.xml:1028
#, no-c-format
msgid ""
"<![CDATA[        // Write HTML header\n"
"        PrintWriter out = response.getWriter();\n"
"        out.println(\"<html><head><title>Event Manager</title></head><body>"
"\");\n"
"\n"
"        // Handle actions\n"
"        if ( \"store\".equals(request.getParameter(\"action\")) ) {\n"
"\n"
"            String eventTitle = request.getParameter(\"eventTitle\");\n"
"            String eventDate = request.getParameter(\"eventDate\");\n"
"\n"
"            if ( \"\".equals(eventTitle) || \"\".equals(eventDate) ) {\n"
"                out.println(\"<b><i>Please enter event title and date.</i></"
"b>\");\n"
"            }\n"
"            else {\n"
"                createAndStoreEvent(eventTitle, dateFormatter.parse"
"(eventDate));\n"
"                out.println(\"<b><i>Added event.</i></b>\");\n"
"            }\n"
"        }\n"
"\n"
"        // Print page\n"
"       printEventForm(out);\n"
"       listEvents(out, dateFormatter);\n"
"\n"
"       // Write HTML footer\n"
"       out.println(\"</body></html>\");\n"
"       out.flush();\n"
"       out.close();]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:1030
#, fuzzy, no-c-format
msgid ""
"This coding style, with a mix of Java and HTML, would not scale in a more "
"complex application&mdash;keep in mind that we are only illustrating basic "
"Hibernate concepts in this tutorial. The code prints an HTML header and a "
"footer. Inside this page, an HTML form for event entry and a list of all "
"events in the database are printed. The first method is trivial and only "
"outputs HTML:"
msgstr ""
"JavaとHTMLが混在するコーディングスタイルは、より複雑なアプリケーションには適"
"していないでしょう （このチュートリアルでは、基本的なHibernateのコンセプトを"
"示しているだけであることを覚えておいてください）。 このコードはHTMLのヘッダー"
"とフッターの記述です。 このページには、イベントを入力するHTMLフォームと、デー"
"タベースにある全てのイベントのリストが表示されます。 最初のメソッドはごく単純"
"なHTML出力です。"

#. Tag: programlisting
#: tutorial.xml:1039
#, no-c-format
msgid ""
"<![CDATA[    private void printEventForm(PrintWriter out) {\n"
"        out.println(\"<h2>Add new event:</h2>\");\n"
"        out.println(\"<form>\");\n"
"        out.println(\"Title: <input name='eventTitle' length='50'/><br/>"
"\");\n"
"        out.println(\"Date (e.g. 24.12.2009): <input name='eventDate' "
"length='10'/><br/>\");\n"
"        out.println(\"<input type='submit' name='action' value='store'/>"
"\");\n"
"        out.println(\"</form>\");\n"
"    }]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:1041
#, no-c-format
msgid ""
"The <literal>listEvents()</literal> method uses the Hibernate "
"<literal>Session</literal> bound to the current thread to execute a query:"
msgstr ""
"<literal>listEvents()</literal> メソッドは、現在のスレッドに結びつく "
"Hibernateの <literal>Session</literal> を使用して、クエリを実行します。"

#. Tag: programlisting
#: tutorial.xml:1047
#, no-c-format
msgid ""
"<![CDATA[    private void listEvents(PrintWriter out, SimpleDateFormat "
"dateFormatter) {\n"
"\n"
"        List result = HibernateUtil.getSessionFactory()\n"
"                .getCurrentSession().createCriteria(Event.class).list();\n"
"        if (result.size() > 0) {\n"
"            out.println(\"<h2>Events in database:</h2>\");\n"
"            out.println(\"<table border='1'>\");\n"
"            out.println(\"<tr>\");\n"
"            out.println(\"<th>Event title</th>\");\n"
"            out.println(\"<th>Event date</th>\");\n"
"            out.println(\"</tr>\");\n"
"            Iterator it = result.iterator();\n"
"            while (it.hasNext()) {\n"
"                Event event = (Event) it.next();\n"
"                out.println(\"<tr>\");\n"
"                out.println(\"<td>\" + event.getTitle() + \"</td>\");\n"
"                out.println(\"<td>\" + dateFormatter.format(event.getDate()) "
"+ \"</td>\");\n"
"                out.println(\"</tr>\");\n"
"            }\n"
"            out.println(\"</table>\");\n"
"        }\n"
"    }]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:1049
#, no-c-format
msgid ""
"Finally, the <literal>store</literal> action is dispatched to the "
"<literal>createAndStoreEvent()</literal> method, which also uses the "
"<literal>Session</literal> of the current thread:"
msgstr ""
"最後に、 <literal>store</literal> アクションが <literal>createAndStoreEvent()"
"</literal> メソッドを 呼び出します。このメソッドでも現在のスレッドの "
"<literal>Session</literal> を利用します。"

#. Tag: programlisting
#: tutorial.xml:1055
#, no-c-format
msgid ""
"<![CDATA[    protected void createAndStoreEvent(String title, Date theDate) "
"{\n"
"        Event theEvent = new Event();\n"
"        theEvent.setTitle(title);\n"
"        theEvent.setDate(theDate);\n"
"\n"
"        HibernateUtil.getSessionFactory()\n"
"                .getCurrentSession().save(theEvent);\n"
"    }]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:1057
#, fuzzy, no-c-format
msgid ""
"The servlet is now complete. A request to the servlet will be processed in a "
"single <literal>Session</literal> and <literal>Transaction</literal>. As "
"earlier in the standalone application, Hibernate can automatically bind "
"these objects to the current thread of execution. This gives you the freedom "
"to layer your code and access the <literal>SessionFactory</literal> in any "
"way you like. Usually you would use a more sophisticated design and move the "
"data access code into data access objects (the DAO pattern). See the "
"Hibernate Wiki for more examples."
msgstr ""
"これでサーブレットの完成です。 サーブレットへのリクエストは、一つの "
"<literal>Session</literal> と <literal>Transaction</literal> で処理されるで"
"しょう。 最初のスタンドアローンのアプリケーションのように、 Hibernateは自動的"
"にこれらのオブジェクトを実行するスレッドに結び付けることができます。 これによ"
"り、開発者が自由にコードをレイヤー分けでき、 好きな方法で "
"<literal>SessionFactory</literal> へのアクセスができるようになります。 通常、"
"開発者はより洗練されたデザインを使用して、データアクセスのコードを データアク"
"セスオブジェクトに移動するでしょう（DAOパターン）。 より多くの例は、Hibernate"
"のWikiを参照してください。"

#. Tag: title
#: tutorial.xml:1071
#, no-c-format
msgid "Deploying and testing"
msgstr "デプロイとテスト"

#. Tag: para
#: tutorial.xml:1073
#, no-c-format
msgid ""
"To deploy this application for testing we must create a Web ARchive (WAR). "
"First we must define the WAR descriptor as <filename>src/main/webapp/WEB-INF/"
"web.xml</filename>"
msgstr ""

#. Tag: programlisting
#: tutorial.xml:1079
#, no-c-format
msgid ""
"<![CDATA[<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<web-app version=\"2.4\"\n"
"    xmlns=\"http://java.sun.com/xml/ns/j2ee\"\n"
"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"    xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/"
"xml/ns/j2ee/web-app_2_4.xsd\">\n"
"\n"
"    <servlet>\n"
"        <servlet-name>Event Manager</servlet-name>\n"
"        <servlet-class>org.hibernate.tutorial.web.EventManagerServlet</"
"servlet-class>\n"
"    </servlet>\n"
"\n"
"    <servlet-mapping>\n"
"        <servlet-name>Event Manager</servlet-name>\n"
"        <url-pattern>/eventmanager</url-pattern>\n"
"    </servlet-mapping>\n"
"</web-app>]]>"
msgstr ""

#. Tag: para
#: tutorial.xml:1081
#, fuzzy, no-c-format
msgid ""
"To build and deploy call <literal>mvn package</literal> in your project "
"directory and copy the <filename>hibernate-tutorial.war</filename> file into "
"your Tomcat <filename>webapps</filename> directory."
msgstr ""
"ビルドとデプロイのために、プロジェクトディレクトリで <literal>ant war</"
"literal> を呼び出し、 <literal>hibernate-tutorial.war</literal> ファイルを"
"Tomcatの <literal>webapp</literal> ディレクトリにコピーしてください。 まだ"
"Tomcatをインストールしていなければ、ダウンロードして、以下のインストールガイ"
"ドに従ってください。 しかし、このアプリケーションのデプロイするために、Tomcat"
"の設定を変更する必要はありません。"

#. Tag: para
#: tutorial.xml:1088
#, no-c-format
msgid ""
"If you do not have Tomcat installed, download it from <ulink url=\"http://"
"tomcat.apache.org/\"></ulink> and follow the installation instructions. Our "
"application requires no changes to the standard Tomcat configuration."
msgstr ""

#. Tag: para
#: tutorial.xml:1096
#, no-c-format
msgid ""
"Once deployed and Tomcat is running, access the application at "
"<literal>http://localhost:8080/hibernate-tutorial/eventmanager</literal>. "
"Make sure you watch the Tomcat log to see Hibernate initialize when the "
"first request hits your servlet (the static initializer in "
"<literal>HibernateUtil</literal> is called) and to get the detailed output "
"if any exceptions occurs."
msgstr ""
"一度デプロイしてTomcatを起動すれば、 <literal>http://localhost:8080/"
"hibernate-tutorial/eventmanager</literal> で アプリケーションへのアクセスが可"
"能です。 最初のリクエストが作成したサーブレットに渡ったときに、Tomcatのログ"
"で Hibernateの初期化処理を確認してください （ <literal>HibernateUtil</"
"literal> 内の静的初期化ブロックが呼ばれています）。 また、exceptionが発生した"
"なら詳細を確認してください。"

#. Tag: title
#: tutorial.xml:1109
#, no-c-format
msgid "Summary"
msgstr "要約"

#. Tag: para
#: tutorial.xml:1111
#, fuzzy, no-c-format
msgid ""
"This tutorial covered the basics of writing a simple standalone Hibernate "
"application and a small web application. More tutorials are available from "
"the Hibernate <ulink url=\"http://hibernate.org\">website</ulink>."
msgstr ""
"このチュートリアルでは、簡単なスタンドアローンのHibernateアプリケーションと "
"小規模のWebアプリケーションを書くための基本を紹介しました。"

#~ msgid "Introduction to Hibernate"
#~ msgstr "Hibernateの導入"

#~ msgid "Preface"
#~ msgstr "前書き"

#~ msgid ""
#~ "This chapter is an introductory tutorial for new users of Hibernate. We "
#~ "start with a simple command line application using an in-memory database "
#~ "and develop it in easy to understand steps."
#~ msgstr ""
#~ "この章はHibernateを初めて使うユーザ向けの入門的なチュートリアルです。 イン"
#~ "メモリデータベースを使う簡単なコマンドラインアプリケーションから始め、 一"
#~ "歩一歩わかりやすいやり方で開発を進めます。"

#~ msgid ""
#~ "This tutorial is intended for new users of Hibernate but requires Java "
#~ "and SQL knowledge. It is based on a tutorial by Michael Gloegl, the third-"
#~ "party libraries we name are for JDK 1.4 and 5.0. You might need others "
#~ "for JDK 1.3."
#~ msgstr ""
#~ "このチュートリアルはHibernateを初めて使うユーザを想定していますが、 理解す"
#~ "るにはJavaとSQLについての知識が必要です。 これはMichael Gloeglの手による"
#~ "チュートリアルを下敷きにしていますが、 ここでサードパーティライブラリと"
#~ "言っているのは、JDK 1.4と5.0用のものです。 JDK 1.3を利用するのであれば他の"
#~ "ライブラリが必要かもしれません。"

#~ msgid ""
#~ "The source code for the tutorial is included in the distribution in the "
#~ "<literal>doc/reference/tutorial/</literal> directory."
#~ msgstr ""
#~ "チュートリアルのソースコードはHibernateディストリビューションの "
#~ "<literal>doc/reference/tutorial/</literal> にあります。"

#~ msgid ""
#~ "First, we'll create a simple console-based Hibernate application. We use "
#~ "an Java database (HSQL DB), so we do not have to install any database "
#~ "server."
#~ msgstr ""
#~ "最初にコンソールベースの簡単なHibernateアプリケーションを作成します。 Java"
#~ "データベース（HSQL DB）を利用するので、 データベースサーバをインストールす"
#~ "る必要はありません。"

#~ msgid ""
#~ "The first thing we do, is set up our development directory and put all "
#~ "the Java libraries we need into it. Download the Hibernate distribution "
#~ "from the Hibernate website. Extract the package and place all required "
#~ "libraries found in <literal>/lib</literal> into into the <literal>/lib</"
#~ "literal> directory of your new development working directory. It should "
#~ "look like this:"
#~ msgstr ""
#~ "まず最初にすることは開発用のディレクトリをセットアップして、 必要となるす"
#~ "べてのJavaライブラリを配置することです。 Hibernateウェブサイトから"
#~ "Hibernateディストリビューションをダウンロードしてください。 ファイルを解凍"
#~ "して <literal>/lib</literal> にある必要なライブラリのすべてを、 新しい開発"
#~ "用ディレクトリの <literal>/lib</literal> ディレクトリに配置してください。 "
#~ "このようになっているはずです："

#~ msgid ""
#~ "This is the minimum set of required libraries (note that we also copied "
#~ "hibernate3.jar, the main archive) for Hibernate <emphasis>at the time of "
#~ "writing</emphasis>. The Hibernate release you are using might require "
#~ "more or less libraries. See the <literal>README.txt</literal> file in the "
#~ "<literal>lib/</literal> directory of the Hibernate distribution for more "
#~ "information about required and optional third-party libraries. (Actually, "
#~ "Log4j is not required but preferred by many developers.)"
#~ msgstr ""
#~ "これが <emphasis>本ドキュメント執筆時点での</emphasis> Hibernateの必要最低"
#~ "限のライブラリです （メインアーカイブのhibernate3.jarもコピーしていること"
#~ "に注意してください）。 Hibernateのバージョンによってはさらに必要なライブラ"
#~ "リや、不要なライブラリがあるかもしれません。 Hibernateディストリビューショ"
#~ "ンの <literal>lib/</literal> ディレクトリにある <literal>README.txt</"
#~ "literal> ファイルを見てください。 必須またはオプションのサードパーティライ"
#~ "ブラリについての情報を載せています （実際Log4jは必須ではありませんが、多く"
#~ "の開発者が好んでいます）。"

#~ msgid ""
#~ "Our first persistent class is a simple JavaBean class with some "
#~ "properties:"
#~ msgstr ""
#~ "最初の永続クラスは、プロパティをいくつか持つシンプルなJavaBeanです："

#~ msgid ""
#~ "Place this Java source file in a directory called <literal>src</literal> "
#~ "in the development folder, and in its correct package. The directory "
#~ "should now look like this:"
#~ msgstr ""
#~ "開発フォルダの <literal>src</literal> というディレクトリの適切なパッケージ"
#~ "に、 このJavaソースファイルを配置してください。 この時点でディレクトリは以"
#~ "下のようになっているはずです："

#~ msgid "In the next step, we tell Hibernate about this persistent class."
#~ msgstr "次のステップでは、Hibernateにこの永続クラスの情報を教えます。"

#~ msgid ""
#~ "The <literal>id</literal> element is the declaration of the identifer "
#~ "property, <literal>name=\"id\"</literal> declares the name of the Java "
#~ "property - Hibernate will use the getter and setter methods to access the "
#~ "property. The column attribute tells Hibernate which column of the "
#~ "<literal>EVENTS</literal> table we use for this primary key. The nested "
#~ "<literal>generator</literal> element specifies the identifier generation "
#~ "strategy, in this case we used <literal>native</literal>, which picks the "
#~ "best strategy depending on the configured database (dialect). Hibernate "
#~ "supports database generated, globally unique, as well as application "
#~ "assigned identifiers (or any strategy you have written an extension for)."
#~ msgstr ""
#~ "<literal>id</literal> 要素は識別子プロパティの宣言であり、 <literal>name="
#~ "\"id\"</literal> でJavaプロパティの名前を宣言します。 Hibernateはこのプロ"
#~ "パティへアクセスするためにゲッター、セッターメソッドを使います。 カラム属"
#~ "性では <literal>EVENTS</literal> テーブルのどのカラムを主キーとして使うの"
#~ "かを Hibernateに教えます。 入れ子になっている <literal>generator</"
#~ "literal> 要素は、識別子を生成する時の戦略を指定します。 （この例では "
#~ "<literal>native</literal> を用いました）。 この要素は、設定したデータベー"
#~ "ス（dialect）に対する最良な識別子生成戦略を選定するものです。 Hibernate"
#~ "は、アプリケーションで値を割り当てる戦略（もしくは独自に拡張した戦略）と同"
#~ "様に、 グローバルにユニークな値をデータベースに生成させる戦略もサポートし"
#~ "ています。"

#~ msgid ""
#~ "This mapping file should be saved as <literal>Event.hbm.xml</literal>, "
#~ "right in the directory next to the <literal>Event</literal> Java class "
#~ "source file. The naming of mapping files can be arbitrary, however the "
#~ "<literal>hbm.xml</literal> suffix is a convention in the Hibernate "
#~ "developer community. The directory structure should now look like this:"
#~ msgstr ""
#~ "このマッピングファイルは、<literal>Event.hbm.xml</literal> として "
#~ "<literal>Event</literal> Javaクラスソースファイルのすぐ隣にセーブするべき"
#~ "です。 マッピングファイルの命名方法は任意ですが、<literal>hbm.xml</"
#~ "literal> サフィックスがHibernateの開発者のコミュニティ内での習慣となってい"
#~ "ます。 現在ディレクトリ構造はこのようになっているはずです："

#~ msgid "We continue with the main configuration of Hibernate."
#~ msgstr "Hibernateの主要な設定を続けます。"

#~ msgid ""
#~ "We now have a persistent class and its mapping file in place. It is time "
#~ "to configure Hibernate. Before we do this, we will need a database. HSQL "
#~ "DB, a java-based SQL DBMS, can be downloaded from the HSQL DB website"
#~ "(http://hsqldb.org/). Actually, you only need the <literal>hsqldb.jar</"
#~ "literal> from this download. Place this file in the <literal>lib/</"
#~ "literal> directory of the development folder."
#~ msgstr ""
#~ "ここまでで永続クラスとマッピングファイルが揃いました。これからHibernateの"
#~ "設定を行いますが、 その前にデータベースが必要です。 HSQL DBはJavaベースの"
#~ "インメモリSQL DBMSであり、HSQL DBウェブサイトからダウンロードできます。 実"
#~ "際にはダウンロードした中の <literal>hsqldb.jar</literal> だけが必要です。 "
#~ "このファイルを開発フォルダの <literal>lib/</literal> ディレクトリに配置し"
#~ "てください。"

#~ msgid ""
#~ "Hibernate is the layer in your application which connects to this "
#~ "database, so it needs connection information. The connections are made "
#~ "through a JDBC connection pool, which we also have to configure. The "
#~ "Hibernate distribution contains several open source JDBC connection "
#~ "pooling tools, but will use the Hibernate built-in connection pool for "
#~ "this tutorial. Note that you have to copy the required library into your "
#~ "classpath and use different connection pooling settings if you want to "
#~ "use a production-quality third party JDBC pooling software."
#~ msgstr ""
#~ "Hibernateはアプリケーションのデータベースに接続する層なので、 コネクション"
#~ "の情報が必要になります。 コネクションはJDBCコネクションプールを通じて行わ"
#~ "れますが、これも設定する必要があります。 Hibernateディストリビューションに"
#~ "はいくつかのオープンソースのJDBCコネクションプールツールが含まれています"
#~ "が、 このチュートリアルではHibernateに組み込まれたコネクションプールを使い"
#~ "ます。 もし製品レベルの品質のサードパーティJDBCコネクションプールソフト"
#~ "ウェアを使いたければ、 クラスパスに必要なライブラリをコピーして、異なるコ"
#~ "ネクションプールを設定しなければ ならないことに注意してください。"

#~ msgid ""
#~ "Copy this file into the source directory, so it will end up in the root "
#~ "of the classpath. Hibernate automatically looks for a file called "
#~ "<literal>hibernate.cfg.xml</literal> in the root of the classpath, on "
#~ "startup."
#~ msgstr ""
#~ "このファイルをソースディレクトリにコピーしてください。 するとこれはクラス"
#~ "パスのルートにあることになります。 Hibernateは、スタートアップ時にクラスパ"
#~ "スのルートで <literal>hibernate.cfg.xml</literal> というファイルを自動的に"
#~ "探します。"

#~ msgid ""
#~ "We'll now build the tutorial with Ant. You will need to have Ant "
#~ "installed - get it from the <ulink url=\"http://ant.apache.org/"
#~ "bindownload.cgi\">Ant download page</ulink>. How to install Ant will not "
#~ "be covered here. Please refer to the <ulink url=\"http://ant.apache.org/"
#~ "manual/index.html\">Ant manual</ulink>. After you have installed Ant, we "
#~ "can start to create the buildfile. It will be called <literal>build.xml</"
#~ "literal> and placed directly in the development directory."
#~ msgstr ""
#~ "それではAntを使ってチュートリアルをビルドしましょう。 それにはAntがインス"
#~ "トールされていなければなりません。 <ulink url=\"http://ant.apache.org/"
#~ "bindownload.cgi\">Antダウンロードページ</ulink> からダウンロードしてくださ"
#~ "い。 Antのインストール方法はここでは説明しませんので、 <ulink url="
#~ "\"http://ant.apache.org/manual/index.html\">Antマニュアル</ulink> を参照し"
#~ "てください。 Antをインストールすれば、ビルドファイルの作成を開始できま"
#~ "す。 このファイルは <literal>build.xml</literal> と呼ばれ、開発ディレクト"
#~ "リに直接配置します。"

#~ msgid "A basic build file looks like this:"
#~ msgstr "基本的なビルドファイルはこのようになります："

#~ msgid ""
#~ "This will tell Ant to add all files in the lib directory ending with "
#~ "<literal>.jar</literal> to the classpath used for compilation. It will "
#~ "also copy all non-Java source files to the target directory, e.g. "
#~ "configuration and Hibernate mapping files. If you now run Ant, you should "
#~ "get this output:"
#~ msgstr ""
#~ "これは <literal>.jar</literal> で終わるlibディレクトリのすべてのファイル"
#~ "を、 コンパイルに使用するクラスパスに追加することをAntに教えます。 また、"
#~ "Javaソースファイルでないすべてのファイルをターゲットディレクトリにコピーす"
#~ "るということでもあります。 例えば設定ファイルやHibernateマッピングファイル"
#~ "などです。 今Antを実行すると、このような出力があるはずです："

#~ msgid ""
#~ "Place <literal>HibernateUtil.java</literal> in the development source "
#~ "directory, in a package next to <literal>events</literal>:"
#~ msgstr ""
#~ "<literal>HibernateUtil.java</literal> を開発ソースディレクトリにある "
#~ "<literal>events</literal> パッケージの 隣に配置してください。"

#~ msgid ""
#~ "To run this first routine we have to add a callable target to the Ant "
#~ "build file:"
#~ msgstr ""
#~ "この最初のルーチンを実行するには、Antのビルドファイルに呼び出し可能なター"
#~ "ゲットを 追加しなければなりません："

#~ msgid ""
#~ "The value of the <literal>action</literal> argument is set on the command "
#~ "line when calling the target:"
#~ msgstr ""
#~ "<literal>action</literal> 引数の値は、ターゲットを呼ぶときにコマンドライン"
#~ "で設定します："

#~ msgid ""
#~ "This is the <literal>INSERT</literal> executed by Hibernate, the question "
#~ "marks represent JDBC bind parameters. To see the values bound as "
#~ "arguments, or to reduce the verbosity of the log, check your "
#~ "<literal>log4j.properties</literal>."
#~ msgstr ""
#~ "これはHibernateが実行する <literal>INSERT</literal> で、 クエスチョンマー"
#~ "クはJDBCバインドパラメータを表しています。 引数としてバインドされる値を見"
#~ "るため、あるいはログの冗長性を減らすためには、 <literal>log4j.properties</"
#~ "literal> をチェックしてください。"

#~ msgid "Now, to execute and test all of this, follow these steps:"
#~ msgstr "以下のステップで、すべての実行とテストを行います。"

#~ msgid ""
#~ "Run <literal>ant run -Daction=store</literal> to store something into the "
#~ "database and, of course, to generate the database schema before through "
#~ "hbm2ddl."
#~ msgstr ""
#~ "hbm2ddlを通す前にデータベースのデータを作成し、データベーススキーマを生成"
#~ "するために、 <literal>ant run -Daction=store</literal> を実行してくださ"
#~ "い。"

#~ msgid ""
#~ "Now disable hbm2ddl by commenting out the property in your "
#~ "<literal>hibernate.cfg.xml</literal> file. Usually you only leave it "
#~ "turned on in continous unit testing, but another run of hbm2ddl would "
#~ "<emphasis>drop</emphasis> everything you have stored - the "
#~ "<literal>create</literal> configuration setting actually translates into "
#~ "\"drop all tables from the schema, then re-create all tables, when the "
#~ "SessionFactory is build\"."
#~ msgstr ""
#~ "今は <literal>hibernate.cfg.xml</literal> ファイルのプロパティをコメントア"
#~ "ウトしてhbm2ddlを無効にしてください。 通常は継続的に単体テストをしている間"
#~ "はhbm2ddlを有効にしておくのですが、 それ以外の場合にhbm2ddlを起動すると格"
#~ "納しておいた全てのデータを <emphasis>ドロップ</emphasis> するでしょう。 設"
#~ "定を <literal>create</literal> にすると、結果として 「SessionFactory生成の"
#~ "際、スキーマから全てのテーブルをドロップして再作成する」という設定になりま"
#~ "す。"

#~ msgid ""
#~ "If you now call Ant with <literal>-Daction=list</literal>, you should see "
#~ "the events you have stored so far. You can of course also call the "
#~ "<literal>store</literal> action a few times more."
#~ msgstr ""
#~ "今 <literal>-Daction=list</literal> と指定してAntを呼ぶと、 これまで格納し"
#~ "たイベントが見えるはずです。 <literal>store</literal> アクションを数回以上"
#~ "呼ぶことも可能です。"

#~ msgid ""
#~ "Note: Most new Hibernate users fail at this point and we see questions "
#~ "about <emphasis>Table not found</emphasis> error messages regularly. "
#~ "However, if you follow the steps outlined above you will not have this "
#~ "problem, as hbm2ddl creates the database schema on the first run, and "
#~ "subsequent application restarts will use this schema. If you change the "
#~ "mapping and/or database schema, you have to re-enable hbm2ddl once again."
#~ msgstr ""
#~ "注意：初めてHibernateに触れる人々の多くがここで失敗するため、"
#~ "<emphasis>Table not found</emphasis> エラーメッセージに 関する質問を定期的"
#~ "に見かけます。 しかし上記のステップに従えば、hbm2ddlが最初に実行されたとき"
#~ "にデータベーススキーマを作成し、 その後の実行においてもこのスキーマを使用"
#~ "するので、問題は起こらないでしょう。 マッピングやデータベーススキーマを変"
#~ "更したときは、もう一度hbm2ddlを有効にしてください。"

#~ msgid ""
#~ "Create a new mapping file called <literal>Person.hbm.xml</literal> (don't "
#~ "forget the DTD reference at the top):"
#~ msgstr ""
#~ "<literal>Person.hbm.xml</literal> という新しいマッピングファイルを作成して"
#~ "ください （ファイルの最初にDTDへの参照を忘れずに入れてください）："

#~ msgid ""
#~ "We need a unidirectional, many-valued associations, implemented with a "
#~ "<literal>Set</literal>. Let's write the code for this in the Java classes "
#~ "and then map it:"
#~ msgstr ""
#~ "<literal>Set</literal> で実装される単方向、多値関連が必要です。 Javaクラス"
#~ "内に対応するコードを書いてマッピングしましょう："

#~ msgid ""
#~ "We add a collection of value typed objects to the <literal>Person</"
#~ "literal> entity. We want to store email addresses, so the type we use is "
#~ "<literal>String</literal>, and the collection is again a <literal>Set</"
#~ "literal>:"
#~ msgstr ""
#~ "値型オブジェクトのコレクションを <literal>Person</literal> エンティティへ"
#~ "追加します。 Eメールアドレスを格納したいのですが、<literal>String</"
#~ "literal> 型を使っているので、 コレクションは再び <literal>Set</literal> で"
#~ "す："

#~ msgid "Let's turn this into a small web application."
#~ msgstr "ではこれを小さなWebアプリケーションにしてみましょう。"

#~ msgid ""
#~ "Create a new class in your source directory, in the <literal>events</"
#~ "literal> package:"
#~ msgstr ""
#~ "新しいクラスを、ソースディレクトリの <literal>events</literal> パッケージ"
#~ "に作成してください。"

#~ msgid ""
#~ "To deploy this application you have to create a web archive, a WAR. Add "
#~ "the following Ant target to your <literal>build.xml</literal>:"
#~ msgstr ""
#~ "このアプリケーションのデプロイのために、Webアーカイブ（WAR）を作成してくだ"
#~ "さい。 以下のAntターゲットを <literal>build.xml</literal> に加えてくださ"
#~ "い。"

#~ msgid ""
#~ "This target creates a file called <literal>hibernate-tutorial.war</"
#~ "literal> in your project directory. It packages all libraries and the "
#~ "<literal>web.xml</literal> descriptor, which is expected in the base "
#~ "directory of your project:"
#~ msgstr ""
#~ "このターゲットは <literal>hibernate-tutorial.war</literal> というファイル"
#~ "を プロジェクトディレクトリに作成します。 このファイルはすべてのライブラリ"
#~ "と <literal>web.xml</literal> 記述子を含んでおり、 プロジェクトのベース"
#~ "ディレクトリに置かれることを期待されます。"

#~ msgid ""
#~ "Before you compile and deploy the web application, note that an "
#~ "additional library is required: <literal>jsdk.jar</literal>. This is the "
#~ "Java servlet development kit, if you don't have this library already, get "
#~ "it from the Sun website and copy it to your library directory. However, "
#~ "it will be only used for compliation and excluded from the WAR package."
#~ msgstr ""
#~ "Webアプリケーションのコンパイルとデプロイの前に、 <literal>jsdk.jar</"
#~ "literal> という 追加のライブラリが必要なことに注意してください。 これは"
#~ "Javaサーブレットの開発キットです。 もしまだこのライブラリを持っていないな"
#~ "ら、Sunのウェブサイトで入手して、 ライブラリディレクトリにコピーしてくださ"
#~ "い。 しかし、これはコンパイルにのみ使用され、WARパッケージからは除外されま"
#~ "す。"

#~ msgid ""
#~ "If you already feel confident with Hibernate, continue browsing through "
#~ "the reference documentation table of contents for topics you find "
#~ "interesting - most asked are transactional processing (<xref linkend="
#~ "\"transactions\"/>), fetch performance (<xref linkend=\"performance\"/>), "
#~ "or the usage of the API (<xref linkend=\"objectstate\"/>) and the query "
#~ "features (<xref linkend=\"objectstate-querying\"/>)."
#~ msgstr ""
#~ "もうHibernateに自信があれば、リファレンスドキュメントの目次に目を通して、 "
#~ "面白そうだと思うトピックを探してください。 最も頻繁に質問があるのは、トラ"
#~ "ンザクション処理（<xref linkend=\"transactions\"/>）、 フェッチのパフォー"
#~ "マンス（<xref linkend=\"performance\"/>）、 APIの使い方（<xref linkend="
#~ "\"objectstate\"/>）とクエリ （<xref linkend=\"objectstate-querying\"/>）で"
#~ "す。"

#~ msgid ""
#~ "Don't forget to check the Hibernate website for more (specialized) "
#~ "tutorials."
#~ msgstr ""
#~ "さらに（特別な）チュートリアルが必要なら、Hibernateウェブサイトを忘れずに"
#~ "チェックしてください。"
