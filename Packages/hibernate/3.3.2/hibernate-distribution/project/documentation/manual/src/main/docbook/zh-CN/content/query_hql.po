msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2009-06-10 21:02+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: query_hql.xml:29
#, no-c-format
msgid "HQL: The Hibernate Query Language"
msgstr "HQL: Hibernate查询语言"

#. Tag: para
#: query_hql.xml:31
#, fuzzy, no-c-format
msgid ""
"Hibernate uses a powerful query language (HQL) that is similar in appearance "
"to SQL. Compared with SQL, however, HQL is fully object-oriented and "
"understands notions like inheritance, polymorphism and association."
msgstr ""
"Hibernate配备了一种非常强大的查询语言，这种语言看上去很像SQL。但是不要被语法"
"结构 上的相似所迷惑，HQL是非常有意识的被设计为完全面向对象的查询，它可以理解"
"如继承、多态 和关联之类的概念。"

#. Tag: title
#: query_hql.xml:38
#, no-c-format
msgid "Case Sensitivity"
msgstr "大小写敏感性问题"

#. Tag: para
#: query_hql.xml:40
#, fuzzy, no-c-format
msgid ""
"With the exception of names of Java classes and properties, queries are case-"
"insensitive. So <literal>SeLeCT</literal> is the same as <literal>sELEct</"
"literal> is the same as <literal>SELECT</literal>, but <literal>org."
"hibernate.eg.FOO</literal> is not <literal>org.hibernate.eg.Foo</literal>, "
"and <literal>foo.barSet</literal> is not <literal>foo.BARSET</literal>."
msgstr ""
"除了Java类与属性的名称外，查询语句对大小写并不敏感。 所以 <literal>SeLeCT</"
"literal> 与 <literal>sELEct</literal> 以及 <literal>SELECT</literal> 是相同"
"的，但是 <literal>org.hibernate.eg.FOO</literal> 并不等价于 <literal>org."
"hibernate.eg.Foo</literal> 并且 <literal>foo.barSet</literal> 也不等价于 "
"<literal>foo.BARSET</literal>。"

#. Tag: para
#: query_hql.xml:51
#, fuzzy, no-c-format
msgid ""
"This manual uses lowercase HQL keywords. Some users find queries with "
"uppercase keywords more readable, but this convention is unsuitable for "
"queries embedded in Java code."
msgstr ""
"本手册中的HQL关键字将使用小写字母. 很多用户发现使用完全大写的关键字会使查询语"
"句 的可读性更强, 但我们发现，当把查询语句嵌入到Java语句中的时候使用大写关键字"
"比较难看。"

#. Tag: title
#: query_hql.xml:59
#, no-c-format
msgid "The from clause"
msgstr "from子句"

#. Tag: para
#: query_hql.xml:61
#, no-c-format
msgid "The simplest possible Hibernate query is of the form:"
msgstr "Hibernate中最简单的查询语句的形式如下："

#. Tag: programlisting
#: query_hql.xml:65
#, no-c-format
msgid "<![CDATA[from eg.Cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:67
#, fuzzy, no-c-format
msgid ""
"This returns all instances of the class <literal>eg.Cat</literal>. You do "
"not usually need to qualify the class name, since <literal>auto-import</"
"literal> is the default. For example:"
msgstr ""
"该子句简单的返回<literal>eg.Cat</literal>类的所有实例。 通常我们不需要使用类"
"的全限定名, 因为 <literal>auto-import</literal>（自动引入） 是缺省的情况。 所"
"以我们几乎只使用如下的简单写法："

#. Tag: programlisting
#: query_hql.xml:73
#, no-c-format
msgid "<![CDATA[from Cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:75
#, no-c-format
msgid ""
"In order to refer to the <literal>Cat</literal> in other parts of the query, "
"you will need to assign an <emphasis>alias</emphasis>. For example:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:81 query_hql.xml:396
#, no-c-format
msgid "<![CDATA[from Cat as cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:83
#, fuzzy, no-c-format
msgid ""
"This query assigns the alias <literal>cat</literal> to <literal>Cat</"
"literal> instances, so you can use that alias later in the query. The "
"<literal>as</literal> keyword is optional. You could also write:"
msgstr ""
"这个语句把别名<literal>cat</literal>指定给类<literal>Cat</literal> 的实例, 这"
"样我们就可以在随后的查询中使用此别名了。 关键字<literal>as</literal> 是可选"
"的，我们也可以这样写:"

#. Tag: programlisting
#: query_hql.xml:89
#, no-c-format
msgid "<![CDATA[from Cat cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:91
#, fuzzy, no-c-format
msgid ""
"Multiple classes can appear, resulting in a cartesian product or \"cross\" "
"join."
msgstr ""
"子句中可以同时出现多个类, 其查询结果是产生一个笛卡儿积或产生跨表的连接。"

#. Tag: programlisting
#: query_hql.xml:95
#, no-c-format
msgid "<![CDATA[from Formula, Parameter]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:96
#, no-c-format
msgid "<![CDATA[from Formula as form, Parameter as param]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:98
#, fuzzy, no-c-format
msgid ""
"It is good practice to name query aliases using an initial lowercase as this "
"is consistent with Java naming standards for local variables (e.g. "
"<literal>domesticCat</literal>)."
msgstr ""
"查询语句中别名的开头部分小写被认为是实践中的好习惯， 这样做与Java变量的命名标"
"准保持了一致 (比如，<literal>domesticCat</literal>)。"

#. Tag: title
#: query_hql.xml:107
#, no-c-format
msgid "Associations and joins"
msgstr "关联(Association)与连接(Join)"

#. Tag: para
#: query_hql.xml:109
#, fuzzy, no-c-format
msgid ""
"You can also assign aliases to associated entities or to elements of a "
"collection of values using a <literal>join</literal>. For example:"
msgstr ""
"我们也可以为相关联的实体甚至是对一个集合中的全部元素指定一个别名, 这时要使用"
"关键字<literal>join</literal>。"

#. Tag: programlisting
#: query_hql.xml:114
#, no-c-format
msgid ""
"<![CDATA[from Cat as cat\n"
"    inner join cat.mate as mate\n"
"    left outer join cat.kittens as kitten]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:116
#, no-c-format
msgid "<![CDATA[from Cat as cat left join cat.mate.kittens as kittens]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:118
#, no-c-format
msgid "<![CDATA[from Formula form full join form.parameter param]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:120
#, fuzzy, no-c-format
msgid "The supported join types are borrowed from ANSI SQL:"
msgstr "受支持的连接类型是从ANSI SQL中借鉴来的。"

#. Tag: literal
#: query_hql.xml:127
#, no-c-format
msgid "inner join"
msgstr "<literal>inner join</literal>（内连接）"

#. Tag: literal
#: query_hql.xml:132
#, no-c-format
msgid "left outer join"
msgstr "<literal>left outer join</literal>（左外连接）"

#. Tag: literal
#: query_hql.xml:137
#, no-c-format
msgid "right outer join"
msgstr "<literal>right outer join</literal>（右外连接）"

#. Tag: para
#: query_hql.xml:141
#, no-c-format
msgid "<literal>full join</literal> (not usually useful)"
msgstr "<literal>full join</literal> (全连接，并不常用)"

#. Tag: para
#: query_hql.xml:147
#, no-c-format
msgid ""
"The <literal>inner join</literal>, <literal>left outer join</literal> and "
"<literal>right outer join</literal> constructs may be abbreviated."
msgstr ""
"语句<literal>inner join</literal>, <literal>left outer join</literal> 以及 "
"<literal>right outer join</literal> 可以简写。"

#. Tag: programlisting
#: query_hql.xml:152
#, no-c-format
msgid ""
"<![CDATA[from Cat as cat\n"
"    join cat.mate as mate\n"
"    left join cat.kittens as kitten]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:154
#, no-c-format
msgid ""
"You may supply extra join conditions using the HQL <literal>with</literal> "
"keyword."
msgstr "通过HQL的<literal>with</literal>关键字，你可以提供额外的join条件。"

#. Tag: programlisting
#: query_hql.xml:159
#, no-c-format
msgid ""
"<![CDATA[from Cat as cat\n"
"    left join cat.kittens as kitten\n"
"        with kitten.bodyWeight > 10.0]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:161
#, fuzzy, no-c-format
msgid ""
"A \"fetch\" join allows associations or collections of values to be "
"initialized along with their parent objects using a single select. This is "
"particularly useful in the case of a collection. It effectively overrides "
"the outer join and lazy declarations of the mapping file for associations "
"and collections. See <xref linkend=\"performance-fetching\"/> for more "
"information."
msgstr ""
"还有，一个\"fetch\"连接允许仅仅使用一个选择语句就将相关联的对象或一组值的集合"
"随着他们的父对象的初始化而被初始化，这种方法在使用到集合的情况下尤其有用，对"
"于关联和集合来说，它有效的代替了映射文件中的外联接 与延迟声明（lazy "
"declarations）. 查看 <xref linkend=\"performance-fetching\"/> 以获得等多的信"
"息。"

#. Tag: programlisting
#: query_hql.xml:169
#, no-c-format
msgid ""
"<![CDATA[from Cat as cat\n"
"    inner join fetch cat.mate\n"
"    left join fetch cat.kittens]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:171
#, fuzzy, no-c-format
msgid ""
"A fetch join does not usually need to assign an alias, because the "
"associated objects should not be used in the <literal>where</literal> clause "
"(or any other clause). The associated objects are also not returned directly "
"in the query results. Instead, they may be accessed via the parent object. "
"The only reason you might need an alias is if you are recursively join "
"fetching a further collection:"
msgstr ""
"一个fetch连接通常不需要被指定别名, 因为相关联的对象不应当被用在 "
"<literal>where</literal> 子句 (或其它任何子句)中。同时，相关联的对象 并不在查"
"询的结果中直接返回，但可以通过他们的父对象来访问到他们。"

#. Tag: programlisting
#: query_hql.xml:179
#, no-c-format
msgid ""
"<![CDATA[from Cat as cat\n"
"    inner join fetch cat.mate\n"
"    left join fetch cat.kittens child\n"
"    left join fetch child.kittens]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:181
#, fuzzy, no-c-format
msgid ""
"The <literal>fetch</literal> construct cannot be used in queries called "
"using <literal>iterate()</literal> (though <literal>scroll()</literal> can "
"be used). <literal>Fetch</literal> should be used together with "
"<literal>setMaxResults()</literal> or <literal>setFirstResult()</literal>, "
"as these operations are based on the result rows which usually contain "
"duplicates for eager collection fetching, hence, the number of rows is not "
"what you would expect. <literal>Fetch</literal> should also not be used "
"together with impromptu <literal>with</literal> condition. It is possible to "
"create a cartesian product by join fetching more than one collection in a "
"query, so take care in this case. Join fetching multiple collection roles "
"can produce unexpected results for bag mappings, so user discretion is "
"advised when formulating queries in this case. Finally, note that "
"<literal>full join fetch</literal> and <literal>right join fetch</literal> "
"are not meaningful."
msgstr ""
"假若使用<literal>iterate()</literal>来调用查询，请注意<literal>fetch</"
"literal>构造是不能使用的(<literal>scroll()</literal> 可以使用)。"
"<literal>fetch</literal>也不应该与<literal>setMaxResults()</literal> 或"
"<literal>setFirstResult()</literal>共用，这是因为这些操作是基于结果集的，而在"
"预先抓取集合类时可能包含重复的数据，也就是说无法预先知道精确的行数。"
"<literal>fetch</literal>还不能与独立的 <literal>with</literal>条件一起使用。"
"通过在一次查询中fetch多个集合，可以制造出笛卡尔积，因此请多加注意。对bag映射"
"来说，同时join fetch多个集合角色可能在某些情况下给出并非预期的结果，也请小"
"心。最后注意，使用<literal>full join fetch</literal> 与 <literal>right join "
"fetch</literal>是没有意义的。"

#. Tag: para
#: query_hql.xml:196
#, fuzzy, no-c-format
msgid ""
"If you are using property-level lazy fetching (with bytecode "
"instrumentation), it is possible to force Hibernate to fetch the lazy "
"properties in the first query immediately using <literal>fetch all "
"properties</literal>."
msgstr ""
"如果你使用属性级别的延迟获取（lazy fetching）（这是通过重新编写字节码实现"
"的），可以使用 <literal>fetch all properties</literal> 来强制Hibernate立即取"
"得那些原本需要延迟加载的属性（在第一个查询中）。"

#. Tag: programlisting
#: query_hql.xml:202
#, no-c-format
msgid "<![CDATA[from Document fetch all properties order by name]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:203
#, no-c-format
msgid ""
"<![CDATA[from Document doc fetch all properties where lower(doc.name) like '%"
"cats%']]>"
msgstr ""

#. Tag: title
#: query_hql.xml:208
#, no-c-format
msgid "Forms of join syntax"
msgstr "join 语法的形式"

#. Tag: para
#: query_hql.xml:210
#, no-c-format
msgid ""
"HQL supports two forms of association joining: <literal>implicit</literal> "
"and <literal>explicit</literal>."
msgstr ""
"HQL支持两种关联join的形式：<literal>implicit(隐式)</literal> 与"
"<literal>explicit（显式）</literal>。"

#. Tag: para
#: query_hql.xml:214
#, fuzzy, no-c-format
msgid ""
"The queries shown in the previous section all use the <literal>explicit</"
"literal> form, that is, where the join keyword is explicitly used in the "
"from clause. This is the recommended form."
msgstr ""
"上一节中给出的查询都是使用<literal>explicit(显式)</literal>形式的，其中form子"
"句中明确给出了join关键字。这是建议使用的方式。"

#. Tag: para
#: query_hql.xml:219
#, no-c-format
msgid ""
"The <literal>implicit</literal> form does not use the join keyword. Instead, "
"the associations are \"dereferenced\" using dot-notation. <literal>implicit</"
"literal> joins can appear in any of the HQL clauses. <literal>implicit</"
"literal> join result in inner joins in the resulting SQL statement."
msgstr ""
"<literal>implicit（隐式）</literal>形式不使用join关键字。关联使用\"点号\"来进"
"行“引用”。<literal>implicit</literal> join可以在任何HQL子句中出现."
"<literal>implicit</literal> join在最终的SQL语句中以inner join的方式出现。"

#. Tag: programlisting
#: query_hql.xml:226
#, no-c-format
msgid "<![CDATA[from Cat as cat where cat.mate.name like '%s%']]>"
msgstr ""

#. Tag: title
#: query_hql.xml:230
#, fuzzy, no-c-format
msgid "Referring to identifier property"
msgstr "Refering to identifier property"

#. Tag: para
#: query_hql.xml:232
#, fuzzy, no-c-format
msgid "There are 2 ways to refer to an entity's identifier property:"
msgstr ""
"There are, generally speaking, 2 ways to refer to an entity's identifier "
"property:"

#. Tag: para
#: query_hql.xml:237
#, fuzzy, no-c-format
msgid ""
"The special property (lowercase) <literal>id</literal> may be used to "
"reference the identifier property of an entity <emphasis>provided that the "
"entity does not define a non-identifier property named id</emphasis>."
msgstr ""
"The special property (lowercase) <literal>id</literal> may be used to "
"reference the identifier property of an entity <emphasis>provided that "
"entity does not define a non-identifier property named id</emphasis>."

#. Tag: para
#: query_hql.xml:244
#, fuzzy, no-c-format
msgid ""
"If the entity defines a named identifier property, you can use that property "
"name."
msgstr ""
"If the entity defines a named identifier property, you may use that property "
"name."

#. Tag: para
#: query_hql.xml:250
#, fuzzy, no-c-format
msgid ""
"References to composite identifier properties follow the same naming rules. "
"If the entity has a non-identifier property named id, the composite "
"identifier property can only be referenced by its defined named. Otherwise, "
"the special <literal>id</literal> property can be used to reference the "
"identifier property."
msgstr ""
"References to composite identifier properties follow the same naming rules. "
"If the entity has a non-identifier property named id, the composite "
"identifier property can only be referenced by its defined named; otherwise, "
"the special <literal>id</literal> property can be used to rerference the "
"identifier property."

#. Tag: para
#: query_hql.xml:258
#, fuzzy, no-c-format
msgid ""
"Please note that, starting in version 3.2.2, this has changed significantly. "
"In previous versions, <literal>id</literal> <emphasis>always</emphasis> "
"referred to the identifier property regardless of its actual name. A "
"ramification of that decision was that non-identifier properties named "
"<literal>id</literal> could never be referenced in Hibernate queries."
msgstr ""
"Note: this has changed significantly starting in version 3.2.2. In previous "
"versions, <literal>id</literal><emphasis>always</emphasis> referred to the "
"identifier property no matter what its actual name. A ramification of that "
"decision was that non-identifier properties named <literal>id</literal> "
"could never be referenced in Hibernate queries."

#. Tag: title
#: query_hql.xml:269
#, no-c-format
msgid "The select clause"
msgstr "select子句"

#. Tag: para
#: query_hql.xml:271
#, fuzzy, no-c-format
msgid ""
"The <literal>select</literal> clause picks which objects and properties to "
"return in the query result set. Consider the following:"
msgstr ""
"<literal>select</literal> 子句选择将哪些对象与属性返 回到查询结果集中. 考虑如"
"下情况:"

#. Tag: programlisting
#: query_hql.xml:276
#, no-c-format
msgid ""
"<![CDATA[select mate\n"
"from Cat as cat\n"
"    inner join cat.mate as mate]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:278
#, fuzzy, no-c-format
msgid ""
"The query will select <literal>mate</literal>s of other <literal>Cat</"
"literal>s. You can express this query more compactly as:"
msgstr ""
"该语句将选择<literal>mate</literal>s of other <literal>Cat</literal>s。（其他"
"猫的配偶） 实际上, 你可以更简洁的用以下的查询语句表达相同的含义:"

#. Tag: programlisting
#: query_hql.xml:283
#, no-c-format
msgid "<![CDATA[select cat.mate from Cat cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:285
#, fuzzy, no-c-format
msgid ""
"Queries can return properties of any value type including properties of "
"component type:"
msgstr ""
"查询语句可以返回值为任何类型的属性，包括返回类型为某种组件(Component)的属性:"

#. Tag: programlisting
#: query_hql.xml:289
#, no-c-format
msgid ""
"<![CDATA[select cat.name from DomesticCat cat\n"
"where cat.name like 'fri%']]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:291
#, no-c-format
msgid "<![CDATA[select cust.name.firstName from Customer as cust]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:293
#, fuzzy, no-c-format
msgid ""
"Queries can return multiple objects and/or properties as an array of type "
"<literal>Object[]</literal>:"
msgstr ""
"查询语句可以返回多个对象和（或）属性，存放在 <literal>Object[]</literal>队列"
"中,"

#. Tag: programlisting
#: query_hql.xml:298
#, no-c-format
msgid ""
"<![CDATA[select mother, offspr, mate.name\n"
"from DomesticCat as mother\n"
"    inner join mother.mate as mate\n"
"    left outer join mother.kittens as offspr]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:300
#, fuzzy, no-c-format
msgid "Or as a <literal>List</literal>:"
msgstr "或存放在一个<literal>List</literal>对象中,"

#. Tag: programlisting
#: query_hql.xml:304
#, no-c-format
msgid ""
"<![CDATA[select new list(mother, offspr, mate.name)\n"
"from DomesticCat as mother\n"
"    inner join mother.mate as mate\n"
"    left outer join mother.kittens as offspr]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:306
#, fuzzy, no-c-format
msgid ""
"Or - assuming that the class <literal>Family</literal> has an appropriate "
"constructor - as an actual typesafe Java object:"
msgstr "假设类<literal>Family</literal>有一个合适的构造函数."

#. Tag: programlisting
#: query_hql.xml:310
#, no-c-format
msgid ""
"<![CDATA[select new Family(mother, mate, offspr)\n"
"from DomesticCat as mother\n"
"    join mother.mate as mate\n"
"    left join mother.kittens as offspr]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:313
#, fuzzy, no-c-format
msgid ""
"You can assign aliases to selected expressions using <literal>as</literal>:"
msgstr "你可以使用关键字<literal>as</literal>给“被选择了的表达式”指派别名:"

#. Tag: programlisting
#: query_hql.xml:317
#, no-c-format
msgid ""
"<![CDATA[select max(bodyWeight) as max, min(bodyWeight) as min, count(*) as "
"n\n"
"from Cat cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:319
#, no-c-format
msgid ""
"This is most useful when used together with <literal>select new map</"
"literal>:"
msgstr "这种做法在与子句<literal>select new map</literal>一起使用时最有用:"

#. Tag: programlisting
#: query_hql.xml:323
#, no-c-format
msgid ""
"<![CDATA[select new map( max(bodyWeight) as max, min(bodyWeight) as min, "
"count(*) as n )\n"
"from Cat cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:325
#, no-c-format
msgid ""
"This query returns a <literal>Map</literal> from aliases to selected values."
msgstr ""
"该查询返回了一个<literal>Map</literal>的对象，内容是别名与被选择的值组成的名-"
"值映射。"

#. Tag: title
#: query_hql.xml:332
#, no-c-format
msgid "Aggregate functions"
msgstr "聚集函数"

#. Tag: para
#: query_hql.xml:334
#, fuzzy, no-c-format
msgid ""
"HQL queries can even return the results of aggregate functions on properties:"
msgstr "HQL查询甚至可以返回作用于属性之上的聚集函数的计算结果:"

#. Tag: programlisting
#: query_hql.xml:338
#, no-c-format
msgid ""
"<![CDATA[select avg(cat.weight), sum(cat.weight), max(cat.weight), count"
"(cat)\n"
"from Cat cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:349
#, fuzzy, no-c-format
msgid "The supported aggregate functions are:"
msgstr "受支持的聚集函数如下："

#. Tag: literal
#: query_hql.xml:356
#, no-c-format
msgid "avg(...), sum(...), min(...), max(...)"
msgstr "avg(...), sum(...), min(...), max(...)"

#. Tag: literal
#: query_hql.xml:361
#, no-c-format
msgid "count(*)"
msgstr "count(*)"

#. Tag: literal
#: query_hql.xml:366
#, no-c-format
msgid "count(...), count(distinct ...), count(all...)"
msgstr "count(...), count(distinct ...), count(all...)"

#. Tag: para
#: query_hql.xml:371
#, fuzzy, no-c-format
msgid ""
"You can use arithmetic operators, concatenation, and recognized SQL "
"functions in the select clause:"
msgstr "你可以在选择子句中使用数学操作符、连接以及经过验证的SQL函数："

#. Tag: programlisting
#: query_hql.xml:376
#, no-c-format
msgid ""
"<![CDATA[select cat.weight + sum(kitten.weight)\n"
"from Cat cat\n"
"    join cat.kittens kitten\n"
"group by cat.id, cat.weight]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:378
#, no-c-format
msgid ""
"<![CDATA[select firstName||' '||initial||' '||upper(lastName) from Person]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:380
#, fuzzy, no-c-format
msgid ""
"The <literal>distinct</literal> and <literal>all</literal> keywords can be "
"used and have the same semantics as in SQL."
msgstr ""
"关键字<literal>distinct</literal>与<literal>all</literal> 也可以使用，它们具"
"有与SQL相同的语义."

#. Tag: programlisting
#: query_hql.xml:385
#, no-c-format
msgid ""
"<![CDATA[select distinct cat.name from Cat cat\n"
"\n"
"select count(distinct cat.name), count(cat) from Cat cat]]>"
msgstr ""

#. Tag: title
#: query_hql.xml:390
#, no-c-format
msgid "Polymorphic queries"
msgstr "多态查询"

#. Tag: para
#: query_hql.xml:392
#, no-c-format
msgid "A query like:"
msgstr "一个如下的查询语句:"

#. Tag: para
#: query_hql.xml:398
#, fuzzy, no-c-format
msgid ""
"returns instances not only of <literal>Cat</literal>, but also of subclasses "
"like <literal>DomesticCat</literal>. Hibernate queries can name "
"<emphasis>any</emphasis> Java class or interface in the <literal>from</"
"literal> clause. The query will return instances of all persistent classes "
"that extend that class or implement the interface. The following query would "
"return all persistent objects:"
msgstr ""
"不仅返回<literal>Cat</literal>类的实例, 也同时返回子类 <literal>DomesticCat</"
"literal>的实例. Hibernate 可以在<literal>from</literal>子句中指定<emphasis>任"
"何</emphasis> Java 类或接口. 查询会返回继承了该类的所有持久化子类 的实例或返"
"回声明了该接口的所有持久化类的实例。下面的查询语句返回所有的被持久化的对象："

#. Tag: programlisting
#: query_hql.xml:406
#, no-c-format
msgid "<![CDATA[from java.lang.Object o]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:408
#, no-c-format
msgid ""
"The interface <literal>Named</literal> might be implemented by various "
"persistent classes:"
msgstr "接口<literal>Named</literal> 可能被各种各样的持久化类声明："

#. Tag: programlisting
#: query_hql.xml:413
#, no-c-format
msgid "<![CDATA[from Named n, Named m where n.name = m.name]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:415
#, fuzzy, no-c-format
msgid ""
"These last two queries will require more than one SQL <literal>SELECT</"
"literal>. This means that the <literal>order by</literal> clause does not "
"correctly order the whole result set. It also means you cannot call these "
"queries using <literal>Query.scroll()</literal>."
msgstr ""
"注意，最后的两个查询将需要超过一个的SQL <literal>SELECT</literal>.这表明"
"<literal>order by</literal>子句 没有对整个结果集进行正确的排序. (这也说明你不"
"能对这样的查询使用<literal>Query.scroll()</literal>方法.)"

#. Tag: title
#: query_hql.xml:424
#, no-c-format
msgid "The where clause"
msgstr "where子句"

#. Tag: para
#: query_hql.xml:426
#, fuzzy, no-c-format
msgid ""
"The <literal>where</literal> clause allows you to refine the list of "
"instances returned. If no alias exists, you can refer to properties by name:"
msgstr ""
"<literal>where</literal>子句允许你将返回的实例列表的范围缩小. 如果没有指定别"
"名，你可以使用属性名来直接引用属性:"

#. Tag: programlisting
#: query_hql.xml:431
#, no-c-format
msgid "<![CDATA[from Cat where name='Fritz']]>"
msgstr ""

#. Tag: para
#: query_hql.xml:433
#, no-c-format
msgid "If there is an alias, use a qualified property name:"
msgstr "如果指派了别名，需要使用完整的属性名:"

#. Tag: programlisting
#: query_hql.xml:437
#, no-c-format
msgid "<![CDATA[from Cat as cat where cat.name='Fritz']]>"
msgstr ""

#. Tag: para
#: query_hql.xml:439
#, fuzzy, no-c-format
msgid "This returns instances of <literal>Cat</literal> named 'Fritz'."
msgstr "返回名为（属性name等于）'Fritz'的<literal>Cat</literal>类的实例。"

#. Tag: para
#: query_hql.xml:443
#, fuzzy, no-c-format
msgid ""
"The following query: <programlisting><![CDATA[select foo\n"
"from Foo foo, Bar bar\n"
"where foo.startDate = bar.date]]></programlisting> returns all instances of "
"<literal>Foo</literal> with an instance of <literal>bar</literal> with a "
"<literal>date</literal> property equal to the <literal>startDate</literal> "
"property of the <literal>Foo</literal>. Compound path expressions make the "
"<literal>where</literal> clause extremely powerful. Consider the following:"
msgstr ""
"将返回所有满足下面条件的<literal>Foo</literal>类的实例： 存在如下的"
"<literal>bar</literal>的一个实例，其<literal>date</literal>属性等于 "
"<literal>Foo</literal>的<literal>startDate</literal>属性。 复合路径表达式使得"
"<literal>where</literal>子句非常的强大，考虑如下情况："

#. Tag: programlisting
#: query_hql.xml:454
#, no-c-format
msgid "<![CDATA[from Cat cat where cat.mate.name is not null]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:456
#, fuzzy, no-c-format
msgid ""
"This query translates to an SQL query with a table (inner) join. For example:"
msgstr ""
"该查询将被翻译成为一个含有表连接（内连接）的SQL查询。如果你打算写像这样的查询"
"语句"

#. Tag: programlisting
#: query_hql.xml:461
#, no-c-format
msgid ""
"<![CDATA[from Foo foo\n"
"where foo.bar.baz.customer.address.city is not null]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:463
#, fuzzy, no-c-format
msgid "would result in a query that would require four table joins in SQL."
msgstr "在SQL中，你为达此目的将需要进行一个四表连接的查询。"

#. Tag: para
#: query_hql.xml:467
#, fuzzy, no-c-format
msgid ""
"The <literal>=</literal> operator can be used to compare not only "
"properties, but also instances:"
msgstr ""
"<literal>=</literal>运算符不仅可以被用来比较属性的值，也可以用来比较实例："

#. Tag: programlisting
#: query_hql.xml:472
#, no-c-format
msgid "<![CDATA[from Cat cat, Cat rival where cat.mate = rival.mate]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:474
#, no-c-format
msgid ""
"<![CDATA[select cat, mate\n"
"from Cat cat, Cat mate\n"
"where cat.mate = mate]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:476
#, fuzzy, no-c-format
msgid ""
"The special property (lowercase) <literal>id</literal> can be used to "
"reference the unique identifier of an object. See <xref linkend=\"queryhql-"
"identifier-property\"/> for more information."
msgstr ""
"特殊属性（小写）<literal>id</literal>可以用来表示一个对象的唯一的标识符。（你"
"也可以使用该对象的属性名。）"

#. Tag: programlisting
#: query_hql.xml:482
#, no-c-format
msgid ""
"<![CDATA[from Cat as cat where cat.id = 123\n"
"\n"
"from Cat as cat where cat.mate.id = 69]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:484
#, fuzzy, no-c-format
msgid "The second query is efficient and does not require a table join."
msgstr "第二个查询是有效的。此时不需要进行表连接！"

#. Tag: para
#: query_hql.xml:488
#, fuzzy, no-c-format
msgid ""
"Properties of composite identifiers can also be used. Consider the following "
"example where <literal>Person</literal> has composite identifiers consisting "
"of <literal>country</literal> and <literal>medicareNumber</literal>:"
msgstr ""
"同样也可以使用复合标识符。比如<literal>Person</literal>类有一个复合标识符，它"
"由<literal>country</literal>属性 与<literal>medicareNumber</literal>属性组"
"成。"

#. Tag: programlisting
#: query_hql.xml:494
#, no-c-format
msgid ""
"<![CDATA[from bank.Person person\n"
"where person.id.country = 'AU'\n"
"    and person.id.medicareNumber = 123456]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:496
#, no-c-format
msgid ""
"<![CDATA[from bank.Account account\n"
"where account.owner.id.country = 'AU'\n"
"    and account.owner.id.medicareNumber = 123456]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:498
#, fuzzy, no-c-format
msgid "Once again, the second query does not require a table join."
msgstr "第二个查询也不需要进行表连接。"

#. Tag: para
#: query_hql.xml:502
#, no-c-format
msgid ""
"See <xref linkend=\"queryhql-identifier-property\"/> for more information "
"regarding referencing identifier properties)"
msgstr ""

#. Tag: para
#: query_hql.xml:507
#, fuzzy, no-c-format
msgid ""
"The special property <literal>class</literal> accesses the discriminator "
"value of an instance in the case of polymorphic persistence. A Java class "
"name embedded in the where clause will be translated to its discriminator "
"value."
msgstr ""
"同样的，特殊属性<literal>class</literal>在进行多态持久化的情况下被用来存取一"
"个实例的鉴别值（discriminator value）。 一个嵌入到where子句中的Java类的名字将"
"被转换为该类的鉴别值。"

#. Tag: programlisting
#: query_hql.xml:513
#, no-c-format
msgid "<![CDATA[from Cat cat where cat.class = DomesticCat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:515
#, fuzzy, no-c-format
msgid ""
"You can also use components or composite user types, or properties of said "
"component types. See <xref linkend=\"queryhql-components\"/> for more "
"information."
msgstr ""
"你也可以声明一个属性的类型是组件或者复合用户类型（以及由组件构成的组件等"
"等）。永远不要尝试使用以组件类型来结尾的路径表达式（path-expression） （与此"
"相反，你应当使用组件的一个属性来结尾）。 举例来说，如果<literal>store.owner</"
"literal>含有一个包含了组件的实体<literal>address</literal>"

#. Tag: para
#: query_hql.xml:520
#, fuzzy, no-c-format
msgid ""
"An \"any\" type has the special properties <literal>id</literal> and "
"<literal>class</literal> that allows you to express a join in the following "
"way (where <literal>AuditLog.item</literal> is a property mapped with "
"<literal>&lt;any&gt;</literal>):"
msgstr ""
"一个“任意”类型有两个特殊的属性<literal>id</literal>和<literal>class</"
"literal>, 来允许我们按照下面的方式表达一个连接（<literal>AuditLog.item</"
"literal> 是一个属性，该属性被映射为<literal>&lt;any&gt;</literal>）。"

#. Tag: programlisting
#: query_hql.xml:526
#, no-c-format
msgid ""
"<![CDATA[from AuditLog log, Payment payment\n"
"where log.item.class = 'Payment' and log.item.id = payment.id]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:528
#, fuzzy, no-c-format
msgid ""
"The <literal>log.item.class</literal> and <literal>payment.class</literal> "
"would refer to the values of completely different database columns in the "
"above query."
msgstr ""
"注意，在上面的查询与句中，<literal>log.item.class</literal> 和 "
"<literal>payment.class</literal> 将涉及到完全不同的数据库中的列。"

#. Tag: title
#: query_hql.xml:536
#, no-c-format
msgid "Expressions"
msgstr "表达式"

#. Tag: para
#: query_hql.xml:538
#, fuzzy, no-c-format
msgid ""
"Expressions used in the <literal>where</literal> clause include the "
"following:"
msgstr ""
"在<literal>where</literal>子句中允许使用的表达式包括 大多数你可以在SQL使用的"
"表达式种类:"

#. Tag: para
#: query_hql.xml:545
#, fuzzy, no-c-format
msgid "mathematical operators: <literal>+, -, *, /</literal>"
msgstr "数学运算符<literal>+, -, *, /</literal>"

#. Tag: para
#: query_hql.xml:550
#, fuzzy, no-c-format
msgid ""
"binary comparison operators: <literal>=, &gt;=, &lt;=, &lt;&gt;, !=, like</"
"literal>"
msgstr "二进制比较运算符<literal>=, &gt;=, &lt;=, &lt;&gt;, !=, like</literal>"

#. Tag: para
#: query_hql.xml:555
#, no-c-format
msgid "logical operations <literal>and, or, not</literal>"
msgstr "逻辑运算符<literal>and, or, not</literal>"

#. Tag: para
#: query_hql.xml:560
#, fuzzy, no-c-format
msgid "Parentheses <literal>( )</literal> that indicates grouping"
msgstr "Parentheses <literal>( )</literal>, indicating grouping"

#. Tag: para
#: query_hql.xml:565
#, no-c-format
msgid ""
"<literal>in</literal>, <literal>not in</literal>, <literal>between</"
"literal>, <literal>is null</literal>, <literal>is not null</literal>, "
"<literal>is empty</literal>, <literal>is not empty</literal>, "
"<literal>member of</literal> and <literal>not member of</literal>"
msgstr ""
"<literal>in</literal>, <literal>not in</literal>, <literal>between</"
"literal>, <literal>is null</literal>, <literal>is not null</literal>, "
"<literal>is empty</literal>, <literal>is not empty</literal>, "
"<literal>member of</literal> and <literal>not member of</literal>"

#. Tag: para
#: query_hql.xml:578
#, no-c-format
msgid ""
"\"Simple\" case, <literal>case ... when ... then ... else ... end</literal>, "
"and \"searched\" case, <literal>case when ... then ... else ... end</literal>"
msgstr ""
"\"简单的\" case, <literal>case ... when ... then ... else ... end</literal>,"
"和 \"搜索\" case, <literal>case when ... then ... else ... end</literal>"

#. Tag: para
#: query_hql.xml:584
#, no-c-format
msgid ""
"string concatenation <literal>...||...</literal> or <literal>concat(...,...)"
"</literal>"
msgstr ""
"字符串连接符<literal>...||...</literal> or <literal>concat(...,...)</literal>"

#. Tag: para
#: query_hql.xml:589
#, fuzzy, no-c-format
msgid ""
"<literal>current_date()</literal>, <literal>current_time()</literal>, and "
"<literal>current_timestamp()</literal>"
msgstr ""
"<literal>current_date()</literal>, <literal>current_time()</literal>, "
"<literal>current_timestamp()</literal>"

#. Tag: para
#: query_hql.xml:595
#, fuzzy, no-c-format
msgid ""
"<literal>second(...)</literal>, <literal>minute(...)</literal>, <literal>hour"
"(...)</literal>, <literal>day(...)</literal>, <literal>month(...)</literal>, "
"and <literal>year(...)</literal>"
msgstr ""
"<literal>second(...)</literal>, <literal>minute(...)</literal>, <literal>hour"
"(...)</literal>, <literal>day(...)</literal>, <literal>month(...)</literal>, "
"<literal>year(...)</literal>,"

#. Tag: para
#: query_hql.xml:602
#, no-c-format
msgid ""
"Any function or operator defined by EJB-QL 3.0: <literal>substring(), trim"
"(), lower(), upper(), length(), locate(), abs(), sqrt(), bit_length(), mod()"
"</literal>"
msgstr ""
"EJB-QL 3.0定义的任何函数或操作：<literal>substring(), trim(), lower(), upper"
"(), length(), locate(), abs(), sqrt(), bit_length()， mod()</literal>"

#. Tag: para
#: query_hql.xml:608
#, no-c-format
msgid "<literal>coalesce()</literal> and <literal>nullif()</literal>"
msgstr "<literal>coalesce()</literal> 和 <literal>nullif()</literal>"

#. Tag: para
#: query_hql.xml:613
#, no-c-format
msgid ""
"<literal>str()</literal> for converting numeric or temporal values to a "
"readable string"
msgstr "<literal>str()</literal> 把数字或者时间值转换为可读的字符串"

#. Tag: para
#: query_hql.xml:619
#, no-c-format
msgid ""
"<literal>cast(... as ...)</literal>, where the second argument is the name "
"of a Hibernate type, and <literal>extract(... from ...)</literal> if ANSI "
"<literal>cast()</literal> and <literal>extract()</literal> is supported by "
"the underlying database"
msgstr ""
"<literal>cast(... as ...)</literal>, 其第二个参数是某Hibernate类型的名字，以"
"及<literal>extract(... from ...)</literal>，只要ANSI <literal>cast()</"
"literal> 和 <literal>extract()</literal> 被底层数据库支持"

#. Tag: para
#: query_hql.xml:627
#, no-c-format
msgid ""
"the HQL <literal>index()</literal> function, that applies to aliases of a "
"joined indexed collection"
msgstr "HQL <literal>index()</literal> 函数，作用于join的有序集合的别名。"

#. Tag: para
#: query_hql.xml:633
#, fuzzy, no-c-format
msgid ""
"HQL functions that take collection-valued path expressions: <literal>size(), "
"minelement(), maxelement(), minindex(), maxindex()</literal>, along with the "
"special <literal>elements()</literal> and <literal>indices</literal> "
"functions that can be quantified using <literal>some, all, exists, any, in</"
"literal>."
msgstr ""
"HQL函数，把集合作为参数:<literal>size(), minelement(), maxelement(), minindex"
"(), maxindex()</literal>,还有特别的<literal>elements()</literal> 和"
"<literal>indices</literal>函数，可以与数量词加以限定：<literal>some, all, "
"exists, any, in</literal>。"

#. Tag: para
#: query_hql.xml:641
#, fuzzy, no-c-format
msgid ""
"Any database-supported SQL scalar function like <literal>sign()</literal>, "
"<literal>trunc()</literal>, <literal>rtrim()</literal>, and <literal>sin()</"
"literal>"
msgstr ""
"任何数据库支持的SQL标量函数，比如<literal>sign()</literal>, <literal>trunc()"
"</literal>, <literal>rtrim()</literal>, <literal>sin()</literal>"

#. Tag: para
#: query_hql.xml:647
#, no-c-format
msgid "JDBC-style positional parameters <literal>?</literal>"
msgstr "JDBC风格的参数传入 <literal>?</literal>"

#. Tag: para
#: query_hql.xml:652
#, fuzzy, no-c-format
msgid ""
"named parameters <literal>:name</literal>, <literal>:start_date</literal>, "
"and <literal>:x1</literal>"
msgstr ""
"命名参数<literal>:name</literal>, <literal>:start_date</literal>, <literal>:"
"x1</literal>"

#. Tag: para
#: query_hql.xml:657
#, no-c-format
msgid ""
"SQL literals <literal>'foo'</literal>, <literal>69</literal>, <literal>6.66E"
"+2</literal>, <literal>'1970-01-01 10:00:01.0'</literal>"
msgstr ""
"SQL 直接常量 <literal>'foo'</literal>, <literal>69</literal>, <literal>6.66E"
"+2</literal>, <literal>'1970-01-01 10:00:01.0'</literal>"

#. Tag: para
#: query_hql.xml:663
#, no-c-format
msgid ""
"Java <literal>public static final</literal> constants <literal>eg.Color."
"TABBY</literal>"
msgstr ""
"Java <literal>public static final</literal> 类型的常量 <literal>eg.Color."
"TABBY</literal>"

#. Tag: para
#: query_hql.xml:669
#, fuzzy, no-c-format
msgid ""
"<literal>in</literal> and <literal>between</literal> can be used as follows:"
msgstr ""
"关键字<literal>in</literal>与<literal>between</literal>可按如下方法使用:"

#. Tag: programlisting
#: query_hql.xml:673
#, no-c-format
msgid "<![CDATA[from DomesticCat cat where cat.name between 'A' and 'B']]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:675
#, no-c-format
msgid ""
"<![CDATA[from DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:677
#, fuzzy, no-c-format
msgid "The negated forms can be written as follows:"
msgstr "而且否定的格式也可以如下书写："

#. Tag: programlisting
#: query_hql.xml:681
#, no-c-format
msgid "<![CDATA[from DomesticCat cat where cat.name not between 'A' and 'B']]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:683
#, no-c-format
msgid ""
"<![CDATA[from DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )]]"
">"
msgstr ""

#. Tag: para
#: query_hql.xml:685
#, fuzzy, no-c-format
msgid ""
"Similarly, <literal>is null</literal> and <literal>is not null</literal> can "
"be used to test for null values."
msgstr ""
"同样, 子句<literal>is null</literal>与<literal>is not null</literal>可以被用"
"来测试空值(null)."

#. Tag: para
#: query_hql.xml:690
#, fuzzy, no-c-format
msgid ""
"Booleans can be easily used in expressions by declaring HQL query "
"substitutions in Hibernate configuration:"
msgstr ""
"在Hibernate配置文件中声明HQL“查询替代（query substitutions）”之后， 布尔表达"
"式（Booleans）可以在其他表达式中轻松的使用:"

#. Tag: programlisting
#: query_hql.xml:695
#, no-c-format
msgid ""
"<![CDATA[<property name=\"hibernate.query.substitutions\">true 1, false 0</"
"property>]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:697
#, no-c-format
msgid ""
"This will replace the keywords <literal>true</literal> and <literal>false</"
"literal> with the literals <literal>1</literal> and <literal>0</literal> in "
"the translated SQL from this HQL:"
msgstr ""
"系统将该HQL转换为SQL语句时，该设置表明将用字符 <literal>1</literal> 和 "
"<literal>0</literal> 来 取代关键字<literal>true</literal> 和 <literal>false</"
"literal>:"

#. Tag: programlisting
#: query_hql.xml:702
#, no-c-format
msgid "<![CDATA[from Cat cat where cat.alive = true]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:704
#, fuzzy, no-c-format
msgid ""
"You can test the size of a collection with the special property "
"<literal>size</literal> or the special <literal>size()</literal> function."
msgstr ""
"你可以用特殊属性<literal>size</literal>, 或是特殊函数<literal>size()</"
"literal>测试一个集合的大小。"

#. Tag: programlisting
#: query_hql.xml:709
#, no-c-format
msgid "<![CDATA[from Cat cat where cat.kittens.size > 0]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:711
#, no-c-format
msgid "<![CDATA[from Cat cat where size(cat.kittens) > 0]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:713
#, fuzzy, no-c-format
msgid ""
"For indexed collections, you can refer to the minimum and maximum indices "
"using <literal>minindex</literal> and <literal>maxindex</literal> functions. "
"Similarly, you can refer to the minimum and maximum elements of a collection "
"of basic type using the <literal>minelement</literal> and "
"<literal>maxelement</literal> functions. For example:"
msgstr ""
"对于索引了（有序）的集合，你可以使用<literal>minindex</literal> 与 "
"<literal>maxindex</literal>函数来引用到最小与最大的索引序数。 同理，你可以使"
"用<literal>minelement</literal> 与 <literal>maxelement</literal>函数来 引用到"
"一个基本数据类型的集合中最小与最大的元素。"

#. Tag: programlisting
#: query_hql.xml:721
#, no-c-format
msgid ""
"<![CDATA[from Calendar cal where maxelement(cal.holidays) > current_date]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:723
#, no-c-format
msgid "<![CDATA[from Order order where maxindex(order.items) > 100]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:725
#, no-c-format
msgid "<![CDATA[from Order order where minelement(order.items) > 10000]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:727
#, fuzzy, no-c-format
msgid ""
"The SQL functions <literal>any, some, all, exists, in</literal> are "
"supported when passed the element or index set of a collection "
"(<literal>elements</literal> and <literal>indices</literal> functions) or "
"the result of a subquery (see below):"
msgstr ""
"在传递一个集合的索引集或者是元素集(<literal>elements</literal>与"
"<literal>indices</literal> 函数) 或者传递一个子查询的结果的时候，可以使用SQL"
"函数<literal>any, some, all, exists, in</literal>"

#. Tag: programlisting
#: query_hql.xml:733
#, no-c-format
msgid ""
"<![CDATA[select mother from Cat as mother, Cat as kit\n"
"where kit in elements(foo.kittens)]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:735
#, no-c-format
msgid ""
"<![CDATA[select p from NameList list, Person p\n"
"where p.name = some elements(list.names)]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:737
#, no-c-format
msgid "<![CDATA[from Cat cat where exists elements(cat.kittens)]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:739
#, no-c-format
msgid "<![CDATA[from Player p where 3 > all elements(p.scores)]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:741
#, no-c-format
msgid "<![CDATA[from Show show where 'fizard' in indices(show.acts)]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:743
#, fuzzy, no-c-format
msgid ""
"Note that these constructs - <literal>size</literal>, <literal>elements</"
"literal>, <literal>indices</literal>, <literal>minindex</literal>, "
"<literal>maxindex</literal>, <literal>minelement</literal>, "
"<literal>maxelement</literal> - can only be used in the where clause in "
"Hibernate3."
msgstr ""
"注意，在Hibernate3种，这些结构变量- <literal>size</literal>, "
"<literal>elements</literal>, <literal>indices</literal>, <literal>minindex</"
"literal>, <literal>maxindex</literal>, <literal>minelement</literal>, "
"<literal>maxelement</literal> - 只能在where子句中使用。"

#. Tag: para
#: query_hql.xml:750
#, fuzzy, no-c-format
msgid ""
"Elements of indexed collections (arrays, lists, and maps) can be referred to "
"by index in a where clause only:"
msgstr ""
"一个被索引过的（有序的）集合的元素(arrays, lists, maps)可以在其他索引中被引用"
"（只能在where子句中）："

#. Tag: programlisting
#: query_hql.xml:755
#, no-c-format
msgid "<![CDATA[from Order order where order.items[0].id = 1234]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:757
#, no-c-format
msgid ""
"<![CDATA[select person from Person person, Calendar calendar\n"
"where calendar.holidays['national day'] = person.birthDay\n"
"    and person.nationality.calendar = calendar]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:759
#, no-c-format
msgid ""
"<![CDATA[select item from Item item, Order order\n"
"where order.items[ order.deliveredItemIndices[0] ] = item and order.id = 11]]"
">"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:761
#, no-c-format
msgid ""
"<![CDATA[select item from Item item, Order order\n"
"where order.items[ maxindex(order.items) ] = item and order.id = 11]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:763
#, fuzzy, no-c-format
msgid ""
"The expression inside <literal>[]</literal> can even be an arithmetic "
"expression:"
msgstr "在<literal>[]</literal>中的表达式甚至可以是一个算数表达式。"

#. Tag: programlisting
#: query_hql.xml:767
#, no-c-format
msgid ""
"<![CDATA[select item from Item item, Order order\n"
"where order.items[ size(order.items) - 1 ] = item]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:769
#, fuzzy, no-c-format
msgid ""
"HQL also provides the built-in <literal>index()</literal> function for "
"elements of a one-to-many association or collection of values."
msgstr ""
"对于一个一对多的关联（one-to-many association）或是值的集合中的元素， HQL也提"
"供内建的<literal>index()</literal>函数，"

#. Tag: programlisting
#: query_hql.xml:774
#, no-c-format
msgid ""
"<![CDATA[select item, index(item) from Order order\n"
"    join order.items item\n"
"where index(item) < 5]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:776
#, fuzzy, no-c-format
msgid "Scalar SQL functions supported by the underlying database can be used:"
msgstr "如果底层数据库支持标量的SQL函数，它们也可以被使用"

#. Tag: programlisting
#: query_hql.xml:780
#, no-c-format
msgid "<![CDATA[from DomesticCat cat where upper(cat.name) like 'FRI%']]>"
msgstr ""

#. Tag: para
#: query_hql.xml:782
#, fuzzy, no-c-format
msgid ""
"Consider how much longer and less readable the following query would be in "
"SQL:"
msgstr ""
"如果你还不能对所有的这些深信不疑，想想下面的查询。如果使用SQL，语句长度会增长"
"多少，可读性会下降多少："

#. Tag: programlisting
#: query_hql.xml:787
#, no-c-format
msgid ""
"<![CDATA[select cust\n"
"from Product prod,\n"
"    Store store\n"
"    inner join store.customers cust\n"
"where prod.name = 'widget'\n"
"    and store.location.name in ( 'Melbourne', 'Sydney' )\n"
"    and prod = all elements(cust.currentOrder.lineItems)]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:789
#, no-c-format
msgid "<emphasis>Hint:</emphasis> something like"
msgstr "<emphasis>提示:</emphasis> 会像如下的语句"

#. Tag: programlisting
#: query_hql.xml:793
#, no-c-format
msgid ""
"<![CDATA[SELECT cust.name, cust.address, cust.phone, cust.id, cust."
"current_order\n"
"FROM customers cust,\n"
"    stores store,\n"
"    locations loc,\n"
"    store_customers sc,\n"
"    product prod\n"
"WHERE prod.name = 'widget'\n"
"    AND store.loc_id = loc.id\n"
"    AND loc.name IN ( 'Melbourne', 'Sydney' )\n"
"    AND sc.store_id = store.id\n"
"    AND sc.cust_id = cust.id\n"
"    AND prod.id = ALL(\n"
"        SELECT item.prod_id\n"
"        FROM line_items item, orders o\n"
"        WHERE item.order_id = o.id\n"
"            AND cust.current_order = o.id\n"
"    )]]>"
msgstr ""

#. Tag: title
#: query_hql.xml:798
#, no-c-format
msgid "The order by clause"
msgstr "order by子句"

#. Tag: para
#: query_hql.xml:800
#, fuzzy, no-c-format
msgid ""
"The list returned by a query can be ordered by any property of a returned "
"class or components:"
msgstr ""
"查询返回的列表(list)可以按照一个返回的类或组件（components)中的任何属性"
"（property）进行排序："

#. Tag: programlisting
#: query_hql.xml:804
#, no-c-format
msgid ""
"<![CDATA[from DomesticCat cat\n"
"order by cat.name asc, cat.weight desc, cat.birthdate]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:806
#, no-c-format
msgid ""
"The optional <literal>asc</literal> or <literal>desc</literal> indicate "
"ascending or descending order respectively."
msgstr ""
"可选的<literal>asc</literal>或<literal>desc</literal>关键字指明了按照升序或降"
"序进行排序."

#. Tag: title
#: query_hql.xml:813
#, no-c-format
msgid "The group by clause"
msgstr "group by子句"

#. Tag: para
#: query_hql.xml:815
#, fuzzy, no-c-format
msgid ""
"A query that returns aggregate values can be grouped by any property of a "
"returned class or components:"
msgstr ""
"一个返回聚集值(aggregate values)的查询可以按照一个返回的类或组件（components)"
"中的任何属性（property）进行分组："

#. Tag: programlisting
#: query_hql.xml:819
#, no-c-format
msgid ""
"<![CDATA[select cat.color, sum(cat.weight), count(cat)\n"
"from Cat cat\n"
"group by cat.color]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:821
#, no-c-format
msgid ""
"<![CDATA[select foo.id, avg(name), max(name)\n"
"from Foo foo join foo.names name\n"
"group by foo.id]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:823
#, no-c-format
msgid "A <literal>having</literal> clause is also allowed."
msgstr "<literal>having</literal>子句在这里也允许使用."

#. Tag: programlisting
#: query_hql.xml:827
#, no-c-format
msgid ""
"<![CDATA[select cat.color, sum(cat.weight), count(cat)\n"
"from Cat cat\n"
"group by cat.color\n"
"having cat.color in (eg.Color.TABBY, eg.Color.BLACK)]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:829
#, fuzzy, no-c-format
msgid ""
"SQL functions and aggregate functions are allowed in the <literal>having</"
"literal> and <literal>order by</literal> clauses if they are supported by "
"the underlying database (i.e., not in MySQL)."
msgstr ""
"如果底层的数据库支持的话(例如不能在MySQL中使用)，SQL的一般函数与聚集函数也可"
"以出现 在<literal>having</literal>与<literal>order by</literal> 子句中。"

#. Tag: programlisting
#: query_hql.xml:835
#, no-c-format
msgid ""
"<![CDATA[select cat\n"
"from Cat cat\n"
"    join cat.kittens kitten\n"
"group by cat.id, cat.name, cat.other, cat.properties\n"
"having avg(kitten.weight) > 100\n"
"order by count(kitten) asc, sum(kitten.weight) desc]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:837
#, fuzzy, no-c-format
msgid ""
"Neither the <literal>group by</literal> clause nor the <literal>order by</"
"literal> clause can contain arithmetic expressions. Hibernate also does not "
"currently expand a grouped entity, so you cannot write <literal>group by "
"cat</literal> if all properties of <literal>cat</literal> are non-"
"aggregated. You have to list all non-aggregated properties explicitly."
msgstr ""
"注意<literal>group by</literal>子句与 <literal>order by</literal>子句中都不能"
"包含算术表达式（arithmetic expressions）. 也要注意Hibernate目前不会扩展group"
"的实体,因此你不能写<literal>group by cat</literal>,除非<literal>cat</literal>"
"的所有属性都不是聚集的(non-aggregated)。你必须明确的列出所有的非聚集属性。"

#. Tag: title
#: query_hql.xml:849
#, no-c-format
msgid "Subqueries"
msgstr "子查询"

#. Tag: para
#: query_hql.xml:851
#, no-c-format
msgid ""
"For databases that support subselects, Hibernate supports subqueries within "
"queries. A subquery must be surrounded by parentheses (often by an SQL "
"aggregate function call). Even correlated subqueries (subqueries that refer "
"to an alias in the outer query) are allowed."
msgstr ""
"对于支持子查询的数据库，Hibernate支持在查询中使用子查询。一个子查询必须被圆括"
"号包围起来（经常是SQL聚集函数的圆括号）。 甚至相互关联的子查询（引用到外部查"
"询中的别名的子查询）也是允许的。"

#. Tag: programlisting
#: query_hql.xml:857
#, no-c-format
msgid ""
"<![CDATA[from Cat as fatcat\n"
"where fatcat.weight > (\n"
"    select avg(cat.weight) from DomesticCat cat\n"
")]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:859
#, no-c-format
msgid ""
"<![CDATA[from DomesticCat as cat\n"
"where cat.name = some (\n"
"    select name.nickName from Name as name\n"
")]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:861
#, no-c-format
msgid ""
"<![CDATA[from Cat as cat\n"
"where not exists (\n"
"    from Cat as mate where mate.mate = cat\n"
")]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:863
#, no-c-format
msgid ""
"<![CDATA[from DomesticCat as cat\n"
"where cat.name not in (\n"
"    select name.nickName from Name as name\n"
")]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:865
#, no-c-format
msgid ""
"<![CDATA[select cat.id, (select max(kit.weight) from cat.kitten kit)\n"
"from Cat as cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:867
#, fuzzy, no-c-format
msgid "Note that HQL subqueries can occur only in the select or where clauses."
msgstr "注意，HQL自查询只可以在select或者where子句中出现。"

#. Tag: para
#: query_hql.xml:871
#, fuzzy, no-c-format
msgid ""
"Note that subqueries can also utilize <literal>row value constructor</"
"literal> syntax. See <xref linkend=\"queryhql-tuple\"/> for more information."
msgstr ""
"Note that subqueries can also utilize <literal>row value constructor</"
"literal> syntax. See <xref linkend=\"queryhql-tuple\"/> for more details."

#. Tag: title
#: query_hql.xml:879
#, no-c-format
msgid "HQL examples"
msgstr "HQL示例"

#. Tag: para
#: query_hql.xml:881
#, fuzzy, no-c-format
msgid ""
"Hibernate queries can be quite powerful and complex. In fact, the power of "
"the query language is one of Hibernate's main strengths. The following "
"example queries are similar to queries that have been used on recent "
"projects. Please note that most queries you will write will be much simpler "
"than the following examples."
msgstr ""
"Hibernate查询可以非常的强大与复杂。实际上，Hibernate的一个主要卖点就是查询语"
"句的威力。这里有一些例子，它们与我在最近的 一个项目中使用的查询非常相似。注意"
"你能用到的大多数查询比这些要简单的多！"

#. Tag: para
#: query_hql.xml:887
#, fuzzy, no-c-format
msgid ""
"The following query returns the order id, number of items, the given minimum "
"total value and the total value of the order for all unpaid orders for a "
"particular customer. The results are ordered by total value. In determining "
"the prices, it uses the current catalog. The resulting SQL query, against "
"the <literal>ORDER</literal>, <literal>ORDER_LINE</literal>, "
"<literal>PRODUCT</literal>, <literal>CATALOG</literal> and <literal>PRICE</"
"literal> tables has four inner joins and an (uncorrelated) subselect."
msgstr ""
"下面的查询对于某个特定的客户的所有未支付的账单，在给定给最小总价值的情况下，"
"返回订单的id，条目的数量和总价值， 返回值按照总价值的结果进行排序。为了决定价"
"格，查询使用了当前目录。作为转换结果的SQL查询，使用了<literal>ORDER</"
"literal>, <literal>ORDER_LINE</literal>, <literal>PRODUCT</literal>, "
"<literal>CATALOG</literal> 和<literal>PRICE</literal> 库表。"

#. Tag: programlisting
#: query_hql.xml:896
#, no-c-format
msgid ""
"<![CDATA[select order.id, sum(price.amount), count(item)\n"
"from Order as order\n"
"    join order.lineItems as item\n"
"    join item.product as product,\n"
"    Catalog as catalog\n"
"    join catalog.prices as price\n"
"where order.paid = false\n"
"    and order.customer = :customer\n"
"    and price.product = product\n"
"    and catalog.effectiveDate < sysdate\n"
"    and catalog.effectiveDate >= all (\n"
"        select cat.effectiveDate\n"
"        from Catalog as cat\n"
"        where cat.effectiveDate < sysdate\n"
"    )\n"
"group by order\n"
"having sum(price.amount) > :minAmount\n"
"order by sum(price.amount) desc]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:898
#, no-c-format
msgid ""
"What a monster! Actually, in real life, I'm not very keen on subqueries, so "
"my query was really more like this:"
msgstr ""
"这简直是一个怪物！实际上，在现实生活中，我并不热衷于子查询，所以我的查询语句"
"看起来更像这个："

#. Tag: programlisting
#: query_hql.xml:903
#, no-c-format
msgid ""
"<![CDATA[select order.id, sum(price.amount), count(item)\n"
"from Order as order\n"
"    join order.lineItems as item\n"
"    join item.product as product,\n"
"    Catalog as catalog\n"
"    join catalog.prices as price\n"
"where order.paid = false\n"
"    and order.customer = :customer\n"
"    and price.product = product\n"
"    and catalog = :currentCatalog\n"
"group by order\n"
"having sum(price.amount) > :minAmount\n"
"order by sum(price.amount) desc]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:905
#, no-c-format
msgid ""
"The next query counts the number of payments in each status, excluding all "
"payments in the <literal>AWAITING_APPROVAL</literal> status where the most "
"recent status change was made by the current user. It translates to an SQL "
"query with two inner joins and a correlated subselect against the "
"<literal>PAYMENT</literal>, <literal>PAYMENT_STATUS</literal> and "
"<literal>PAYMENT_STATUS_CHANGE</literal> tables."
msgstr ""
"下面一个查询计算每一种状态下的支付的数目，除去所有处于"
"<literal>AWAITING_APPROVAL</literal>状态的支付，因为在该状态下 当前的用户作出"
"了状态的最新改变。该查询被转换成含有两个内连接以及一个相关联的子选择的SQL查"
"询，该查询使用了表 <literal>PAYMENT</literal>, <literal>PAYMENT_STATUS</"
"literal> 以及 <literal>PAYMENT_STATUS_CHANGE</literal>。"

#. Tag: programlisting
#: query_hql.xml:913
#, no-c-format
msgid ""
"<![CDATA[select count(payment), status.name\n"
"from Payment as payment\n"
"    join payment.currentStatus as status\n"
"    join payment.statusChanges as statusChange\n"
"where payment.status.name <> PaymentStatus.AWAITING_APPROVAL\n"
"    or (\n"
"        statusChange.timeStamp = (\n"
"            select max(change.timeStamp)\n"
"            from PaymentStatusChange change\n"
"            where change.payment = payment\n"
"        )\n"
"        and statusChange.user <> :currentUser\n"
"    )\n"
"group by status.name, status.sortOrder\n"
"order by status.sortOrder]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:915
#, fuzzy, no-c-format
msgid ""
"If the <literal>statusChanges</literal> collection was mapped as a list, "
"instead of a set, the query would have been much simpler to write."
msgstr ""
"如果我把<literal>statusChanges</literal>实例集映射为一个列表（list）而不是一"
"个集合（set）, 书写查询语句将更加简单."

#. Tag: programlisting
#: query_hql.xml:920
#, no-c-format
msgid ""
"<![CDATA[select count(payment), status.name\n"
"from Payment as payment\n"
"    join payment.currentStatus as status\n"
"where payment.status.name <> PaymentStatus.AWAITING_APPROVAL\n"
"    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user <> :"
"currentUser\n"
"group by status.name, status.sortOrder\n"
"order by status.sortOrder]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:922
#, no-c-format
msgid ""
"The next query uses the MS SQL Server <literal>isNull()</literal> function "
"to return all the accounts and unpaid payments for the organization to which "
"the current user belongs. It translates to an SQL query with three inner "
"joins, an outer join and a subselect against the <literal>ACCOUNT</literal>, "
"<literal>PAYMENT</literal>, <literal>PAYMENT_STATUS</literal>, "
"<literal>ACCOUNT_TYPE</literal>, <literal>ORGANIZATION</literal> and "
"<literal>ORG_USER</literal> tables."
msgstr ""
"下面一个查询使用了MS SQL Server的 <literal>isNull()</literal>函数用以返回当前"
"用户所属组织的组织帐号及组织未支付的账。 它被转换成一个对表<literal>ACCOUNT</"
"literal>, <literal>PAYMENT</literal>, <literal>PAYMENT_STATUS</literal>, "
"<literal>ACCOUNT_TYPE</literal>, <literal>ORGANIZATION</literal> 以及 "
"<literal>ORG_USER</literal>进行的三个内连接， 一个外连接和一个子选择的SQL查"
"询。"

#. Tag: programlisting
#: query_hql.xml:931
#, no-c-format
msgid ""
"<![CDATA[select account, payment\n"
"from Account as account\n"
"    left outer join account.payments as payment\n"
"where :currentUser in elements(account.holder.users)\n"
"    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, "
"PaymentStatus.UNPAID)\n"
"order by account.type.sortOrder, account.accountNumber, payment.dueDate]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:933
#, no-c-format
msgid ""
"For some databases, we would need to do away with the (correlated) subselect."
msgstr "对于一些数据库，我们需要弃用（相关的）子选择。"

#. Tag: programlisting
#: query_hql.xml:937
#, no-c-format
msgid ""
"<![CDATA[select account, payment\n"
"from Account as account\n"
"    join account.holder.users as user\n"
"    left outer join account.payments as payment\n"
"where :currentUser = user\n"
"    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, "
"PaymentStatus.UNPAID)\n"
"order by account.type.sortOrder, account.accountNumber, payment.dueDate]]>"
msgstr ""

#. Tag: title
#: query_hql.xml:942
#, no-c-format
msgid "Bulk update and delete"
msgstr "批量的UPDATE和DELETE"

#. Tag: para
#: query_hql.xml:944
#, fuzzy, no-c-format
msgid ""
"HQL now supports <literal>update</literal>, <literal>delete</literal> and "
"<literal>insert ... select ...</literal> statements. See <xref linkend="
"\"batch-direct\"/> for more information."
msgstr ""
"HQL现在支持 <literal>update</literal>, <literal>delete</literal> 和 "
"<literal>insert ... select ...</literal>语句. 查阅 <xref linkend=\"batch-"
"direct\"/> 以获得更多信息。"

#. Tag: title
#: query_hql.xml:952
#, no-c-format
msgid "Tips &amp; Tricks"
msgstr "小技巧 &amp; 小窍门"

#. Tag: para
#: query_hql.xml:954
#, fuzzy, no-c-format
msgid "You can count the number of query results without returning them:"
msgstr "你可以统计查询结果的数目而不必实际的返回他们："

#. Tag: programlisting
#: query_hql.xml:958
#, no-c-format
msgid ""
"<![CDATA[( (Integer) session.createQuery(\"select count(*) from ....\")."
"iterate().next() ).intValue()]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:960
#, no-c-format
msgid "To order a result by the size of a collection, use the following query:"
msgstr "若想根据一个集合的大小来进行排序，可以使用如下的语句："

#. Tag: programlisting
#: query_hql.xml:964
#, no-c-format
msgid ""
"<![CDATA[select usr.id, usr.name\n"
"from User as usr\n"
"    left join usr.messages as msg\n"
"group by usr.id, usr.name\n"
"order by count(msg)]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:966
#, no-c-format
msgid ""
"If your database supports subselects, you can place a condition upon "
"selection size in the where clause of your query:"
msgstr ""
"如果你的数据库支持子选择，你可以在你的查询的where子句中为选择的大小"
"（selection size）指定一个条件:"

#. Tag: programlisting
#: query_hql.xml:971
#, no-c-format
msgid "<![CDATA[from User usr where size(usr.messages) >= 1]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:973
#, fuzzy, no-c-format
msgid "If your database does not support subselects, use the following query:"
msgstr "如果你的数据库不支持子选择语句，使用下面的查询："

#. Tag: programlisting
#: query_hql.xml:977
#, no-c-format
msgid ""
"<![CDATA[select usr.id, usr.name\n"
"from User usr.name\n"
"    join usr.messages msg\n"
"group by usr.id, usr.name\n"
"having count(msg) >= 1]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:980
#, fuzzy, no-c-format
msgid ""
"As this solution cannot return a <literal>User</literal> with zero messages "
"because of the inner join, the following form is also useful:"
msgstr ""
"因为内连接（inner join）的原因，这个解决方案不能返回含有零个信息的"
"<literal>User</literal> 类的实例, 所以这种情况下使用下面的格式将是有帮助的:"

#. Tag: programlisting
#: query_hql.xml:985
#, no-c-format
msgid ""
"<![CDATA[select usr.id, usr.name\n"
"from User as usr\n"
"    left join usr.messages as msg\n"
"group by usr.id, usr.name\n"
"having count(msg) = 0]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:987
#, no-c-format
msgid "Properties of a JavaBean can be bound to named query parameters:"
msgstr "JavaBean的属性可以被绑定到一个命名查询（named query）的参数上："

#. Tag: programlisting
#: query_hql.xml:991
#, no-c-format
msgid ""
"<![CDATA[Query q = s.createQuery(\"from foo Foo as foo where foo.name=:name "
"and foo.size=:size\");\n"
"q.setProperties(fooBean); // fooBean has getName() and getSize()\n"
"List foos = q.list();]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:993
#, no-c-format
msgid ""
"Collections are pageable by using the <literal>Query</literal> interface "
"with a filter:"
msgstr ""
"通过将接口<literal>Query</literal>与一个过滤器（filter）一起使用，集合"
"（Collections）是可以分页的："

#. Tag: programlisting
#: query_hql.xml:997
#, no-c-format
msgid ""
"<![CDATA[Query q = s.createFilter( collection, \"\" ); // the trivial "
"filter\n"
"q.setMaxResults(PAGE_SIZE);\n"
"q.setFirstResult(PAGE_SIZE * pageNumber);\n"
"List page = q.list();]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:999
#, fuzzy, no-c-format
msgid "Collection elements can be ordered or grouped using a query filter:"
msgstr ""
"通过使用查询过滤器（query filter）可以将集合（Collection）的原素分组或排序:"

#. Tag: programlisting
#: query_hql.xml:1003
#, no-c-format
msgid ""
"<![CDATA[Collection orderedCollection = s.filter( collection, \"order by "
"this.amount\" );\n"
"Collection counts = s.filter( collection, \"select this.type, count(this) "
"group by this.type\" );]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:1005
#, no-c-format
msgid "You can find the size of a collection without initializing it:"
msgstr "不用通过初始化，你就可以知道一个集合（Collection）的大小："

#. Tag: programlisting
#: query_hql.xml:1009
#, no-c-format
msgid ""
"<![CDATA[( (Integer) session.createQuery(\"select count(*) from ....\")."
"iterate().next() ).intValue();]]>"
msgstr ""

#. Tag: title
#: query_hql.xml:1014
#, no-c-format
msgid "Components"
msgstr "translator-credits"

#. Tag: para
#: query_hql.xml:1016
#, no-c-format
msgid ""
"Components can be used similarly to the simple value types that are used in "
"HQL queries. They can appear in the <literal>select</literal> clause as "
"follows:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1021 query_hql.xml:1067
#, no-c-format
msgid "<![CDATA[select p.name from Person p]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1022
#, no-c-format
msgid "<![CDATA[select p.name.first from Person p]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:1024
#, no-c-format
msgid ""
"where the Person's name property is a component. Components can also be used "
"in the <literal>where</literal> clause:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1029
#, no-c-format
msgid "<![CDATA[from Person p where p.name = :name]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1030
#, no-c-format
msgid "<![CDATA[from Person p where p.name.first = :firstName]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:1032
#, no-c-format
msgid "Components can also be used in the <literal>order by</literal> clause:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1036
#, no-c-format
msgid "<![CDATA[from Person p order by p.name]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1037
#, no-c-format
msgid "<![CDATA[from Person p order by p.name.first]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:1039
#, no-c-format
msgid ""
"Another common use of components is in <link linkend=\"queryhql-tuple\">row "
"value constructors</link>."
msgstr ""

#. Tag: title
#: query_hql.xml:1045
#, no-c-format
msgid "Row value constructor syntax"
msgstr ""

#. Tag: para
#: query_hql.xml:1047
#, no-c-format
msgid ""
"HQL supports the use of ANSI SQL <literal>row value constructor</literal> "
"syntax, sometimes referred to AS <literal>tuple</literal> syntax, even "
"though the underlying database may not support that notion. Here, we are "
"generally referring to multi-valued comparisons, typically associated with "
"components. Consider an entity Person which defines a name component:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1054
#, no-c-format
msgid ""
"<![CDATA[from Person p where p.name.first='John' and p.name."
"last='Jingleheimer-Schmidt']]>"
msgstr ""

#. Tag: para
#: query_hql.xml:1056
#, no-c-format
msgid ""
"That is valid syntax although it is a little verbose. You can make this more "
"concise by using <literal>row value constructor</literal> syntax:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1061
#, no-c-format
msgid "<![CDATA[from Person p where p.name=('John', 'Jingleheimer-Schmidt')]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:1063
#, no-c-format
msgid ""
"It can also be useful to specify this in the <literal>select</literal> "
"clause:"
msgstr ""

#. Tag: para
#: query_hql.xml:1069
#, no-c-format
msgid ""
"Using <literal>row value constructor</literal> syntax can also be beneficial "
"when using subqueries that need to compare against multiple values:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1074
#, no-c-format
msgid ""
"<![CDATA[from Cat as cat\n"
"where not ( cat.name, cat.color ) in (\n"
"    select cat.name, cat.color from DomesticCat cat\n"
")]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:1076
#, no-c-format
msgid ""
"One thing to consider when deciding if you want to use this syntax, is that "
"the query will be dependent upon the ordering of the component sub-"
"properties in the metadata."
msgstr ""

#~ msgid ""
#~ "Most of the time, you will need to assign an <emphasis>alias</emphasis>, "
#~ "since you will want to refer to the <literal>Cat</literal> in other parts "
#~ "of the query."
#~ msgstr ""
#~ "大多数情况下, 你需要指定一个<emphasis>别名</emphasis>, 原因是你可能需要 在"
#~ "查询语句的其它部分引用到<literal>Cat</literal>"

#~ msgid "or as an actual typesafe Java object,"
#~ msgstr "也可能直接返回一个实际的类型安全的Java对象,"
