# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2009-06-10 21:02+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: application/x-xml2pot; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: query_hql.xml:29
#, no-c-format
msgid "HQL: The Hibernate Query Language"
msgstr ""

#. Tag: para
#: query_hql.xml:31
#, no-c-format
msgid "Hibernate uses a powerful query language (HQL) that is similar in appearance to SQL. Compared with SQL, however, HQL is fully object-oriented and understands notions like inheritance, polymorphism and association."
msgstr ""

#. Tag: title
#: query_hql.xml:38
#, no-c-format
msgid "Case Sensitivity"
msgstr ""

#. Tag: para
#: query_hql.xml:40
#, no-c-format
msgid "With the exception of names of Java classes and properties, queries are case-insensitive. So <literal>SeLeCT</literal> is the same as <literal>sELEct</literal> is the same as <literal>SELECT</literal>, but <literal>org.hibernate.eg.FOO</literal> is not <literal>org.hibernate.eg.Foo</literal>, and <literal>foo.barSet</literal> is not <literal>foo.BARSET</literal>."
msgstr ""

#. Tag: para
#: query_hql.xml:51
#, no-c-format
msgid "This manual uses lowercase HQL keywords. Some users find queries with uppercase keywords more readable, but this convention is unsuitable for queries embedded in Java code."
msgstr ""

#. Tag: title
#: query_hql.xml:59
#, no-c-format
msgid "The from clause"
msgstr ""

#. Tag: para
#: query_hql.xml:61
#, no-c-format
msgid "The simplest possible Hibernate query is of the form:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:65
#, no-c-format
msgid "<![CDATA[from eg.Cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:67
#, no-c-format
msgid "This returns all instances of the class <literal>eg.Cat</literal>. You do not usually need to qualify the class name, since <literal>auto-import</literal> is the default. For example:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:73
#, no-c-format
msgid "<![CDATA[from Cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:75
#, no-c-format
msgid "In order to refer to the <literal>Cat</literal> in other parts of the query, you will need to assign an <emphasis>alias</emphasis>. For example:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:81 query_hql.xml:396
#, no-c-format
msgid "<![CDATA[from Cat as cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:83
#, no-c-format
msgid "This query assigns the alias <literal>cat</literal> to <literal>Cat</literal> instances, so you can use that alias later in the query. The <literal>as</literal> keyword is optional. You could also write:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:89
#, no-c-format
msgid "<![CDATA[from Cat cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:91
#, no-c-format
msgid "Multiple classes can appear, resulting in a cartesian product or \"cross\" join."
msgstr ""

#. Tag: programlisting
#: query_hql.xml:95
#, no-c-format
msgid "<![CDATA[from Formula, Parameter]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:96
#, no-c-format
msgid "<![CDATA[from Formula as form, Parameter as param]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:98
#, no-c-format
msgid "It is good practice to name query aliases using an initial lowercase as this is consistent with Java naming standards for local variables (e.g. <literal>domesticCat</literal>)."
msgstr ""

#. Tag: title
#: query_hql.xml:107
#, no-c-format
msgid "Associations and joins"
msgstr ""

#. Tag: para
#: query_hql.xml:109
#, no-c-format
msgid "You can also assign aliases to associated entities or to elements of a collection of values using a <literal>join</literal>. For example:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:114
#, no-c-format
msgid ""
      "<![CDATA[from Cat as cat\n"
      "    inner join cat.mate as mate\n"
      "    left outer join cat.kittens as kitten]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:116
#, no-c-format
msgid "<![CDATA[from Cat as cat left join cat.mate.kittens as kittens]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:118
#, no-c-format
msgid "<![CDATA[from Formula form full join form.parameter param]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:120
#, no-c-format
msgid "The supported join types are borrowed from ANSI SQL:"
msgstr ""

#. Tag: literal
#: query_hql.xml:127
#, no-c-format
msgid "inner join"
msgstr ""

#. Tag: literal
#: query_hql.xml:132
#, no-c-format
msgid "left outer join"
msgstr ""

#. Tag: literal
#: query_hql.xml:137
#, no-c-format
msgid "right outer join"
msgstr ""

#. Tag: para
#: query_hql.xml:141
#, no-c-format
msgid "<literal>full join</literal> (not usually useful)"
msgstr ""

#. Tag: para
#: query_hql.xml:147
#, no-c-format
msgid "The <literal>inner join</literal>, <literal>left outer join</literal> and <literal>right outer join</literal> constructs may be abbreviated."
msgstr ""

#. Tag: programlisting
#: query_hql.xml:152
#, no-c-format
msgid ""
      "<![CDATA[from Cat as cat\n"
      "    join cat.mate as mate\n"
      "    left join cat.kittens as kitten]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:154
#, no-c-format
msgid "You may supply extra join conditions using the HQL <literal>with</literal> keyword."
msgstr ""

#. Tag: programlisting
#: query_hql.xml:159
#, no-c-format
msgid ""
      "<![CDATA[from Cat as cat\n"
      "    left join cat.kittens as kitten\n"
      "        with kitten.bodyWeight > 10.0]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:161
#, no-c-format
msgid "A \"fetch\" join allows associations or collections of values to be initialized along with their parent objects using a single select. This is particularly useful in the case of a collection. It effectively overrides the outer join and lazy declarations of the mapping file for associations and collections. See <xref linkend=\"performance-fetching\"/> for more information."
msgstr ""

#. Tag: programlisting
#: query_hql.xml:169
#, no-c-format
msgid ""
      "<![CDATA[from Cat as cat\n"
      "    inner join fetch cat.mate\n"
      "    left join fetch cat.kittens]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:171
#, no-c-format
msgid "A fetch join does not usually need to assign an alias, because the associated objects should not be used in the <literal>where</literal> clause (or any other clause). The associated objects are also not returned directly in the query results. Instead, they may be accessed via the parent object. The only reason you might need an alias is if you are recursively join fetching a further collection:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:179
#, no-c-format
msgid ""
      "<![CDATA[from Cat as cat\n"
      "    inner join fetch cat.mate\n"
      "    left join fetch cat.kittens child\n"
      "    left join fetch child.kittens]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:181
#, no-c-format
msgid "The <literal>fetch</literal> construct cannot be used in queries called using <literal>iterate()</literal> (though <literal>scroll()</literal> can be used). <literal>Fetch</literal> should be used together with <literal>setMaxResults()</literal> or <literal>setFirstResult()</literal>, as these operations are based on the result rows which usually contain duplicates for eager collection fetching, hence, the number of rows is not what you would expect. <literal>Fetch</literal> should also not be used together with impromptu <literal>with</literal> condition. It is possible to create a cartesian product by join fetching more than one collection in a query, so take care in this case. Join fetching multiple collection roles can produce unexpected results for bag mappings, so user discretion is advised when formulating queries in this case. Finally, note that <literal>full join fetch</literal> and <literal>right join fetch</literal> are not meaningful."
msgstr ""

#. Tag: para
#: query_hql.xml:196
#, no-c-format
msgid "If you are using property-level lazy fetching (with bytecode instrumentation), it is possible to force Hibernate to fetch the lazy properties in the first query immediately using <literal>fetch all properties</literal>."
msgstr ""

#. Tag: programlisting
#: query_hql.xml:202
#, no-c-format
msgid "<![CDATA[from Document fetch all properties order by name]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:203
#, no-c-format
msgid "<![CDATA[from Document doc fetch all properties where lower(doc.name) like '%cats%']]>"
msgstr ""

#. Tag: title
#: query_hql.xml:208
#, no-c-format
msgid "Forms of join syntax"
msgstr ""

#. Tag: para
#: query_hql.xml:210
#, no-c-format
msgid "HQL supports two forms of association joining: <literal>implicit</literal> and <literal>explicit</literal>."
msgstr ""

#. Tag: para
#: query_hql.xml:214
#, no-c-format
msgid "The queries shown in the previous section all use the <literal>explicit</literal> form, that is, where the join keyword is explicitly used in the from clause. This is the recommended form."
msgstr ""

#. Tag: para
#: query_hql.xml:219
#, no-c-format
msgid "The <literal>implicit</literal> form does not use the join keyword. Instead, the associations are \"dereferenced\" using dot-notation. <literal>implicit</literal> joins can appear in any of the HQL clauses. <literal>implicit</literal> join result in inner joins in the resulting SQL statement."
msgstr ""

#. Tag: programlisting
#: query_hql.xml:226
#, no-c-format
msgid "<![CDATA[from Cat as cat where cat.mate.name like '%s%']]>"
msgstr ""

#. Tag: title
#: query_hql.xml:230
#, no-c-format
msgid "Referring to identifier property"
msgstr ""

#. Tag: para
#: query_hql.xml:232
#, no-c-format
msgid "There are 2 ways to refer to an entity's identifier property:"
msgstr ""

#. Tag: para
#: query_hql.xml:237
#, no-c-format
msgid "The special property (lowercase) <literal>id</literal> may be used to reference the identifier property of an entity <emphasis>provided that the entity does not define a non-identifier property named id</emphasis>."
msgstr ""

#. Tag: para
#: query_hql.xml:244
#, no-c-format
msgid "If the entity defines a named identifier property, you can use that property name."
msgstr ""

#. Tag: para
#: query_hql.xml:250
#, no-c-format
msgid "References to composite identifier properties follow the same naming rules. If the entity has a non-identifier property named id, the composite identifier property can only be referenced by its defined named. Otherwise, the special <literal>id</literal> property can be used to reference the identifier property."
msgstr ""

#. Tag: para
#: query_hql.xml:258
#, no-c-format
msgid "Please note that, starting in version 3.2.2, this has changed significantly. In previous versions, <literal>id</literal> <emphasis>always</emphasis> referred to the identifier property regardless of its actual name. A ramification of that decision was that non-identifier properties named <literal>id</literal> could never be referenced in Hibernate queries."
msgstr ""

#. Tag: title
#: query_hql.xml:269
#, no-c-format
msgid "The select clause"
msgstr ""

#. Tag: para
#: query_hql.xml:271
#, no-c-format
msgid "The <literal>select</literal> clause picks which objects and properties to return in the query result set. Consider the following:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:276
#, no-c-format
msgid ""
      "<![CDATA[select mate\n"
      "from Cat as cat\n"
      "    inner join cat.mate as mate]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:278
#, no-c-format
msgid "The query will select <literal>mate</literal>s of other <literal>Cat</literal>s. You can express this query more compactly as:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:283
#, no-c-format
msgid "<![CDATA[select cat.mate from Cat cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:285
#, no-c-format
msgid "Queries can return properties of any value type including properties of component type:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:289
#, no-c-format
msgid ""
      "<![CDATA[select cat.name from DomesticCat cat\n"
      "where cat.name like 'fri%']]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:291
#, no-c-format
msgid "<![CDATA[select cust.name.firstName from Customer as cust]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:293
#, no-c-format
msgid "Queries can return multiple objects and/or properties as an array of type <literal>Object[]</literal>:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:298
#, no-c-format
msgid ""
      "<![CDATA[select mother, offspr, mate.name\n"
      "from DomesticCat as mother\n"
      "    inner join mother.mate as mate\n"
      "    left outer join mother.kittens as offspr]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:300
#, no-c-format
msgid "Or as a <literal>List</literal>:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:304
#, no-c-format
msgid ""
      "<![CDATA[select new list(mother, offspr, mate.name)\n"
      "from DomesticCat as mother\n"
      "    inner join mother.mate as mate\n"
      "    left outer join mother.kittens as offspr]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:306
#, no-c-format
msgid "Or - assuming that the class <literal>Family</literal> has an appropriate constructor - as an actual typesafe Java object:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:310
#, no-c-format
msgid ""
      "<![CDATA[select new Family(mother, mate, offspr)\n"
      "from DomesticCat as mother\n"
      "    join mother.mate as mate\n"
      "    left join mother.kittens as offspr]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:313
#, no-c-format
msgid "You can assign aliases to selected expressions using <literal>as</literal>:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:317
#, no-c-format
msgid ""
      "<![CDATA[select max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n\n"
      "from Cat cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:319
#, no-c-format
msgid "This is most useful when used together with <literal>select new map</literal>:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:323
#, no-c-format
msgid ""
      "<![CDATA[select new map( max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n )\n"
      "from Cat cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:325
#, no-c-format
msgid "This query returns a <literal>Map</literal> from aliases to selected values."
msgstr ""

#. Tag: title
#: query_hql.xml:332
#, no-c-format
msgid "Aggregate functions"
msgstr ""

#. Tag: para
#: query_hql.xml:334
#, no-c-format
msgid "HQL queries can even return the results of aggregate functions on properties:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:338
#, no-c-format
msgid ""
      "<![CDATA[select avg(cat.weight), sum(cat.weight), max(cat.weight), count(cat)\n"
      "from Cat cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:349
#, no-c-format
msgid "The supported aggregate functions are:"
msgstr ""

#. Tag: literal
#: query_hql.xml:356
#, no-c-format
msgid "avg(...), sum(...), min(...), max(...)"
msgstr ""

#. Tag: literal
#: query_hql.xml:361
#, no-c-format
msgid "count(*)"
msgstr ""

#. Tag: literal
#: query_hql.xml:366
#, no-c-format
msgid "count(...), count(distinct ...), count(all...)"
msgstr ""

#. Tag: para
#: query_hql.xml:371
#, no-c-format
msgid "You can use arithmetic operators, concatenation, and recognized SQL functions in the select clause:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:376
#, no-c-format
msgid ""
      "<![CDATA[select cat.weight + sum(kitten.weight)\n"
      "from Cat cat\n"
      "    join cat.kittens kitten\n"
      "group by cat.id, cat.weight]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:378
#, no-c-format
msgid "<![CDATA[select firstName||' '||initial||' '||upper(lastName) from Person]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:380
#, no-c-format
msgid "The <literal>distinct</literal> and <literal>all</literal> keywords can be used and have the same semantics as in SQL."
msgstr ""

#. Tag: programlisting
#: query_hql.xml:385
#, no-c-format
msgid ""
      "<![CDATA[select distinct cat.name from Cat cat\n"
      "\n"
      "select count(distinct cat.name), count(cat) from Cat cat]]>"
msgstr ""

#. Tag: title
#: query_hql.xml:390
#, no-c-format
msgid "Polymorphic queries"
msgstr ""

#. Tag: para
#: query_hql.xml:392
#, no-c-format
msgid "A query like:"
msgstr ""

#. Tag: para
#: query_hql.xml:398
#, no-c-format
msgid "returns instances not only of <literal>Cat</literal>, but also of subclasses like <literal>DomesticCat</literal>. Hibernate queries can name <emphasis>any</emphasis> Java class or interface in the <literal>from</literal> clause. The query will return instances of all persistent classes that extend that class or implement the interface. The following query would return all persistent objects:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:406
#, no-c-format
msgid "<![CDATA[from java.lang.Object o]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:408
#, no-c-format
msgid "The interface <literal>Named</literal> might be implemented by various persistent classes:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:413
#, no-c-format
msgid "<![CDATA[from Named n, Named m where n.name = m.name]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:415
#, no-c-format
msgid "These last two queries will require more than one SQL <literal>SELECT</literal>. This means that the <literal>order by</literal> clause does not correctly order the whole result set. It also means you cannot call these queries using <literal>Query.scroll()</literal>."
msgstr ""

#. Tag: title
#: query_hql.xml:424
#, no-c-format
msgid "The where clause"
msgstr ""

#. Tag: para
#: query_hql.xml:426
#, no-c-format
msgid "The <literal>where</literal> clause allows you to refine the list of instances returned. If no alias exists, you can refer to properties by name:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:431
#, no-c-format
msgid "<![CDATA[from Cat where name='Fritz']]>"
msgstr ""

#. Tag: para
#: query_hql.xml:433
#, no-c-format
msgid "If there is an alias, use a qualified property name:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:437
#, no-c-format
msgid "<![CDATA[from Cat as cat where cat.name='Fritz']]>"
msgstr ""

#. Tag: para
#: query_hql.xml:439
#, no-c-format
msgid "This returns instances of <literal>Cat</literal> named 'Fritz'."
msgstr ""

#. Tag: para
#: query_hql.xml:443
#, no-c-format
msgid ""
      "The following query: <programlisting><![CDATA[select foo\n"
      "from Foo foo, Bar bar\n"
      "where foo.startDate = bar.date]]></programlisting> returns all instances of <literal>Foo</literal> with an instance of <literal>bar</literal> with a <literal>date</literal> property equal to the <literal>startDate</literal> property of the <literal>Foo</literal>. Compound path expressions make the <literal>where</literal> clause extremely powerful. Consider the following:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:454
#, no-c-format
msgid "<![CDATA[from Cat cat where cat.mate.name is not null]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:456
#, no-c-format
msgid "This query translates to an SQL query with a table (inner) join. For example:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:461
#, no-c-format
msgid ""
      "<![CDATA[from Foo foo\n"
      "where foo.bar.baz.customer.address.city is not null]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:463
#, no-c-format
msgid "would result in a query that would require four table joins in SQL."
msgstr ""

#. Tag: para
#: query_hql.xml:467
#, no-c-format
msgid "The <literal>=</literal> operator can be used to compare not only properties, but also instances:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:472
#, no-c-format
msgid "<![CDATA[from Cat cat, Cat rival where cat.mate = rival.mate]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:474
#, no-c-format
msgid ""
      "<![CDATA[select cat, mate\n"
      "from Cat cat, Cat mate\n"
      "where cat.mate = mate]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:476
#, no-c-format
msgid "The special property (lowercase) <literal>id</literal> can be used to reference the unique identifier of an object. See <xref linkend=\"queryhql-identifier-property\"/> for more information."
msgstr ""

#. Tag: programlisting
#: query_hql.xml:482
#, no-c-format
msgid ""
      "<![CDATA[from Cat as cat where cat.id = 123\n"
      "\n"
      "from Cat as cat where cat.mate.id = 69]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:484
#, no-c-format
msgid "The second query is efficient and does not require a table join."
msgstr ""

#. Tag: para
#: query_hql.xml:488
#, no-c-format
msgid "Properties of composite identifiers can also be used. Consider the following example where <literal>Person</literal> has composite identifiers consisting of <literal>country</literal> and <literal>medicareNumber</literal>:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:494
#, no-c-format
msgid ""
      "<![CDATA[from bank.Person person\n"
      "where person.id.country = 'AU'\n"
      "    and person.id.medicareNumber = 123456]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:496
#, no-c-format
msgid ""
      "<![CDATA[from bank.Account account\n"
      "where account.owner.id.country = 'AU'\n"
      "    and account.owner.id.medicareNumber = 123456]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:498
#, no-c-format
msgid "Once again, the second query does not require a table join."
msgstr ""

#. Tag: para
#: query_hql.xml:502
#, no-c-format
msgid "See <xref linkend=\"queryhql-identifier-property\"/> for more information regarding referencing identifier properties)"
msgstr ""

#. Tag: para
#: query_hql.xml:507
#, no-c-format
msgid "The special property <literal>class</literal> accesses the discriminator value of an instance in the case of polymorphic persistence. A Java class name embedded in the where clause will be translated to its discriminator value."
msgstr ""

#. Tag: programlisting
#: query_hql.xml:513
#, no-c-format
msgid "<![CDATA[from Cat cat where cat.class = DomesticCat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:515
#, no-c-format
msgid "You can also use components or composite user types, or properties of said component types. See <xref linkend=\"queryhql-components\"/> for more information."
msgstr ""

#. Tag: para
#: query_hql.xml:520
#, no-c-format
msgid "An \"any\" type has the special properties <literal>id</literal> and <literal>class</literal> that allows you to express a join in the following way (where <literal>AuditLog.item</literal> is a property mapped with <literal>&lt;any&gt;</literal>):"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:526
#, no-c-format
msgid ""
      "<![CDATA[from AuditLog log, Payment payment\n"
      "where log.item.class = 'Payment' and log.item.id = payment.id]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:528
#, no-c-format
msgid "The <literal>log.item.class</literal> and <literal>payment.class</literal> would refer to the values of completely different database columns in the above query."
msgstr ""

#. Tag: title
#: query_hql.xml:536
#, no-c-format
msgid "Expressions"
msgstr ""

#. Tag: para
#: query_hql.xml:538
#, no-c-format
msgid "Expressions used in the <literal>where</literal> clause include the following:"
msgstr ""

#. Tag: para
#: query_hql.xml:545
#, no-c-format
msgid "mathematical operators: <literal>+, -, *, /</literal>"
msgstr ""

#. Tag: para
#: query_hql.xml:550
#, no-c-format
msgid "binary comparison operators: <literal>=, &gt;=, &lt;=, &lt;&gt;, !=, like</literal>"
msgstr ""

#. Tag: para
#: query_hql.xml:555
#, no-c-format
msgid "logical operations <literal>and, or, not</literal>"
msgstr ""

#. Tag: para
#: query_hql.xml:560
#, no-c-format
msgid "Parentheses <literal>( )</literal> that indicates grouping"
msgstr ""

#. Tag: para
#: query_hql.xml:565
#, no-c-format
msgid "<literal>in</literal>, <literal>not in</literal>, <literal>between</literal>, <literal>is null</literal>, <literal>is not null</literal>, <literal>is empty</literal>, <literal>is not empty</literal>, <literal>member of</literal> and <literal>not member of</literal>"
msgstr ""

#. Tag: para
#: query_hql.xml:578
#, no-c-format
msgid "\"Simple\" case, <literal>case ... when ... then ... else ... end</literal>, and \"searched\" case, <literal>case when ... then ... else ... end</literal>"
msgstr ""

#. Tag: para
#: query_hql.xml:584
#, no-c-format
msgid "string concatenation <literal>...||...</literal> or <literal>concat(...,...)</literal>"
msgstr ""

#. Tag: para
#: query_hql.xml:589
#, no-c-format
msgid "<literal>current_date()</literal>, <literal>current_time()</literal>, and <literal>current_timestamp()</literal>"
msgstr ""

#. Tag: para
#: query_hql.xml:595
#, no-c-format
msgid "<literal>second(...)</literal>, <literal>minute(...)</literal>, <literal>hour(...)</literal>, <literal>day(...)</literal>, <literal>month(...)</literal>, and <literal>year(...)</literal>"
msgstr ""

#. Tag: para
#: query_hql.xml:602
#, no-c-format
msgid "Any function or operator defined by EJB-QL 3.0: <literal>substring(), trim(), lower(), upper(), length(), locate(), abs(), sqrt(), bit_length(), mod()</literal>"
msgstr ""

#. Tag: para
#: query_hql.xml:608
#, no-c-format
msgid "<literal>coalesce()</literal> and <literal>nullif()</literal>"
msgstr ""

#. Tag: para
#: query_hql.xml:613
#, no-c-format
msgid "<literal>str()</literal> for converting numeric or temporal values to a readable string"
msgstr ""

#. Tag: para
#: query_hql.xml:619
#, no-c-format
msgid "<literal>cast(... as ...)</literal>, where the second argument is the name of a Hibernate type, and <literal>extract(... from ...)</literal> if ANSI <literal>cast()</literal> and <literal>extract()</literal> is supported by the underlying database"
msgstr ""

#. Tag: para
#: query_hql.xml:627
#, no-c-format
msgid "the HQL <literal>index()</literal> function, that applies to aliases of a joined indexed collection"
msgstr ""

#. Tag: para
#: query_hql.xml:633
#, no-c-format
msgid "HQL functions that take collection-valued path expressions: <literal>size(), minelement(), maxelement(), minindex(), maxindex()</literal>, along with the special <literal>elements()</literal> and <literal>indices</literal> functions that can be quantified using <literal>some, all, exists, any, in</literal>."
msgstr ""

#. Tag: para
#: query_hql.xml:641
#, no-c-format
msgid "Any database-supported SQL scalar function like <literal>sign()</literal>, <literal>trunc()</literal>, <literal>rtrim()</literal>, and <literal>sin()</literal>"
msgstr ""

#. Tag: para
#: query_hql.xml:647
#, no-c-format
msgid "JDBC-style positional parameters <literal>?</literal>"
msgstr ""

#. Tag: para
#: query_hql.xml:652
#, no-c-format
msgid "named parameters <literal>:name</literal>, <literal>:start_date</literal>, and <literal>:x1</literal>"
msgstr ""

#. Tag: para
#: query_hql.xml:657
#, no-c-format
msgid "SQL literals <literal>'foo'</literal>, <literal>69</literal>, <literal>6.66E+2</literal>, <literal>'1970-01-01 10:00:01.0'</literal>"
msgstr ""

#. Tag: para
#: query_hql.xml:663
#, no-c-format
msgid "Java <literal>public static final</literal> constants <literal>eg.Color.TABBY</literal>"
msgstr ""

#. Tag: para
#: query_hql.xml:669
#, no-c-format
msgid "<literal>in</literal> and <literal>between</literal> can be used as follows:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:673
#, no-c-format
msgid "<![CDATA[from DomesticCat cat where cat.name between 'A' and 'B']]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:675
#, no-c-format
msgid "<![CDATA[from DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:677
#, no-c-format
msgid "The negated forms can be written as follows:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:681
#, no-c-format
msgid "<![CDATA[from DomesticCat cat where cat.name not between 'A' and 'B']]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:683
#, no-c-format
msgid "<![CDATA[from DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:685
#, no-c-format
msgid "Similarly, <literal>is null</literal> and <literal>is not null</literal> can be used to test for null values."
msgstr ""

#. Tag: para
#: query_hql.xml:690
#, no-c-format
msgid "Booleans can be easily used in expressions by declaring HQL query substitutions in Hibernate configuration:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:695
#, no-c-format
msgid "<![CDATA[<property name=\"hibernate.query.substitutions\">true 1, false 0</property>]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:697
#, no-c-format
msgid "This will replace the keywords <literal>true</literal> and <literal>false</literal> with the literals <literal>1</literal> and <literal>0</literal> in the translated SQL from this HQL:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:702
#, no-c-format
msgid "<![CDATA[from Cat cat where cat.alive = true]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:704
#, no-c-format
msgid "You can test the size of a collection with the special property <literal>size</literal> or the special <literal>size()</literal> function."
msgstr ""

#. Tag: programlisting
#: query_hql.xml:709
#, no-c-format
msgid "<![CDATA[from Cat cat where cat.kittens.size > 0]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:711
#, no-c-format
msgid "<![CDATA[from Cat cat where size(cat.kittens) > 0]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:713
#, no-c-format
msgid "For indexed collections, you can refer to the minimum and maximum indices using <literal>minindex</literal> and <literal>maxindex</literal> functions. Similarly, you can refer to the minimum and maximum elements of a collection of basic type using the <literal>minelement</literal> and <literal>maxelement</literal> functions. For example:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:721
#, no-c-format
msgid "<![CDATA[from Calendar cal where maxelement(cal.holidays) > current_date]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:723
#, no-c-format
msgid "<![CDATA[from Order order where maxindex(order.items) > 100]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:725
#, no-c-format
msgid "<![CDATA[from Order order where minelement(order.items) > 10000]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:727
#, no-c-format
msgid "The SQL functions <literal>any, some, all, exists, in</literal> are supported when passed the element or index set of a collection (<literal>elements</literal> and <literal>indices</literal> functions) or the result of a subquery (see below):"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:733
#, no-c-format
msgid ""
      "<![CDATA[select mother from Cat as mother, Cat as kit\n"
      "where kit in elements(foo.kittens)]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:735
#, no-c-format
msgid ""
      "<![CDATA[select p from NameList list, Person p\n"
      "where p.name = some elements(list.names)]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:737
#, no-c-format
msgid "<![CDATA[from Cat cat where exists elements(cat.kittens)]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:739
#, no-c-format
msgid "<![CDATA[from Player p where 3 > all elements(p.scores)]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:741
#, no-c-format
msgid "<![CDATA[from Show show where 'fizard' in indices(show.acts)]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:743
#, no-c-format
msgid "Note that these constructs - <literal>size</literal>, <literal>elements</literal>, <literal>indices</literal>, <literal>minindex</literal>, <literal>maxindex</literal>, <literal>minelement</literal>, <literal>maxelement</literal> - can only be used in the where clause in Hibernate3."
msgstr ""

#. Tag: para
#: query_hql.xml:750
#, no-c-format
msgid "Elements of indexed collections (arrays, lists, and maps) can be referred to by index in a where clause only:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:755
#, no-c-format
msgid "<![CDATA[from Order order where order.items[0].id = 1234]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:757
#, no-c-format
msgid ""
      "<![CDATA[select person from Person person, Calendar calendar\n"
      "where calendar.holidays['national day'] = person.birthDay\n"
      "    and person.nationality.calendar = calendar]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:759
#, no-c-format
msgid ""
      "<![CDATA[select item from Item item, Order order\n"
      "where order.items[ order.deliveredItemIndices[0] ] = item and order.id = 11]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:761
#, no-c-format
msgid ""
      "<![CDATA[select item from Item item, Order order\n"
      "where order.items[ maxindex(order.items) ] = item and order.id = 11]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:763
#, no-c-format
msgid "The expression inside <literal>[]</literal> can even be an arithmetic expression:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:767
#, no-c-format
msgid ""
      "<![CDATA[select item from Item item, Order order\n"
      "where order.items[ size(order.items) - 1 ] = item]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:769
#, no-c-format
msgid "HQL also provides the built-in <literal>index()</literal> function for elements of a one-to-many association or collection of values."
msgstr ""

#. Tag: programlisting
#: query_hql.xml:774
#, no-c-format
msgid ""
      "<![CDATA[select item, index(item) from Order order\n"
      "    join order.items item\n"
      "where index(item) < 5]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:776
#, no-c-format
msgid "Scalar SQL functions supported by the underlying database can be used:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:780
#, no-c-format
msgid "<![CDATA[from DomesticCat cat where upper(cat.name) like 'FRI%']]>"
msgstr ""

#. Tag: para
#: query_hql.xml:782
#, no-c-format
msgid "Consider how much longer and less readable the following query would be in SQL:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:787
#, no-c-format
msgid ""
      "<![CDATA[select cust\n"
      "from Product prod,\n"
      "    Store store\n"
      "    inner join store.customers cust\n"
      "where prod.name = 'widget'\n"
      "    and store.location.name in ( 'Melbourne', 'Sydney' )\n"
      "    and prod = all elements(cust.currentOrder.lineItems)]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:789
#, no-c-format
msgid "<emphasis>Hint:</emphasis> something like"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:793
#, no-c-format
msgid ""
      "<![CDATA[SELECT cust.name, cust.address, cust.phone, cust.id, cust.current_order\n"
      "FROM customers cust,\n"
      "    stores store,\n"
      "    locations loc,\n"
      "    store_customers sc,\n"
      "    product prod\n"
      "WHERE prod.name = 'widget'\n"
      "    AND store.loc_id = loc.id\n"
      "    AND loc.name IN ( 'Melbourne', 'Sydney' )\n"
      "    AND sc.store_id = store.id\n"
      "    AND sc.cust_id = cust.id\n"
      "    AND prod.id = ALL(\n"
      "        SELECT item.prod_id\n"
      "        FROM line_items item, orders o\n"
      "        WHERE item.order_id = o.id\n"
      "            AND cust.current_order = o.id\n"
      "    )]]>"
msgstr ""

#. Tag: title
#: query_hql.xml:798
#, no-c-format
msgid "The order by clause"
msgstr ""

#. Tag: para
#: query_hql.xml:800
#, no-c-format
msgid "The list returned by a query can be ordered by any property of a returned class or components:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:804
#, no-c-format
msgid ""
      "<![CDATA[from DomesticCat cat\n"
      "order by cat.name asc, cat.weight desc, cat.birthdate]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:806
#, no-c-format
msgid "The optional <literal>asc</literal> or <literal>desc</literal> indicate ascending or descending order respectively."
msgstr ""

#. Tag: title
#: query_hql.xml:813
#, no-c-format
msgid "The group by clause"
msgstr ""

#. Tag: para
#: query_hql.xml:815
#, no-c-format
msgid "A query that returns aggregate values can be grouped by any property of a returned class or components:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:819
#, no-c-format
msgid ""
      "<![CDATA[select cat.color, sum(cat.weight), count(cat)\n"
      "from Cat cat\n"
      "group by cat.color]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:821
#, no-c-format
msgid ""
      "<![CDATA[select foo.id, avg(name), max(name)\n"
      "from Foo foo join foo.names name\n"
      "group by foo.id]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:823
#, no-c-format
msgid "A <literal>having</literal> clause is also allowed."
msgstr ""

#. Tag: programlisting
#: query_hql.xml:827
#, no-c-format
msgid ""
      "<![CDATA[select cat.color, sum(cat.weight), count(cat)\n"
      "from Cat cat\n"
      "group by cat.color\n"
      "having cat.color in (eg.Color.TABBY, eg.Color.BLACK)]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:829
#, no-c-format
msgid "SQL functions and aggregate functions are allowed in the <literal>having</literal> and <literal>order by</literal> clauses if they are supported by the underlying database (i.e., not in MySQL)."
msgstr ""

#. Tag: programlisting
#: query_hql.xml:835
#, no-c-format
msgid ""
      "<![CDATA[select cat\n"
      "from Cat cat\n"
      "    join cat.kittens kitten\n"
      "group by cat.id, cat.name, cat.other, cat.properties\n"
      "having avg(kitten.weight) > 100\n"
      "order by count(kitten) asc, sum(kitten.weight) desc]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:837
#, no-c-format
msgid "Neither the <literal>group by</literal> clause nor the <literal>order by</literal> clause can contain arithmetic expressions. Hibernate also does not currently expand a grouped entity, so you cannot write <literal>group by cat</literal> if all properties of <literal>cat</literal> are non-aggregated. You have to list all non-aggregated properties explicitly."
msgstr ""

#. Tag: title
#: query_hql.xml:849
#, no-c-format
msgid "Subqueries"
msgstr ""

#. Tag: para
#: query_hql.xml:851
#, no-c-format
msgid "For databases that support subselects, Hibernate supports subqueries within queries. A subquery must be surrounded by parentheses (often by an SQL aggregate function call). Even correlated subqueries (subqueries that refer to an alias in the outer query) are allowed."
msgstr ""

#. Tag: programlisting
#: query_hql.xml:857
#, no-c-format
msgid ""
      "<![CDATA[from Cat as fatcat\n"
      "where fatcat.weight > (\n"
      "    select avg(cat.weight) from DomesticCat cat\n"
      ")]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:859
#, no-c-format
msgid ""
      "<![CDATA[from DomesticCat as cat\n"
      "where cat.name = some (\n"
      "    select name.nickName from Name as name\n"
      ")]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:861
#, no-c-format
msgid ""
      "<![CDATA[from Cat as cat\n"
      "where not exists (\n"
      "    from Cat as mate where mate.mate = cat\n"
      ")]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:863
#, no-c-format
msgid ""
      "<![CDATA[from DomesticCat as cat\n"
      "where cat.name not in (\n"
      "    select name.nickName from Name as name\n"
      ")]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:865
#, no-c-format
msgid ""
      "<![CDATA[select cat.id, (select max(kit.weight) from cat.kitten kit)\n"
      "from Cat as cat]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:867
#, no-c-format
msgid "Note that HQL subqueries can occur only in the select or where clauses."
msgstr ""

#. Tag: para
#: query_hql.xml:871
#, no-c-format
msgid "Note that subqueries can also utilize <literal>row value constructor</literal> syntax. See <xref linkend=\"queryhql-tuple\"/> for more information."
msgstr ""

#. Tag: title
#: query_hql.xml:879
#, no-c-format
msgid "HQL examples"
msgstr ""

#. Tag: para
#: query_hql.xml:881
#, no-c-format
msgid "Hibernate queries can be quite powerful and complex. In fact, the power of the query language is one of Hibernate's main strengths. The following example queries are similar to queries that have been used on recent projects. Please note that most queries you will write will be much simpler than the following examples."
msgstr ""

#. Tag: para
#: query_hql.xml:887
#, no-c-format
msgid "The following query returns the order id, number of items, the given minimum total value and the total value of the order for all unpaid orders for a particular customer. The results are ordered by total value. In determining the prices, it uses the current catalog. The resulting SQL query, against the <literal>ORDER</literal>, <literal>ORDER_LINE</literal>, <literal>PRODUCT</literal>, <literal>CATALOG</literal> and <literal>PRICE</literal> tables has four inner joins and an (uncorrelated) subselect."
msgstr ""

#. Tag: programlisting
#: query_hql.xml:896
#, no-c-format
msgid ""
      "<![CDATA[select order.id, sum(price.amount), count(item)\n"
      "from Order as order\n"
      "    join order.lineItems as item\n"
      "    join item.product as product,\n"
      "    Catalog as catalog\n"
      "    join catalog.prices as price\n"
      "where order.paid = false\n"
      "    and order.customer = :customer\n"
      "    and price.product = product\n"
      "    and catalog.effectiveDate < sysdate\n"
      "    and catalog.effectiveDate >= all (\n"
      "        select cat.effectiveDate\n"
      "        from Catalog as cat\n"
      "        where cat.effectiveDate < sysdate\n"
      "    )\n"
      "group by order\n"
      "having sum(price.amount) > :minAmount\n"
      "order by sum(price.amount) desc]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:898
#, no-c-format
msgid "What a monster! Actually, in real life, I'm not very keen on subqueries, so my query was really more like this:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:903
#, no-c-format
msgid ""
      "<![CDATA[select order.id, sum(price.amount), count(item)\n"
      "from Order as order\n"
      "    join order.lineItems as item\n"
      "    join item.product as product,\n"
      "    Catalog as catalog\n"
      "    join catalog.prices as price\n"
      "where order.paid = false\n"
      "    and order.customer = :customer\n"
      "    and price.product = product\n"
      "    and catalog = :currentCatalog\n"
      "group by order\n"
      "having sum(price.amount) > :minAmount\n"
      "order by sum(price.amount) desc]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:905
#, no-c-format
msgid "The next query counts the number of payments in each status, excluding all payments in the <literal>AWAITING_APPROVAL</literal> status where the most recent status change was made by the current user. It translates to an SQL query with two inner joins and a correlated subselect against the <literal>PAYMENT</literal>, <literal>PAYMENT_STATUS</literal> and <literal>PAYMENT_STATUS_CHANGE</literal> tables."
msgstr ""

#. Tag: programlisting
#: query_hql.xml:913
#, no-c-format
msgid ""
      "<![CDATA[select count(payment), status.name\n"
      "from Payment as payment\n"
      "    join payment.currentStatus as status\n"
      "    join payment.statusChanges as statusChange\n"
      "where payment.status.name <> PaymentStatus.AWAITING_APPROVAL\n"
      "    or (\n"
      "        statusChange.timeStamp = (\n"
      "            select max(change.timeStamp)\n"
      "            from PaymentStatusChange change\n"
      "            where change.payment = payment\n"
      "        )\n"
      "        and statusChange.user <> :currentUser\n"
      "    )\n"
      "group by status.name, status.sortOrder\n"
      "order by status.sortOrder]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:915
#, no-c-format
msgid "If the <literal>statusChanges</literal> collection was mapped as a list, instead of a set, the query would have been much simpler to write."
msgstr ""

#. Tag: programlisting
#: query_hql.xml:920
#, no-c-format
msgid ""
      "<![CDATA[select count(payment), status.name\n"
      "from Payment as payment\n"
      "    join payment.currentStatus as status\n"
      "where payment.status.name <> PaymentStatus.AWAITING_APPROVAL\n"
      "    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user <> :currentUser\n"
      "group by status.name, status.sortOrder\n"
      "order by status.sortOrder]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:922
#, no-c-format
msgid "The next query uses the MS SQL Server <literal>isNull()</literal> function to return all the accounts and unpaid payments for the organization to which the current user belongs. It translates to an SQL query with three inner joins, an outer join and a subselect against the <literal>ACCOUNT</literal>, <literal>PAYMENT</literal>, <literal>PAYMENT_STATUS</literal>, <literal>ACCOUNT_TYPE</literal>, <literal>ORGANIZATION</literal> and <literal>ORG_USER</literal> tables."
msgstr ""

#. Tag: programlisting
#: query_hql.xml:931
#, no-c-format
msgid ""
      "<![CDATA[select account, payment\n"
      "from Account as account\n"
      "    left outer join account.payments as payment\n"
      "where :currentUser in elements(account.holder.users)\n"
      "    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)\n"
      "order by account.type.sortOrder, account.accountNumber, payment.dueDate]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:933
#, no-c-format
msgid "For some databases, we would need to do away with the (correlated) subselect."
msgstr ""

#. Tag: programlisting
#: query_hql.xml:937
#, no-c-format
msgid ""
      "<![CDATA[select account, payment\n"
      "from Account as account\n"
      "    join account.holder.users as user\n"
      "    left outer join account.payments as payment\n"
      "where :currentUser = user\n"
      "    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)\n"
      "order by account.type.sortOrder, account.accountNumber, payment.dueDate]]>"
msgstr ""

#. Tag: title
#: query_hql.xml:942
#, no-c-format
msgid "Bulk update and delete"
msgstr ""

#. Tag: para
#: query_hql.xml:944
#, no-c-format
msgid "HQL now supports <literal>update</literal>, <literal>delete</literal> and <literal>insert ... select ...</literal> statements. See <xref linkend=\"batch-direct\"/> for more information."
msgstr ""

#. Tag: title
#: query_hql.xml:952
#, no-c-format
msgid "Tips &amp; Tricks"
msgstr ""

#. Tag: para
#: query_hql.xml:954
#, no-c-format
msgid "You can count the number of query results without returning them:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:958
#, no-c-format
msgid "<![CDATA[( (Integer) session.createQuery(\"select count(*) from ....\").iterate().next() ).intValue()]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:960
#, no-c-format
msgid "To order a result by the size of a collection, use the following query:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:964
#, no-c-format
msgid ""
      "<![CDATA[select usr.id, usr.name\n"
      "from User as usr\n"
      "    left join usr.messages as msg\n"
      "group by usr.id, usr.name\n"
      "order by count(msg)]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:966
#, no-c-format
msgid "If your database supports subselects, you can place a condition upon selection size in the where clause of your query:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:971
#, no-c-format
msgid "<![CDATA[from User usr where size(usr.messages) >= 1]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:973
#, no-c-format
msgid "If your database does not support subselects, use the following query:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:977
#, no-c-format
msgid ""
      "<![CDATA[select usr.id, usr.name\n"
      "from User usr.name\n"
      "    join usr.messages msg\n"
      "group by usr.id, usr.name\n"
      "having count(msg) >= 1]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:980
#, no-c-format
msgid "As this solution cannot return a <literal>User</literal> with zero messages because of the inner join, the following form is also useful:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:985
#, no-c-format
msgid ""
      "<![CDATA[select usr.id, usr.name\n"
      "from User as usr\n"
      "    left join usr.messages as msg\n"
      "group by usr.id, usr.name\n"
      "having count(msg) = 0]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:987
#, no-c-format
msgid "Properties of a JavaBean can be bound to named query parameters:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:991
#, no-c-format
msgid ""
      "<![CDATA[Query q = s.createQuery(\"from foo Foo as foo where foo.name=:name and foo.size=:size\");\n"
      "q.setProperties(fooBean); // fooBean has getName() and getSize()\n"
      "List foos = q.list();]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:993
#, no-c-format
msgid "Collections are pageable by using the <literal>Query</literal> interface with a filter:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:997
#, no-c-format
msgid ""
      "<![CDATA[Query q = s.createFilter( collection, \"\" ); // the trivial filter\n"
      "q.setMaxResults(PAGE_SIZE);\n"
      "q.setFirstResult(PAGE_SIZE * pageNumber);\n"
      "List page = q.list();]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:999
#, no-c-format
msgid "Collection elements can be ordered or grouped using a query filter:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1003
#, no-c-format
msgid ""
      "<![CDATA[Collection orderedCollection = s.filter( collection, \"order by this.amount\" );\n"
      "Collection counts = s.filter( collection, \"select this.type, count(this) group by this.type\" );]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:1005
#, no-c-format
msgid "You can find the size of a collection without initializing it:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1009
#, no-c-format
msgid "<![CDATA[( (Integer) session.createQuery(\"select count(*) from ....\").iterate().next() ).intValue();]]>"
msgstr ""

#. Tag: title
#: query_hql.xml:1014
#, no-c-format
msgid "Components"
msgstr ""

#. Tag: para
#: query_hql.xml:1016
#, no-c-format
msgid "Components can be used similarly to the simple value types that are used in HQL queries. They can appear in the <literal>select</literal> clause as follows:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1021 query_hql.xml:1067
#, no-c-format
msgid "<![CDATA[select p.name from Person p]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1022
#, no-c-format
msgid "<![CDATA[select p.name.first from Person p]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:1024
#, no-c-format
msgid "where the Person's name property is a component. Components can also be used in the <literal>where</literal> clause:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1029
#, no-c-format
msgid "<![CDATA[from Person p where p.name = :name]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1030
#, no-c-format
msgid "<![CDATA[from Person p where p.name.first = :firstName]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:1032
#, no-c-format
msgid "Components can also be used in the <literal>order by</literal> clause:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1036
#, no-c-format
msgid "<![CDATA[from Person p order by p.name]]>"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1037
#, no-c-format
msgid "<![CDATA[from Person p order by p.name.first]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:1039
#, no-c-format
msgid "Another common use of components is in <link linkend=\"queryhql-tuple\">row value constructors</link>."
msgstr ""

#. Tag: title
#: query_hql.xml:1045
#, no-c-format
msgid "Row value constructor syntax"
msgstr ""

#. Tag: para
#: query_hql.xml:1047
#, no-c-format
msgid "HQL supports the use of ANSI SQL <literal>row value constructor</literal> syntax, sometimes referred to AS <literal>tuple</literal> syntax, even though the underlying database may not support that notion. Here, we are generally referring to multi-valued comparisons, typically associated with components. Consider an entity Person which defines a name component:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1054
#, no-c-format
msgid "<![CDATA[from Person p where p.name.first='John' and p.name.last='Jingleheimer-Schmidt']]>"
msgstr ""

#. Tag: para
#: query_hql.xml:1056
#, no-c-format
msgid "That is valid syntax although it is a little verbose. You can make this more concise by using <literal>row value constructor</literal> syntax:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1061
#, no-c-format
msgid "<![CDATA[from Person p where p.name=('John', 'Jingleheimer-Schmidt')]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:1063
#, no-c-format
msgid "It can also be useful to specify this in the <literal>select</literal> clause:"
msgstr ""

#. Tag: para
#: query_hql.xml:1069
#, no-c-format
msgid "Using <literal>row value constructor</literal> syntax can also be beneficial when using subqueries that need to compare against multiple values:"
msgstr ""

#. Tag: programlisting
#: query_hql.xml:1074
#, no-c-format
msgid ""
      "<![CDATA[from Cat as cat\n"
      "where not ( cat.name, cat.color ) in (\n"
      "    select cat.name, cat.color from DomesticCat cat\n"
      ")]]>"
msgstr ""

#. Tag: para
#: query_hql.xml:1076
#, no-c-format
msgid "One thing to consider when deciding if you want to use this syntax, is that the query will be dependent upon the ordering of the component sub-properties in the metadata."
msgstr ""

